<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/sysbench/third_party/luajit/luajit/src/lj_parse.c"><comment type="block">/*
** Lua parser (source code -&gt; bytecode).
** Copyright (C) 2005-2020 Mike Pall. See Copyright Notice in luajit.h
**
** Major portions taken verbatim or adapted from the Lua interpreter.
** Copyright (C) 1994-2008 Lua.org, PUC-Rio. See Copyright Notice in lua.h
*/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lj_parse_c</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUA_CORE</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_obj.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_gc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_err.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_debug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_buf.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_str.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_tab.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_func.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_state.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_bc.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_ctype.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_strfmt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_lex.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_parse.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_vm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_vmevent.h"</cpp:file></cpp:include>

<comment type="block">/* -- Parser structures and definitions ----------------------------------- */</comment>

<comment type="block">/* Expression kinds. */</comment>
<typedef>typedef <type><enum>enum <block>{
  <comment type="block">/* Constant expressions must be first and in this order: */</comment>
  <decl><name>VKNIL</name></decl>,
  <decl><name>VKFALSE</name></decl>,
  <decl><name>VKTRUE</name></decl>,
  <decl><name>VKSTR</name></decl>,	<comment type="block">/* sval = string value */</comment>
  <decl><name>VKNUM</name></decl>,	<comment type="block">/* nval = number value */</comment>
  <decl><name>VKLAST</name> <init>= <expr><name>VKNUM</name></expr></init></decl>,
  <decl><name>VKCDATA</name></decl>,	<comment type="block">/* nval = cdata value, not treated as a constant expression */</comment>
  <comment type="block">/* Non-constant expressions follow: */</comment>
  <decl><name>VLOCAL</name></decl>,	<comment type="block">/* info = local register, aux = vstack index */</comment>
  <decl><name>VUPVAL</name></decl>,	<comment type="block">/* info = upvalue index, aux = vstack index */</comment>
  <decl><name>VGLOBAL</name></decl>,	<comment type="block">/* sval = string value */</comment>
  <decl><name>VINDEXED</name></decl>,	<comment type="block">/* info = table register, aux = index reg/byte/string const */</comment>
  <decl><name>VJMP</name></decl>,		<comment type="block">/* info = instruction PC */</comment>
  <decl><name>VRELOCABLE</name></decl>,	<comment type="block">/* info = instruction PC */</comment>
  <decl><name>VNONRELOC</name></decl>,	<comment type="block">/* info = result register */</comment>
  <decl><name>VCALL</name></decl>,	<comment type="block">/* info = instruction PC, aux = base */</comment>
  <decl><name>VVOID</name></decl>
}</block></enum></type> <name>ExpKind</name>;</typedef>

<comment type="block">/* Expression descriptor. */</comment>
<typedef>typedef <type><struct>struct <name>ExpDesc</name> <block>{
  <union>union <block>{
    <struct>struct <block>{
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>info</name></decl>;</decl_stmt>	<comment type="block">/* Primary info. */</comment>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>aux</name></decl>;</decl_stmt>	<comment type="block">/* Secondary info. */</comment>
    }</block> <decl><name>s</name></decl>;</struct>
    <decl_stmt><decl><type><name>TValue</name></type> <name>nval</name></decl>;</decl_stmt>	<comment type="block">/* Number value. */</comment>
    <decl_stmt><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>sval</name></decl>;</decl_stmt>	<comment type="block">/* String value. */</comment>
  }</block> <decl><name>u</name></decl>;</union>
  <decl_stmt><decl><type><name>ExpKind</name></type> <name>k</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCPos</name></type> <name>t</name></decl>;</decl_stmt>		<comment type="block">/* True condition jump list. */</comment>
  <decl_stmt><decl><type><name>BCPos</name></type> <name>f</name></decl>;</decl_stmt>		<comment type="block">/* False condition jump list. */</comment>
}</block></struct></type> <name>ExpDesc</name>;</typedef>

<comment type="block">/* Macros for expressions. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>expr_hasjump</name><parameter_list>(<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>((e)-&gt;t != (e)-&gt;f)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>expr_isk</name><parameter_list>(<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>((e)-&gt;k &lt;= VKLAST)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>expr_isk_nojump</name><parameter_list>(<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(expr_isk(e) &amp;&amp; !expr_hasjump(e))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>expr_isnumk</name><parameter_list>(<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>((e)-&gt;k == VKNUM)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>expr_isnumk_nojump</name><parameter_list>(<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(expr_isnumk(e) &amp;&amp; !expr_hasjump(e))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>expr_isstrk</name><parameter_list>(<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>((e)-&gt;k == VKSTR)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>expr_numtv</name><parameter_list>(<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>check_exp(expr_isnumk((e)), &amp;(e)-&gt;u.nval)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>expr_numberV</name><parameter_list>(<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>numberVnum(expr_numtv((e)))</cpp:value></cpp:define>

<comment type="block">/* Initialize expression. */</comment>
<function><type><specifier>static</specifier> <name>LJ_AINLINE</name> <name>void</name></type> <name>expr_init</name><parameter_list>(<parameter><decl><type><name>ExpDesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>, <parameter><decl><type><name>ExpKind</name></type> <name>k</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <name>k</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name> <operator>=</operator> <name>info</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>f</name></name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>t</name></name> <operator>=</operator> <name>NO_JMP</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Check number constant for +-0. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>expr_numiszero</name><parameter_list>(<parameter><decl><type><name>ExpDesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>expr_numtv</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><ternary><condition><expr><call><name>tvisint</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><operator>(</operator><call><name>intV</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> </then><else>: <expr><call><name>tviszero</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Per-function linked list of scope blocks. */</comment>
<typedef>typedef <type><struct>struct <name>FuncScope</name> <block>{
  <decl_stmt><decl><type><name><name>struct</name> <name>FuncScope</name></name> <modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>	<comment type="block">/* Link to outer scope. */</comment>
  <decl_stmt><decl><type><name>MSize</name></type> <name>vstart</name></decl>;</decl_stmt>			<comment type="block">/* Start of block-local variables. */</comment>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>nactvar</name></decl>;</decl_stmt>		<comment type="block">/* Number of active vars outside the scope. */</comment>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>flags</name></decl>;</decl_stmt>		<comment type="block">/* Scope flags. */</comment>
}</block></struct></type> <name>FuncScope</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FSCOPE_LOOP</name></cpp:macro>		<cpp:value>0x01</cpp:value></cpp:define>	<comment type="block">/* Scope is a (breakable) loop. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FSCOPE_BREAK</name></cpp:macro>		<cpp:value>0x02</cpp:value></cpp:define>	<comment type="block">/* Break used in scope. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FSCOPE_GOLA</name></cpp:macro>		<cpp:value>0x04</cpp:value></cpp:define>	<comment type="block">/* Goto or label used in scope. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FSCOPE_UPVAL</name></cpp:macro>		<cpp:value>0x08</cpp:value></cpp:define>	<comment type="block">/* Upvalue in scope. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FSCOPE_NOCLOSE</name></cpp:macro>		<cpp:value>0x10</cpp:value></cpp:define>	<comment type="block">/* Do not close upvalues. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NAME_BREAK</name></cpp:macro>		<cpp:value>((GCstr *)(uintptr_t)1)</cpp:value></cpp:define>

<comment type="block">/* Index into variable stack. */</comment>
<typedef>typedef <type><name>uint16_t</name></type> <name>VarIndex</name>;</typedef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LJ_MAX_VSTACK</name></cpp:macro>		<cpp:value>(65536 - LJ_MAX_UPVAL)</cpp:value></cpp:define>

<comment type="block">/* Variable/goto/label info. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VSTACK_VAR_RW</name></cpp:macro>		<cpp:value>0x01</cpp:value></cpp:define>	<comment type="block">/* R/W variable. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VSTACK_GOTO</name></cpp:macro>		<cpp:value>0x02</cpp:value></cpp:define>	<comment type="block">/* Pending goto. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VSTACK_LABEL</name></cpp:macro>		<cpp:value>0x04</cpp:value></cpp:define>	<comment type="block">/* Label. */</comment>

<comment type="block">/* Per-function state. */</comment>
<typedef>typedef <type><struct>struct <name>FuncState</name> <block>{
  <decl_stmt><decl><type><name>GCtab</name> <modifier>*</modifier></type><name>kt</name></decl>;</decl_stmt>			<comment type="block">/* Hash table for constants. */</comment>
  <decl_stmt><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl>;</decl_stmt>			<comment type="block">/* Lexer state. */</comment>
  <decl_stmt><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl>;</decl_stmt>			<comment type="block">/* Lua state. */</comment>
  <decl_stmt><decl><type><name>FuncScope</name> <modifier>*</modifier></type><name>bl</name></decl>;</decl_stmt>		<comment type="block">/* Current scope. */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>FuncState</name></name> <modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>	<comment type="block">/* Enclosing function. */</comment>
  <decl_stmt><decl><type><name>BCPos</name></type> <name>pc</name></decl>;</decl_stmt>			<comment type="block">/* Next bytecode position. */</comment>
  <decl_stmt><decl><type><name>BCPos</name></type> <name>lasttarget</name></decl>;</decl_stmt>		<comment type="block">/* Bytecode position of last jump target. */</comment>
  <decl_stmt><decl><type><name>BCPos</name></type> <name>jpc</name></decl>;</decl_stmt>			<comment type="block">/* Pending jump list to next bytecode. */</comment>
  <decl_stmt><decl><type><name>BCReg</name></type> <name>freereg</name></decl>;</decl_stmt>		<comment type="block">/* First free register. */</comment>
  <decl_stmt><decl><type><name>BCReg</name></type> <name>nactvar</name></decl>;</decl_stmt>		<comment type="block">/* Number of active local variables. */</comment>
  <decl_stmt><decl><type><name>BCReg</name></type> <name>nkn</name></decl>, <name>nkgc</name>;</decl_stmt>		<comment type="block">/* Number of lua_Number/GCobj constants */</comment>
  <decl_stmt><decl><type><name>BCLine</name></type> <name>linedefined</name></decl>;</decl_stmt>		<comment type="block">/* First line of the function definition. */</comment>
  <decl_stmt><decl><type><name>BCInsLine</name> <modifier>*</modifier></type><name>bcbase</name></decl>;</decl_stmt>		<comment type="block">/* Base of bytecode stack. */</comment>
  <decl_stmt><decl><type><name>BCPos</name></type> <name>bclim</name></decl>;</decl_stmt>			<comment type="block">/* Limit of bytecode stack. */</comment>
  <decl_stmt><decl><type><name>MSize</name></type> <name>vbase</name></decl>;</decl_stmt>			<comment type="block">/* Base of variable stack for this function. */</comment>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>flags</name></decl>;</decl_stmt>		<comment type="block">/* Prototype flags. */</comment>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>numparams</name></decl>;</decl_stmt>		<comment type="block">/* Number of parameters. */</comment>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>framesize</name></decl>;</decl_stmt>		<comment type="block">/* Fixed frame size. */</comment>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>nuv</name></decl>;</decl_stmt>			<comment type="block">/* Number of upvalues */</comment>
  <decl_stmt><decl><type><name>VarIndex</name></type> <name><name>varmap</name><index>[<expr><name>LJ_MAX_LOCVAR</name></expr>]</index></name></decl>;</decl_stmt>  <comment type="block">/* Map from register to variable idx. */</comment>
  <decl_stmt><decl><type><name>VarIndex</name></type> <name><name>uvmap</name><index>[<expr><name>LJ_MAX_UPVAL</name></expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* Map from upvalue to variable idx. */</comment>
  <decl_stmt><decl><type><name>VarIndex</name></type> <name><name>uvtmp</name><index>[<expr><name>LJ_MAX_UPVAL</name></expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* Temporary upvalue map. */</comment>
}</block></struct></type> <name>FuncState</name>;</typedef>

<comment type="block">/* Binary and unary operators. ORDER OPR */</comment>
<typedef>typedef <type><enum>enum <name>BinOpr</name> <block>{
  <decl><name>OPR_ADD</name></decl>, <decl><name>OPR_SUB</name></decl>, <decl><name>OPR_MUL</name></decl>, <decl><name>OPR_DIV</name></decl>, <decl><name>OPR_MOD</name></decl>, <decl><name>OPR_POW</name></decl>,  <comment type="block">/* ORDER ARITH */</comment>
  <decl><name>OPR_CONCAT</name></decl>,
  <decl><name>OPR_NE</name></decl>, <decl><name>OPR_EQ</name></decl>,
  <decl><name>OPR_LT</name></decl>, <decl><name>OPR_GE</name></decl>, <decl><name>OPR_LE</name></decl>, <decl><name>OPR_GT</name></decl>,
  <decl><name>OPR_AND</name></decl>, <decl><name>OPR_OR</name></decl>,
  <decl><name>OPR_NOBINOPR</name></decl>
}</block></enum></type> <name>BinOpr</name>;</typedef>

<expr_stmt><expr><call><name>LJ_STATIC_ASSERT</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>BC_ISGE</name><operator>-</operator><operator>(</operator><name>int</name><operator>)</operator><name>BC_ISLT</name> <operator>==</operator> <operator>(</operator><name>int</name><operator>)</operator><name>OPR_GE</name><operator>-</operator><operator>(</operator><name>int</name><operator>)</operator><name>OPR_LT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>LJ_STATIC_ASSERT</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>BC_ISLE</name><operator>-</operator><operator>(</operator><name>int</name><operator>)</operator><name>BC_ISLT</name> <operator>==</operator> <operator>(</operator><name>int</name><operator>)</operator><name>OPR_LE</name><operator>-</operator><operator>(</operator><name>int</name><operator>)</operator><name>OPR_LT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>LJ_STATIC_ASSERT</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>BC_ISGT</name><operator>-</operator><operator>(</operator><name>int</name><operator>)</operator><name>BC_ISLT</name> <operator>==</operator> <operator>(</operator><name>int</name><operator>)</operator><name>OPR_GT</name><operator>-</operator><operator>(</operator><name>int</name><operator>)</operator><name>OPR_LT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>LJ_STATIC_ASSERT</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>BC_SUBVV</name><operator>-</operator><operator>(</operator><name>int</name><operator>)</operator><name>BC_ADDVV</name> <operator>==</operator> <operator>(</operator><name>int</name><operator>)</operator><name>OPR_SUB</name><operator>-</operator><operator>(</operator><name>int</name><operator>)</operator><name>OPR_ADD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>LJ_STATIC_ASSERT</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>BC_MULVV</name><operator>-</operator><operator>(</operator><name>int</name><operator>)</operator><name>BC_ADDVV</name> <operator>==</operator> <operator>(</operator><name>int</name><operator>)</operator><name>OPR_MUL</name><operator>-</operator><operator>(</operator><name>int</name><operator>)</operator><name>OPR_ADD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>LJ_STATIC_ASSERT</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>BC_DIVVV</name><operator>-</operator><operator>(</operator><name>int</name><operator>)</operator><name>BC_ADDVV</name> <operator>==</operator> <operator>(</operator><name>int</name><operator>)</operator><name>OPR_DIV</name><operator>-</operator><operator>(</operator><name>int</name><operator>)</operator><name>OPR_ADD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>LJ_STATIC_ASSERT</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>BC_MODVV</name><operator>-</operator><operator>(</operator><name>int</name><operator>)</operator><name>BC_ADDVV</name> <operator>==</operator> <operator>(</operator><name>int</name><operator>)</operator><name>OPR_MOD</name><operator>-</operator><operator>(</operator><name>int</name><operator>)</operator><name>OPR_ADD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* -- Error handling ------------------------------------------------------ */</comment>

<function><type><name>LJ_NORET</name> <name>LJ_NOINLINE</name> <specifier>static</specifier> <name>void</name></type> <name>err_syntax</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>ErrMsg</name></type> <name>em</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>lj_lex_error</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name><name>ls</name><operator>-&gt;</operator><name>tok</name></name></expr></argument>, <argument><expr><name>em</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>LJ_NORET</name> <name>LJ_NOINLINE</name> <specifier>static</specifier> <name>void</name></type> <name>err_token</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>LexToken</name></type> <name>tok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>lj_lex_error</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name><name>ls</name><operator>-&gt;</operator><name>tok</name></name></expr></argument>, <argument><expr><name>LJ_ERR_XTOKEN</name></expr></argument>, <argument><expr><call><name>lj_lex_token2str</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>LJ_NORET</name> <specifier>static</specifier> <name>void</name></type> <name>err_limit</name><parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>limit</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>what</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>fs</name><operator>-&gt;</operator><name>linedefined</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_lex_error</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>ls</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>LJ_ERR_XLIMM</name></expr></argument>, <argument><expr><name>limit</name></expr></argument>, <argument><expr><name>what</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_lex_error</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>ls</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>LJ_ERR_XLIMF</name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>linedefined</name></name></expr></argument>, <argument><expr><name>limit</name></expr></argument>, <argument><expr><name>what</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>checklimit</name><parameter_list>(<parameter><type><name>fs</name></type></parameter>, <parameter><type><name>v</name></type></parameter>, <parameter><type><name>l</name></type></parameter>, <parameter><type><name>m</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>if ((v) &gt;= (l)) err_limit(fs, l, m)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>checklimitgt</name><parameter_list>(<parameter><type><name>fs</name></type></parameter>, <parameter><type><name>v</name></type></parameter>, <parameter><type><name>l</name></type></parameter>, <parameter><type><name>m</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>if ((v) &gt; (l)) err_limit(fs, l, m)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>checkcond</name><parameter_list>(<parameter><type><name>ls</name></type></parameter>, <parameter><type><name>c</name></type></parameter>, <parameter><type><name>em</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>{ if (!(c)) err_syntax(ls, em); }</cpp:value></cpp:define>

<comment type="block">/* -- Management of constants --------------------------------------------- */</comment>

<comment type="block">/* Return bytecode encoding for primitive constant. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>const_pri</name><parameter_list>(<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>check_exp((e)-&gt;k &lt;= VKTRUE, (e)-&gt;k)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>tvhaskslot</name><parameter_list>(<parameter><type><name>o</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((o)-&gt;u32.hi == 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>tvkslot</name><parameter_list>(<parameter><type><name>o</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((o)-&gt;u32.lo)</cpp:value></cpp:define>

<comment type="block">/* Add a number constant. */</comment>
<function><type><specifier>static</specifier> <name>BCReg</name></type> <name>const_num</name><parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>ExpDesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>L</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>o</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>expr_isnumk</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>lj_tab_set</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>kt</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>nval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>tvhaskslot</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>tvkslot</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>u64</name></name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>nkn</name></name></expr>;</expr_stmt>
  <return>return <expr><name><name>fs</name><operator>-&gt;</operator><name>nkn</name></name><operator>++</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Add a GC object constant. */</comment>
<function><type><specifier>static</specifier> <name>BCReg</name></type> <name>const_gc</name><parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>GCobj</name> <modifier>*</modifier></type><name>gc</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>itype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>L</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TValue</name></type> <name>key</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>o</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>setgcV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>gc</name></expr></argument>, <argument><expr><name>itype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* NOBARRIER: the key is new or kept alive. */</comment>
  <expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>lj_tab_set</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>kt</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>tvhaskslot</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>tvkslot</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>u64</name></name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>nkgc</name></name></expr>;</expr_stmt>
  <return>return <expr><name><name>fs</name><operator>-&gt;</operator><name>nkgc</name></name><operator>++</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Add a string constant. */</comment>
<function><type><specifier>static</specifier> <name>BCReg</name></type> <name>const_str</name><parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>ExpDesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>expr_isstrk</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VGLOBAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>const_gc</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><call><name>obj2gco</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>sval</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LJ_TSTR</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Anchor string constant to avoid GC. */</comment>
<function><type><name>GCstr</name> <modifier>*</modifier></type><name>lj_parse_keepstr</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* NOBARRIER: the key is new or kept alive. */</comment>
  <decl_stmt><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>lj_str_new</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>tv</name> <init>= <expr><call><name>lj_tab_setstr</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name><operator>-&gt;</operator><name>kt</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>tvisnil</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>setboolV</name><argument_list>(<argument><expr><name>tv</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>lj_gc_check</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>s</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>
<comment type="block">/* Anchor cdata to avoid GC. */</comment>
<function><type><name>void</name></type> <name>lj_parse_keepcdata</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>TValue</name> <modifier>*</modifier></type><name>tv</name></decl></parameter>, <parameter><decl><type><name>GCcdata</name> <modifier>*</modifier></type><name>cd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* NOBARRIER: the key is new or kept alive. */</comment>
  <decl_stmt><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>setcdataV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>tv</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setboolV</name><argument_list>(<argument><expr><call><name>lj_tab_set</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name><operator>-&gt;</operator><name>kt</name></name></expr></argument>, <argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* -- Jump list handling -------------------------------------------------- */</comment>

<comment type="block">/* Get next element in jump list. */</comment>
<function><type><specifier>static</specifier> <name>BCPos</name></type> <name>jmp_next</name><parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>BCPos</name></type> <name>pc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>delta</name> <init>= <expr><call><name>bc_j</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>bcbase</name><index>[<expr><name>pc</name></expr>]</index></name><operator>.</operator><name>ins</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>BCPos</name><operator>)</operator><name>delta</name> <operator>==</operator> <name>NO_JMP</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>NO_JMP</name></expr>;</return></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <return>return <expr><operator>(</operator><name>BCPos</name><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>ptrdiff_t</name><operator>)</operator><name>pc</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>+</operator><name>delta</name><operator>)</operator></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Check if any of the instructions on the jump list produce no value. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jmp_novalue</name><parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>BCPos</name></type> <name>list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <for>for <control>(<init>;</init> <condition><expr><name>list</name> <operator>!=</operator> <name>NO_JMP</name></expr>;</condition> <incr><expr><name>list</name> <operator>=</operator> <call><name>jmp_next</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>BCIns</name></type> <name>p</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>bcbase</name><index>[<expr><ternary><condition><expr><name>list</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><name>list</name><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><name>list</name></expr></else></ternary></expr>]</index></name><operator>.</operator><name>ins</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>bc_op</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BC_ISTC</name> <operator>||</operator> <call><name>bc_op</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BC_ISFC</name> <operator>||</operator> <call><name>bc_a</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NO_REG</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Patch register of test instructions. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jmp_patchtestreg</name><parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>BCPos</name></type> <name>pc</name></decl></parameter>, <parameter><decl><type><name>BCReg</name></type> <name>reg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>BCInsLine</name> <modifier>*</modifier></type><name>ilp</name> <init>= <expr><operator>&amp;</operator><name><name>fs</name><operator>-&gt;</operator><name>bcbase</name><index>[<expr><ternary><condition><expr><name>pc</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><name>pc</name><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><name>pc</name></expr></else></ternary></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCOp</name></type> <name>op</name> <init>= <expr><call><name>bc_op</name><argument_list>(<argument><expr><name><name>ilp</name><operator>-&gt;</operator><name>ins</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>BC_ISTC</name> <operator>||</operator> <name>op</name> <operator>==</operator> <name>BC_ISFC</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>reg</name> <operator>!=</operator> <name>NO_REG</name> <operator>&amp;&amp;</operator> <name>reg</name> <operator>!=</operator> <call><name>bc_d</name><argument_list>(<argument><expr><name><name>ilp</name><operator>-&gt;</operator><name>ins</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>setbc_a</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ilp</name><operator>-&gt;</operator><name>ins</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* Nothing to store or already in the right register. */</comment>
      <expr_stmt><expr><call><name>setbc_op</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ilp</name><operator>-&gt;</operator><name>ins</name></name></expr></argument>, <argument><expr><name>op</name><operator>+</operator><operator>(</operator><name>BC_IST</name><operator>-</operator><name>BC_ISTC</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>setbc_a</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ilp</name><operator>-&gt;</operator><name>ins</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>bc_a</name><argument_list>(<argument><expr><name><name>ilp</name><operator>-&gt;</operator><name>ins</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NO_REG</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>reg</name> <operator>==</operator> <name>NO_REG</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>ilp</name><operator>-&gt;</operator><name>ins</name></name> <operator>=</operator> <call><name>BCINS_AJ</name><argument_list>(<argument><expr><name>BC_JMP</name></expr></argument>, <argument><expr><call><name>bc_a</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>bcbase</name><index>[<expr><name>pc</name></expr>]</index></name><operator>.</operator><name>ins</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>setbc_a</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ilp</name><operator>-&gt;</operator><name>ins</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>reg</name> <operator>&gt;=</operator> <call><name>bc_a</name><argument_list>(<argument><expr><name><name>ilp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>ins</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>setbc_a</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ilp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>ins</name></expr></argument>, <argument><expr><name>reg</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* Cannot patch other instructions. */</comment>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Drop values for all instructions on jump list. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jmp_dropval</name><parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>BCPos</name></type> <name>list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <for>for <control>(<init>;</init> <condition><expr><name>list</name> <operator>!=</operator> <name>NO_JMP</name></expr>;</condition> <incr><expr><name>list</name> <operator>=</operator> <call><name>jmp_next</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr></incr>)</control><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>jmp_patchtestreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>list</name></expr></argument>, <argument><expr><name>NO_REG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<comment type="block">/* Patch jump instruction to target. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jmp_patchins</name><parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>BCPos</name></type> <name>pc</name></decl></parameter>, <parameter><decl><type><name>BCPos</name></type> <name>dest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>BCIns</name> <modifier>*</modifier></type><name>jmp</name> <init>= <expr><operator>&amp;</operator><name><name>fs</name><operator>-&gt;</operator><name>bcbase</name><index>[<expr><name>pc</name></expr>]</index></name><operator>.</operator><name>ins</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCPos</name></type> <name>offset</name> <init>= <expr><name>dest</name><operator>-</operator><operator>(</operator><name>pc</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>+</operator><name>BCBIAS_J</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>dest</name> <operator>!=</operator> <name>NO_JMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&gt;</operator> <name>BCMAX_D</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>err_syntax</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>ls</name></name></expr></argument>, <argument><expr><name>LJ_ERR_XJUMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>setbc_d</name><argument_list>(<argument><expr><name>jmp</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Append to jump list. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jmp_append</name><parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>BCPos</name> <modifier>*</modifier></type><name>l1</name></decl></parameter>, <parameter><decl><type><name>BCPos</name></type> <name>l2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>l2</name> <operator>==</operator> <name>NO_JMP</name></expr>)</condition> <block>{<block_content>
    <return>return;</return>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>*</operator><name>l1</name> <operator>==</operator> <name>NO_JMP</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>l1</name> <operator>=</operator> <name>l2</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>BCPos</name></type> <name>list</name> <init>= <expr><operator>*</operator><name>l1</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BCPos</name></type> <name>next</name></decl>;</decl_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>next</name> <operator>=</operator> <call><name>jmp_next</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NO_JMP</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* Find last element. */</comment>
      <expr_stmt><expr><name>list</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt></block_content></block></while>
    <expr_stmt><expr><call><name>jmp_patchins</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>list</name></expr></argument>, <argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Patch jump list and preserve produced values. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jmp_patchval</name><parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>BCPos</name></type> <name>list</name></decl></parameter>, <parameter><decl><type><name>BCPos</name></type> <name>vtarget</name></decl></parameter>,
			 <parameter><decl><type><name>BCReg</name></type> <name>reg</name></decl></parameter>, <parameter><decl><type><name>BCPos</name></type> <name>dtarget</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <while>while <condition>(<expr><name>list</name> <operator>!=</operator> <name>NO_JMP</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>BCPos</name></type> <name>next</name> <init>= <expr><call><name>jmp_next</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>jmp_patchtestreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>list</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>jmp_patchins</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>list</name></expr></argument>, <argument><expr><name>vtarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>  <comment type="block">/* Jump to target with value. */</comment>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>jmp_patchins</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>list</name></expr></argument>, <argument><expr><name>dtarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>  <comment type="block">/* Jump to default target. */</comment>
    <expr_stmt><expr><name>list</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/* Jump to following instruction. Append to list of pending jumps. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jmp_tohere</name><parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>BCPos</name></type> <name>list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>lasttarget</name></name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>pc</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>jmp_append</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>fs</name><operator>-&gt;</operator><name>jpc</name></name></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Patch jump list to target. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jmp_patch</name><parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>BCPos</name></type> <name>list</name></decl></parameter>, <parameter><decl><type><name>BCPos</name></type> <name>target</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>target</name> <operator>==</operator> <name><name>fs</name><operator>-&gt;</operator><name>pc</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>jmp_tohere</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>target</name> <operator>&lt;</operator> <name><name>fs</name><operator>-&gt;</operator><name>pc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>jmp_patchval</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>list</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>NO_REG</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* -- Bytecode register allocator ----------------------------------------- */</comment>

<comment type="block">/* Bump frame size. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>bcreg_bump</name><parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>BCReg</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>BCReg</name></type> <name>sz</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name> <operator>+</operator> <name>n</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>sz</name> <operator>&gt;</operator> <name><name>fs</name><operator>-&gt;</operator><name>framesize</name></name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>sz</name> <operator>&gt;=</operator> <name>LJ_MAX_SLOTS</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>err_syntax</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>ls</name></name></expr></argument>, <argument><expr><name>LJ_ERR_XSLOTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>framesize</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name>sz</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Reserve registers. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>bcreg_reserve</name><parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>BCReg</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>bcreg_bump</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Free register. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>bcreg_free</name><parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>BCReg</name></type> <name>reg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>reg</name> <operator>&gt;=</operator> <name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>reg</name> <operator>==</operator> <name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Free register for expression. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>expr_free</name><parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>ExpDesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VNONRELOC</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>bcreg_free</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* -- Bytecode emitter ---------------------------------------------------- */</comment>

<comment type="block">/* Emit bytecode instruction. */</comment>
<function><type><specifier>static</specifier> <name>BCPos</name></type> <name>bcemit_INS</name><parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>BCIns</name></type> <name>ins</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>BCPos</name></type> <name>pc</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>pc</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>ls</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>jmp_patchval</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>jpc</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>NO_REG</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>jpc</name></name> <operator>=</operator> <name>NO_JMP</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>LJ_UNLIKELY</name><argument_list>(<argument><expr><name>pc</name> <operator>&gt;=</operator> <name><name>fs</name><operator>-&gt;</operator><name>bclim</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>base</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>bcbase</name></name> <operator>-</operator> <name><name>ls</name><operator>-&gt;</operator><name>bcstack</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>checklimit</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>ls</name><operator>-&gt;</operator><name>sizebcstack</name></name></expr></argument>, <argument><expr><name>LJ_MAX_BCINS</name></expr></argument>, <argument><expr><literal type="string">"bytecode instructions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lj_mem_growvec</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name><name>ls</name><operator>-&gt;</operator><name>bcstack</name></name></expr></argument>, <argument><expr><name><name>ls</name><operator>-&gt;</operator><name>sizebcstack</name></name></expr></argument>, <argument><expr><name>LJ_MAX_BCINS</name></expr></argument>,<argument><expr><name>BCInsLine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>bclim</name></name> <operator>=</operator> <operator>(</operator><name>BCPos</name><operator>)</operator><operator>(</operator><name><name>ls</name><operator>-&gt;</operator><name>sizebcstack</name></name> <operator>-</operator> <name>base</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>bcbase</name></name> <operator>=</operator> <name><name>ls</name><operator>-&gt;</operator><name>bcstack</name></name> <operator>+</operator> <name>base</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>bcbase</name><index>[<expr><name>pc</name></expr>]</index></name><operator>.</operator><name>ins</name> <operator>=</operator> <name>ins</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>bcbase</name><index>[<expr><name>pc</name></expr>]</index></name><operator>.</operator><name>line</name> <operator>=</operator> <name><name>ls</name><operator>-&gt;</operator><name>lastline</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>pc</name></name> <operator>=</operator> <name>pc</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <return>return <expr><name>pc</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>bcemit_ABC</name><parameter_list>(<parameter><type><name>fs</name></type></parameter>, <parameter><type><name>o</name></type></parameter>, <parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>bcemit_INS(fs, BCINS_ABC(o, a, b, c))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>bcemit_AD</name><parameter_list>(<parameter><type><name>fs</name></type></parameter>, <parameter><type><name>o</name></type></parameter>, <parameter><type><name>a</name></type></parameter>, <parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>bcemit_INS(fs, BCINS_AD(o, a, d))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>bcemit_AJ</name><parameter_list>(<parameter><type><name>fs</name></type></parameter>, <parameter><type><name>o</name></type></parameter>, <parameter><type><name>a</name></type></parameter>, <parameter><type><name>j</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>bcemit_INS(fs, BCINS_AJ(o, a, j))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>bcptr</name><parameter_list>(<parameter><type><name>fs</name></type></parameter>, <parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro>			<cpp:value>(&amp;(fs)-&gt;bcbase[(e)-&gt;u.s.info].ins)</cpp:value></cpp:define>

<comment type="block">/* -- Bytecode emitter for expressions ------------------------------------ */</comment>

<comment type="block">/* Discharge non-constant expression to any register. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>expr_discharge</name><parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>ExpDesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>BCIns</name></type> <name>ins</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VUPVAL</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>BCINS_AD</name><argument_list>(<argument><expr><name>BC_UGET</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VGLOBAL</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>BCINS_AD</name><argument_list>(<argument><expr><name>BC_GGET</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>const_str</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VINDEXED</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>BCReg</name></type> <name>rc</name> <init>= <expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>aux</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>int32_t</name><operator>)</operator><name>rc</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>BCINS_ABC</name><argument_list>(<argument><expr><name>BC_TGETS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr></argument>, <argument><expr><operator>~</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>rc</name> <operator>&gt;</operator> <name>BCMAX_C</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>BCINS_ABC</name><argument_list>(<argument><expr><name>BC_TGETB</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr></argument>, <argument><expr><name>rc</name><operator>-</operator><operator>(</operator><name>BCMAX_C</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>bcreg_free</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>BCINS_ABC</name><argument_list>(<argument><expr><name>BC_TGETV</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>bcreg_free</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VCALL</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>aux</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <name>VNONRELOC</name></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VLOCAL</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <name>VNONRELOC</name></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <return>return;</return>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name> <operator>=</operator> <call><name>bcemit_INS</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <name>VRELOCABLE</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Emit bytecode to set a range of registers to nil. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>bcemit_nil</name><parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>BCReg</name></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>BCReg</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>fs</name><operator>-&gt;</operator><name>pc</name></name> <operator>&gt;</operator> <name><name>fs</name><operator>-&gt;</operator><name>lasttarget</name></name></expr>)</condition> <block>{<block_content>  <comment type="block">/* No jumps to current position? */</comment>
    <decl_stmt><decl><type><name>BCIns</name> <modifier>*</modifier></type><name>ip</name> <init>= <expr><operator>&amp;</operator><name><name>fs</name><operator>-&gt;</operator><name>bcbase</name><index>[<expr><name><name>fs</name><operator>-&gt;</operator><name>pc</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>ins</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BCReg</name></type> <name>pto</name></decl>, <decl><type ref="prev"/><name>pfrom</name> <init>= <expr><call><name>bc_a</name><argument_list>(<argument><expr><operator>*</operator><name>ip</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <switch>switch <condition>(<expr><call><name>bc_op</name><argument_list>(<argument><expr><operator>*</operator><name>ip</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Try to merge with the previous instruction. */</comment>
    <case>case <expr><name>BC_KPRI</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><call><name>bc_d</name><argument_list>(<argument><expr><operator>*</operator><name>ip</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>~</operator><name>LJ_TNIL</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>from</name> <operator>==</operator> <name>pfrom</name></expr>)</condition> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>from</name> <operator>==</operator> <name>pfrom</name><operator>+</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name>from</name> <operator>=</operator> <name>pfrom</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<break>break;</break>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>ip</name> <operator>=</operator> <call><name>BCINS_AD</name><argument_list>(<argument><expr><name>BC_KNIL</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>from</name><operator>+</operator><name>n</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Replace KPRI. */</comment>
      <return>return;</return>
    <case>case <expr><name>BC_KNIL</name></expr>:</case>
      <expr_stmt><expr><name>pto</name> <operator>=</operator> <call><name>bc_d</name><argument_list>(<argument><expr><operator>*</operator><name>ip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>pfrom</name> <operator>&lt;=</operator> <name>from</name> <operator>&amp;&amp;</operator> <name>from</name> <operator>&lt;=</operator> <name>pto</name><operator>+</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* Can we connect both ranges? */</comment>
	<if_stmt><if>if <condition>(<expr><name>from</name><operator>+</operator><name>n</name><operator>-</operator><literal type="number">1</literal> <operator>&gt;</operator> <name>pto</name></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><call><name>setbc_d</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>from</name><operator>+</operator><name>n</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Patch previous instruction range. */</comment>
	<return>return;</return>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    <default>default:</default>
      <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* Emit new instruction or replace old instruction. */</comment>
  <expr_stmt><expr><call><name>bcemit_INS</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><ternary><condition><expr><name>n</name> <operator>==</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><call><name>BCINS_AD</name><argument_list>(<argument><expr><name>BC_KPRI</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>VKNIL</name></expr></argument>)</argument_list></call></expr> </then><else>:
			  <expr><call><name>BCINS_AD</name><argument_list>(<argument><expr><name>BC_KNIL</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>from</name><operator>+</operator><name>n</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Discharge an expression to a specific register. Ignore branches. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>expr_toreg_nobranch</name><parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>ExpDesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>, <parameter><decl><type><name>BCReg</name></type> <name>reg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>BCIns</name></type> <name>ins</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>expr_discharge</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VKSTR</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>BCINS_AD</name><argument_list>(<argument><expr><name>BC_KSTR</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><call><name>const_str</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VKNUM</name></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_DUALNUM</name></expr></cpp:if>
    <decl_stmt><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>tv</name> <init>= <expr><call><name>expr_numtv</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>tvisint</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>checki16</name><argument_list>(<argument><expr><call><name>intV</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>BCINS_AD</name><argument_list>(<argument><expr><name>BC_KSHORT</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><operator>(</operator><name>BCReg</name><operator>)</operator><operator>(</operator><name>uint16_t</name><operator>)</operator><call><name>intV</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>lua_Number</name></type> <name>n</name> <init>= <expr><call><name>expr_numberV</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt></block_content></block></else></if_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>k</name> <init>= <expr><call><name>lj_num2int</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>checki16</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>n</name> <operator>==</operator> <operator>(</operator><name>lua_Number</name><operator>)</operator><name>k</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>BCINS_AD</name><argument_list>(<argument><expr><name>BC_KSHORT</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><operator>(</operator><name>BCReg</name><operator>)</operator><operator>(</operator><name>uint16_t</name><operator>)</operator><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>BCINS_AD</name><argument_list>(<argument><expr><name>BC_KNUM</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><call><name>const_num</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VKCDATA</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>PROTO_FFI</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>BCINS_AD</name><argument_list>(<argument><expr><name>BC_KCDATA</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>,
		   <argument><expr><call><name>const_gc</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><call><name>obj2gco</name><argument_list>(<argument><expr><call><name>cdataV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>nval</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LJ_TCDATA</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VRELOCABLE</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>setbc_a</name><argument_list>(<argument><expr><call><name>bcptr</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>noins</name>;</goto>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VNONRELOC</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>reg</name> <operator>==</operator> <name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr>)</condition><block type="pseudo"><block_content>
      <goto>goto <name>noins</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>BCINS_AD</name><argument_list>(<argument><expr><name>BC_MOV</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VKNIL</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>bcemit_nil</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>noins</name>;</goto>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>&lt;=</operator> <name>VKTRUE</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>BCINS_AD</name><argument_list>(<argument><expr><name>BC_KPRI</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><call><name>const_pri</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VVOID</name> <operator>||</operator> <name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VJMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>bcemit_INS</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>noins</name>:</label>
  <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name> <operator>=</operator> <name>reg</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <name>VNONRELOC</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Forward declaration. */</comment>
<function_decl><type><specifier>static</specifier> <name>BCPos</name></type> <name>bcemit_jmp</name><parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Discharge an expression to a specific register. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>expr_toreg</name><parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>ExpDesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>, <parameter><decl><type><name>BCReg</name></type> <name>reg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>expr_toreg_nobranch</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VJMP</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>jmp_append</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>e</name><operator>-&gt;</operator><name>t</name></name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Add it to the true jump list. */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>expr_hasjump</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Discharge expression with branches. */</comment>
    <decl_stmt><decl><type><name>BCPos</name></type> <name>jend</name></decl>, <decl><type ref="prev"/><name>jfalse</name> <init>= <expr><name>NO_JMP</name></expr></init></decl>, <decl><type ref="prev"/><name>jtrue</name> <init>= <expr><name>NO_JMP</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>jmp_novalue</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>jmp_novalue</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>BCPos</name></type> <name>jval</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VJMP</name><operator>)</operator></expr> ?</condition><then> <expr><name>NO_JMP</name></expr> </then><else>: <expr><call><name>bcemit_jmp</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>jfalse</name> <operator>=</operator> <call><name>bcemit_AD</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>BC_KPRI</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><name>VKFALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>bcemit_AJ</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>BC_JMP</name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>jtrue</name> <operator>=</operator> <call><name>bcemit_AD</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>BC_KPRI</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><name>VKTRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>jmp_tohere</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>jval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>jend</name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>pc</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>lasttarget</name></name> <operator>=</operator> <name>jend</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>jmp_patchval</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>f</name></name></expr></argument>, <argument><expr><name>jend</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><name>jfalse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>jmp_patchval</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>t</name></name></expr></argument>, <argument><expr><name>jend</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><name>jtrue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>f</name></name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>t</name></name> <operator>=</operator> <name>NO_JMP</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name> <operator>=</operator> <name>reg</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <name>VNONRELOC</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Discharge an expression to the next free register. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>expr_tonextreg</name><parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>ExpDesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>expr_discharge</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>expr_free</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>bcreg_reserve</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>expr_toreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Discharge an expression to any register. */</comment>
<function><type><specifier>static</specifier> <name>BCReg</name></type> <name>expr_toanyreg</name><parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>ExpDesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>expr_discharge</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VNONRELOC</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>expr_hasjump</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* Already in a register. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name> <operator>&gt;=</operator> <name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>expr_toreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Discharge to temp. register. */</comment>
      <return>return <expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>expr_tonextreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Discharge to next register. */</comment>
  <return>return <expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Partially discharge expression to a value. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>expr_toval</name><parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>ExpDesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>expr_hasjump</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>expr_toanyreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>expr_discharge</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Emit store for LHS expression. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>bcemit_store</name><parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>ExpDesc</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><name>ExpDesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>BCIns</name></type> <name>ins</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VLOCAL</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>ls</name><operator>-&gt;</operator><name>vstack</name><index>[<expr><name><name>var</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>aux</name></name></expr>]</index></name><operator>.</operator><name>info</name> <operator>|=</operator> <name>VSTACK_VAR_RW</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>expr_free</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>expr_toreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VUPVAL</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>ls</name><operator>-&gt;</operator><name>vstack</name><index>[<expr><name><name>var</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>aux</name></name></expr>]</index></name><operator>.</operator><name>info</name> <operator>|=</operator> <name>VSTACK_VAR_RW</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>expr_toval</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>&lt;=</operator> <name>VKTRUE</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>BCINS_AD</name><argument_list>(<argument><expr><name>BC_USETP</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr></argument>, <argument><expr><call><name>const_pri</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VKSTR</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>BCINS_AD</name><argument_list>(<argument><expr><name>BC_USETS</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr></argument>, <argument><expr><call><name>const_str</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VKNUM</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>BCINS_AD</name><argument_list>(<argument><expr><name>BC_USETN</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr></argument>, <argument><expr><call><name>const_num</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>BCINS_AD</name><argument_list>(<argument><expr><name>BC_USETV</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr></argument>, <argument><expr><call><name>expr_toanyreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VGLOBAL</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>BCReg</name></type> <name>ra</name> <init>= <expr><call><name>expr_toanyreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>BCINS_AD</name><argument_list>(<argument><expr><name>BC_GSET</name></expr></argument>, <argument><expr><name>ra</name></expr></argument>, <argument><expr><call><name>const_str</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>var</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>BCReg</name></type> <name>ra</name></decl>, <decl><type ref="prev"/><name>rc</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VINDEXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ra</name> <operator>=</operator> <call><name>expr_toanyreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>aux</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>int32_t</name><operator>)</operator><name>rc</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>BCINS_ABC</name><argument_list>(<argument><expr><name>BC_TSETS</name></expr></argument>, <argument><expr><name>ra</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr></argument>, <argument><expr><operator>~</operator><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>rc</name> <operator>&gt;</operator> <name>BCMAX_C</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>BCINS_ABC</name><argument_list>(<argument><expr><name>BC_TSETB</name></expr></argument>, <argument><expr><name>ra</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr></argument>, <argument><expr><name>rc</name><operator>-</operator><operator>(</operator><name>BCMAX_C</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <comment type="block">/* Free late alloced key reg to avoid assert on free of value reg. */</comment>
      <comment type="block">/* This can only happen when called from expr_table(). */</comment>
      <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>!=</operator> <name>VNONRELOC</name> <operator>||</operator> <name>ra</name> <operator>&lt;</operator> <name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name> <operator>||</operator>
		 <name>rc</name> <operator>&lt;</operator> <name>ra</name> <operator>||</operator> <operator>(</operator><call><name>bcreg_free</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call><operator>,</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>BCINS_ABC</name><argument_list>(<argument><expr><name>BC_TSETV</name></expr></argument>, <argument><expr><name>ra</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>bcemit_INS</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>expr_free</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Emit method lookup expression. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>bcemit_method</name><parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>ExpDesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>, <parameter><decl><type><name>ExpDesc</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>BCReg</name></type> <name>idx</name></decl>, <decl><type ref="prev"/><name>func</name></decl>, <decl><type ref="prev"/><name>obj</name> <init>= <expr><call><name>expr_toanyreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>expr_free</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>func</name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>bcemit_AD</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>BC_MOV</name></expr></argument>, <argument><expr><name>func</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><name>LJ_FR2</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Copy object to 1st argument. */</comment>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>expr_isstrk</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>const_str</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&lt;=</operator> <name>BCMAX_C</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>bcreg_reserve</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><literal type="number">2</literal><operator>+</operator><name>LJ_FR2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>bcemit_ABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>BC_TGETS</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>bcreg_reserve</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><literal type="number">3</literal><operator>+</operator><name>LJ_FR2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>bcemit_AD</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>BC_KSTR</name></expr></argument>, <argument><expr><name>func</name><operator>+</operator><literal type="number">2</literal><operator>+</operator><name>LJ_FR2</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>bcemit_ABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>BC_TGETV</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>func</name><operator>+</operator><literal type="number">2</literal><operator>+</operator><name>LJ_FR2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name><operator>--</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name> <operator>=</operator> <name>func</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <name>VNONRELOC</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* -- Bytecode emitter for branches --------------------------------------- */</comment>

<comment type="block">/* Emit unconditional branch. */</comment>
<function><type><specifier>static</specifier> <name>BCPos</name></type> <name>bcemit_jmp</name><parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>BCPos</name></type> <name>jpc</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>jpc</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCPos</name></type> <name>j</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>pc</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCIns</name> <modifier>*</modifier></type><name>ip</name> <init>= <expr><operator>&amp;</operator><name><name>fs</name><operator>-&gt;</operator><name>bcbase</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>ins</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>jpc</name></name> <operator>=</operator> <name>NO_JMP</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>int32_t</name><operator>)</operator><name>j</name> <operator>&gt;=</operator> <operator>(</operator><name>int32_t</name><operator>)</operator><name><name>fs</name><operator>-&gt;</operator><name>lasttarget</name></name> <operator>&amp;&amp;</operator> <call><name>bc_op</name><argument_list>(<argument><expr><operator>*</operator><name>ip</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BC_UCLO</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>setbc_j</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>NO_JMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>lasttarget</name></name> <operator>=</operator> <name>j</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name>j</name> <operator>=</operator> <call><name>bcemit_AJ</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>BC_JMP</name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name></expr></argument>, <argument><expr><name>NO_JMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>jmp_append</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>j</name></expr></argument>, <argument><expr><name>jpc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>j</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Invert branch condition of bytecode instruction. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>invertcond</name><parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>ExpDesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>BCIns</name> <modifier>*</modifier></type><name>ip</name> <init>= <expr><operator>&amp;</operator><name><name>fs</name><operator>-&gt;</operator><name>bcbase</name><index>[<expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>ins</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>setbc_op</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><call><name>bc_op</name><argument_list>(<argument><expr><operator>*</operator><name>ip</name></expr></argument>)</argument_list></call><operator>^</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Emit conditional branch. */</comment>
<function><type><specifier>static</specifier> <name>BCPos</name></type> <name>bcemit_branch</name><parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>ExpDesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cond</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>BCPos</name></type> <name>pc</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VRELOCABLE</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>BCIns</name> <modifier>*</modifier></type><name>ip</name> <init>= <expr><call><name>bcptr</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>bc_op</name><argument_list>(<argument><expr><operator>*</operator><name>ip</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BC_NOT</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>ip</name> <operator>=</operator> <call><name>BCINS_AD</name><argument_list>(<argument><expr><ternary><condition><expr><name>cond</name></expr> ?</condition><then> <expr><name>BC_ISF</name></expr> </then><else>: <expr><name>BC_IST</name></expr></else></ternary></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>bc_d</name><argument_list>(<argument><expr><operator>*</operator><name>ip</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><call><name>bcemit_jmp</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>!=</operator> <name>VNONRELOC</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>bcreg_reserve</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>expr_toreg_nobranch</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>bcemit_AD</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><ternary><condition><expr><name>cond</name></expr> ?</condition><then> <expr><name>BC_ISTC</name></expr> </then><else>: <expr><name>BC_ISFC</name></expr></else></ternary></expr></argument>, <argument><expr><name>NO_REG</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pc</name> <operator>=</operator> <call><name>bcemit_jmp</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>expr_free</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Emit branch on true condition. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>bcemit_branch_t</name><parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>ExpDesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>BCPos</name></type> <name>pc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>expr_discharge</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VKSTR</name> <operator>||</operator> <name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VKNUM</name> <operator>||</operator> <name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VKTRUE</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>pc</name> <operator>=</operator> <name>NO_JMP</name></expr>;</expr_stmt></block_content></block></if>  <comment type="block">/* Never jump. */</comment>
  <if type="elseif">else if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VJMP</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>invertcond</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><name>pc</name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VKFALSE</name> <operator>||</operator> <name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VKNIL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>expr_toreg_nobranch</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>NO_REG</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><name>pc</name> <operator>=</operator> <call><name>bcemit_jmp</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><name>pc</name> <operator>=</operator> <call><name>bcemit_branch</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  <expr_stmt><expr><call><name>jmp_append</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>e</name><operator>-&gt;</operator><name>f</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>jmp_tohere</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>t</name></name> <operator>=</operator> <name>NO_JMP</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Emit branch on false condition. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>bcemit_branch_f</name><parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>ExpDesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>BCPos</name></type> <name>pc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>expr_discharge</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VKNIL</name> <operator>||</operator> <name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VKFALSE</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>pc</name> <operator>=</operator> <name>NO_JMP</name></expr>;</expr_stmt></block_content></block></if>  <comment type="block">/* Never jump. */</comment>
  <if type="elseif">else if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VJMP</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>pc</name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VKSTR</name> <operator>||</operator> <name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VKNUM</name> <operator>||</operator> <name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VKTRUE</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>expr_toreg_nobranch</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>NO_REG</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><name>pc</name> <operator>=</operator> <call><name>bcemit_jmp</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><name>pc</name> <operator>=</operator> <call><name>bcemit_branch</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  <expr_stmt><expr><call><name>jmp_append</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>e</name><operator>-&gt;</operator><name>t</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>jmp_tohere</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>f</name></name> <operator>=</operator> <name>NO_JMP</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* -- Bytecode emitter for operators -------------------------------------- */</comment>

<comment type="block">/* Try constant-folding of arithmetic operators. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>foldarith</name><parameter_list>(<parameter><decl><type><name>BinOpr</name></type> <name>opr</name></decl></parameter>, <parameter><decl><type><name>ExpDesc</name> <modifier>*</modifier></type><name>e1</name></decl></parameter>, <parameter><decl><type><name>ExpDesc</name> <modifier>*</modifier></type><name>e2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TValue</name></type> <name>o</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>lua_Number</name></type> <name>n</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>expr_isnumk_nojump</name><argument_list>(<argument><expr><name>e1</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>expr_isnumk_nojump</name><argument_list>(<argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>lj_vm_foldarith</name><argument_list>(<argument><expr><call><name>expr_numberV</name><argument_list>(<argument><expr><name>e1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>expr_numberV</name><argument_list>(<argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>opr</name><operator>-</operator><name>OPR_ADD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setnumV</name><argument_list>(<argument><expr><operator>&amp;</operator><name>o</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>tvisnan</name><argument_list>(<argument><expr><operator>&amp;</operator><name>o</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>tvismzero</name><argument_list>(<argument><expr><operator>&amp;</operator><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* Avoid NaN and -0 as consts. */</comment>
  <if_stmt><if>if <condition>(<expr><name>LJ_DUALNUM</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>k</name> <init>= <expr><call><name>lj_num2int</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>lua_Number</name><operator>)</operator><name>k</name> <operator>==</operator> <name>n</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>setintV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>e1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>nval</name></name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>setnumV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>e1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>nval</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Emit arithmetic operator. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>bcemit_arith</name><parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>BinOpr</name></type> <name>opr</name></decl></parameter>, <parameter><decl><type><name>ExpDesc</name> <modifier>*</modifier></type><name>e1</name></decl></parameter>, <parameter><decl><type><name>ExpDesc</name> <modifier>*</modifier></type><name>e2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>BCReg</name></type> <name>rb</name></decl>, <decl><type ref="prev"/><name>rc</name></decl>, <decl><type ref="prev"/><name>t</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>op</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>foldarith</name><argument_list>(<argument><expr><name>opr</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>opr</name> <operator>==</operator> <name>OPR_POW</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>op</name> <operator>=</operator> <name>BC_POW</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>expr_toanyreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rb</name> <operator>=</operator> <call><name>expr_toanyreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name>op</name> <operator>=</operator> <name>opr</name><operator>-</operator><name>OPR_ADD</name><operator>+</operator><name>BC_ADDVV</name></expr>;</expr_stmt>
    <comment type="block">/* Must discharge 2nd operand first since VINDEXED might free regs. */</comment>
    <expr_stmt><expr><call><name>expr_toval</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>expr_isnumk</name><argument_list>(<argument><expr><name>e2</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>rc</name> <operator>=</operator> <call><name>const_num</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;=</operator> <name>BCMAX_C</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>op</name> <operator>-=</operator> <name>BC_ADDVV</name><operator>-</operator><name>BC_ADDVN</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>expr_toanyreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <comment type="block">/* 1st operand discharged by bcemit_binop_left, but need KNUM/KSHORT. */</comment>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>expr_isnumk</name><argument_list>(<argument><expr><name>e1</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>e1</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VNONRELOC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>expr_toval</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Avoid two consts to satisfy bytecode constraints. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>expr_isnumk</name><argument_list>(<argument><expr><name>e1</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>expr_isnumk</name><argument_list>(<argument><expr><name>e2</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
	<operator>(</operator><name>t</name> <operator>=</operator> <call><name>const_num</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;=</operator> <name>BCMAX_B</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>rb</name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>t</name></expr>;</expr_stmt> <expr_stmt><expr><name>op</name> <operator>-=</operator> <name>BC_ADDVV</name><operator>-</operator><name>BC_ADDNV</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>rb</name> <operator>=</operator> <call><name>expr_toanyreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
  <comment type="block">/* Using expr_free might cause asserts if the order is wrong. */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>e1</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VNONRELOC</name> <operator>&amp;&amp;</operator> <name><name>e1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name> <operator>&gt;=</operator> <name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>e2</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VNONRELOC</name> <operator>&amp;&amp;</operator> <name><name>e2</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name> <operator>&gt;=</operator> <name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>e1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name> <operator>=</operator> <call><name>bcemit_ABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>rb</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>e1</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <name>VRELOCABLE</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Emit comparison operator. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>bcemit_comp</name><parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>BinOpr</name></type> <name>opr</name></decl></parameter>, <parameter><decl><type><name>ExpDesc</name> <modifier>*</modifier></type><name>e1</name></decl></parameter>, <parameter><decl><type><name>ExpDesc</name> <modifier>*</modifier></type><name>e2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>ExpDesc</name> <modifier>*</modifier></type><name>eret</name> <init>= <expr><name>e1</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCIns</name></type> <name>ins</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>expr_toval</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>opr</name> <operator>==</operator> <name>OPR_EQ</name> <operator>||</operator> <name>opr</name> <operator>==</operator> <name>OPR_NE</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>BCOp</name></type> <name>op</name> <init>= <expr><ternary><condition><expr><name>opr</name> <operator>==</operator> <name>OPR_EQ</name></expr> ?</condition><then> <expr><name>BC_ISEQV</name></expr> </then><else>: <expr><name>BC_ISNEV</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BCReg</name></type> <name>ra</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>expr_isk</name><argument_list>(<argument><expr><name>e1</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>e1</name> <operator>=</operator> <name>e2</name></expr>;</expr_stmt> <expr_stmt><expr><name>e2</name> <operator>=</operator> <name>eret</name></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>  <comment type="block">/* Need constant in 2nd arg. */</comment>
    <expr_stmt><expr><name>ra</name> <operator>=</operator> <call><name>expr_toanyreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* First arg must be in a reg. */</comment>
    <expr_stmt><expr><call><name>expr_toval</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <switch>switch <condition>(<expr><name><name>e2</name><operator>-&gt;</operator><name>k</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>VKNIL</name></expr>:</case> <case>case <expr><name>VKFALSE</name></expr>:</case> <case>case <expr><name>VKTRUE</name></expr>:</case>
      <expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>BCINS_AD</name><argument_list>(<argument><expr><name>op</name><operator>+</operator><operator>(</operator><name>BC_ISEQP</name><operator>-</operator><name>BC_ISEQV</name><operator>)</operator></expr></argument>, <argument><expr><name>ra</name></expr></argument>, <argument><expr><call><name>const_pri</name><argument_list>(<argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>VKSTR</name></expr>:</case>
      <expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>BCINS_AD</name><argument_list>(<argument><expr><name>op</name><operator>+</operator><operator>(</operator><name>BC_ISEQS</name><operator>-</operator><name>BC_ISEQV</name><operator>)</operator></expr></argument>, <argument><expr><name>ra</name></expr></argument>, <argument><expr><call><name>const_str</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>VKNUM</name></expr>:</case>
      <expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>BCINS_AD</name><argument_list>(<argument><expr><name>op</name><operator>+</operator><operator>(</operator><name>BC_ISEQN</name><operator>-</operator><name>BC_ISEQV</name><operator>)</operator></expr></argument>, <argument><expr><name>ra</name></expr></argument>, <argument><expr><call><name>const_num</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <default>default:</default>
      <expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>BCINS_AD</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>ra</name></expr></argument>, <argument><expr><call><name>expr_toanyreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>op</name> <init>= <expr><name>opr</name><operator>-</operator><name>OPR_LT</name><operator>+</operator><name>BC_ISLT</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BCReg</name></type> <name>ra</name></decl>, <decl><type ref="prev"/><name>rd</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>op</name><operator>-</operator><name>BC_ISLT</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* GT -&gt; LT, GE -&gt; LE */</comment>
      <expr_stmt><expr><name>e1</name> <operator>=</operator> <name>e2</name></expr>;</expr_stmt> <expr_stmt><expr><name>e2</name> <operator>=</operator> <name>eret</name></expr>;</expr_stmt>  <comment type="block">/* Swap operands. */</comment>
      <expr_stmt><expr><name>op</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>op</name><operator>-</operator><name>BC_ISLT</name><operator>)</operator><operator>^</operator><literal type="number">3</literal><operator>)</operator><operator>+</operator><name>BC_ISLT</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>expr_toval</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>ra</name> <operator>=</operator> <call><name>expr_toanyreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rd</name> <operator>=</operator> <call><name>expr_toanyreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>rd</name> <operator>=</operator> <call><name>expr_toanyreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>ra</name> <operator>=</operator> <call><name>expr_toanyreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>BCINS_AD</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>ra</name></expr></argument>, <argument><expr><name>rd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <comment type="block">/* Using expr_free might cause asserts if the order is wrong. */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>e1</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VNONRELOC</name> <operator>&amp;&amp;</operator> <name><name>e1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name> <operator>&gt;=</operator> <name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>e2</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VNONRELOC</name> <operator>&amp;&amp;</operator> <name><name>e2</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name> <operator>&gt;=</operator> <name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>bcemit_INS</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>eret</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name> <operator>=</operator> <call><name>bcemit_jmp</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>eret</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <name>VJMP</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Fixup left side of binary operator. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>bcemit_binop_left</name><parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>BinOpr</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>ExpDesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>OPR_AND</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>bcemit_branch_t</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>op</name> <operator>==</operator> <name>OPR_OR</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>bcemit_branch_f</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>op</name> <operator>==</operator> <name>OPR_CONCAT</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>expr_tonextreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>op</name> <operator>==</operator> <name>OPR_EQ</name> <operator>||</operator> <name>op</name> <operator>==</operator> <name>OPR_NE</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>expr_isk_nojump</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>expr_toanyreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>expr_isnumk_nojump</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>expr_toanyreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Emit binary operator. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>bcemit_binop</name><parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>BinOpr</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>ExpDesc</name> <modifier>*</modifier></type><name>e1</name></decl></parameter>, <parameter><decl><type><name>ExpDesc</name> <modifier>*</modifier></type><name>e2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>op</name> <operator>&lt;=</operator> <name>OPR_POW</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>bcemit_arith</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>op</name> <operator>==</operator> <name>OPR_AND</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>e1</name><operator>-&gt;</operator><name>t</name></name> <operator>==</operator> <name>NO_JMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* List must be closed. */</comment>
    <expr_stmt><expr><call><name>expr_discharge</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>jmp_append</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>e2</name><operator>-&gt;</operator><name>f</name></name></expr></argument>, <argument><expr><name><name>e1</name><operator>-&gt;</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>e1</name> <operator>=</operator> <operator>*</operator><name>e2</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>op</name> <operator>==</operator> <name>OPR_OR</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>e1</name><operator>-&gt;</operator><name>f</name></name> <operator>==</operator> <name>NO_JMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* List must be closed. */</comment>
    <expr_stmt><expr><call><name>expr_discharge</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>jmp_append</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>e2</name><operator>-&gt;</operator><name>t</name></name></expr></argument>, <argument><expr><name><name>e1</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>e1</name> <operator>=</operator> <operator>*</operator><name>e2</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>op</name> <operator>==</operator> <name>OPR_CONCAT</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>expr_toval</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>e2</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VRELOCABLE</name> <operator>&amp;&amp;</operator> <call><name>bc_op</name><argument_list>(<argument><expr><operator>*</operator><call><name>bcptr</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>BC_CAT</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>e1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name> <operator>==</operator> <call><name>bc_b</name><argument_list>(<argument><expr><operator>*</operator><call><name>bcptr</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>expr_free</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>setbc_b</name><argument_list>(<argument><expr><call><name>bcptr</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>e1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>e1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name> <operator>=</operator> <name><name>e2</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>expr_tonextreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>expr_free</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>expr_free</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>e1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name> <operator>=</operator> <call><name>bcemit_ABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>BC_CAT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>e1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr></argument>, <argument><expr><name><name>e2</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>e1</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <name>VRELOCABLE</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>op</name> <operator>==</operator> <name>OPR_NE</name> <operator>||</operator> <name>op</name> <operator>==</operator> <name>OPR_EQ</name> <operator>||</operator>
	       <name>op</name> <operator>==</operator> <name>OPR_LT</name> <operator>||</operator> <name>op</name> <operator>==</operator> <name>OPR_GE</name> <operator>||</operator> <name>op</name> <operator>==</operator> <name>OPR_LE</name> <operator>||</operator> <name>op</name> <operator>==</operator> <name>OPR_GT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>bcemit_comp</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Emit unary operator. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>bcemit_unop</name><parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>BCOp</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>ExpDesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>BC_NOT</name></expr>)</condition> <block>{<block_content>
    <comment type="block">/* Swap true and false lists. */</comment>
    <block>{<block_content> <decl_stmt><decl><type><name>BCPos</name></type> <name>temp</name> <init>= <expr><name><name>e</name><operator>-&gt;</operator><name>f</name></name></expr></init></decl>;</decl_stmt> <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>f</name></name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>t</name></name></expr>;</expr_stmt> <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>t</name></name> <operator>=</operator> <name>temp</name></expr>;</expr_stmt> </block_content>}</block>
    <expr_stmt><expr><call><name>jmp_dropval</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>jmp_dropval</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>expr_discharge</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VKNIL</name> <operator>||</operator> <name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VKFALSE</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <name>VKTRUE</name></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>expr_isk</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name>LJ_HASFFI</name> <operator>&amp;&amp;</operator> <name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VKCDATA</name><operator>)</operator></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <name>VKFALSE</name></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VJMP</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>invertcond</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VRELOCABLE</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>bcreg_reserve</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>setbc_a</name><argument_list>(<argument><expr><call><name>bcptr</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <name>VNONRELOC</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VNONRELOC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>op</name> <operator>==</operator> <name>BC_UNM</name> <operator>||</operator> <name>op</name> <operator>==</operator> <name>BC_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>BC_UNM</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>expr_hasjump</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Constant-fold negations. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>
      <if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VKCDATA</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Fold in-place since cdata is not interned. */</comment>
	<decl_stmt><decl><type><name>GCcdata</name> <modifier>*</modifier></type><name>cd</name> <init>= <expr><call><name>cdataV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>nval</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator><call><name>cdataptr</name><argument_list>(<argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>cd</name><operator>-&gt;</operator><name>ctypeid</name></name> <operator>==</operator> <name>CTID_COMPLEX_DOUBLE</name></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>^=</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><call><name>U64x</name><argument_list>(<argument><expr><literal type="number">80000000</literal></expr></argument>,<argument><expr><literal type="number">00000000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
	  <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <operator>-</operator><operator>*</operator><name>p</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<return>return;</return>
      </block_content>}</block></if> <if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      if <condition>(<expr><call><name>expr_isnumk</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>expr_numiszero</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Avoid folding to -0. */</comment>
	<decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>expr_numtv</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>tvisint</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	  <decl_stmt><decl><type><name>int32_t</name></type> <name>k</name> <init>= <expr><call><name>intV</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	  <if_stmt><if>if <condition>(<expr><name>k</name> <operator>==</operator> <operator>-</operator><name>k</name></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><call><name>setnumV</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><operator>-</operator><operator>(</operator><name>lua_Number</name><operator>)</operator><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	  <else>else<block type="pseudo"><block_content>
	    <expr_stmt><expr><call><name>setintV</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><operator>-</operator><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	  <return>return;</return>
	</block_content>}</block></if> <else>else <block>{<block_content>
	  <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>u64</name></name> <operator>^=</operator> <call><name>U64x</name><argument_list>(<argument><expr><literal type="number">80000000</literal></expr></argument>,<argument><expr><literal type="number">00000000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <return>return;</return>
	</block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>expr_toanyreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>expr_free</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name> <operator>=</operator> <call><name>bcemit_AD</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <name>VRELOCABLE</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* -- Lexer support ------------------------------------------------------- */</comment>

<comment type="block">/* Check and consume optional token. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lex_opt</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>LexToken</name></type> <name>tok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>tok</name></name> <operator>==</operator> <name>tok</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>lj_lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Check and consume token. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>lex_check</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>LexToken</name></type> <name>tok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>tok</name></name> <operator>!=</operator> <name>tok</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>err_token</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>lj_lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Check for matching token. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>lex_match</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>LexToken</name></type> <name>what</name></decl></parameter>, <parameter><decl><type><name>LexToken</name></type> <name>who</name></decl></parameter>, <parameter><decl><type><name>BCLine</name></type> <name>line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lex_opt</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>what</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>line</name> <operator>==</operator> <name><name>ls</name><operator>-&gt;</operator><name>linenumber</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>err_token</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>what</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>swhat</name> <init>= <expr><call><name>lj_lex_token2str</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>what</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>swho</name> <init>= <expr><call><name>lj_lex_token2str</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>who</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>lj_lex_error</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name><name>ls</name><operator>-&gt;</operator><name>tok</name></name></expr></argument>, <argument><expr><name>LJ_ERR_XMATCH</name></expr></argument>, <argument><expr><name>swhat</name></expr></argument>, <argument><expr><name>swho</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Check for string token. */</comment>
<function><type><specifier>static</specifier> <name>GCstr</name> <modifier>*</modifier></type><name>lex_str</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>tok</name></name> <operator>!=</operator> <name>TK_name</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>LJ_52</name> <operator>||</operator> <name><name>ls</name><operator>-&gt;</operator><name>tok</name></name> <operator>!=</operator> <name>TK_goto</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>err_token</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>TK_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>strV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ls</name><operator>-&gt;</operator><name>tokval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lj_lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>s</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -- Variable handling --------------------------------------------------- */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>var_get</name><parameter_list>(<parameter><type><name>ls</name></type></parameter>, <parameter><type><name>fs</name></type></parameter>, <parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((ls)-&gt;vstack[(fs)-&gt;varmap[(i)]])</cpp:value></cpp:define>

<comment type="block">/* Define a new local variable. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>var_new</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>BCReg</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MSize</name></type> <name>vtop</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>vtop</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>checklimit</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name><operator>+</operator><name>n</name></expr></argument>, <argument><expr><name>LJ_MAX_LOCVAR</name></expr></argument>, <argument><expr><literal type="string">"local variables"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>LJ_UNLIKELY</name><argument_list>(<argument><expr><name>vtop</name> <operator>&gt;=</operator> <name><name>ls</name><operator>-&gt;</operator><name>sizevstack</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>sizevstack</name></name> <operator>&gt;=</operator> <name>LJ_MAX_VSTACK</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>lj_lex_error</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>LJ_ERR_XLIMC</name></expr></argument>, <argument><expr><name>LJ_MAX_VSTACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>lj_mem_growvec</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name><name>ls</name><operator>-&gt;</operator><name>vstack</name></name></expr></argument>, <argument><expr><name><name>ls</name><operator>-&gt;</operator><name>sizevstack</name></name></expr></argument>, <argument><expr><name>LJ_MAX_VSTACK</name></expr></argument>, <argument><expr><name>VarInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>name</name> <operator>&lt;</operator> <name>VARNAME__MAX</name> <operator>||</operator>
	     <call><name>lj_tab_getstr</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>kt</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* NOBARRIER: name is anchored in fs-&gt;kt and ls-&gt;vstack is not a GCobj. */</comment>
  <expr_stmt><expr><call><name>setgcref</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>vstack</name><index>[<expr><name>vtop</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><call><name>obj2gco</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>varmap</name><index>[<expr><name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name><operator>+</operator><name>n</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><name>vtop</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>vtop</name></name> <operator>=</operator> <name>vtop</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>var_new_lit</name><parameter_list>(<parameter><type><name>ls</name></type></parameter>, <parameter><type><name>n</name></type></parameter>, <parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>var_new(ls, (n), lj_parse_keepstr(ls, "" v, sizeof(v)-1))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>var_new_fixed</name><parameter_list>(<parameter><type><name>ls</name></type></parameter>, <parameter><type><name>n</name></type></parameter>, <parameter><type><name>vn</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>var_new(ls, (n), (GCstr *)(uintptr_t)(vn))</cpp:value></cpp:define>

<comment type="block">/* Add local variables. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>var_add</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>BCReg</name></type> <name>nvars</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCReg</name></type> <name>nactvar</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><name>nvars</name><operator>--</operator></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>VarInfo</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><operator>&amp;</operator><call><name>var_get</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>nactvar</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>startpc</name></name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>pc</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>slot</name></name> <operator>=</operator> <name>nactvar</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>info</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name> <operator>=</operator> <name>nactvar</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Remove local variables. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>var_remove</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>BCReg</name></type> <name>tolevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name> <operator>&gt;</operator> <name>tolevel</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>var_get</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>--</operator><name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name></expr></argument>)</argument_list></call><operator>.</operator><name>endpc</name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>pc</name></name></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></function>

<comment type="block">/* Lookup local variable name. */</comment>
<function><type><specifier>static</specifier> <name>BCReg</name></type> <name>var_lookup_local</name><parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <call><name>strref</name><argument_list>(<argument><expr><call><name>var_get</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>ls</name></name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><operator>(</operator><name>BCReg</name><operator>)</operator><name>i</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><operator>(</operator><name>BCReg</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr>;</return>  <comment type="block">/* Not found. */</comment>
</block_content>}</block></function>

<comment type="block">/* Lookup or add upvalue index. */</comment>
<function><type><specifier>static</specifier> <name>MSize</name></type> <name>var_lookup_uv</name><parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>MSize</name></type> <name>vidx</name></decl></parameter>, <parameter><decl><type><name>ExpDesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>MSize</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>nuv</name></name></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <if_stmt><if>if <condition>(<expr><name><name>fs</name><operator>-&gt;</operator><name>uvmap</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>vidx</name></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>i</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>  <comment type="block">/* Already exists. */</comment>
  <comment type="block">/* Otherwise create a new one. */</comment>
  <expr_stmt><expr><call><name>checklimit</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>nuv</name></name></expr></argument>, <argument><expr><name>LJ_MAX_UPVAL</name></expr></argument>, <argument><expr><literal type="string">"upvalues"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VLOCAL</name> <operator>||</operator> <name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VUPVAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>uvmap</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><name>vidx</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>uvtmp</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><operator>(</operator><ternary><condition><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VLOCAL</name></expr> ?</condition><then> <expr><name>vidx</name></expr> </then><else>: <expr><name>LJ_MAX_VSTACK</name><operator>+</operator><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>nuv</name></name> <operator>=</operator> <name>n</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Forward declaration. */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>fscope_uvmark</name><parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>BCReg</name></type> <name>level</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Recursively lookup variables in enclosing functions. */</comment>
<function><type><specifier>static</specifier> <name>MSize</name></type> <name>var_lookup_</name><parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>ExpDesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>first</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>fs</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>BCReg</name></type> <name>reg</name> <init>= <expr><call><name>var_lookup_local</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>int32_t</name><operator>)</operator><name>reg</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* Local in this function? */</comment>
      <expr_stmt><expr><call><name>expr_init</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>VLOCAL</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>fscope_uvmark</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Scope now has an upvalue. */</comment>
      <return>return <expr><operator>(</operator><name>MSize</name><operator>)</operator><operator>(</operator><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>aux</name></name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>fs</name><operator>-&gt;</operator><name>varmap</name><index>[<expr><name>reg</name></expr>]</index></name><operator>)</operator></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <decl_stmt><decl><type><name>MSize</name></type> <name>vidx</name> <init>= <expr><call><name>var_lookup_</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>prev</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* Var in outer func? */</comment>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>int32_t</name><operator>)</operator><name>vidx</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* Yes, make it an upvalue here. */</comment>
	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><call><name>var_lookup_uv</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>vidx</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <name>VUPVAL</name></expr>;</expr_stmt>
	<return>return <expr><name>vidx</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* Not found in any function, must be a global. */</comment>
    <expr_stmt><expr><call><name>expr_init</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>VGLOBAL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>sval</name></name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><operator>(</operator><name>MSize</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr>;</return>  <comment type="block">/* Global. */</comment>
</block_content>}</block></function>

<comment type="block">/* Lookup variable name. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>var_lookup</name><parameter_list>(<parameter><type><name>ls</name></type></parameter>, <parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>var_lookup_((ls)-&gt;fs, lex_str(ls), (e), 1)</cpp:value></cpp:define>

<comment type="block">/* -- Goto an label handling ---------------------------------------------- */</comment>

<comment type="block">/* Add a new goto or label. */</comment>
<function><type><specifier>static</specifier> <name>MSize</name></type> <name>gola_new</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>info</name></decl></parameter>, <parameter><decl><type><name>BCPos</name></type> <name>pc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MSize</name></type> <name>vtop</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>vtop</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>LJ_UNLIKELY</name><argument_list>(<argument><expr><name>vtop</name> <operator>&gt;=</operator> <name><name>ls</name><operator>-&gt;</operator><name>sizevstack</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>sizevstack</name></name> <operator>&gt;=</operator> <name>LJ_MAX_VSTACK</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>lj_lex_error</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>LJ_ERR_XLIMC</name></expr></argument>, <argument><expr><name>LJ_MAX_VSTACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>lj_mem_growvec</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name><name>ls</name><operator>-&gt;</operator><name>vstack</name></name></expr></argument>, <argument><expr><name><name>ls</name><operator>-&gt;</operator><name>sizevstack</name></name></expr></argument>, <argument><expr><name>LJ_MAX_VSTACK</name></expr></argument>, <argument><expr><name>VarInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>name</name> <operator>==</operator> <name>NAME_BREAK</name> <operator>||</operator> <call><name>lj_tab_getstr</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>kt</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* NOBARRIER: name is anchored in fs-&gt;kt and ls-&gt;vstack is not a GCobj. */</comment>
  <expr_stmt><expr><call><name>setgcref</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>vstack</name><index>[<expr><name>vtop</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><call><name>obj2gco</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>vstack</name><index>[<expr><name>vtop</name></expr>]</index></name><operator>.</operator><name>startpc</name> <operator>=</operator> <name>pc</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>vstack</name><index>[<expr><name>vtop</name></expr>]</index></name><operator>.</operator><name>slot</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>vstack</name><index>[<expr><name>vtop</name></expr>]</index></name><operator>.</operator><name>info</name> <operator>=</operator> <name>info</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>vtop</name></name> <operator>=</operator> <name>vtop</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <return>return <expr><name>vtop</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>gola_isgoto</name><parameter_list>(<parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>((v)-&gt;info &amp; VSTACK_GOTO)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>gola_islabel</name><parameter_list>(<parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>((v)-&gt;info &amp; VSTACK_LABEL)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>gola_isgotolabel</name><parameter_list>(<parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((v)-&gt;info &amp; (VSTACK_GOTO|VSTACK_LABEL))</cpp:value></cpp:define>

<comment type="block">/* Patch goto to jump to label. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>gola_patch</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>VarInfo</name> <modifier>*</modifier></type><name>vg</name></decl></parameter>, <parameter><decl><type><name>VarInfo</name> <modifier>*</modifier></type><name>vl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCPos</name></type> <name>pc</name> <init>= <expr><name><name>vg</name><operator>-&gt;</operator><name>startpc</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>setgcrefnull</name><argument_list>(<argument><expr><name><name>vg</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Invalidate pending goto. */</comment>
  <expr_stmt><expr><call><name>setbc_a</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fs</name><operator>-&gt;</operator><name>bcbase</name><index>[<expr><name>pc</name></expr>]</index></name><operator>.</operator><name>ins</name></expr></argument>, <argument><expr><name><name>vl</name><operator>-&gt;</operator><name>slot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>jmp_patch</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name><name>vl</name><operator>-&gt;</operator><name>startpc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Patch goto to close upvalues. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>gola_close</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>VarInfo</name> <modifier>*</modifier></type><name>vg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCPos</name></type> <name>pc</name> <init>= <expr><name><name>vg</name><operator>-&gt;</operator><name>startpc</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCIns</name> <modifier>*</modifier></type><name>ip</name> <init>= <expr><operator>&amp;</operator><name><name>fs</name><operator>-&gt;</operator><name>bcbase</name><index>[<expr><name>pc</name></expr>]</index></name><operator>.</operator><name>ins</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>gola_isgoto</name><argument_list>(<argument><expr><name>vg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>bc_op</name><argument_list>(<argument><expr><operator>*</operator><name>ip</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BC_JMP</name> <operator>||</operator> <call><name>bc_op</name><argument_list>(<argument><expr><operator>*</operator><name>ip</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BC_UCLO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setbc_a</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name><name>vg</name><operator>-&gt;</operator><name>slot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>bc_op</name><argument_list>(<argument><expr><operator>*</operator><name>ip</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BC_JMP</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>BCPos</name></type> <name>next</name> <init>= <expr><call><name>jmp_next</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>next</name> <operator>!=</operator> <name>NO_JMP</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>jmp_patch</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>next</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Jump to UCLO. */</comment>
    <expr_stmt><expr><call><name>setbc_op</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>BC_UCLO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Turn into UCLO. */</comment>
    <expr_stmt><expr><call><name>setbc_j</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>NO_JMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Resolve pending forward gotos for label. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>gola_resolve</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>FuncScope</name> <modifier>*</modifier></type><name>bl</name></decl></parameter>, <parameter><decl><type><name>MSize</name></type> <name>idx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>VarInfo</name> <modifier>*</modifier></type><name>vg</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>vstack</name></name> <operator>+</operator> <name><name>bl</name><operator>-&gt;</operator><name>vstart</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>VarInfo</name> <modifier>*</modifier></type><name>vl</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>vstack</name></name> <operator>+</operator> <name>idx</name></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init>;</init> <condition><expr><name>vg</name> <operator>&lt;</operator> <name>vl</name></expr>;</condition> <incr><expr><name>vg</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <if_stmt><if>if <condition>(<expr><call><name>gcrefeq</name><argument_list>(<argument><expr><name><name>vg</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>vl</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>gola_isgoto</name><argument_list>(<argument><expr><name>vg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>vg</name><operator>-&gt;</operator><name>slot</name></name> <operator>&lt;</operator> <name><name>vl</name><operator>-&gt;</operator><name>slot</name></name></expr>)</condition> <block>{<block_content>
	<decl_stmt><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>strref</name><argument_list>(<argument><expr><call><name>var_get</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>, <argument><expr><name><name>vg</name><operator>-&gt;</operator><name>slot</name></name></expr></argument>)</argument_list></call><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>name</name> <operator>&gt;=</operator> <name>VARNAME__MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>linenumber</name></name> <operator>=</operator> <name><name>ls</name><operator>-&gt;</operator><name>fs</name><operator>-&gt;</operator><name>bcbase</name><index>[<expr><name><name>vg</name><operator>-&gt;</operator><name>startpc</name></name></expr>]</index></name><operator>.</operator><name>line</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>strref</name><argument_list>(<argument><expr><name><name>vg</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NAME_BREAK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lj_lex_error</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>LJ_ERR_XGSCOPE</name></expr></argument>,
		     <argument><expr><call><name>strdata</name><argument_list>(<argument><expr><call><name>strref</name><argument_list>(<argument><expr><name><name>vg</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strdata</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>gola_patch</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>vg</name></expr></argument>, <argument><expr><name>vl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt></block_content></block></for>
</block_content>}</block></function>

<comment type="block">/* Fixup remaining gotos and labels for scope. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>gola_fixup</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>FuncScope</name> <modifier>*</modifier></type><name>bl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>VarInfo</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>vstack</name></name> <operator>+</operator> <name><name>bl</name><operator>-&gt;</operator><name>vstart</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>VarInfo</name> <modifier>*</modifier></type><name>ve</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>vstack</name></name> <operator>+</operator> <name><name>ls</name><operator>-&gt;</operator><name>vtop</name></name></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init>;</init> <condition><expr><name>v</name> <operator>&lt;</operator> <name>ve</name></expr>;</condition> <incr><expr><name>v</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>strref</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>name</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Only consider remaining valid gotos/labels. */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>gola_islabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<decl_stmt><decl><type><name>VarInfo</name> <modifier>*</modifier></type><name>vg</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>setgcrefnull</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Invalidate label that goes out of scope. */</comment>
	<for>for <control>(<init><expr><name>vg</name> <operator>=</operator> <name>v</name><operator>+</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>vg</name> <operator>&lt;</operator> <name>ve</name></expr>;</condition> <incr><expr><name>vg</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>  <comment type="block">/* Resolve pending backward gotos. */</comment>
	  <if_stmt><if>if <condition>(<expr><call><name>strref</name><argument_list>(<argument><expr><name><name>vg</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>name</name> <operator>&amp;&amp;</operator> <call><name>gola_isgoto</name><argument_list>(<argument><expr><name>vg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>bl</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>FSCOPE_UPVAL</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>vg</name><operator>-&gt;</operator><name>slot</name></name> <operator>&gt;</operator> <name><name>v</name><operator>-&gt;</operator><name>slot</name></name></expr>)</condition><block type="pseudo"><block_content>
	      <expr_stmt><expr><call><name>gola_close</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>vg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	    <expr_stmt><expr><call><name>gola_patch</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>vg</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  </block_content>}</block></if></if_stmt></block_content></block></for>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>gola_isgoto</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>bl</name><operator>-&gt;</operator><name>prev</name></name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Propagate goto or break to outer scope. */</comment>
	  <expr_stmt><expr><name><name>bl</name><operator>-&gt;</operator><name>prev</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <ternary><condition><expr><name>name</name> <operator>==</operator> <name>NAME_BREAK</name></expr> ?</condition><then> <expr><name>FSCOPE_BREAK</name></expr> </then><else>: <expr><name>FSCOPE_GOLA</name></expr></else></ternary></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>slot</name></name> <operator>=</operator> <name><name>bl</name><operator>-&gt;</operator><name>nactvar</name></name></expr>;</expr_stmt>
	  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>bl</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>FSCOPE_UPVAL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><call><name>gola_close</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* No outer scope: undefined goto label or no loop. */</comment>
	  <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>linenumber</name></name> <operator>=</operator> <name><name>ls</name><operator>-&gt;</operator><name>fs</name><operator>-&gt;</operator><name>bcbase</name><index>[<expr><name><name>v</name><operator>-&gt;</operator><name>startpc</name></name></expr>]</index></name><operator>.</operator><name>line</name></expr>;</expr_stmt>
	  <if_stmt><if>if <condition>(<expr><name>name</name> <operator>==</operator> <name>NAME_BREAK</name></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><call><name>lj_lex_error</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>LJ_ERR_XBREAK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	  <else>else<block type="pseudo"><block_content>
	    <expr_stmt><expr><call><name>lj_lex_error</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>LJ_ERR_XLUNDEF</name></expr></argument>, <argument><expr><call><name>strdata</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* Find existing label. */</comment>
<function><type><specifier>static</specifier> <name>VarInfo</name> <modifier>*</modifier></type><name>gola_findlabel</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>VarInfo</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>vstack</name></name> <operator>+</operator> <name><name>ls</name><operator>-&gt;</operator><name>fs</name><operator>-&gt;</operator><name>bl</name><operator>-&gt;</operator><name>vstart</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>VarInfo</name> <modifier>*</modifier></type><name>ve</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>vstack</name></name> <operator>+</operator> <name><name>ls</name><operator>-&gt;</operator><name>vtop</name></name></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init>;</init> <condition><expr><name>v</name> <operator>&lt;</operator> <name>ve</name></expr>;</condition> <incr><expr><name>v</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <if_stmt><if>if <condition>(<expr><call><name>strref</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>name</name> <operator>&amp;&amp;</operator> <call><name>gola_islabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>v</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>
  <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -- Scope handling ------------------------------------------------------ */</comment>

<comment type="block">/* Begin a scope. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fscope_begin</name><parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>FuncScope</name> <modifier>*</modifier></type><name>bl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><name><name>bl</name><operator>-&gt;</operator><name>nactvar</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>bl</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>bl</name><operator>-&gt;</operator><name>vstart</name></name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>ls</name><operator>-&gt;</operator><name>vtop</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>bl</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>bl</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>bl</name></name> <operator>=</operator> <name>bl</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name> <operator>==</operator> <name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* End a scope. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fscope_end</name><parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>FuncScope</name> <modifier>*</modifier></type><name>bl</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>bl</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>ls</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>bl</name></name> <operator>=</operator> <name><name>bl</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>var_remove</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name><name>bl</name><operator>-&gt;</operator><name>nactvar</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>bl</name><operator>-&gt;</operator><name>nactvar</name></name> <operator>==</operator> <name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>bl</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>FSCOPE_UPVAL</name><operator>|</operator><name>FSCOPE_NOCLOSE</name><operator>)</operator><operator>)</operator> <operator>==</operator> <name>FSCOPE_UPVAL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>bcemit_AJ</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>BC_UCLO</name></expr></argument>, <argument><expr><name><name>bl</name><operator>-&gt;</operator><name>nactvar</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>bl</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>FSCOPE_BREAK</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>bl</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>FSCOPE_LOOP</name><operator>)</operator></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>MSize</name></type> <name>idx</name> <init>= <expr><call><name>gola_new</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>NAME_BREAK</name></expr></argument>, <argument><expr><name>VSTACK_LABEL</name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>pc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>vtop</name></name> <operator>=</operator> <name>idx</name></expr>;</expr_stmt>  <comment type="block">/* Drop break label immediately. */</comment>
      <expr_stmt><expr><call><name>gola_resolve</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>bl</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* Need the fixup step to propagate the breaks. */</comment>
      <expr_stmt><expr><call><name>gola_fixup</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>bl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>bl</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>FSCOPE_GOLA</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>gola_fixup</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>bl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Mark scope as having an upvalue. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fscope_uvmark</name><parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>BCReg</name></type> <name>level</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>FuncScope</name> <modifier>*</modifier></type><name>bl</name></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>bl</name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>bl</name></name></expr>;</init> <condition><expr><name>bl</name> <operator>&amp;&amp;</operator> <name><name>bl</name><operator>-&gt;</operator><name>nactvar</name></name> <operator>&gt;</operator> <name>level</name></expr>;</condition> <incr><expr><name>bl</name> <operator>=</operator> <name><name>bl</name><operator>-&gt;</operator><name>prev</name></name></expr></incr>)</control><block type="pseudo"><block_content>
    <empty_stmt>;</empty_stmt></block_content></block></for>
  <if_stmt><if>if <condition>(<expr><name>bl</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>bl</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>FSCOPE_UPVAL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* -- Function state management ------------------------------------------- */</comment>

<comment type="block">/* Fixup bytecode for prototype. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fs_fixup_bc</name><parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>GCproto</name> <modifier>*</modifier></type><name>pt</name></decl></parameter>, <parameter><decl><type><name>BCIns</name> <modifier>*</modifier></type><name>bc</name></decl></parameter>, <parameter><decl><type><name>MSize</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>BCInsLine</name> <modifier>*</modifier></type><name>base</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>bcbase</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MSize</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pt</name><operator>-&gt;</operator><name>sizebc</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>bc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>BCINS_AD</name><argument_list>(<argument><expr><ternary><condition><expr><operator>(</operator><name><name>fs</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PROTO_VARARG</name><operator>)</operator></expr> ?</condition><then> <expr><name>BC_FUNCV</name></expr> </then><else>: <expr><name>BC_FUNCF</name></expr></else></ternary></expr></argument>,
		   <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>framesize</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>bc</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>base</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ins</name></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<comment type="block">/* Fixup upvalues for child prototype, step #2. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fs_fixup_uv2</name><parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>GCproto</name> <modifier>*</modifier></type><name>pt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>VarInfo</name> <modifier>*</modifier></type><name>vstack</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>ls</name><operator>-&gt;</operator><name>vstack</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>uv</name> <init>= <expr><call><name>proto_uv</name><argument_list>(<argument><expr><name>pt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MSize</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr><name><name>pt</name><operator>-&gt;</operator><name>sizeuv</name></name></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>VarIndex</name></type> <name>vidx</name> <init>= <expr><name><name>uv</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>vidx</name> <operator>&gt;=</operator> <name>LJ_MAX_VSTACK</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>uv</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>vidx</name> <operator>-</operator> <name>LJ_MAX_VSTACK</name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>vstack</name><index>[<expr><name>vidx</name></expr>]</index></name><operator>.</operator><name>info</name> <operator>&amp;</operator> <name>VSTACK_VAR_RW</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>uv</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>vstack</name><index>[<expr><name>vidx</name></expr>]</index></name><operator>.</operator><name>slot</name> <operator>|</operator> <name>PROTO_UV_LOCAL</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>uv</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>vstack</name><index>[<expr><name>vidx</name></expr>]</index></name><operator>.</operator><name>slot</name> <operator>|</operator> <name>PROTO_UV_LOCAL</name> <operator>|</operator> <name>PROTO_UV_IMMUTABLE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* Fixup constants for prototype. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fs_fixup_k</name><parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>GCproto</name> <modifier>*</modifier></type><name>pt</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>kptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>GCtab</name> <modifier>*</modifier></type><name>kt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>array</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MSize</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>hmask</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>checklimitgt</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>nkn</name></name></expr></argument>, <argument><expr><name>BCMAX_D</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"constants"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>checklimitgt</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>nkgc</name></name></expr></argument>, <argument><expr><name>BCMAX_D</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"constants"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setmref</name><argument_list>(<argument><expr><name><name>pt</name><operator>-&gt;</operator><name>k</name></name></expr></argument>, <argument><expr><name>kptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pt</name><operator>-&gt;</operator><name>sizekn</name></name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>nkn</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pt</name><operator>-&gt;</operator><name>sizekgc</name></name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>nkgc</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>kt</name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>kt</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>array</name> <operator>=</operator> <call><name>tvref</name><argument_list>(<argument><expr><name><name>kt</name><operator>-&gt;</operator><name>array</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>kt</name><operator>-&gt;</operator><name>asize</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <if_stmt><if>if <condition>(<expr><call><name>tvhaskslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>tv</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>TValue</name> <operator>*</operator><operator>)</operator><name>kptr</name><operator>)</operator><index>[<expr><call><name>tvkslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>]</index></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>LJ_DUALNUM</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>setintV</name><argument_list>(<argument><expr><name>tv</name></expr></argument>, <argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
      <else>else<block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>setnumV</name><argument_list>(<argument><expr><name>tv</name></expr></argument>, <argument><expr><operator>(</operator><name>lua_Number</name><operator>)</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt></block_content></block></for>
  <expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>noderef</name><argument_list>(<argument><expr><name><name>kt</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>hmask</name> <operator>=</operator> <name><name>kt</name><operator>-&gt;</operator><name>hmask</name></name></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>hmask</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>tvhaskslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>n</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>kidx</name> <init>= <expr><operator>(</operator><name>ptrdiff_t</name><operator>)</operator><call><name>tvkslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>n</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>tvisint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>n</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>tvisnum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>n</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>tv</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>TValue</name> <operator>*</operator><operator>)</operator><name>kptr</name><operator>)</operator><index>[<expr><name>kidx</name></expr>]</index></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>LJ_DUALNUM</name></expr>)</condition> <block>{<block_content>
	  <decl_stmt><decl><type><name>lua_Number</name></type> <name>nn</name> <init>= <expr><call><name>numV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>n</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	  <decl_stmt><decl><type><name>int32_t</name></type> <name>k</name> <init>= <expr><call><name>lj_num2int</name><argument_list>(<argument><expr><name>nn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>tvismzero</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>n</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>lua_Number</name><operator>)</operator><name>k</name> <operator>==</operator> <name>nn</name></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><call><name>setintV</name><argument_list>(<argument><expr><name>tv</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	  <else>else<block type="pseudo"><block_content>
	    <expr_stmt><expr><operator>*</operator><name>tv</name> <operator>=</operator> <name><name>n</name><operator>-&gt;</operator><name>key</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
	  <expr_stmt><expr><operator>*</operator><name>tv</name> <operator>=</operator> <name><name>n</name><operator>-&gt;</operator><name>key</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<decl_stmt><decl><type><name>GCobj</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>gcV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>n</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>setgcref</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>GCRef</name> <operator>*</operator><operator>)</operator><name>kptr</name><operator>)</operator><index>[<expr><operator>~</operator><name>kidx</name></expr>]</index></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lj_gc_objbarrier</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>pt</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>tvisproto</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>n</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><call><name>fs_fixup_uv2</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><call><name>gco2pt</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* Fixup upvalues for prototype, step #1. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fs_fixup_uv1</name><parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>GCproto</name> <modifier>*</modifier></type><name>pt</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>uv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>setmref</name><argument_list>(<argument><expr><name><name>pt</name><operator>-&gt;</operator><name>uv</name></name></expr></argument>, <argument><expr><name>uv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pt</name><operator>-&gt;</operator><name>sizeuv</name></name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>nuv</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>uv</name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>uvtmp</name></name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>nuv</name></name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>VarIndex</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>LUAJIT_DISABLE_DEBUGINFO</name></cpp:ifndef>
<comment type="block">/* Prepare lineinfo for prototype. */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>fs_prep_line</name><parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>BCLine</name></type> <name>numline</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><operator>(</operator><name><name>fs</name><operator>-&gt;</operator><name>pc</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <operator>(</operator><ternary><condition><expr><name>numline</name> <operator>&lt;</operator> <literal type="number">256</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><ternary><condition><expr><name>numline</name> <operator>&lt;</operator> <literal type="number">65536</literal></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">2</literal></expr></else></ternary></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Fixup lineinfo for prototype. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fs_fixup_line</name><parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>GCproto</name> <modifier>*</modifier></type><name>pt</name></decl></parameter>,
			  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>lineinfo</name></decl></parameter>, <parameter><decl><type><name>BCLine</name></type> <name>numline</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>BCInsLine</name> <modifier>*</modifier></type><name>base</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>bcbase</name></name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCLine</name></type> <name>first</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>linedefined</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MSize</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>pc</name></name><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pt</name><operator>-&gt;</operator><name>firstline</name></name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>linedefined</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pt</name><operator>-&gt;</operator><name>numline</name></name> <operator>=</operator> <name>numline</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setmref</name><argument_list>(<argument><expr><name><name>pt</name><operator>-&gt;</operator><name>lineinfo</name></name></expr></argument>, <argument><expr><name>lineinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>LJ_LIKELY</name><argument_list>(<argument><expr><name>numline</name> <operator>&lt;</operator> <literal type="number">256</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>li</name> <init>= <expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>lineinfo</name></expr></init></decl>;</decl_stmt>
    <do>do <block>{<block_content>
      <decl_stmt><decl><type><name>BCLine</name></type> <name>delta</name> <init>= <expr><name><name>base</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>line</name> <operator>-</operator> <name>first</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>delta</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>delta</name> <operator>&lt;</operator> <literal type="number">256</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>li</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name>delta</name></expr>;</expr_stmt>
    </block_content>}</block> while <condition>(<expr><operator>++</operator><name>i</name> <operator>&lt;</operator> <name>n</name></expr>)</condition>;</do>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>LJ_LIKELY</name><argument_list>(<argument><expr><name>numline</name> <operator>&lt;</operator> <literal type="number">65536</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>li</name> <init>= <expr><operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator><name>lineinfo</name></expr></init></decl>;</decl_stmt>
    <do>do <block>{<block_content>
      <decl_stmt><decl><type><name>BCLine</name></type> <name>delta</name> <init>= <expr><name><name>base</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>line</name> <operator>-</operator> <name>first</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>delta</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>delta</name> <operator>&lt;</operator> <literal type="number">65536</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>li</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><name>delta</name></expr>;</expr_stmt>
    </block_content>}</block> while <condition>(<expr><operator>++</operator><name>i</name> <operator>&lt;</operator> <name>n</name></expr>)</condition>;</do>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>li</name> <init>= <expr><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><name>lineinfo</name></expr></init></decl>;</decl_stmt>
    <do>do <block>{<block_content>
      <decl_stmt><decl><type><name>BCLine</name></type> <name>delta</name> <init>= <expr><name><name>base</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>line</name> <operator>-</operator> <name>first</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>delta</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>li</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>delta</name></expr>;</expr_stmt>
    </block_content>}</block> while <condition>(<expr><operator>++</operator><name>i</name> <operator>&lt;</operator> <name>n</name></expr>)</condition>;</do>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Prepare variable info for prototype. */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>fs_prep_var</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>ofsvar</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>VarInfo</name> <modifier>*</modifier></type><name>vs</name> <init>=<expr><name><name>ls</name><operator>-&gt;</operator><name>vstack</name></name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ve</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MSize</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCPos</name></type> <name>lastpc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lj_buf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ls</name><operator>-&gt;</operator><name>sb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Copy to temp. string buffer. */</comment>
  <comment type="block">/* Store upvalue names. */</comment>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>n</name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>nuv</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>strref</name><argument_list>(<argument><expr><name><name>vs</name><index>[<expr><name><name>fs</name><operator>-&gt;</operator><name>uvmap</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MSize</name></type> <name>len</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>len</name></name><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>lj_buf_more</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ls</name><operator>-&gt;</operator><name>sb</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lj_buf_wmem</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>strdata</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setsbufP</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ls</name><operator>-&gt;</operator><name>sb</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><operator>*</operator><name>ofsvar</name> <operator>=</operator> <call><name>sbuflen</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ls</name><operator>-&gt;</operator><name>sb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>lastpc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <comment type="block">/* Store local variable names and compressed ranges. */</comment>
  <for>for <control>(<init><expr><name>ve</name> <operator>=</operator> <name>vs</name> <operator>+</operator> <name><name>ls</name><operator>-&gt;</operator><name>vtop</name></name></expr><operator>,</operator> <expr><name>vs</name> <operator>+=</operator> <name><name>fs</name><operator>-&gt;</operator><name>vbase</name></name></expr>;</init> <condition><expr><name>vs</name> <operator>&lt;</operator> <name>ve</name></expr>;</condition> <incr><expr><name>vs</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>gola_isgotolabel</name><argument_list>(<argument><expr><name>vs</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>strref</name><argument_list>(<argument><expr><name><name>vs</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>BCPos</name></type> <name>startpc</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>s</name> <operator>&lt;</operator> <name>VARNAME__MAX</name></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lj_buf_more</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ls</name><operator>-&gt;</operator><name>sb</name></name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>s</name></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<decl_stmt><decl><type><name>MSize</name></type> <name>len</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>len</name></name><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lj_buf_more</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ls</name><operator>-&gt;</operator><name>sb</name></name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lj_buf_wmem</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>strdata</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name>startpc</name> <operator>=</operator> <name><name>vs</name><operator>-&gt;</operator><name>startpc</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lj_strfmt_wuleb128</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>startpc</name><operator>-</operator><name>lastpc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lj_strfmt_wuleb128</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>vs</name><operator>-&gt;</operator><name>endpc</name></name><operator>-</operator><name>startpc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>setsbufP</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ls</name><operator>-&gt;</operator><name>sb</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>lastpc</name> <operator>=</operator> <name>startpc</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>lj_buf_putb</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ls</name><operator>-&gt;</operator><name>sb</name></name></expr></argument>, <argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Terminator for varinfo. */</comment>
  <return>return <expr><call><name>sbuflen</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ls</name><operator>-&gt;</operator><name>sb</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Fixup variable info for prototype. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fs_fixup_var</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>GCproto</name> <modifier>*</modifier></type><name>pt</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>ofsvar</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>setmref</name><argument_list>(<argument><expr><name><name>pt</name><operator>-&gt;</operator><name>uvinfo</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setmref</name><argument_list>(<argument><expr><name><name>pt</name><operator>-&gt;</operator><name>varinfo</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>p</name> <operator>+</operator> <name>ofsvar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>sbufB</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ls</name><operator>-&gt;</operator><name>sb</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>sbuflen</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ls</name><operator>-&gt;</operator><name>sb</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Copy from temp. buffer. */</comment>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<comment type="block">/* Initialize with empty debug info, if disabled. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>fs_prep_line</name><parameter_list>(<parameter><type><name>fs</name></type></parameter>, <parameter><type><name>numline</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>(UNUSED(numline), 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>fs_fixup_line</name><parameter_list>(<parameter><type><name>fs</name></type></parameter>, <parameter><type><name>pt</name></type></parameter>, <parameter><type><name>li</name></type></parameter>, <parameter><type><name>numline</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>pt-&gt;firstline = pt-&gt;numline = 0, setmref((pt)-&gt;lineinfo, NULL)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>fs_prep_var</name><parameter_list>(<parameter><type><name>ls</name></type></parameter>, <parameter><type><name>fs</name></type></parameter>, <parameter><type><name>ofsvar</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>(UNUSED(ofsvar), 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>fs_fixup_var</name><parameter_list>(<parameter><type><name>ls</name></type></parameter>, <parameter><type><name>pt</name></type></parameter>, <parameter><type><name>p</name></type></parameter>, <parameter><type><name>ofsvar</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>setmref((pt)-&gt;uvinfo, NULL), setmref((pt)-&gt;varinfo, NULL)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Check if bytecode op returns. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>bcopisret</name><parameter_list>(<parameter><decl><type><name>BCOp</name></type> <name>op</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{<block_content>
  <case>case <expr><name>BC_CALLMT</name></expr>:</case> <case>case <expr><name>BC_CALLT</name></expr>:</case>
  <case>case <expr><name>BC_RETM</name></expr>:</case> <case>case <expr><name>BC_RET</name></expr>:</case> <case>case <expr><name>BC_RET0</name></expr>:</case> <case>case <expr><name>BC_RET1</name></expr>:</case>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  <default>default:</default>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/* Fixup return instruction for prototype. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fs_fixup_ret</name><parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>BCPos</name></type> <name>lastpc</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>pc</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>lastpc</name> <operator>&lt;=</operator> <name><name>fs</name><operator>-&gt;</operator><name>lasttarget</name></name> <operator>||</operator> <operator>!</operator><call><name>bcopisret</name><argument_list>(<argument><expr><call><name>bc_op</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>bcbase</name><index>[<expr><name>lastpc</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>ins</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>fs</name><operator>-&gt;</operator><name>bl</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>FSCOPE_UPVAL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>bcemit_AJ</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>BC_UCLO</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>bcemit_AD</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>BC_RET0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Need final return. */</comment>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>bl</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>FSCOPE_NOCLOSE</name></expr>;</expr_stmt>  <comment type="block">/* Handled above. */</comment>
  <expr_stmt><expr><call><name>fscope_end</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>bl</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* May need to fixup returns encoded before first function was created. */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>fs</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PROTO_FIXUP_RETURN</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>BCPos</name></type> <name>pc</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>pc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>pc</name> <operator>&lt;</operator> <name>lastpc</name></expr>;</condition> <incr><expr><name>pc</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <decl_stmt><decl><type><name>BCIns</name></type> <name>ins</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>bcbase</name><index>[<expr><name>pc</name></expr>]</index></name><operator>.</operator><name>ins</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>BCPos</name></type> <name>offset</name></decl>;</decl_stmt>
      <switch>switch <condition>(<expr><call><name>bc_op</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <case>case <expr><name>BC_CALLMT</name></expr>:</case> <case>case <expr><name>BC_CALLT</name></expr>:</case>
      <case>case <expr><name>BC_RETM</name></expr>:</case> <case>case <expr><name>BC_RET</name></expr>:</case> <case>case <expr><name>BC_RET0</name></expr>:</case> <case>case <expr><name>BC_RET1</name></expr>:</case>
	<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>bcemit_INS</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Copy original instruction. */</comment>
	<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>bcbase</name><index>[<expr><name>offset</name></expr>]</index></name><operator>.</operator><name>line</name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>bcbase</name><index>[<expr><name>pc</name></expr>]</index></name><operator>.</operator><name>line</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>offset</name> <operator>=</operator> <name>offset</name><operator>-</operator><operator>(</operator><name>pc</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>+</operator><name>BCBIAS_J</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&gt;</operator> <name>BCMAX_D</name></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><call><name>err_syntax</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>ls</name></name></expr></argument>, <argument><expr><name>LJ_ERR_XFIXUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* Replace with UCLO plus branch. */</comment>
	<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>bcbase</name><index>[<expr><name>pc</name></expr>]</index></name><operator>.</operator><name>ins</name> <operator>=</operator> <call><name>BCINS_AD</name><argument_list>(<argument><expr><name>BC_UCLO</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
      <case>case <expr><name>BC_UCLO</name></expr>:</case>
	<return>return;</return>  <comment type="block">/* We're done. */</comment>
      <default>default:</default>
	<break>break;</break>
      </block_content>}</block></switch>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Finish a FuncState and return the new prototype. */</comment>
<function><type><specifier>static</specifier> <name>GCproto</name> <modifier>*</modifier></type><name>fs_finish</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>BCLine</name></type> <name>line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCLine</name></type> <name>numline</name> <init>= <expr><name>line</name> <operator>-</operator> <name><name>fs</name><operator>-&gt;</operator><name>linedefined</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>sizept</name></decl>, <decl><type ref="prev"/><name>ofsk</name></decl>, <decl><type ref="prev"/><name>ofsuv</name></decl>, <decl><type ref="prev"/><name>ofsli</name></decl>, <decl><type ref="prev"/><name>ofsdbg</name></decl>, <decl><type ref="prev"/><name>ofsvar</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GCproto</name> <modifier>*</modifier></type><name>pt</name></decl>;</decl_stmt>

  <comment type="block">/* Apply final fixups. */</comment>
  <expr_stmt><expr><call><name>fs_fixup_ret</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Calculate total size of prototype including all colocated arrays. */</comment>
  <expr_stmt><expr><name>sizept</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GCproto</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>fs</name><operator>-&gt;</operator><name>pc</name></name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>BCIns</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>fs</name><operator>-&gt;</operator><name>nkgc</name></name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>GCRef</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  <expr_stmt><expr><name>sizept</name> <operator>=</operator> <operator>(</operator><name>sizept</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TValue</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>TValue</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>ofsk</name> <operator>=</operator> <name>sizept</name></expr>;</expr_stmt> <expr_stmt><expr><name>sizept</name> <operator>+=</operator> <name><name>fs</name><operator>-&gt;</operator><name>nkn</name></name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>TValue</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  <expr_stmt><expr><name>ofsuv</name> <operator>=</operator> <name>sizept</name></expr>;</expr_stmt> <expr_stmt><expr><name>sizept</name> <operator>+=</operator> <operator>(</operator><operator>(</operator><name><name>fs</name><operator>-&gt;</operator><name>nuv</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>&amp;</operator><operator>~</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><literal type="number">2</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>ofsli</name> <operator>=</operator> <name>sizept</name></expr>;</expr_stmt> <expr_stmt><expr><name>sizept</name> <operator>+=</operator> <call><name>fs_prep_line</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>numline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>ofsdbg</name> <operator>=</operator> <name>sizept</name></expr>;</expr_stmt> <expr_stmt><expr><name>sizept</name> <operator>+=</operator> <call><name>fs_prep_var</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ofsvar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Allocate prototype and initialize its fields. */</comment>
  <expr_stmt><expr><name>pt</name> <operator>=</operator> <operator>(</operator><name>GCproto</name> <operator>*</operator><operator>)</operator><call><name>lj_mem_newgco</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>(</operator><name>MSize</name><operator>)</operator><name>sizept</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pt</name><operator>-&gt;</operator><name>gct</name></name> <operator>=</operator> <operator>~</operator><name>LJ_TPROTO</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pt</name><operator>-&gt;</operator><name>sizept</name></name> <operator>=</operator> <operator>(</operator><name>MSize</name><operator>)</operator><name>sizept</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pt</name><operator>-&gt;</operator><name>trace</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pt</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><name><name>fs</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>PROTO_HAS_RETURN</name><operator>|</operator><name>PROTO_FIXUP_RETURN</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pt</name><operator>-&gt;</operator><name>numparams</name></name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>numparams</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pt</name><operator>-&gt;</operator><name>framesize</name></name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>framesize</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setgcref</name><argument_list>(<argument><expr><name><name>pt</name><operator>-&gt;</operator><name>chunkname</name></name></expr></argument>, <argument><expr><call><name>obj2gco</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>chunkname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Close potentially uninitialized gap between bc and kgc. */</comment>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>pt</name> <operator>+</operator> <name>ofsk</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GCRef</name></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><name><name>fs</name><operator>-&gt;</operator><name>nkgc</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fs_fixup_bc</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>pt</name></expr></argument>, <argument><expr><operator>(</operator><name>BCIns</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>pt</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GCproto</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>pc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fs_fixup_k</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>pt</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>pt</name> <operator>+</operator> <name>ofsk</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fs_fixup_uv1</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>pt</name></expr></argument>, <argument><expr><operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>pt</name> <operator>+</operator> <name>ofsuv</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fs_fixup_line</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>pt</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>pt</name> <operator>+</operator> <name>ofsli</name><operator>)</operator></expr></argument>, <argument><expr><name>numline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fs_fixup_var</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>pt</name></expr></argument>, <argument><expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>pt</name> <operator>+</operator> <name>ofsdbg</name><operator>)</operator></expr></argument>, <argument><expr><name>ofsvar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <macro><name>lj_vmevent_send</name><argument_list>(<argument>L</argument>, <argument>BC</argument>,
    <argument>setprotoV(L, L-&gt;top++, pt);</argument>
  )</argument_list></macro><empty_stmt>;</empty_stmt>

  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>--</operator></expr>;</expr_stmt>  <comment type="block">/* Pop table of constants. */</comment>
  <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>vtop</name></name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>vbase</name></name></expr>;</expr_stmt>  <comment type="block">/* Reset variable stack. */</comment>
  <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <name><name>ls</name><operator>-&gt;</operator><name>tok</name></name> <operator>==</operator> <name>TK_eof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pt</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Initialize a new FuncState. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fs_init</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr>;</expr_stmt> <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name> <operator>=</operator> <name>fs</name></expr>;</expr_stmt>  <comment type="block">/* Append to list. */</comment>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>ls</name></name> <operator>=</operator> <name>ls</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>vbase</name></name> <operator>=</operator> <name><name>ls</name><operator>-&gt;</operator><name>vtop</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>L</name></name> <operator>=</operator> <name>L</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>pc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>lasttarget</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>jpc</name></name> <operator>=</operator> <name>NO_JMP</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>nkgc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>nkn</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>nuv</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>bl</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>framesize</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* Minimum frame size. */</comment>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>kt</name></name> <operator>=</operator> <call><name>lj_tab_new</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Anchor table of constants in stack to avoid being collected. */</comment>
  <expr_stmt><expr><call><name>settabV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>kt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>incr_top</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* -- Expressions --------------------------------------------------------- */</comment>

<comment type="block">/* Forward declaration. */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>expr</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>ExpDesc</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Return string expression. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>expr_str</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>ExpDesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>expr_init</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>VKSTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>sval</name></name> <operator>=</operator> <call><name>lex_str</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Return index expression. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>expr_index</name><parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>ExpDesc</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><name>ExpDesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Already called: expr_toval(fs, e). */</comment>
  <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <name>VINDEXED</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>expr_isnumk</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_DUALNUM</name></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><call><name>tvisint</name><argument_list>(<argument><expr><call><name>expr_numtv</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>int32_t</name></type> <name>k</name> <init>= <expr><call><name>intV</name><argument_list>(<argument><expr><call><name>expr_numtv</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>checku8</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>aux</name></name> <operator>=</operator> <name>BCMAX_C</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name>k</name></expr>;</expr_stmt>  <comment type="block">/* 256..511: const byte key */</comment>
	<return>return;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>lua_Number</name></type> <name>n</name> <init>= <expr><call><name>expr_numberV</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>k</name> <init>= <expr><call><name>lj_num2int</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>checku8</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>n</name> <operator>==</operator> <operator>(</operator><name>lua_Number</name><operator>)</operator><name>k</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>aux</name></name> <operator>=</operator> <name>BCMAX_C</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name>k</name></expr>;</expr_stmt>  <comment type="block">/* 256..511: const byte key */</comment>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>expr_isstrk</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>BCReg</name></type> <name>idx</name> <init>= <expr><call><name>const_str</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&lt;=</operator> <name>BCMAX_C</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>aux</name></name> <operator>=</operator> <operator>~</operator><name>idx</name></expr>;</expr_stmt>  <comment type="block">/* -256..-1: const string key */</comment>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>aux</name></name> <operator>=</operator> <call><name>expr_toanyreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* 0..255: register */</comment>
</block_content>}</block></function>

<comment type="block">/* Parse index expression with named field. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>expr_field</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>ExpDesc</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ExpDesc</name></type> <name>key</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>expr_toanyreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lj_lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Skip dot or colon. */</comment>
  <expr_stmt><expr><call><name>expr_str</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>expr_index</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Parse index expression with brackets. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>expr_bracket</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>ExpDesc</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>lj_lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Skip '['. */</comment>
  <expr_stmt><expr><call><name>expr</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>expr_toval</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lex_check</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">']'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Get value of constant expression. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>expr_kvalue</name><parameter_list>(<parameter><decl><type><name>TValue</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>ExpDesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>&lt;=</operator> <name>VKTRUE</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>setpriV</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>~</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>e</name><operator>-&gt;</operator><name>k</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VKSTR</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>setgcVraw</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>obj2gco</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>sval</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LJ_TSTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>tvisnumber</name><argument_list>(<argument><expr><call><name>expr_numtv</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>v</name> <operator>=</operator> <operator>*</operator><call><name>expr_numtv</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Parse table constructor expression. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>expr_table</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>ExpDesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCLine</name></type> <name>line</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>linenumber</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GCtab</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>vcall</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>needarr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>fixt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>narr</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* First array index. */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>nhash</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* Number of hash entries. */</comment>
  <decl_stmt><decl><type><name>BCReg</name></type> <name>freg</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCPos</name></type> <name>pc</name> <init>= <expr><call><name>bcemit_AD</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>BC_TNEW</name></expr></argument>, <argument><expr><name>freg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>expr_init</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>VNONRELOC</name></expr></argument>, <argument><expr><name>freg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>bcreg_reserve</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>freg</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lex_check</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">'{'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>tok</name></name> <operator>!=</operator> <literal type="char">'}'</literal></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>ExpDesc</name></type> <name>key</name></decl>, <decl><type ref="prev"/><name>val</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>vcall</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>tok</name></name> <operator>==</operator> <literal type="char">'['</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>expr_bracket</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Already calls expr_toval. */</comment>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>expr_isk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>expr_index</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>expr_isnumk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>expr_numiszero</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>needarr</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if> <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>nhash</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
      <expr_stmt><expr><call><name>lex_check</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>ls</name><operator>-&gt;</operator><name>tok</name></name> <operator>==</operator> <name>TK_name</name> <operator>||</operator> <operator>(</operator><operator>!</operator><name>LJ_52</name> <operator>&amp;&amp;</operator> <name><name>ls</name><operator>-&gt;</operator><name>tok</name></name> <operator>==</operator> <name>TK_goto</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
	       <call><name>lj_lex_lookahead</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>expr_str</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lex_check</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nhash</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>expr_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>VKNUM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>setintV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><operator>.</operator><name>u</name><operator>.</operator><name>nval</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>narr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>narr</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>needarr</name> <operator>=</operator> <name>vcall</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>expr</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>expr_isk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>key</name><operator>.</operator><name>k</name></name> <operator>!=</operator> <name>VKNIL</name> <operator>&amp;&amp;</operator>
	<operator>(</operator><name><name>key</name><operator>.</operator><name>k</name></name> <operator>==</operator> <name>VKSTR</name> <operator>||</operator> <call><name>expr_isk_nojump</name><argument_list>(<argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>TValue</name></type> <name>k</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>t</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Create template table on demand. */</comment>
	<decl_stmt><decl><type><name>BCReg</name></type> <name>kidx</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>lj_tab_new</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name>needarr</name></expr> ?</condition><then> <expr><name>narr</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>, <argument><expr><call><name>hsize2hbits</name><argument_list>(<argument><expr><name>nhash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>kidx</name> <operator>=</operator> <call><name>const_gc</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><call><name>obj2gco</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LJ_TTAB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>bcbase</name><index>[<expr><name>pc</name></expr>]</index></name><operator>.</operator><name>ins</name> <operator>=</operator> <call><name>BCINS_AD</name><argument_list>(<argument><expr><name>BC_TDUP</name></expr></argument>, <argument><expr><name>freg</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>kidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>vcall</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>expr_kvalue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>k</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>lj_tab_set</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lj_gc_anybarriert</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>expr_isk_nojump</name><argument_list>(<argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Add const key/value to template table. */</comment>
	<expr_stmt><expr><call><name>expr_kvalue</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* Otherwise create dummy string key (avoids lj_tab_newkey). */</comment>
	<expr_stmt><expr><call><name>settabV</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Preserve key with table itself as value. */</comment>
	<expr_stmt><expr><name>fixt</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>   <comment type="block">/* Fix this later, after all resizes. */</comment>
	<goto>goto <name>nonconst</name>;</goto>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
    <label><name>nonconst</name>:</label>
      <if_stmt><if>if <condition>(<expr><name><name>val</name><operator>.</operator><name>k</name></name> <operator>!=</operator> <name>VCALL</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><call><name>expr_toanyreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>vcall</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>expr_isk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>expr_index</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>bcemit_store</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name> <operator>=</operator> <name>freg</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lex_opt</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>lex_opt</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">';'</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>lex_match</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">'}'</literal></expr></argument>, <argument><expr><literal type="char">'{'</literal></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>vcall</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>BCInsLine</name> <modifier>*</modifier></type><name>ilp</name> <init>= <expr><operator>&amp;</operator><name><name>fs</name><operator>-&gt;</operator><name>bcbase</name><index>[<expr><name><name>fs</name><operator>-&gt;</operator><name>pc</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExpDesc</name></type> <name>en</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>bc_a</name><argument_list>(<argument><expr><name><name>ilp</name><operator>-&gt;</operator><name>ins</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>freg</name> <operator>&amp;&amp;</operator>
	       <call><name>bc_op</name><argument_list>(<argument><expr><name><name>ilp</name><operator>-&gt;</operator><name>ins</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>(</operator><ternary><condition><expr><name>narr</name> <operator>&gt;</operator> <literal type="number">256</literal></expr> ?</condition><then> <expr><name>BC_TSETV</name></expr> </then><else>: <expr><name>BC_TSETB</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>expr_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>en</name></expr></argument>, <argument><expr><name>VKNUM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>en</name><operator>.</operator><name>u</name><operator>.</operator><name>nval</name><operator>.</operator><name>u32</name><operator>.</operator><name>lo</name></name> <operator>=</operator> <name>narr</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>en</name><operator>.</operator><name>u</name><operator>.</operator><name>nval</name><operator>.</operator><name>u32</name><operator>.</operator><name>hi</name></name> <operator>=</operator> <literal type="number">0x43300000</literal></expr>;</expr_stmt>  <comment type="block">/* Biased integer to avoid denormals. */</comment>
    <if_stmt><if>if <condition>(<expr><name>narr</name> <operator>&gt;</operator> <literal type="number">256</literal></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>pc</name></name><operator>--</operator></expr>;</expr_stmt> <expr_stmt><expr><name>ilp</name><operator>--</operator></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>ilp</name><operator>-&gt;</operator><name>ins</name></name> <operator>=</operator> <call><name>BCINS_AD</name><argument_list>(<argument><expr><name>BC_TSETM</name></expr></argument>, <argument><expr><name>freg</name></expr></argument>, <argument><expr><call><name>const_num</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>en</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setbc_b</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ilp</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>ins</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>pc</name> <operator>==</operator> <name><name>fs</name><operator>-&gt;</operator><name>pc</name></name><operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* Make expr relocable if possible. */</comment>
    <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name> <operator>=</operator> <name>pc</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <name>VRELOCABLE</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <name>VNONRELOC</name></expr>;</expr_stmt>  <comment type="block">/* May have been changed by expr_index. */</comment>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>t</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Construct TNEW RD: hhhhhaaaaaaaaaaa. */</comment>
    <decl_stmt><decl><type><name>BCIns</name> <modifier>*</modifier></type><name>ip</name> <init>= <expr><operator>&amp;</operator><name><name>fs</name><operator>-&gt;</operator><name>bcbase</name><index>[<expr><name>pc</name></expr>]</index></name><operator>.</operator><name>ins</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>needarr</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>narr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>narr</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>narr</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>narr</name> <operator>&gt;</operator> <literal type="number">0x7ff</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>narr</name> <operator>=</operator> <literal type="number">0x7ff</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>setbc_d</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>narr</name><operator>|</operator><operator>(</operator><call><name>hsize2hbits</name><argument_list>(<argument><expr><name>nhash</name></expr></argument>)</argument_list></call><operator>&lt;&lt;</operator><literal type="number">11</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>needarr</name> <operator>&amp;&amp;</operator> <name><name>t</name><operator>-&gt;</operator><name>asize</name></name> <operator>&lt;</operator> <name>narr</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>lj_tab_reasize</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>narr</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>fixt</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Fix value for dummy keys in template table. */</comment>
      <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>noderef</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>hmask</name> <init>= <expr><name><name>t</name><operator>-&gt;</operator><name>hmask</name></name></expr></init></decl>;</decl_stmt>
      <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>hmask</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>tvistab</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>n</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>tabV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>n</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><call><name>setnilV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>n</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Turn value into nil. */</comment>
	</block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>lj_gc_check</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>L</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Parse function parameters. */</comment>
<function><type><specifier>static</specifier> <name>BCReg</name></type> <name>parse_params</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>needself</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCReg</name></type> <name>nparams</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lex_check</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>needself</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>var_new_lit</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>nparams</name><operator>++</operator></expr></argument>, <argument><expr><literal type="string">"self"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>tok</name></name> <operator>!=</operator> <literal type="char">')'</literal></expr>)</condition> <block>{<block_content>
    <do>do <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>tok</name></name> <operator>==</operator> <name>TK_name</name> <operator>||</operator> <operator>(</operator><operator>!</operator><name>LJ_52</name> <operator>&amp;&amp;</operator> <name><name>ls</name><operator>-&gt;</operator><name>tok</name></name> <operator>==</operator> <name>TK_goto</name><operator>)</operator></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>var_new</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>nparams</name><operator>++</operator></expr></argument>, <argument><expr><call><name>lex_str</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>tok</name></name> <operator>==</operator> <name>TK_dots</name></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>lj_lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>PROTO_VARARG</name></expr>;</expr_stmt>
	<break>break;</break>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<expr_stmt><expr><call><name>err_syntax</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>LJ_ERR_XPARAM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block> while <condition>(<expr><call><name>lex_opt</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>)</condition>;</do>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>var_add</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>nparams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name> <operator>==</operator> <name>nparams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>bcreg_reserve</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>nparams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lex_check</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>nparams</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Forward declaration. */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>parse_chunk</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Parse body of a function. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>parse_body</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>ExpDesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>needself</name></decl></parameter>, <parameter><decl><type><name>BCLine</name></type> <name>line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>FuncState</name></type> <name>fs</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pfs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FuncScope</name></type> <name>bl</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GCproto</name> <modifier>*</modifier></type><name>pt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>oldbase</name> <init>= <expr><name><name>pfs</name><operator>-&gt;</operator><name>bcbase</name></name> <operator>-</operator> <name><name>ls</name><operator>-&gt;</operator><name>bcstack</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>fs_init</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fscope_begin</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>.</operator><name>linedefined</name></name> <operator>=</operator> <name>line</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>.</operator><name>numparams</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><call><name>parse_params</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>needself</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>.</operator><name>bcbase</name></name> <operator>=</operator> <name><name>pfs</name><operator>-&gt;</operator><name>bcbase</name></name> <operator>+</operator> <name><name>pfs</name><operator>-&gt;</operator><name>pc</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>.</operator><name>bclim</name></name> <operator>=</operator> <name><name>pfs</name><operator>-&gt;</operator><name>bclim</name></name> <operator>-</operator> <name><name>pfs</name><operator>-&gt;</operator><name>pc</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>bcemit_AD</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fs</name></expr></argument>, <argument><expr><name>BC_FUNCF</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Placeholder. */</comment>
  <expr_stmt><expr><call><name>parse_chunk</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>tok</name></name> <operator>!=</operator> <name>TK_end</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>lex_match</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>TK_end</name></expr></argument>, <argument><expr><name>TK_function</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pt</name> <operator>=</operator> <call><name>fs_finish</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>(</operator><name><name>ls</name><operator>-&gt;</operator><name>lastline</name></name> <operator>=</operator> <name><name>ls</name><operator>-&gt;</operator><name>linenumber</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pfs</name><operator>-&gt;</operator><name>bcbase</name></name> <operator>=</operator> <name><name>ls</name><operator>-&gt;</operator><name>bcstack</name></name> <operator>+</operator> <name>oldbase</name></expr>;</expr_stmt>  <comment type="block">/* May have been reallocated. */</comment>
  <expr_stmt><expr><name><name>pfs</name><operator>-&gt;</operator><name>bclim</name></name> <operator>=</operator> <operator>(</operator><name>BCPos</name><operator>)</operator><operator>(</operator><name><name>ls</name><operator>-&gt;</operator><name>sizebcstack</name></name> <operator>-</operator> <name>oldbase</name><operator>)</operator></expr>;</expr_stmt>
  <comment type="block">/* Store new prototype in the constant array of the parent. */</comment>
  <expr_stmt><expr><call><name>expr_init</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>VRELOCABLE</name></expr></argument>,
	    <argument><expr><call><name>bcemit_AD</name><argument_list>(<argument><expr><name>pfs</name></expr></argument>, <argument><expr><name>BC_FNEW</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>const_gc</name><argument_list>(<argument><expr><name>pfs</name></expr></argument>, <argument><expr><call><name>obj2gco</name><argument_list>(<argument><expr><name>pt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LJ_TPROTO</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>
  <expr_stmt><expr><name><name>pfs</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <operator>(</operator><name><name>fs</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>PROTO_FFI</name><operator>)</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>pfs</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PROTO_CHILD</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>pfs</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PROTO_HAS_RETURN</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>pfs</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>PROTO_FIXUP_RETURN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>pfs</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>PROTO_CHILD</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>lj_lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Parse expression list. Last expression is left open. */</comment>
<function><type><specifier>static</specifier> <name>BCReg</name></type> <name>expr_list</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>ExpDesc</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>BCReg</name></type> <name>n</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>expr</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while <condition>(<expr><call><name>lex_opt</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>expr_tonextreg</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>expr</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
  <return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Parse function argument list. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>parse_args</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>ExpDesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ExpDesc</name></type> <name>args</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCIns</name></type> <name>ins</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCReg</name></type> <name>base</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCLine</name></type> <name>line</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>linenumber</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>tok</name></name> <operator>==</operator> <literal type="char">'('</literal></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>LJ_52</name></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><name>line</name> <operator>!=</operator> <name><name>ls</name><operator>-&gt;</operator><name>lastline</name></name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>err_syntax</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>LJ_ERR_XAMBIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>lj_lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>tok</name></name> <operator>==</operator> <literal type="char">')'</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* f(). */</comment>
      <expr_stmt><expr><name><name>args</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name>VVOID</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>expr_list</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>args</name><operator>.</operator><name>k</name></name> <operator>==</operator> <name>VCALL</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* f(a, b, g()) or f(a, b, ...). */</comment>
	<expr_stmt><expr><call><name>setbc_b</name><argument_list>(<argument><expr><call><name>bcptr</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Pass on multiple results. */</comment>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>lex_match</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>tok</name></name> <operator>==</operator> <literal type="char">'{'</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>expr_table</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>tok</name></name> <operator>==</operator> <name>TK_string</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>expr_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><name>VKSTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>args</name><operator>.</operator><name>u</name><operator>.</operator><name>sval</name></name> <operator>=</operator> <call><name>strV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ls</name><operator>-&gt;</operator><name>tokval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lj_lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>err_syntax</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>LJ_ERR_XFUNARG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>  <comment type="block">/* Silence compiler. */</comment>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VNONRELOC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>base</name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr>;</expr_stmt>  <comment type="block">/* Base register for call. */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>args</name><operator>.</operator><name>k</name></name> <operator>==</operator> <name>VCALL</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>BCINS_ABC</name><argument_list>(<argument><expr><name>BC_CALLM</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>args</name><operator>.</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>aux</name></name> <operator>-</operator> <name>base</name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <name>LJ_FR2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>args</name><operator>.</operator><name>k</name></name> <operator>!=</operator> <name>VVOID</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>expr_tonextreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>BCINS_ABC</name><argument_list>(<argument><expr><name>BC_CALL</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name> <operator>-</operator> <name>base</name> <operator>-</operator> <name>LJ_FR2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>expr_init</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>VCALL</name></expr></argument>, <argument><expr><call><name>bcemit_INS</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>aux</name></name> <operator>=</operator> <name>base</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>bcbase</name><index>[<expr><name><name>fs</name><operator>-&gt;</operator><name>pc</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>line</name> <operator>=</operator> <name>line</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name> <operator>=</operator> <name>base</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* Leave one result by default. */</comment>
</block_content>}</block></function>

<comment type="block">/* Parse primary expression. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>expr_primary</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>ExpDesc</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <comment type="block">/* Parse prefix expression. */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>tok</name></name> <operator>==</operator> <literal type="char">'('</literal></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>BCLine</name></type> <name>line</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>linenumber</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>lj_lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>expr</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lex_match</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>expr_discharge</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>tok</name></name> <operator>==</operator> <name>TK_name</name> <operator>||</operator> <operator>(</operator><operator>!</operator><name>LJ_52</name> <operator>&amp;&amp;</operator> <name><name>ls</name><operator>-&gt;</operator><name>tok</name></name> <operator>==</operator> <name>TK_goto</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>var_lookup</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>err_syntax</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>LJ_ERR_XSYMBOL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>  <comment type="block">/* Parse multiple expression suffixes. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>tok</name></name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>expr_field</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>tok</name></name> <operator>==</operator> <literal type="char">'['</literal></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>ExpDesc</name></type> <name>key</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>expr_toanyreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>expr_bracket</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>expr_index</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>tok</name></name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>ExpDesc</name></type> <name>key</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>lj_lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>expr_str</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>bcemit_method</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>parse_args</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>tok</name></name> <operator>==</operator> <literal type="char">'('</literal> <operator>||</operator> <name><name>ls</name><operator>-&gt;</operator><name>tok</name></name> <operator>==</operator> <name>TK_string</name> <operator>||</operator> <name><name>ls</name><operator>-&gt;</operator><name>tok</name></name> <operator>==</operator> <literal type="char">'{'</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>expr_tonextreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>LJ_FR2</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bcreg_reserve</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>parse_args</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <break>break;</break>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* Parse simple expression. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>expr_simple</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>ExpDesc</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <switch>switch <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>tok</name></name></expr>)</condition> <block>{<block_content>
  <case>case <expr><name>TK_number</name></expr>:</case>
    <expr_stmt><expr><call><name>expr_init</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>LJ_HASFFI</name> <operator>&amp;&amp;</operator> <call><name>tviscdata</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ls</name><operator>-&gt;</operator><name>tokval</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr> ?</condition><then> <expr><name>VKCDATA</name></expr> </then><else>: <expr><name>VKNUM</name></expr></else></ternary></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>v</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>nval</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ls</name><operator>-&gt;</operator><name>tokval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  <case>case <expr><name>TK_string</name></expr>:</case>
    <expr_stmt><expr><call><name>expr_init</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>VKSTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>sval</name></name> <operator>=</operator> <call><name>strV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ls</name><operator>-&gt;</operator><name>tokval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  <case>case <expr><name>TK_nil</name></expr>:</case>
    <expr_stmt><expr><call><name>expr_init</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>VKNIL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  <case>case <expr><name>TK_true</name></expr>:</case>
    <expr_stmt><expr><call><name>expr_init</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>VKTRUE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  <case>case <expr><name>TK_false</name></expr>:</case>
    <expr_stmt><expr><call><name>expr_init</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>VKFALSE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  <case>case <expr><name>TK_dots</name></expr>:</case> <block>{<block_content>  <comment type="block">/* Vararg. */</comment>
    <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BCReg</name></type> <name>base</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>checkcond</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PROTO_VARARG</name></expr></argument>, <argument><expr><name>LJ_ERR_XDOTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>bcreg_reserve</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>base</name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>expr_init</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>VCALL</name></expr></argument>, <argument><expr><call><name>bcemit_ABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>BC_VARG</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>numparams</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>aux</name></name> <operator>=</operator> <name>base</name></expr>;</expr_stmt>
    <break>break;</break>
  </block_content>}</block>
  <case>case <expr><literal type="char">'{'</literal></expr>:</case>  <comment type="block">/* Table constructor. */</comment>
    <expr_stmt><expr><call><name>expr_table</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  <case>case <expr><name>TK_function</name></expr>:</case>
    <expr_stmt><expr><call><name>lj_lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>parse_body</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>ls</name><operator>-&gt;</operator><name>linenumber</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  <default>default:</default>
    <expr_stmt><expr><call><name>expr_primary</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></switch>
  <expr_stmt><expr><call><name>lj_lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Manage syntactic levels to avoid blowing up the stack. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>synlevel_begin</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>++</operator><name><name>ls</name><operator>-&gt;</operator><name>level</name></name> <operator>&gt;=</operator> <name>LJ_MAX_XLEVEL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_lex_error</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>LJ_ERR_XLEVELS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>synlevel_end</name><parameter_list>(<parameter><type><name>ls</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((ls)-&gt;level--)</cpp:value></cpp:define>

<comment type="block">/* Convert token to binary operator. */</comment>
<function><type><specifier>static</specifier> <name>BinOpr</name></type> <name>token2binop</name><parameter_list>(<parameter><decl><type><name>LexToken</name></type> <name>tok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <switch>switch <condition>(<expr><name>tok</name></expr>)</condition> <block>{<block_content>
  <case>case <expr><literal type="char">'+'</literal></expr>:</case>	<return>return <expr><name>OPR_ADD</name></expr>;</return>
  <case>case <expr><literal type="char">'-'</literal></expr>:</case>	<return>return <expr><name>OPR_SUB</name></expr>;</return>
  <case>case <expr><literal type="char">'*'</literal></expr>:</case>	<return>return <expr><name>OPR_MUL</name></expr>;</return>
  <case>case <expr><literal type="char">'/'</literal></expr>:</case>	<return>return <expr><name>OPR_DIV</name></expr>;</return>
  <case>case <expr><literal type="char">'%'</literal></expr>:</case>	<return>return <expr><name>OPR_MOD</name></expr>;</return>
  <case>case <expr><literal type="char">'^'</literal></expr>:</case>	<return>return <expr><name>OPR_POW</name></expr>;</return>
  <case>case <expr><name>TK_concat</name></expr>:</case> <return>return <expr><name>OPR_CONCAT</name></expr>;</return>
  <case>case <expr><name>TK_ne</name></expr>:</case>	<return>return <expr><name>OPR_NE</name></expr>;</return>
  <case>case <expr><name>TK_eq</name></expr>:</case>	<return>return <expr><name>OPR_EQ</name></expr>;</return>
  <case>case <expr><literal type="char">'&lt;'</literal></expr>:</case>	<return>return <expr><name>OPR_LT</name></expr>;</return>
  <case>case <expr><name>TK_le</name></expr>:</case>	<return>return <expr><name>OPR_LE</name></expr>;</return>
  <case>case <expr><literal type="char">'&gt;'</literal></expr>:</case>	<return>return <expr><name>OPR_GT</name></expr>;</return>
  <case>case <expr><name>TK_ge</name></expr>:</case>	<return>return <expr><name>OPR_GE</name></expr>;</return>
  <case>case <expr><name>TK_and</name></expr>:</case>	<return>return <expr><name>OPR_AND</name></expr>;</return>
  <case>case <expr><name>TK_or</name></expr>:</case>	<return>return <expr><name>OPR_OR</name></expr>;</return>
  <default>default:</default>	<return>return <expr><name>OPR_NOBINOPR</name></expr>;</return>
  </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/* Priorities for each binary operator. ORDER OPR. */</comment>
<struct><specifier>static</specifier> <specifier>const</specifier> struct <block>{
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>left</name></decl>;</decl_stmt>		<comment type="block">/* Left priority. */</comment>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>right</name></decl>;</decl_stmt>	<comment type="block">/* Right priority. */</comment>
}</block> <decl><name><name>priority</name><index>[]</index></name> <init>= <expr><block>{
  <expr><block>{<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>}</block></expr>,	<comment type="block">/* ADD SUB MUL DIV MOD */</comment>
  <expr><block>{<expr><literal type="number">10</literal></expr>,<expr><literal type="number">9</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">5</literal></expr>,<expr><literal type="number">4</literal></expr>}</block></expr>,			<comment type="block">/* POW CONCAT (right associative) */</comment>
  <expr><block>{<expr><literal type="number">3</literal></expr>,<expr><literal type="number">3</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">3</literal></expr>,<expr><literal type="number">3</literal></expr>}</block></expr>,				<comment type="block">/* EQ NE */</comment>
  <expr><block>{<expr><literal type="number">3</literal></expr>,<expr><literal type="number">3</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">3</literal></expr>,<expr><literal type="number">3</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">3</literal></expr>,<expr><literal type="number">3</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">3</literal></expr>,<expr><literal type="number">3</literal></expr>}</block></expr>,		<comment type="block">/* LT GE GT LE */</comment>
  <expr><block>{<expr><literal type="number">2</literal></expr>,<expr><literal type="number">2</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">1</literal></expr>,<expr><literal type="number">1</literal></expr>}</block></expr>				<comment type="block">/* AND OR */</comment>
}</block></expr></init></decl>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNARY_PRIORITY</name></cpp:macro>		<cpp:value>8</cpp:value></cpp:define>  <comment type="block">/* Priority for unary operators. */</comment>

<comment type="block">/* Forward declaration. */</comment>
<function_decl><type><specifier>static</specifier> <name>BinOpr</name></type> <name>expr_binop</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>ExpDesc</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>limit</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Parse unary expression. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>expr_unop</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>ExpDesc</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>BCOp</name></type> <name>op</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>tok</name></name> <operator>==</operator> <name>TK_not</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>op</name> <operator>=</operator> <name>BC_NOT</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>tok</name></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>op</name> <operator>=</operator> <name>BC_UNM</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>tok</name></name> <operator>==</operator> <literal type="char">'#'</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>op</name> <operator>=</operator> <name>BC_LEN</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>expr_simple</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>lj_lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>expr_binop</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>UNARY_PRIORITY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>bcemit_unop</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Parse binary expressions with priority higher than the limit. */</comment>
<function><type><specifier>static</specifier> <name>BinOpr</name></type> <name>expr_binop</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>ExpDesc</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>limit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>BinOpr</name></type> <name>op</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>synlevel_begin</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>expr_unop</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>op</name> <operator>=</operator> <call><name>token2binop</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>tok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while <condition>(<expr><name>op</name> <operator>!=</operator> <name>OPR_NOBINOPR</name> <operator>&amp;&amp;</operator> <name><name>priority</name><index>[<expr><name>op</name></expr>]</index></name><operator>.</operator><name>left</name> <operator>&gt;</operator> <name>limit</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>ExpDesc</name></type> <name>v2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BinOpr</name></type> <name>nextop</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>lj_lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>bcemit_binop_left</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Parse binary expression with higher priority. */</comment>
    <expr_stmt><expr><name>nextop</name> <operator>=</operator> <call><name>expr_binop</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v2</name></expr></argument>, <argument><expr><name><name>priority</name><index>[<expr><name>op</name></expr>]</index></name><operator>.</operator><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>bcemit_binop</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>op</name> <operator>=</operator> <name>nextop</name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>synlevel_end</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>op</name></expr>;</return>  <comment type="block">/* Return unconsumed binary operator (if any). */</comment>
</block_content>}</block></function>

<comment type="block">/* Parse expression. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>expr</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>ExpDesc</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>expr_binop</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Priority 0: parse whole expression. */</comment>
</block_content>}</block></function>

<comment type="block">/* Assign expression to the next register. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>expr_next</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>ExpDesc</name></type> <name>e</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>expr</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>expr_tonextreg</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Parse conditional expression. */</comment>
<function><type><specifier>static</specifier> <name>BCPos</name></type> <name>expr_cond</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>ExpDesc</name></type> <name>v</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>expr</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>v</name><operator>.</operator><name>k</name></name> <operator>==</operator> <name>VKNIL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>v</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name>VKFALSE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>bcemit_branch_t</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>v</name><operator>.</operator><name>f</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -- Assignments --------------------------------------------------------- */</comment>

<comment type="block">/* List of LHS variables. */</comment>
<typedef>typedef <type><struct>struct <name>LHSVarList</name> <block>{
  <decl_stmt><decl><type><name>ExpDesc</name></type> <name>v</name></decl>;</decl_stmt>			<comment type="block">/* LHS variable. */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>LHSVarList</name></name> <modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>	<comment type="block">/* Link to previous LHS variable. */</comment>
}</block></struct></type> <name>LHSVarList</name>;</typedef>

<comment type="block">/* Eliminate write-after-read hazards for local variable assignment. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>assign_hazard</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>LHSVarList</name> <modifier>*</modifier></type><name>lh</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ExpDesc</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCReg</name></type> <name>reg</name> <init>= <expr><name><name>v</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* Check against this variable. */</comment>
  <decl_stmt><decl><type><name>BCReg</name></type> <name>tmp</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* Rename to this temp. register (if needed). */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>hazard</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init>;</init> <condition><expr><name>lh</name></expr>;</condition> <incr><expr><name>lh</name> <operator>=</operator> <name><name>lh</name><operator>-&gt;</operator><name>prev</name></name></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>lh</name><operator>-&gt;</operator><name>v</name><operator>.</operator><name>k</name></name> <operator>==</operator> <name>VINDEXED</name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>lh</name><operator>-&gt;</operator><name>v</name><operator>.</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name> <operator>==</operator> <name>reg</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* t[i], t = 1, 2 */</comment>
	<expr_stmt><expr><name>hazard</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lh</name><operator>-&gt;</operator><name>v</name><operator>.</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>lh</name><operator>-&gt;</operator><name>v</name><operator>.</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>aux</name></name> <operator>==</operator> <name>reg</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* t[i], i = 1, 2 */</comment>
	<expr_stmt><expr><name>hazard</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lh</name><operator>-&gt;</operator><name>v</name><operator>.</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>aux</name></name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if <condition>(<expr><name>hazard</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>bcemit_AD</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>BC_MOV</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Rename conflicting variable. */</comment>
    <expr_stmt><expr><call><name>bcreg_reserve</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Adjust LHS/RHS of an assignment. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>assign_adjust</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>BCReg</name></type> <name>nvars</name></decl></parameter>, <parameter><decl><type><name>BCReg</name></type> <name>nexps</name></decl></parameter>, <parameter><decl><type><name>ExpDesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>extra</name> <init>= <expr><operator>(</operator><name>int32_t</name><operator>)</operator><name>nvars</name> <operator>-</operator> <operator>(</operator><name>int32_t</name><operator>)</operator><name>nexps</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VCALL</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>extra</name><operator>++</operator></expr>;</expr_stmt>  <comment type="block">/* Compensate for the VCALL itself. */</comment>
    <if_stmt><if>if <condition>(<expr><name>extra</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>extra</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>setbc_b</name><argument_list>(<argument><expr><call><name>bcptr</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>extra</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Fixup call results. */</comment>
    <if_stmt><if>if <condition>(<expr><name>extra</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bcreg_reserve</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>(</operator><name>BCReg</name><operator>)</operator><name>extra</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>!=</operator> <name>VVOID</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>expr_tonextreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Close last expression. */</comment>
    <if_stmt><if>if <condition>(<expr><name>extra</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* Leftover LHS are set to nil. */</comment>
      <decl_stmt><decl><type><name>BCReg</name></type> <name>reg</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>bcreg_reserve</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>(</operator><name>BCReg</name><operator>)</operator><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>bcemit_nil</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><operator>(</operator><name>BCReg</name><operator>)</operator><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>nexps</name> <operator>&gt;</operator> <name>nvars</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name><operator>-&gt;</operator><name>freereg</name></name> <operator>-=</operator> <name>nexps</name> <operator>-</operator> <name>nvars</name></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Drop leftover regs. */</comment>
</block_content>}</block></function>

<comment type="block">/* Recursively parse assignment statement. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>parse_assignment</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>LHSVarList</name> <modifier>*</modifier></type><name>lh</name></decl></parameter>, <parameter><decl><type><name>BCReg</name></type> <name>nvars</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>ExpDesc</name></type> <name>e</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>checkcond</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>VLOCAL</name> <operator>&lt;=</operator> <name><name>lh</name><operator>-&gt;</operator><name>v</name><operator>.</operator><name>k</name></name> <operator>&amp;&amp;</operator> <name><name>lh</name><operator>-&gt;</operator><name>v</name><operator>.</operator><name>k</name></name> <operator>&lt;=</operator> <name>VINDEXED</name></expr></argument>, <argument><expr><name>LJ_ERR_XSYNTAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>lex_opt</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Collect LHS list and recurse upwards. */</comment>
    <decl_stmt><decl><type><name>LHSVarList</name></type> <name>vl</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>vl</name><operator>.</operator><name>prev</name></name> <operator>=</operator> <name>lh</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>expr_primary</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>vl</name><operator>.</operator><name>v</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>vl</name><operator>.</operator><name>v</name><operator>.</operator><name>k</name></name> <operator>==</operator> <name>VLOCAL</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>assign_hazard</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>lh</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>vl</name><operator>.</operator><name>v</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>checklimit</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>, <argument><expr><name><name>ls</name><operator>-&gt;</operator><name>level</name></name> <operator>+</operator> <name>nvars</name></expr></argument>, <argument><expr><name>LJ_MAX_XLEVEL</name></expr></argument>, <argument><expr><literal type="string">"variable names"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>parse_assignment</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vl</name></expr></argument>, <argument><expr><name>nvars</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* Parse RHS. */</comment>
    <decl_stmt><decl><type><name>BCReg</name></type> <name>nexps</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>lex_check</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nexps</name> <operator>=</operator> <call><name>expr_list</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>nexps</name> <operator>==</operator> <name>nvars</name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>e</name><operator>.</operator><name>k</name></name> <operator>==</operator> <name>VCALL</name></expr>)</condition> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>bc_op</name><argument_list>(<argument><expr><operator>*</operator><call><name>bcptr</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>BC_VARG</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Vararg assignment. */</comment>
	  <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name><operator>-&gt;</operator><name>freereg</name></name><operator>--</operator></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>e</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name>VRELOCABLE</name></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* Multiple call results. */</comment>
	  <expr_stmt><expr><name><name>e</name><operator>.</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name> <operator>=</operator> <name><name>e</name><operator>.</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>aux</name></name></expr>;</expr_stmt>  <comment type="block">/* Base of call is not relocatable. */</comment>
	  <expr_stmt><expr><name><name>e</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name>VNONRELOC</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>bcemit_store</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lh</name><operator>-&gt;</operator><name>v</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assign_adjust</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>nvars</name></expr></argument>, <argument><expr><name>nexps</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <comment type="block">/* Assign RHS to LHS and recurse downwards. */</comment>
  <expr_stmt><expr><call><name>expr_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>e</name></expr></argument>, <argument><expr><name>VNONRELOC</name></expr></argument>, <argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name><operator>-&gt;</operator><name>freereg</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>bcemit_store</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lh</name><operator>-&gt;</operator><name>v</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Parse call statement or assignment. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>parse_call_assign</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LHSVarList</name></type> <name>vl</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>expr_primary</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>vl</name><operator>.</operator><name>v</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>vl</name><operator>.</operator><name>v</name><operator>.</operator><name>k</name></name> <operator>==</operator> <name>VCALL</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Function call statement. */</comment>
    <expr_stmt><expr><call><name>setbc_b</name><argument_list>(<argument><expr><call><name>bcptr</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>vl</name><operator>.</operator><name>v</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* No results. */</comment>
  </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* Start of an assignment. */</comment>
    <expr_stmt><expr><name><name>vl</name><operator>.</operator><name>prev</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>parse_assignment</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vl</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Parse 'local' statement. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>parse_local</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>lex_opt</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>TK_function</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Local function declaration. */</comment>
    <decl_stmt><decl><type><name>ExpDesc</name></type> <name>v</name></decl>, <decl><type ref="prev"/><name>b</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>var_new</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>lex_str</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>expr_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><name>VLOCAL</name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>v</name><operator>.</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>aux</name></name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>varmap</name><index>[<expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>bcreg_reserve</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>var_add</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>parse_body</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>b</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>ls</name><operator>-&gt;</operator><name>linenumber</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* bcemit_store(fs, &amp;v, &amp;b) without setting VSTACK_VAR_RW. */</comment>
    <expr_stmt><expr><call><name>expr_free</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>expr_toreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>b</name></expr></argument>, <argument><expr><name><name>v</name><operator>.</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* The upvalue is in scope, but the local is only valid after the store. */</comment>
    <expr_stmt><expr><call><name>var_get</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>.</operator><name>startpc</name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>pc</name></name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* Local variable declaration. */</comment>
    <decl_stmt><decl><type><name>ExpDesc</name></type> <name>e</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BCReg</name></type> <name>nexps</name></decl>, <decl><type ref="prev"/><name>nvars</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <do>do <block>{<block_content>  <comment type="block">/* Collect LHS. */</comment>
      <expr_stmt><expr><call><name>var_new</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>nvars</name><operator>++</operator></expr></argument>, <argument><expr><call><name>lex_str</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block> while <condition>(<expr><call><name>lex_opt</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>)</condition>;</do>
    <if_stmt><if>if <condition>(<expr><call><name>lex_opt</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Optional RHS. */</comment>
      <expr_stmt><expr><name>nexps</name> <operator>=</operator> <call><name>expr_list</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* Or implicitly set to nil. */</comment>
      <expr_stmt><expr><name><name>e</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name>VVOID</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>nexps</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>assign_adjust</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>nvars</name></expr></argument>, <argument><expr><name>nexps</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>var_add</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>nvars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Parse 'function' statement. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>parse_func</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>BCLine</name></type> <name>line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ExpDesc</name></type> <name>v</name></decl>, <decl><type ref="prev"/><name>b</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>needself</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lj_lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Skip 'function'. */</comment>
  <comment type="block">/* Parse function name. */</comment>
  <expr_stmt><expr><call><name>var_lookup</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>tok</name></name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* Multiple dot-separated fields. */</comment>
    <expr_stmt><expr><call><name>expr_field</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
  <if_stmt><if>if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>tok</name></name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* Optional colon to signify method call. */</comment>
    <expr_stmt><expr><name>needself</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>expr_field</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>parse_body</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>b</name></expr></argument>, <argument><expr><name>needself</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>fs</name> <operator>=</operator> <name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>bcemit_store</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>bcbase</name><index>[<expr><name><name>fs</name><operator>-&gt;</operator><name>pc</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>line</name> <operator>=</operator> <name>line</name></expr>;</expr_stmt>  <comment type="block">/* Set line for the store. */</comment>
</block_content>}</block></function>

<comment type="block">/* -- Control transfer statements ----------------------------------------- */</comment>

<comment type="block">/* Check for end of block. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_isend</name><parameter_list>(<parameter><decl><type><name>LexToken</name></type> <name>tok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <switch>switch <condition>(<expr><name>tok</name></expr>)</condition> <block>{<block_content>
  <case>case <expr><name>TK_else</name></expr>:</case> <case>case <expr><name>TK_elseif</name></expr>:</case> <case>case <expr><name>TK_end</name></expr>:</case> <case>case <expr><name>TK_until</name></expr>:</case> <case>case <expr><name>TK_eof</name></expr>:</case>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  <default>default:</default>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/* Parse 'return' statement. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>parse_return</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>BCIns</name></type> <name>ins</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lj_lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Skip 'return'. */</comment>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>PROTO_HAS_RETURN</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>parse_isend</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>tok</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>ls</name><operator>-&gt;</operator><name>tok</name></name> <operator>==</operator> <literal type="char">';'</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* Bare return. */</comment>
    <expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>BCINS_AD</name><argument_list>(<argument><expr><name>BC_RET0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* Return with one or more values. */</comment>
    <decl_stmt><decl><type><name>ExpDesc</name></type> <name>e</name></decl>;</decl_stmt>  <comment type="block">/* Receives the _last_ expression in the list. */</comment>
    <decl_stmt><decl><type><name>BCReg</name></type> <name>nret</name> <init>= <expr><call><name>expr_list</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>nret</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* Return one result. */</comment>
      <if_stmt><if>if <condition>(<expr><name><name>e</name><operator>.</operator><name>k</name></name> <operator>==</operator> <name>VCALL</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Check for tail call. */</comment>
	<decl_stmt><decl><type><name>BCIns</name> <modifier>*</modifier></type><name>ip</name> <init>= <expr><call><name>bcptr</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="block">/* It doesn't pay off to add BC_VARGT just for 'return ...'. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>bc_op</name><argument_list>(<argument><expr><operator>*</operator><name>ip</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BC_VARG</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>notailcall</name>;</goto></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>pc</name></name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>BCINS_AD</name><argument_list>(<argument><expr><call><name>bc_op</name><argument_list>(<argument><expr><operator>*</operator><name>ip</name></expr></argument>)</argument_list></call><operator>-</operator><name>BC_CALL</name><operator>+</operator><name>BC_CALLT</name></expr></argument>, <argument><expr><call><name>bc_a</name><argument_list>(<argument><expr><operator>*</operator><name>ip</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>bc_c</name><argument_list>(<argument><expr><operator>*</operator><name>ip</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* Can return the result from any register. */</comment>
	<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>BCINS_AD</name><argument_list>(<argument><expr><name>BC_RET1</name></expr></argument>, <argument><expr><call><name>expr_toanyreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>e</name><operator>.</operator><name>k</name></name> <operator>==</operator> <name>VCALL</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Append all results from a call. */</comment>
      <label><name>notailcall</name>:</label>
	<expr_stmt><expr><call><name>setbc_b</name><argument_list>(<argument><expr><call><name>bcptr</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>BCINS_AD</name><argument_list>(<argument><expr><name>BC_RETM</name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name></expr></argument>, <argument><expr><name><name>e</name><operator>.</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>aux</name></name> <operator>-</operator> <name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<expr_stmt><expr><call><name>expr_tonextreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Force contiguous registers. */</comment>
	<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>BCINS_AD</name><argument_list>(<argument><expr><name>BC_RET</name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name></expr></argument>, <argument><expr><name>nret</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>fs</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PROTO_CHILD</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>bcemit_AJ</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>BC_UCLO</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* May need to close upvalues first. */</comment>
  <expr_stmt><expr><call><name>bcemit_INS</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Parse 'break' statement. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>parse_break</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name><operator>-&gt;</operator><name>bl</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>FSCOPE_BREAK</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>gola_new</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>NAME_BREAK</name></expr></argument>, <argument><expr><name>VSTACK_GOTO</name></expr></argument>, <argument><expr><call><name>bcemit_jmp</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Parse 'goto' statement. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>parse_goto</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>lex_str</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>VarInfo</name> <modifier>*</modifier></type><name>vl</name> <init>= <expr><call><name>gola_findlabel</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>vl</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* Treat backwards goto within same scope like a loop. */</comment>
    <expr_stmt><expr><call><name>bcemit_AJ</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>BC_LOOP</name></expr></argument>, <argument><expr><name><name>vl</name><operator>-&gt;</operator><name>slot</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* No BC range check. */</comment>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>bl</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>FSCOPE_GOLA</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>gola_new</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>VSTACK_GOTO</name></expr></argument>, <argument><expr><call><name>bcemit_jmp</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Parse label. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>parse_label</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MSize</name></type> <name>idx</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>lasttarget</name></name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>pc</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>bl</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>FSCOPE_GOLA</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lj_lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Skip '::'. */</comment>
  <expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>lex_str</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>gola_findlabel</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_lex_error</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>LJ_ERR_XLDUP</name></expr></argument>, <argument><expr><call><name>strdata</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>gola_new</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>VSTACK_LABEL</name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>pc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lex_check</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>TK_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Recursively parse trailing statements: labels and ';' (Lua 5.2 only). */</comment>
  <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>tok</name></name> <operator>==</operator> <name>TK_label</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>synlevel_begin</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>parse_label</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>synlevel_end</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>LJ_52</name> <operator>&amp;&amp;</operator> <name><name>ls</name><operator>-&gt;</operator><name>tok</name></name> <operator>==</operator> <literal type="char">';'</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>lj_lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <break>break;</break>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
  <comment type="block">/* Trailing label is considered to be outside of scope. */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>parse_isend</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>tok</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>ls</name><operator>-&gt;</operator><name>tok</name></name> <operator>!=</operator> <name>TK_until</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>vstack</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>slot</name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>bl</name><operator>-&gt;</operator><name>nactvar</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>gola_resolve</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>bl</name></name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* -- Blocks, loops and conditional statements ---------------------------- */</comment>

<comment type="block">/* Parse a block. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>parse_block</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FuncScope</name></type> <name>bl</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>fscope_begin</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>parse_chunk</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fscope_end</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Parse 'while' statement. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>parse_while</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>BCLine</name></type> <name>line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCPos</name></type> <name>start</name></decl>, <decl><type ref="prev"/><name>loop</name></decl>, <decl><type ref="prev"/><name>condexit</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FuncScope</name></type> <name>bl</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lj_lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Skip 'while'. */</comment>
  <expr_stmt><expr><name>start</name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>lasttarget</name></name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>pc</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>condexit</name> <operator>=</operator> <call><name>expr_cond</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fscope_begin</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bl</name></expr></argument>, <argument><expr><name>FSCOPE_LOOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lex_check</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>TK_do</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>loop</name> <operator>=</operator> <call><name>bcemit_AD</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>BC_LOOP</name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>parse_block</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>jmp_patch</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><call><name>bcemit_jmp</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lex_match</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>TK_end</name></expr></argument>, <argument><expr><name>TK_while</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fscope_end</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>jmp_tohere</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>condexit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>jmp_patchins</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>loop</name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>pc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Parse 'repeat' statement. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>parse_repeat</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>BCLine</name></type> <name>line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCPos</name></type> <name>loop</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>lasttarget</name></name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>pc</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCPos</name></type> <name>condexit</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FuncScope</name></type> <name>bl1</name></decl>, <decl><type ref="prev"/><name>bl2</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>fscope_begin</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bl1</name></expr></argument>, <argument><expr><name>FSCOPE_LOOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Breakable loop scope. */</comment>
  <expr_stmt><expr><call><name>fscope_begin</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bl2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Inner scope. */</comment>
  <expr_stmt><expr><call><name>lj_lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Skip 'repeat'. */</comment>
  <expr_stmt><expr><call><name>bcemit_AD</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>BC_LOOP</name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>parse_chunk</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lex_match</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>TK_until</name></expr></argument>, <argument><expr><name>TK_repeat</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>condexit</name> <operator>=</operator> <call><name>expr_cond</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Parse condition (still inside inner scope). */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>bl2</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>FSCOPE_UPVAL</name><operator>)</operator></expr>)</condition> <block>{<block_content>  <comment type="block">/* No upvalues? Just end inner scope. */</comment>
    <expr_stmt><expr><call><name>fscope_end</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* Otherwise generate: cond: UCLO+JMP out, !cond: UCLO+JMP loop. */</comment>
    <expr_stmt><expr><call><name>parse_break</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Break from loop and close upvalues. */</comment>
    <expr_stmt><expr><call><name>jmp_tohere</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>condexit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fscope_end</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* End inner scope and close upvalues. */</comment>
    <expr_stmt><expr><name>condexit</name> <operator>=</operator> <call><name>bcemit_jmp</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>jmp_patch</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>condexit</name></expr></argument>, <argument><expr><name>loop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Jump backwards if !cond. */</comment>
  <expr_stmt><expr><call><name>jmp_patchins</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>loop</name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>pc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fscope_end</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* End loop scope. */</comment>
</block_content>}</block></function>

<comment type="block">/* Parse numeric 'for'. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>parse_for_num</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>varname</name></decl></parameter>, <parameter><decl><type><name>BCLine</name></type> <name>line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCReg</name></type> <name>base</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FuncScope</name></type> <name>bl</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCPos</name></type> <name>loop</name></decl>, <decl><type ref="prev"/><name>loopend</name></decl>;</decl_stmt>
  <comment type="block">/* Hidden control variables. */</comment>
  <expr_stmt><expr><call><name>var_new_fixed</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>FORL_IDX</name></expr></argument>, <argument><expr><name>VARNAME_FOR_IDX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>var_new_fixed</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>FORL_STOP</name></expr></argument>, <argument><expr><name>VARNAME_FOR_STOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>var_new_fixed</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>FORL_STEP</name></expr></argument>, <argument><expr><name>VARNAME_FOR_STEP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Visible copy of index variable. */</comment>
  <expr_stmt><expr><call><name>var_new</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>FORL_EXT</name></expr></argument>, <argument><expr><name>varname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lex_check</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>expr_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lex_check</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>expr_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>lex_opt</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>expr_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>bcemit_AD</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>BC_KSHORT</name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Default step is 1. */</comment>
    <expr_stmt><expr><call><name>bcreg_reserve</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>var_add</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Hidden control variables. */</comment>
  <expr_stmt><expr><call><name>lex_check</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>TK_do</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>loop</name> <operator>=</operator> <call><name>bcemit_AJ</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>BC_FORI</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>NO_JMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fscope_begin</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Scope for visible variables. */</comment>
  <expr_stmt><expr><call><name>var_add</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>bcreg_reserve</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>parse_block</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fscope_end</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Perform loop inversion. Loop control instructions are at the end. */</comment>
  <expr_stmt><expr><name>loopend</name> <operator>=</operator> <call><name>bcemit_AJ</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>BC_FORL</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>NO_JMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>bcbase</name><index>[<expr><name>loopend</name></expr>]</index></name><operator>.</operator><name>line</name> <operator>=</operator> <name>line</name></expr>;</expr_stmt>  <comment type="block">/* Fix line for control ins. */</comment>
  <expr_stmt><expr><call><name>jmp_patchins</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>loopend</name></expr></argument>, <argument><expr><name>loop</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>jmp_patchins</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>loop</name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>pc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Try to predict whether the iterator is next() and specialize the bytecode.
** Detecting next() and pairs() by name is simplistic, but quite effective.
** The interpreter backs off if the check for the closure fails at runtime.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>predict_next</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>BCPos</name></type> <name>pc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>BCIns</name></type> <name>ins</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>bcbase</name><index>[<expr><name>pc</name></expr>]</index></name><operator>.</operator><name>ins</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>o</name></decl>;</decl_stmt>
  <switch>switch <condition>(<expr><call><name>bc_op</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
  <case>case <expr><name>BC_MOV</name></expr>:</case>
    <expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>gco2str</name><argument_list>(<argument><expr><call><name>gcref</name><argument_list>(<argument><expr><call><name>var_get</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><call><name>bc_d</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  <case>case <expr><name>BC_UGET</name></expr>:</case>
    <expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>gco2str</name><argument_list>(<argument><expr><call><name>gcref</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>vstack</name><index>[<expr><name><name>fs</name><operator>-&gt;</operator><name>uvmap</name><index>[<expr><call><name>bc_d</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  <case>case <expr><name>BC_GGET</name></expr>:</case>
    <comment type="block">/* There's no inverse index (yet), so lookup the strings. */</comment>
    <expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>lj_tab_getstr</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>kt</name></name></expr></argument>, <argument><expr><call><name>lj_str_newlit</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><literal type="string">"pairs"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>o</name> <operator>&amp;&amp;</operator> <call><name>tvhaskslot</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>tvkslot</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>bc_d</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>lj_tab_getstr</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>kt</name></name></expr></argument>, <argument><expr><call><name>lj_str_newlit</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><literal type="string">"next"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>o</name> <operator>&amp;&amp;</operator> <call><name>tvhaskslot</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>tvkslot</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>bc_d</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  <default>default:</default>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></switch>
  <return>return <expr><operator>(</operator><name><name>name</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">5</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><call><name>strdata</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"pairs"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
	 <operator>(</operator><name><name>name</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><call><name>strdata</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"next"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Parse 'for' iterator. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>parse_for_iter</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>indexname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ExpDesc</name></type> <name>e</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCReg</name></type> <name>nvars</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCLine</name></type> <name>line</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCReg</name></type> <name>base</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name> <operator>+</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCPos</name></type> <name>loop</name></decl>, <decl><type ref="prev"/><name>loopend</name></decl>, <decl><type ref="prev"/><name>exprpc</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>pc</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FuncScope</name></type> <name>bl</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>isnext</name></decl>;</decl_stmt>
  <comment type="block">/* Hidden control variables. */</comment>
  <expr_stmt><expr><call><name>var_new_fixed</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>nvars</name><operator>++</operator></expr></argument>, <argument><expr><name>VARNAME_FOR_GEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>var_new_fixed</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>nvars</name><operator>++</operator></expr></argument>, <argument><expr><name>VARNAME_FOR_STATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>var_new_fixed</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>nvars</name><operator>++</operator></expr></argument>, <argument><expr><name>VARNAME_FOR_CTL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Visible variables returned from iterator. */</comment>
  <expr_stmt><expr><call><name>var_new</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>nvars</name><operator>++</operator></expr></argument>, <argument><expr><name>indexname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while <condition>(<expr><call><name>lex_opt</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>var_new</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>nvars</name><operator>++</operator></expr></argument>, <argument><expr><call><name>lex_str</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
  <expr_stmt><expr><call><name>lex_check</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>TK_in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>line</name> <operator>=</operator> <name><name>ls</name><operator>-&gt;</operator><name>linenumber</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assign_adjust</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><call><name>expr_list</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* The iterator needs another 3 [4] slots (func [pc] | state ctl). */</comment>
  <expr_stmt><expr><call><name>bcreg_bump</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><literal type="number">3</literal><operator>+</operator><name>LJ_FR2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>isnext</name> <operator>=</operator> <operator>(</operator><name>nvars</name> <operator>&lt;=</operator> <literal type="number">5</literal> <operator>&amp;&amp;</operator> <call><name>predict_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>exprpc</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>var_add</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Hidden control variables. */</comment>
  <expr_stmt><expr><call><name>lex_check</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>TK_do</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>loop</name> <operator>=</operator> <call><name>bcemit_AJ</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><ternary><condition><expr><name>isnext</name></expr> ?</condition><then> <expr><name>BC_ISNEXT</name></expr> </then><else>: <expr><name>BC_JMP</name></expr></else></ternary></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>NO_JMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fscope_begin</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Scope for visible variables. */</comment>
  <expr_stmt><expr><call><name>var_add</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>nvars</name><operator>-</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>bcreg_reserve</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>nvars</name><operator>-</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>parse_block</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fscope_end</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Perform loop inversion. Loop control instructions are at the end. */</comment>
  <expr_stmt><expr><call><name>jmp_patchins</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>loop</name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>pc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>bcemit_ABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><ternary><condition><expr><name>isnext</name></expr> ?</condition><then> <expr><name>BC_ITERN</name></expr> </then><else>: <expr><name>BC_ITERC</name></expr></else></ternary></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>nvars</name><operator>-</operator><literal type="number">3</literal><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>loopend</name> <operator>=</operator> <call><name>bcemit_AJ</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>BC_ITERL</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>NO_JMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>bcbase</name><index>[<expr><name>loopend</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>line</name> <operator>=</operator> <name>line</name></expr>;</expr_stmt>  <comment type="block">/* Fix line for control ins. */</comment>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>bcbase</name><index>[<expr><name>loopend</name></expr>]</index></name><operator>.</operator><name>line</name> <operator>=</operator> <name>line</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>jmp_patchins</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>loopend</name></expr></argument>, <argument><expr><name>loop</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Parse 'for' statement. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>parse_for</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>BCLine</name></type> <name>line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>varname</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FuncScope</name></type> <name>bl</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>fscope_begin</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bl</name></expr></argument>, <argument><expr><name>FSCOPE_LOOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lj_lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Skip 'for'. */</comment>
  <expr_stmt><expr><name>varname</name> <operator>=</operator> <call><name>lex_str</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Get first variable name. */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>tok</name></name> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>parse_for_num</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>varname</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>tok</name></name> <operator>==</operator> <literal type="char">','</literal> <operator>||</operator> <name><name>ls</name><operator>-&gt;</operator><name>tok</name></name> <operator>==</operator> <name>TK_in</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>parse_for_iter</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>varname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>err_syntax</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>LJ_ERR_XFOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  <expr_stmt><expr><call><name>lex_match</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>TK_end</name></expr></argument>, <argument><expr><name>TK_for</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fscope_end</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Resolve break list. */</comment>
</block_content>}</block></function>

<comment type="block">/* Parse condition and 'then' block. */</comment>
<function><type><specifier>static</specifier> <name>BCPos</name></type> <name>parse_then</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>BCPos</name></type> <name>condexit</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lj_lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Skip 'if' or 'elseif'. */</comment>
  <expr_stmt><expr><name>condexit</name> <operator>=</operator> <call><name>expr_cond</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lex_check</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>TK_then</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>parse_block</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>condexit</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Parse 'if' statement. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>parse_if</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>BCLine</name></type> <name>line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCPos</name></type> <name>flist</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCPos</name></type> <name>escapelist</name> <init>= <expr><name>NO_JMP</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>flist</name> <operator>=</operator> <call><name>parse_then</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>tok</name></name> <operator>==</operator> <name>TK_elseif</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Parse multiple 'elseif' blocks. */</comment>
    <expr_stmt><expr><call><name>jmp_append</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>escapelist</name></expr></argument>, <argument><expr><call><name>bcemit_jmp</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>jmp_tohere</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>flist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>flist</name> <operator>=</operator> <call><name>parse_then</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>tok</name></name> <operator>==</operator> <name>TK_else</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Parse optional 'else' block. */</comment>
    <expr_stmt><expr><call><name>jmp_append</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>escapelist</name></expr></argument>, <argument><expr><call><name>bcemit_jmp</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>jmp_tohere</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>flist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lj_lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Skip 'else'. */</comment>
    <expr_stmt><expr><call><name>parse_block</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>jmp_append</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>escapelist</name></expr></argument>, <argument><expr><name>flist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>jmp_tohere</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>escapelist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lex_match</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>TK_end</name></expr></argument>, <argument><expr><name>TK_if</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* -- Parse statements ---------------------------------------------------- */</comment>

<comment type="block">/* Parse a statement. Returns 1 if it must be the last one in a chunk. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_stmt</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>BCLine</name></type> <name>line</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>linenumber</name></name></expr></init></decl>;</decl_stmt>
  <switch>switch <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>tok</name></name></expr>)</condition> <block>{<block_content>
  <case>case <expr><name>TK_if</name></expr>:</case>
    <expr_stmt><expr><call><name>parse_if</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  <case>case <expr><name>TK_while</name></expr>:</case>
    <expr_stmt><expr><call><name>parse_while</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  <case>case <expr><name>TK_do</name></expr>:</case>
    <expr_stmt><expr><call><name>lj_lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>parse_block</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lex_match</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>TK_end</name></expr></argument>, <argument><expr><name>TK_do</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  <case>case <expr><name>TK_for</name></expr>:</case>
    <expr_stmt><expr><call><name>parse_for</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  <case>case <expr><name>TK_repeat</name></expr>:</case>
    <expr_stmt><expr><call><name>parse_repeat</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  <case>case <expr><name>TK_function</name></expr>:</case>
    <expr_stmt><expr><call><name>parse_func</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  <case>case <expr><name>TK_local</name></expr>:</case>
    <expr_stmt><expr><call><name>lj_lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>parse_local</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  <case>case <expr><name>TK_return</name></expr>:</case>
    <expr_stmt><expr><call><name>parse_return</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>  <comment type="block">/* Must be last. */</comment>
  <case>case <expr><name>TK_break</name></expr>:</case>
    <expr_stmt><expr><call><name>lj_lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>parse_break</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>!</operator><name>LJ_52</name></expr>;</return>  <comment type="block">/* Must be last in Lua 5.1. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_52</name></expr></cpp:if>
  <case>case <expr><literal type="char">';'</literal></expr>:</case>
    <expr_stmt><expr><call><name>lj_lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <case>case <expr><name>TK_label</name></expr>:</case>
    <expr_stmt><expr><call><name>parse_label</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  <case>case <expr><name>TK_goto</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>LJ_52</name> <operator>||</operator> <call><name>lj_lex_lookahead</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TK_name</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>lj_lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>parse_goto</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* fallthrough */</comment>
  <default>default:</default>
    <expr_stmt><expr><call><name>parse_call_assign</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  </block_content>}</block></switch>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* A chunk is a list of statements optionally separated by semicolons. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>parse_chunk</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>islast</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>synlevel_begin</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while <condition>(<expr><operator>!</operator><name>islast</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>parse_isend</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>tok</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>islast</name> <operator>=</operator> <call><name>parse_stmt</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lex_opt</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">';'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name><operator>-&gt;</operator><name>framesize</name></name> <operator>&gt;=</operator> <name><name>ls</name><operator>-&gt;</operator><name>fs</name><operator>-&gt;</operator><name>freereg</name></name> <operator>&amp;&amp;</operator>
	       <name><name>ls</name><operator>-&gt;</operator><name>fs</name><operator>-&gt;</operator><name>freereg</name></name> <operator>&gt;=</operator> <name><name>ls</name><operator>-&gt;</operator><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name><operator>-&gt;</operator><name>freereg</name></name> <operator>=</operator> <name><name>ls</name><operator>-&gt;</operator><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name></expr>;</expr_stmt>  <comment type="block">/* Free registers after each stmt. */</comment>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>synlevel_end</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Entry point of bytecode parser. */</comment>
<function><type><name>GCproto</name> <modifier>*</modifier></type><name>lj_parse</name><parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>FuncState</name></type> <name>fs</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FuncScope</name></type> <name>bl</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GCproto</name> <modifier>*</modifier></type><name>pt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LUAJIT_DISABLE_DEBUGINFO</name></cpp:ifdef>
  <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>chunkname</name></name> <operator>=</operator> <call><name>lj_str_newlit</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"="</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>chunkname</name></name> <operator>=</operator> <call><name>lj_str_newz</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>ls</name><operator>-&gt;</operator><name>chunkarg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>setstrV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>, <argument><expr><name><name>ls</name><operator>-&gt;</operator><name>chunkname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Anchor chunkname string. */</comment>
  <expr_stmt><expr><call><name>incr_top</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>level</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fs_init</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>.</operator><name>linedefined</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>.</operator><name>numparams</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>.</operator><name>bcbase</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>.</operator><name>bclim</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>.</operator><name>flags</name></name> <operator>|=</operator> <name>PROTO_VARARG</name></expr>;</expr_stmt>  <comment type="block">/* Main chunk is always a vararg func. */</comment>
  <expr_stmt><expr><call><name>fscope_begin</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>bcemit_AD</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fs</name></expr></argument>, <argument><expr><name>BC_FUNCV</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Placeholder. */</comment>
  <expr_stmt><expr><call><name>lj_lex_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Read-ahead first token. */</comment>
  <expr_stmt><expr><call><name>parse_chunk</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>tok</name></name> <operator>!=</operator> <name>TK_eof</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>err_token</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>TK_eof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pt</name> <operator>=</operator> <call><name>fs_finish</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name><name>ls</name><operator>-&gt;</operator><name>linenumber</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>--</operator></expr>;</expr_stmt>  <comment type="block">/* Drop chunkname. */</comment>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>fs</name><operator>.</operator><name>prev</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>pt</name><operator>-&gt;</operator><name>sizeuv</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pt</name></expr>;</return>
</block_content>}</block></function>

</unit>
