<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/sysbench/third_party/luajit/luajit/src/lj_opt_split.c"><comment type="block">/*
** SPLIT: Split 64 bit IR instructions into 32 bit IR instructions.
** Copyright (C) 2005-2020 Mike Pall. See Copyright Notice in luajit.h
*/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lj_opt_split_c</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUA_CORE</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_obj.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASJIT</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>LJ_SOFTFP32</name> <operator>||</operator> <operator>(</operator><name>LJ_32</name> <operator>&amp;&amp;</operator> <name>LJ_HASFFI</name><operator>)</operator><operator>)</operator></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_err.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_buf.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_ir.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_jit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_ircall.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_iropt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_dispatch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_vm.h"</cpp:file></cpp:include>

<comment type="block">/* SPLIT pass:
**
** This pass splits up 64 bit IR instructions into multiple 32 bit IR
** instructions. It's only active for soft-float targets or for 32 bit CPUs
** which lack native 64 bit integer operations (the FFI is currently the
** only emitter for 64 bit integer instructions).
**
** Splitting the IR in a separate pass keeps each 32 bit IR assembler
** backend simple. Only a small amount of extra functionality needs to be
** implemented. This is much easier than adding support for allocating
** register pairs to each backend (believe me, I tried). A few simple, but
** important optimizations can be performed by the SPLIT pass, which would
** be tedious to do in the backend.
**
** The basic idea is to replace each 64 bit IR instruction with its 32 bit
** equivalent plus an extra HIOP instruction. The splitted IR is not passed
** through FOLD or any other optimizations, so each HIOP is guaranteed to
** immediately follow it's counterpart. The actual functionality of HIOP is
** inferred from the previous instruction.
**
** The operands of HIOP hold the hiword input references. The output of HIOP
** is the hiword output reference, which is also used to hold the hiword
** register or spill slot information. The register allocator treats this
** instruction independently of any other instruction, which improves code
** quality compared to using fixed register pairs.
**
** It's easier to split up some instructions into two regular 32 bit
** instructions. E.g. XLOAD is split up into two XLOADs with two different
** addresses. Obviously 64 bit constants need to be split up into two 32 bit
** constants, too. Some hiword instructions can be entirely omitted, e.g.
** when zero-extending a 32 bit value to 64 bits. 64 bit arguments for calls
** are split up into two 32 bit arguments each.
**
** On soft-float targets, floating-point instructions are directly converted
** to soft-float calls by the SPLIT pass (except for comparisons and MIN/MAX).
** HIOP for number results has the type IRT_SOFTFP ("sfp" in -jdump).
**
** Here's the IR and x64 machine code for 'x.b = x.a + 1' for a struct with
** two int64_t fields:
**
** 0100    p32 ADD    base  +8
** 0101    i64 XLOAD  0100
** 0102    i64 ADD    0101  +1
** 0103    p32 ADD    base  +16
** 0104    i64 XSTORE 0103  0102
**
**         mov rax, [esi+0x8]
**         add rax, +0x01
**         mov [esi+0x10], rax
**
** Here's the transformed IR and the x86 machine code after the SPLIT pass:
**
** 0100    p32 ADD    base  +8
** 0101    int XLOAD  0100
** 0102    p32 ADD    base  +12
** 0103    int XLOAD  0102
** 0104    int ADD    0101  +1
** 0105    int HIOP   0103  +0
** 0106    p32 ADD    base  +16
** 0107    int XSTORE 0106  0104
** 0108    int HIOP   0106  0105
**
**         mov eax, [esi+0x8]
**         mov ecx, [esi+0xc]
**         add eax, +0x01
**         adc ecx, +0x00
**         mov [esi+0x10], eax
**         mov [esi+0x14], ecx
**
** You may notice the reassociated hiword address computation, which is
** later fused into the mov operands by the assembler.
*/</comment>

<comment type="block">/* Some local macros to save typing. Undef'd at the end. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IR</name><parameter_list>(<parameter><type><name>ref</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>(&amp;J-&gt;cur.ir[(ref)])</cpp:value></cpp:define>

<comment type="block">/* Directly emit the transformed IR without updating chains etc. */</comment>
<function><type><specifier>static</specifier> <name>IRRef</name></type> <name>split_emit</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>ot</name></decl></parameter>, <parameter><decl><type><name>IRRef1</name></type> <name>op1</name></decl></parameter>, <parameter><decl><type><name>IRRef1</name></type> <name>op2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>IRRef</name></type> <name>nref</name> <init>= <expr><call><name>lj_ir_nextins</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name>nref</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>ot</name></name> <operator>=</operator> <name>ot</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name> <operator>=</operator> <name>op1</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <name>op2</name></expr>;</expr_stmt>
  <return>return <expr><name>nref</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_SOFTFP</name></expr></cpp:if>
<comment type="block">/* Emit a (checked) number to integer conversion. */</comment>
<function><type><specifier>static</specifier> <name>IRRef</name></type> <name>split_num2int</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>IRRef</name></type> <name>lo</name></decl></parameter>, <parameter><decl><type><name>IRRef</name></type> <name>hi</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>check</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>IRRef</name></type> <name>tmp</name></decl>, <decl><type ref="prev"/><name>res</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_LE</name></expr></cpp:if>
  <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_CARG</name></expr></argument>, <argument><expr><name>IRT_NIL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lo</name></expr></argument>, <argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_CARG</name></expr></argument>, <argument><expr><name>IRT_NIL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>hi</name></expr></argument>, <argument><expr><name>lo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_CALLN</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>IRCALL_softfp_d2i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>check</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_CALLN</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>IRCALL_softfp_i2d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_HIOP</name></expr></argument>, <argument><expr><name>IRT_SOFTFP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRTGI</name><argument_list>(<argument><expr><name>IR_EQ</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>lo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_HIOP</name></expr></argument>, <argument><expr><name>IRT_SOFTFP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tmp</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Emit a CALLN with one split 64 bit argument. */</comment>
<function><type><specifier>static</specifier> <name>IRRef</name></type> <name>split_call_l</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>IRRef1</name> <modifier>*</modifier></type><name>hisubst</name></decl></parameter>, <parameter><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>oir</name></decl></parameter>,
			  <parameter><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name></decl></parameter>, <parameter><decl><type><name>IRCallID</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>IRRef</name></type> <name>tmp</name></decl>, <decl><type ref="prev"/><name>op1</name> <init>= <expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nins</name></name><operator>--</operator></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_LE</name></expr></cpp:if>
  <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_CARG</name></expr></argument>, <argument><expr><name>IRT_NIL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>oir</name><index>[<expr><name>op1</name></expr>]</index></name><operator>.</operator><name>prev</name></expr></argument>, <argument><expr><name><name>hisubst</name><index>[<expr><name>op1</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_CARG</name></expr></argument>, <argument><expr><name>IRT_NIL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>hisubst</name><index>[<expr><name>op1</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>oir</name><index>[<expr><name>op1</name></expr>]</index></name><operator>.</operator><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>tmp</name> <operator>=</operator> <call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_CALLN</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_HIOP</name></expr></argument>, <argument><expr><name>IRT_SOFTFP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Emit a CALLN with one split 64 bit argument and a 32 bit argument. */</comment>
<function><type><specifier>static</specifier> <name>IRRef</name></type> <name>split_call_li</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>IRRef1</name> <modifier>*</modifier></type><name>hisubst</name></decl></parameter>, <parameter><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>oir</name></decl></parameter>,
			   <parameter><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name></decl></parameter>, <parameter><decl><type><name>IRCallID</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>IRRef</name></type> <name>tmp</name></decl>, <decl><type ref="prev"/><name>op1</name> <init>= <expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr></init></decl>, <decl><type ref="prev"/><name>op2</name> <init>= <expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nins</name></name><operator>--</operator></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_LE</name></expr></cpp:if>
  <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_CARG</name></expr></argument>, <argument><expr><name>IRT_NIL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>oir</name><index>[<expr><name>op1</name></expr>]</index></name><operator>.</operator><name>prev</name></expr></argument>, <argument><expr><name><name>hisubst</name><index>[<expr><name>op1</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_CARG</name></expr></argument>, <argument><expr><name>IRT_NIL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>hisubst</name><index>[<expr><name>op1</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>oir</name><index>[<expr><name>op1</name></expr>]</index></name><operator>.</operator><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_CARG</name></expr></argument>, <argument><expr><name>IRT_NIL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name><name>oir</name><index>[<expr><name>op2</name></expr>]</index></name><operator>.</operator><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>tmp</name> <operator>=</operator> <call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_CALLN</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_HIOP</name></expr></argument>, <argument><expr><name>IRT_SOFTFP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Emit a CALLN with two split 64 bit arguments. */</comment>
<function><type><specifier>static</specifier> <name>IRRef</name></type> <name>split_call_ll</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>IRRef1</name> <modifier>*</modifier></type><name>hisubst</name></decl></parameter>, <parameter><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>oir</name></decl></parameter>,
			   <parameter><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name></decl></parameter>, <parameter><decl><type><name>IRCallID</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>IRRef</name></type> <name>tmp</name></decl>, <decl><type ref="prev"/><name>op1</name> <init>= <expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr></init></decl>, <decl><type ref="prev"/><name>op2</name> <init>= <expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nins</name></name><operator>--</operator></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_LE</name></expr></cpp:if>
  <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_CARG</name></expr></argument>, <argument><expr><name>IRT_NIL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>oir</name><index>[<expr><name>op1</name></expr>]</index></name><operator>.</operator><name>prev</name></expr></argument>, <argument><expr><name><name>hisubst</name><index>[<expr><name>op1</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_CARG</name></expr></argument>, <argument><expr><name>IRT_NIL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name><name>oir</name><index>[<expr><name>op2</name></expr>]</index></name><operator>.</operator><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_CARG</name></expr></argument>, <argument><expr><name>IRT_NIL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name><name>hisubst</name><index>[<expr><name>op2</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_CARG</name></expr></argument>, <argument><expr><name>IRT_NIL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>hisubst</name><index>[<expr><name>op1</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>oir</name><index>[<expr><name>op1</name></expr>]</index></name><operator>.</operator><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_CARG</name></expr></argument>, <argument><expr><name>IRT_NIL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name><name>hisubst</name><index>[<expr><name>op2</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_CARG</name></expr></argument>, <argument><expr><name>IRT_NIL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name><name>oir</name><index>[<expr><name>op2</name></expr>]</index></name><operator>.</operator><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>tmp</name> <operator>=</operator> <call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_CALLN</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>,
    <argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_HIOP</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>LJ_SOFTFP</name> <operator>&amp;&amp;</operator> <call><name>irt_isnum</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr> ?</condition><then> <expr><name>IRT_SOFTFP</name></expr> </then><else>: <expr><name>IRT_INT</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>,
    <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Get a pointer to the other 32 bit word (LE: hiword, BE: loword). */</comment>
<function><type><specifier>static</specifier> <name>IRRef</name></type> <name>split_ptr</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>oir</name></decl></parameter>, <parameter><decl><type><name>IRRef</name></type> <name>ref</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>IRRef</name></type> <name>nref</name> <init>= <expr><name><name>oir</name><index>[<expr><name>ref</name></expr>]</index></name><operator>.</operator><name>prev</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name>nref</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>ofs</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_KPTR</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>lj_ir_kptr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>ir_kptr</name><argument_list>(<argument><expr><name>ir</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>ofs</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_ADD</name> <operator>&amp;&amp;</operator> <call><name>irref_isk</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>irt_isphi</name><argument_list>(<argument><expr><name><name>oir</name><index>[<expr><name>ref</name></expr>]</index></name><operator>.</operator><name>t</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <comment type="block">/* Reassociate address. */</comment>
    <expr_stmt><expr><name>ofs</name> <operator>+=</operator> <call><name>IR</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>i</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nref</name> <operator>=</operator> <name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ofs</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>nref</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_ADD</name></expr></argument>, <argument><expr><name>IRT_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nref</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ofs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>
<function><type><specifier>static</specifier> <name>IRRef</name></type> <name>split_bitshift</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>IRRef1</name> <modifier>*</modifier></type><name>hisubst</name></decl></parameter>,
			    <parameter><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>oir</name></decl></parameter>, <parameter><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>nir</name></decl></parameter>, <parameter><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>IROp</name></type> <name>op</name> <init>= <expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IRRef</name></type> <name>kref</name> <init>= <expr><name><name>nir</name><operator>-&gt;</operator><name>op2</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>irref_isk</name><argument_list>(<argument><expr><name>kref</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Optimize constant shifts. */</comment>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>k</name> <init>= <expr><operator>(</operator><call><name>IR</name><argument_list>(<argument><expr><name>kref</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>i</name> <operator>&amp;</operator> <literal type="number">63</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IRRef</name></type> <name>lo</name> <init>= <expr><name><name>nir</name><operator>-&gt;</operator><name>op1</name></name></expr></init></decl>, <decl><type ref="prev"/><name>hi</name> <init>= <expr><name><name>hisubst</name><index>[<expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>IR_BROL</name> <operator>||</operator> <name>op</name> <operator>==</operator> <name>IR_BROR</name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>IR_BROR</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>k</name> <operator>=</operator> <operator>(</operator><operator>-</operator><name>k</name> <operator>&amp;</operator> <literal type="number">63</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>k</name> <operator>&gt;=</operator> <literal type="number">32</literal></expr>)</condition> <block>{<block_content> <decl_stmt><decl><type><name>IRRef</name></type> <name>t</name> <init>= <expr><name>lo</name></expr></init></decl>;</decl_stmt> <expr_stmt><expr><name>lo</name> <operator>=</operator> <name>hi</name></expr>;</expr_stmt> <expr_stmt><expr><name>hi</name> <operator>=</operator> <name>t</name></expr>;</expr_stmt> <expr_stmt><expr><name>k</name> <operator>-=</operator> <literal type="number">32</literal></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>k</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <label><name>passthrough</name>:</label>
	<expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nins</name></name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>lo</name></expr>;</expr_stmt>
	<return>return <expr><name>hi</name></expr>;</return>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<decl_stmt><decl><type><name>TRef</name></type> <name>k1</name></decl>, <decl><type ref="prev"/><name>k2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IRRef</name></type> <name>t1</name></decl>, <decl><type ref="prev"/><name>t2</name></decl>, <decl><type ref="prev"/><name>t3</name></decl>, <decl><type ref="prev"/><name>t4</name></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nins</name></name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>k1</name> <operator>=</operator> <call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>k2</name> <operator>=</operator> <call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>(</operator><operator>-</operator><name>k</name> <operator>&amp;</operator> <literal type="number">31</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>t1</name> <operator>=</operator> <call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_BSHL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lo</name></expr></argument>, <argument><expr><name>k1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>t2</name> <operator>=</operator> <call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_BSHL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>hi</name></expr></argument>, <argument><expr><name>k1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>t3</name> <operator>=</operator> <call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_BSHR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lo</name></expr></argument>, <argument><expr><name>k2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>t4</name> <operator>=</operator> <call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_BSHR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>hi</name></expr></argument>, <argument><expr><name>k2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_BOR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_BOR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>t2</name></expr></argument>, <argument><expr><name>t3</name></expr></argument>)</argument_list></call></expr>;</return>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>k</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <goto>goto <name>passthrough</name>;</goto>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>k</name> <operator>&lt;</operator> <literal type="number">32</literal></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>IR_BSHL</name></expr>)</condition> <block>{<block_content>
	<decl_stmt><decl><type><name>IRRef</name></type> <name>t1</name> <init>= <expr><call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_BSHL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>hi</name></expr></argument>, <argument><expr><name>kref</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IRRef</name></type> <name>t2</name> <init>= <expr><call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_BSHR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lo</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>(</operator><operator>-</operator><name>k</name><operator>&amp;</operator><literal type="number">31</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_BOR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</return>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<decl_stmt><decl><type><name>IRRef</name></type> <name>t1</name> <init>= <expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name></expr></init></decl>, <decl><type ref="prev"/><name>t2</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>op</name> <operator>==</operator> <name>IR_BSHR</name> <operator>||</operator> <name>op</name> <operator>==</operator> <name>IR_BSAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nir</name><operator>-&gt;</operator><name>o</name></name> <operator>=</operator> <name>IR_BSHR</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>t2</name> <operator>=</operator> <call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_BSHL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>hi</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>(</operator><operator>-</operator><name>k</name><operator>&amp;</operator><literal type="number">31</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_BOR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>hi</name></expr></argument>, <argument><expr><name>kref</name></expr></argument>)</argument_list></call></expr>;</return>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>IR_BSHL</name></expr>)</condition> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>k</name> <operator>==</operator> <literal type="number">32</literal></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nins</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
	  <expr_stmt><expr><name>lo</name> <operator>=</operator> <name><name>ir</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>lo</name></expr>;</return>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>op</name> <operator>==</operator> <name>IR_BSHR</name> <operator>||</operator> <name>op</name> <operator>==</operator> <name>IR_BSAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>k</name> <operator>==</operator> <literal type="number">32</literal></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nins</name></name><operator>--</operator></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>hi</name></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
	  <expr_stmt><expr><name><name>nir</name><operator>-&gt;</operator><name>op1</name></name> <operator>=</operator> <name>hi</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>IR_BSHR</name></expr>)</condition><block type="pseudo"><block_content>
	  <return>return <expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
	  <return>return <expr><call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_BSAR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>hi</name></expr></argument>, <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><literal type="number">31</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>split_call_li</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>hisubst</name></expr></argument>, <argument><expr><name>oir</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>,
		       <argument><expr><name>op</name> <operator>-</operator> <name>IR_BSHL</name> <operator>+</operator> <name>IRCALL_lj_carith_shl64</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>IRRef</name></type> <name>split_bitop</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>IRRef1</name> <modifier>*</modifier></type><name>hisubst</name></decl></parameter>,
			 <parameter><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>nir</name></decl></parameter>, <parameter><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>IROp</name></type> <name>op</name> <init>= <expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IRRef</name></type> <name>hi</name></decl>, <decl><type ref="prev"/><name>kref</name> <init>= <expr><name><name>nir</name><operator>-&gt;</operator><name>op2</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>irref_isk</name><argument_list>(<argument><expr><name>kref</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Optimize bit operations with lo constant. */</comment>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>k</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name>kref</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>i</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>k</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>k</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>IR_BAND</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>k</name> <operator>=</operator> <operator>~</operator><name>k</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>k</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nins</name></name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name><name>nir</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>op</name> <operator>==</operator> <name>IR_BXOR</name></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name><name>nir</name><operator>-&gt;</operator><name>o</name></name> <operator>=</operator> <name>IR_BNOT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nir</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nins</name></name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>kref</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>hi</name> <operator>=</operator> <name><name>hisubst</name><index>[<expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>kref</name> <operator>=</operator> <name><name>hisubst</name><index>[<expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>irref_isk</name><argument_list>(<argument><expr><name>kref</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Optimize bit operations with hi constant. */</comment>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>k</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name>kref</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>i</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>k</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>k</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>IR_BAND</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>k</name> <operator>=</operator> <operator>~</operator><name>k</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>k</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
	<return>return <expr><name>hi</name></expr>;</return>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>op</name> <operator>==</operator> <name>IR_BXOR</name></expr>)</condition> <block>{<block_content>
	<return>return <expr><call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_BNOT</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>hi</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<return>return <expr><name>kref</name></expr>;</return>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>hi</name></expr></argument>, <argument><expr><name>kref</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Substitute references of a snapshot. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>split_subst_snap</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>SnapShot</name> <modifier>*</modifier></type><name>snap</name></decl></parameter>, <parameter><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>oir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>SnapEntry</name> <modifier>*</modifier></type><name>map</name> <init>= <expr><operator>&amp;</operator><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>snapmap</name><index>[<expr><name><name>snap</name><operator>-&gt;</operator><name>mapofs</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MSize</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>nent</name> <init>= <expr><name><name>snap</name><operator>-&gt;</operator><name>nent</name></name></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name>nent</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>SnapEntry</name></type> <name>sn</name> <init>= <expr><name><name>map</name><index>[<expr><name>n</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name> <init>= <expr><operator>&amp;</operator><name><name>oir</name><index>[<expr><call><name>snap_ref</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>LJ_SOFTFP</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>sn</name> <operator>&amp;</operator> <name>SNAP_SOFTFPNUM</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>irref_isk</name><argument_list>(<argument><expr><call><name>snap_ref</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>map</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>sn</name> <operator>&amp;</operator> <literal type="number">0xffff0000</literal><operator>)</operator> <operator>|</operator> <name><name>ir</name><operator>-&gt;</operator><name>prev</name></name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* Transform the old IR to the new IR. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>split_ir</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>IRRef</name></type> <name>nins</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nins</name></name></expr></init></decl>, <decl><type ref="prev"/><name>nk</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nk</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MSize</name></type> <name>irlen</name> <init>= <expr><name>nins</name> <operator>-</operator> <name>nk</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MSize</name></type> <name>need</name> <init>= <expr><operator>(</operator><name>irlen</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>IRIns</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>IRRef1</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>oir</name> <init>= <expr><operator>(</operator><name>IRIns</name> <operator>*</operator><operator>)</operator><call><name>lj_buf_tmp</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>need</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IRRef1</name> <modifier>*</modifier></type><name>hisubst</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IRRef</name></type> <name>ref</name></decl>, <decl><type ref="prev"/><name>snref</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SnapShot</name> <modifier>*</modifier></type><name>snap</name></decl>;</decl_stmt>

  <comment type="block">/* Copy old IR to buffer. */</comment>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>oir</name></expr></argument>, <argument><expr><call><name>IR</name><argument_list>(<argument><expr><name>nk</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>irlen</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>IRIns</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Bias hiword substitution table and old IR. Loword kept in field prev. */</comment>
  <expr_stmt><expr><name>hisubst</name> <operator>=</operator> <operator>(</operator><name>IRRef1</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>oir</name><index>[<expr><name>irlen</name></expr>]</index></name> <operator>-</operator> <name>nk</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>oir</name> <operator>-=</operator> <name>nk</name></expr>;</expr_stmt>

  <comment type="block">/* Remove all IR instructions, but retain IR constants. */</comment>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nins</name></name> <operator>=</operator> <name>REF_FIRST</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>loopref</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <comment type="block">/* Process constants and fixed references. */</comment>
  <for>for <control>(<init><expr><name>ref</name> <operator>=</operator> <name>nk</name></expr>;</init> <condition><expr><name>ref</name> <operator>&lt;=</operator> <name>REF_BASE</name></expr>;</condition> <incr><expr><name>ref</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name> <init>= <expr><operator>&amp;</operator><name><name>oir</name><index>[<expr><name>ref</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>LJ_SOFTFP</name> <operator>&amp;&amp;</operator> <name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_KNUM</name><operator>)</operator> <operator>||</operator> <name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_KINT64</name></expr>)</condition> <block>{<block_content>
      <comment type="block">/* Split up 64 bit constant. */</comment>
      <decl_stmt><decl><type><name>TValue</name></type> <name>tv</name> <init>= <expr><operator>*</operator><call><name>ir_k64</name><argument_list>(<argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><name><name>tv</name><operator>.</operator><name>u32</name><operator>.</operator><name>lo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hisubst</name><index>[<expr><name>ref</name></expr>]</index></name> <operator>=</operator> <call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><name><name>tv</name><operator>.</operator><name>u32</name><operator>.</operator><name>hi</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>ref</name></expr>;</expr_stmt>  <comment type="block">/* Identity substitution for loword. */</comment>
      <expr_stmt><expr><name><name>hisubst</name><index>[<expr><name>ref</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>irt_is64</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>!=</operator> <name>IR_KNULL</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>ref</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Process old IR instructions. */</comment>
  <expr_stmt><expr><name>snap</name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>snap</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>snref</name> <operator>=</operator> <name><name>snap</name><operator>-&gt;</operator><name>ref</name></name></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>ref</name> <operator>=</operator> <name>REF_FIRST</name></expr>;</init> <condition><expr><name>ref</name> <operator>&lt;</operator> <name>nins</name></expr>;</condition> <incr><expr><name>ref</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name> <init>= <expr><operator>&amp;</operator><name><name>oir</name><index>[<expr><name>ref</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IRRef</name></type> <name>nref</name> <init>= <expr><call><name>lj_ir_nextins</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>nir</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name>nref</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IRRef</name></type> <name>hi</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>ref</name> <operator>&gt;=</operator> <name>snref</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>snap</name><operator>-&gt;</operator><name>ref</name></name> <operator>=</operator> <name>nref</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>split_subst_snap</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>snap</name><operator>++</operator></expr></argument>, <argument><expr><name>oir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>snref</name> <operator>=</operator> <ternary><condition><expr><name>snap</name> <operator>&lt;</operator> <operator>&amp;</operator><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>snap</name><index>[<expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nsnap</name></name></expr>]</index></name></expr> ?</condition><then> <expr><name><name>snap</name><operator>-&gt;</operator><name>ref</name></name></expr> </then><else>: <expr><operator>~</operator><operator>(</operator><name>IRRef</name><operator>)</operator><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Copy-substitute old instruction to new instruction. */</comment>
    <expr_stmt><expr><name><name>nir</name><operator>-&gt;</operator><name>op1</name></name> <operator>=</operator> <ternary><condition><expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name> <operator>&lt;</operator> <name>nk</name></expr> ?</condition><then> <expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr> </then><else>: <expr><name><name>oir</name><index>[<expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr>]</index></name><operator>.</operator><name>prev</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>nir</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <ternary><condition><expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name> <operator>&lt;</operator> <name>nk</name></expr> ?</condition><then> <expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr> </then><else>: <expr><name><name>oir</name><index>[<expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr>]</index></name><operator>.</operator><name>prev</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>nref</name></expr>;</expr_stmt>  <comment type="block">/* Loword substitution. */</comment>
    <expr_stmt><expr><name><name>nir</name><operator>-&gt;</operator><name>o</name></name> <operator>=</operator> <name><name>ir</name><operator>-&gt;</operator><name>o</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>nir</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>irt</name></name> <operator>=</operator> <name><name>ir</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>irt</name></name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>IRT_MARK</name><operator>|</operator><name>IRT_ISPHI</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hisubst</name><index>[<expr><name>ref</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/* Split 64 bit instructions. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_SOFTFP</name></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><call><name>irt_isnum</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>nir</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>irt</name></name> <operator>=</operator> <name>IRT_INT</name> <operator>|</operator> <operator>(</operator><name><name>nir</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>irt</name></name> <operator>&amp;</operator> <name>IRT_GUARD</name><operator>)</operator></expr>;</expr_stmt>  <comment type="block">/* Turn into INT op. */</comment>
      <comment type="block">/* Note: hi ref = lo ref + 1! Required for SNAP_SOFTFPNUM logic. */</comment>
      <switch>switch <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name></expr>)</condition> <block>{<block_content>
      <case>case <expr><name>IR_ADD</name></expr>:</case>
	<expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>split_call_ll</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>hisubst</name></expr></argument>, <argument><expr><name>oir</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><name>IRCALL_softfp_add</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
      <case>case <expr><name>IR_SUB</name></expr>:</case>
	<expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>split_call_ll</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>hisubst</name></expr></argument>, <argument><expr><name>oir</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><name>IRCALL_softfp_sub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
      <case>case <expr><name>IR_MUL</name></expr>:</case>
	<expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>split_call_ll</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>hisubst</name></expr></argument>, <argument><expr><name>oir</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><name>IRCALL_softfp_mul</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
      <case>case <expr><name>IR_DIV</name></expr>:</case>
	<expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>split_call_ll</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>hisubst</name></expr></argument>, <argument><expr><name>oir</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><name>IRCALL_softfp_div</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
      <case>case <expr><name>IR_POW</name></expr>:</case>
	<expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>split_call_li</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>hisubst</name></expr></argument>, <argument><expr><name>oir</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><name>IRCALL_lj_vm_powi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
      <case>case <expr><name>IR_FPMATH</name></expr>:</case>
	<expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>split_call_l</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>hisubst</name></expr></argument>, <argument><expr><name>oir</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><name>IRCALL_lj_vm_floor</name> <operator>+</operator> <name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
      <case>case <expr><name>IR_LDEXP</name></expr>:</case>
	<expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>split_call_li</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>hisubst</name></expr></argument>, <argument><expr><name>oir</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><name>IRCALL_ldexp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
      <case>case <expr><name>IR_NEG</name></expr>:</case> <case>case <expr><name>IR_ABS</name></expr>:</case>
	<expr_stmt><expr><name><name>nir</name><operator>-&gt;</operator><name>o</name></name> <operator>=</operator> <name>IR_CONV</name></expr>;</expr_stmt>  <comment type="block">/* Pass through loword. */</comment>
	<expr_stmt><expr><name><name>nir</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <operator>(</operator><name>IRT_INT</name> <operator>&lt;&lt;</operator> <literal type="number">5</literal><operator>)</operator> <operator>|</operator> <name>IRT_INT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRT</name><argument_list>(<argument><expr><ternary><condition><expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_NEG</name></expr> ?</condition><then> <expr><name>IR_BXOR</name></expr> </then><else>: <expr><name>IR_BAND</name></expr></else></ternary></expr></argument>, <argument><expr><name>IRT_SOFTFP</name></expr></argument>)</argument_list></call></expr></argument>,
	       <argument><expr><name><name>hisubst</name><index>[<expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr>]</index></name></expr></argument>,
	       <argument><expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><operator>(</operator><literal type="number">0x7fffffffu</literal> <operator>+</operator> <operator>(</operator><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_NEG</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
      <case>case <expr><name>IR_SLOAD</name></expr>:</case>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>nir</name><operator>-&gt;</operator><name>op2</name></name> <operator>&amp;</operator> <name>IRSLOAD_CONVERT</name><operator>)</operator></expr>)</condition> <block>{<block_content>  <comment type="block">/* Convert from int to number. */</comment>
	  <expr_stmt><expr><name><name>nir</name><operator>-&gt;</operator><name>op2</name></name> <operator>&amp;=</operator> <operator>~</operator><name>IRSLOAD_CONVERT</name></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>nref</name> <operator>=</operator> <call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_CALLN</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nref</name></expr></argument>,
				       <argument><expr><name>IRCALL_softfp_i2d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_HIOP</name></expr></argument>, <argument><expr><name>IRT_SOFTFP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nref</name></expr></argument>, <argument><expr><name>nref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <break>break;</break>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* fallthrough */</comment>
      <case>case <expr><name>IR_ALOAD</name></expr>:</case> <case>case <expr><name>IR_HLOAD</name></expr>:</case> <case>case <expr><name>IR_ULOAD</name></expr>:</case> <case>case <expr><name>IR_VLOAD</name></expr>:</case>
      <case>case <expr><name>IR_STRTO</name></expr>:</case>
	<expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_HIOP</name></expr></argument>, <argument><expr><name>IRT_SOFTFP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nref</name></expr></argument>, <argument><expr><name>nref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
      <case>case <expr><name>IR_FLOAD</name></expr>:</case>
	<expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name> <operator>==</operator> <name>REF_NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><name>int32_t</name><operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>J2GG</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>ir</name><operator>-&gt;</operator><name>op2</name></name> <operator>+</operator> <name>LJ_LE</name><operator>*</operator><literal type="number">4</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nir</name><operator>-&gt;</operator><name>op2</name></name> <operator>+=</operator> <name>LJ_BE</name><operator>*</operator><literal type="number">4</literal></expr>;</expr_stmt>
	<break>break;</break>
      <case>case <expr><name>IR_XLOAD</name></expr>:</case> <block>{<block_content>
	<decl_stmt><decl><type><name>IRIns</name></type> <name>inslo</name> <init>= <expr><operator>*</operator><name>nir</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* Save/undo the emit of the lo XLOAD. */</comment>
	<expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nins</name></name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>split_ptr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>oir</name></expr></argument>, <argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Insert the hiref ADD. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_BE</name></expr></cpp:if>
	<expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_XLOAD</name></expr></argument>, <argument><expr><name>IRT_INT</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>hi</name></expr></argument>, <argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>inslo</name><operator>.</operator><name>t</name><operator>.</operator><name>irt</name></name> <operator>=</operator> <name>IRT_SOFTFP</name> <operator>|</operator> <operator>(</operator><name><name>inslo</name><operator>.</operator><name>t</name><operator>.</operator><name>irt</name></name> <operator>&amp;</operator> <name>IRT_GUARD</name><operator>)</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name>nref</name> <operator>=</operator> <call><name>lj_ir_nextins</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nir</name> <operator>=</operator> <call><name>IR</name><argument_list>(<argument><expr><name>nref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>nir</name> <operator>=</operator> <name>inslo</name></expr>;</expr_stmt>  <comment type="block">/* Re-emit lo XLOAD. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_LE</name></expr></cpp:if>
	<expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_XLOAD</name></expr></argument>, <argument><expr><name>IRT_SOFTFP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>hi</name></expr></argument>, <argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>nref</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>hi</name></expr>;</expr_stmt> <expr_stmt><expr><name>hi</name> <operator>=</operator> <name>nref</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<break>break;</break>
	</block_content>}</block>
      <case>case <expr><name>IR_ASTORE</name></expr>:</case> <case>case <expr><name>IR_HSTORE</name></expr>:</case> <case>case <expr><name>IR_USTORE</name></expr>:</case> <case>case <expr><name>IR_XSTORE</name></expr>:</case>
	<expr_stmt><expr><call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_HIOP</name></expr></argument>, <argument><expr><name>IRT_SOFTFP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>nir</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>, <argument><expr><name><name>hisubst</name><index>[<expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
      <case>case <expr><name>IR_CONV</name></expr>:</case> <block>{<block_content>  <comment type="block">/* Conversion to number. Others handled below. */</comment>
	<decl_stmt><decl><type><name>IRType</name></type> <name>st</name> <init>= <expr><operator>(</operator><name>IRType</name><operator>)</operator><operator>(</operator><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name> <operator>&amp;</operator> <name>IRCONV_SRCMASK</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_32</name> <operator>&amp;&amp;</operator> <name>LJ_HASFFI</name></expr></cpp:if>
	<if_stmt><if>if <condition>(<expr><name>st</name> <operator>==</operator> <name>IRT_I64</name> <operator>||</operator> <name>st</name> <operator>==</operator> <name>IRT_U64</name></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>split_call_l</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>hisubst</name></expr></argument>, <argument><expr><name>oir</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>,
		 <argument><expr><ternary><condition><expr><name>st</name> <operator>==</operator> <name>IRT_I64</name></expr> ?</condition><then> <expr><name>IRCALL_fp64_l2d</name></expr> </then><else>: <expr><name>IRCALL_fp64_ul2d</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <break>break;</break>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>st</name> <operator>==</operator> <name>IRT_INT</name> <operator>||</operator>
		   <operator>(</operator><name>LJ_32</name> <operator>&amp;&amp;</operator> <name>LJ_HASFFI</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>st</name> <operator>==</operator> <name>IRT_U32</name> <operator>||</operator> <name>st</name> <operator>==</operator> <name>IRT_FLOAT</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nir</name><operator>-&gt;</operator><name>o</name></name> <operator>=</operator> <name>IR_CALLN</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_32</name> <operator>&amp;&amp;</operator> <name>LJ_HASFFI</name></expr></cpp:if>
	<expr_stmt><expr><name><name>nir</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <ternary><condition><expr><name>st</name> <operator>==</operator> <name>IRT_INT</name></expr> ?</condition><then> <expr><name>IRCALL_softfp_i2d</name></expr> </then><else>:
		   <expr><ternary><condition><expr><name>st</name> <operator>==</operator> <name>IRT_FLOAT</name></expr> ?</condition><then> <expr><name>IRCALL_softfp_f2d</name></expr> </then><else>:
		   <expr><name>IRCALL_softfp_ui2d</name></expr></else></ternary></expr></else></ternary></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name><name>nir</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <name>IRCALL_softfp_i2d</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_HIOP</name></expr></argument>, <argument><expr><name>IRT_SOFTFP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nref</name></expr></argument>, <argument><expr><name>nref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
	</block_content>}</block>
      <case>case <expr><name>IR_CALLN</name></expr>:</case>
      <case>case <expr><name>IR_CALLL</name></expr>:</case>
      <case>case <expr><name>IR_CALLS</name></expr>:</case>
      <case>case <expr><name>IR_CALLXS</name></expr>:</case>
	<goto>goto <name>split_call</name>;</goto>
      <case>case <expr><name>IR_PHI</name></expr>:</case>
	<if_stmt><if>if <condition>(<expr><name><name>nir</name><operator>-&gt;</operator><name>op1</name></name> <operator>==</operator> <name><name>nir</name><operator>-&gt;</operator><name>op2</name></name></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nins</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Drop useless PHIs. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>hisubst</name><index>[<expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr>]</index></name> <operator>!=</operator> <name><name>hisubst</name><index>[<expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_PHI</name></expr></argument>, <argument><expr><name>IRT_SOFTFP</name></expr></argument>)</argument_list></call></expr></argument>,
		     <argument><expr><name><name>hisubst</name><index>[<expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr>]</index></name></expr></argument>, <argument><expr><name><name>hisubst</name><index>[<expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<break>break;</break>
      <case>case <expr><name>IR_HIOP</name></expr>:</case>
	<expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nins</name></name><operator>--</operator></expr>;</expr_stmt>  <comment type="block">/* Drop joining HIOP. */</comment>
	<expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name><name>nir</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>hi</name> <operator>=</operator> <name><name>nir</name><operator>-&gt;</operator><name>op2</name></name></expr>;</expr_stmt>
	<break>break;</break>
      <default>default:</default>
	<expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>&lt;=</operator> <name>IR_NE</name> <operator>||</operator> <name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_MIN</name> <operator>||</operator> <name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_HIOP</name></expr></argument>, <argument><expr><name>IRT_SOFTFP</name></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><name><name>hisubst</name><index>[<expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr>]</index></name></expr></argument>, <argument><expr><name><name>hisubst</name><index>[<expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
      </block_content>}</block></switch>
    </block_content>}</block></if> <if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_32</name> <operator>&amp;&amp;</operator> <name>LJ_HASFFI</name></expr></cpp:if>
    if <condition>(<expr><call><name>irt_isint64</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>IRRef</name></type> <name>hiref</name> <init>= <expr><name><name>hisubst</name><index>[<expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>nir</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>irt</name></name> <operator>=</operator> <name>IRT_INT</name> <operator>|</operator> <operator>(</operator><name><name>nir</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>irt</name></name> <operator>&amp;</operator> <name>IRT_GUARD</name><operator>)</operator></expr>;</expr_stmt>  <comment type="block">/* Turn into INT op. */</comment>
      <switch>switch <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name></expr>)</condition> <block>{<block_content>
      <case>case <expr><name>IR_ADD</name></expr>:</case>
      <case>case <expr><name>IR_SUB</name></expr>:</case>
	<comment type="block">/* Use plain op for hiword if loword cannot produce a carry/borrow. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>irref_isk</name><argument_list>(<argument><expr><name><name>nir</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IR</name><argument_list>(<argument><expr><name><name>nir</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name><name>nir</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt>  <comment type="block">/* Pass through loword. */</comment>
	  <expr_stmt><expr><name><name>nir</name><operator>-&gt;</operator><name>op1</name></name> <operator>=</operator> <name>hiref</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>nir</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <name><name>hisubst</name><index>[<expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr>]</index></name></expr>;</expr_stmt>
	  <expr_stmt><expr><name>hi</name> <operator>=</operator> <name>nref</name></expr>;</expr_stmt>
	  <break>break;</break>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* fallthrough */</comment>
      <case>case <expr><name>IR_NEG</name></expr>:</case>
	<expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_HIOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>hiref</name></expr></argument>, <argument><expr><name><name>hisubst</name><index>[<expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
      <case>case <expr><name>IR_MUL</name></expr>:</case>
	<expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>split_call_ll</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>hisubst</name></expr></argument>, <argument><expr><name>oir</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><name>IRCALL_lj_carith_mul64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
      <case>case <expr><name>IR_DIV</name></expr>:</case>
	<expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>split_call_ll</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>hisubst</name></expr></argument>, <argument><expr><name>oir</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>,
			   <argument><expr><ternary><condition><expr><call><name>irt_isi64</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>IRCALL_lj_carith_divi64</name></expr> </then><else>:
					      <expr><name>IRCALL_lj_carith_divu64</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
      <case>case <expr><name>IR_MOD</name></expr>:</case>
	<expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>split_call_ll</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>hisubst</name></expr></argument>, <argument><expr><name>oir</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>,
			   <argument><expr><ternary><condition><expr><call><name>irt_isi64</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>IRCALL_lj_carith_modi64</name></expr> </then><else>:
					      <expr><name>IRCALL_lj_carith_modu64</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
      <case>case <expr><name>IR_POW</name></expr>:</case>
	<expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>split_call_ll</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>hisubst</name></expr></argument>, <argument><expr><name>oir</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>,
			   <argument><expr><ternary><condition><expr><call><name>irt_isi64</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>IRCALL_lj_carith_powi64</name></expr> </then><else>:
					      <expr><name>IRCALL_lj_carith_powu64</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
      <case>case <expr><name>IR_BNOT</name></expr>:</case>
	<expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_BNOT</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>hiref</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
      <case>case <expr><name>IR_BSWAP</name></expr>:</case>
	<expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_BSWAP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>hiref</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>hi</name> <operator>=</operator> <name>nref</name></expr>;</expr_stmt>
	<break>break;</break>
      <case>case <expr><name>IR_BAND</name></expr>:</case> <case>case <expr><name>IR_BOR</name></expr>:</case> <case>case <expr><name>IR_BXOR</name></expr>:</case>
	<expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>split_bitop</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>hisubst</name></expr></argument>, <argument><expr><name>nir</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
      <case>case <expr><name>IR_BSHL</name></expr>:</case> <case>case <expr><name>IR_BSHR</name></expr>:</case> <case>case <expr><name>IR_BSAR</name></expr>:</case> <case>case <expr><name>IR_BROL</name></expr>:</case> <case>case <expr><name>IR_BROR</name></expr>:</case>
	<expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>split_bitshift</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>hisubst</name></expr></argument>, <argument><expr><name>oir</name></expr></argument>, <argument><expr><name>nir</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
      <case>case <expr><name>IR_FLOAD</name></expr>:</case>
	<expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name> <operator>==</operator> <name>IRFL_CDATA_INT64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_FLOAD</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>nir</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>, <argument><expr><name>IRFL_CDATA_INT64_4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_BE</name></expr></cpp:if>
	<expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>hi</name></expr>;</expr_stmt> <expr_stmt><expr><name>hi</name> <operator>=</operator> <name>nref</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<break>break;</break>
      <case>case <expr><name>IR_XLOAD</name></expr>:</case>
	<expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_XLOAD</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>split_ptr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>oir</name></expr></argument>, <argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_BE</name></expr></cpp:if>
	<expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>hi</name></expr>;</expr_stmt> <expr_stmt><expr><name>hi</name> <operator>=</operator> <name>nref</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<break>break;</break>
      <case>case <expr><name>IR_XSTORE</name></expr>:</case>
	<expr_stmt><expr><call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_HIOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>nir</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>, <argument><expr><name><name>hisubst</name><index>[<expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
      <case>case <expr><name>IR_CONV</name></expr>:</case> <block>{<block_content>  <comment type="block">/* Conversion to 64 bit integer. Others handled below. */</comment>
	<decl_stmt><decl><type><name>IRType</name></type> <name>st</name> <init>= <expr><operator>(</operator><name>IRType</name><operator>)</operator><operator>(</operator><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name> <operator>&amp;</operator> <name>IRCONV_SRCMASK</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_SOFTFP</name></expr></cpp:if>
	<if_stmt><if>if <condition>(<expr><name>st</name> <operator>==</operator> <name>IRT_NUM</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* NUM to 64 bit int conv. */</comment>
	  <expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>split_call_l</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>hisubst</name></expr></argument>, <argument><expr><name>oir</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>,
		 <argument><expr><ternary><condition><expr><call><name>irt_isi64</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>IRCALL_fp64_d2l</name></expr> </then><else>: <expr><name>IRCALL_fp64_d2ul</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>st</name> <operator>==</operator> <name>IRT_FLOAT</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* FLOAT to 64 bit int conv. */</comment>
	  <expr_stmt><expr><name><name>nir</name><operator>-&gt;</operator><name>o</name></name> <operator>=</operator> <name>IR_CALLN</name></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>nir</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <ternary><condition><expr><call><name>irt_isi64</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>IRCALL_fp64_f2l</name></expr> </then><else>: <expr><name>IRCALL_fp64_f2ul</name></expr></else></ternary></expr>;</expr_stmt>
	  <expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_HIOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nref</name></expr></argument>, <argument><expr><name>nref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<if_stmt><if>if <condition>(<expr><name>st</name> <operator>==</operator> <name>IRT_NUM</name> <operator>||</operator> <name>st</name> <operator>==</operator> <name>IRT_FLOAT</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* FP to 64 bit int conv. */</comment>
	  <expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_HIOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>nir</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>, <argument><expr><name>nref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if type="elseif">else if <condition>(<expr><name>st</name> <operator>==</operator> <name>IRT_I64</name> <operator>||</operator> <name>st</name> <operator>==</operator> <name>IRT_U64</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* 64/64 bit cast. */</comment>
	  <comment type="block">/* Drop cast, since assembler doesn't care. But fwd both parts. */</comment>
	  <expr_stmt><expr><name>hi</name> <operator>=</operator> <name>hiref</name></expr>;</expr_stmt>
	  <goto>goto <name>fwdlo</name>;</goto>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name> <operator>&amp;</operator> <name>IRCONV_SEXT</name><operator>)</operator></expr>)</condition> <block>{<block_content>  <comment type="block">/* Sign-extend to 64 bit. */</comment>
	  <decl_stmt><decl><type><name>IRRef</name></type> <name>k31</name> <init>= <expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><literal type="number">31</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	  <expr_stmt><expr><name>nir</name> <operator>=</operator> <call><name>IR</name><argument_list>(<argument><expr><name>nref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* May have been reallocated. */</comment>
	  <expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name><name>nir</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt>  <comment type="block">/* Pass through loword. */</comment>
	  <expr_stmt><expr><name><name>nir</name><operator>-&gt;</operator><name>o</name></name> <operator>=</operator> <name>IR_BSAR</name></expr>;</expr_stmt>  <comment type="block">/* hi = bsar(lo, 31). */</comment>
	  <expr_stmt><expr><name><name>nir</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <name>k31</name></expr>;</expr_stmt>
	  <expr_stmt><expr><name>hi</name> <operator>=</operator> <name>nref</name></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* Zero-extend to 64 bit. */</comment>
	  <expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <goto>goto <name>fwdlo</name>;</goto>
	</block_content>}</block></else></if_stmt>
	<break>break;</break>
	</block_content>}</block>
      <case>case <expr><name>IR_CALLXS</name></expr>:</case>
	<goto>goto <name>split_call</name>;</goto>
      <case>case <expr><name>IR_PHI</name></expr>:</case> <block>{<block_content>
	<decl_stmt><decl><type><name>IRRef</name></type> <name>hiref2</name></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>irref_isk</name><argument_list>(<argument><expr><name><name>nir</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>irref_isk</name><argument_list>(<argument><expr><name><name>nir</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
	    <name><name>nir</name><operator>-&gt;</operator><name>op1</name></name> <operator>==</operator> <name><name>nir</name><operator>-&gt;</operator><name>op2</name></name></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nins</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Drop useless PHIs. */</comment>
	<expr_stmt><expr><name>hiref2</name> <operator>=</operator> <name><name>hisubst</name><index>[<expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr>]</index></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><call><name>irref_isk</name><argument_list>(<argument><expr><name>hiref</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>irref_isk</name><argument_list>(<argument><expr><name>hiref2</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator> <name>hiref</name> <operator>==</operator> <name>hiref2</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_PHI</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>hiref</name></expr></argument>, <argument><expr><name>hiref2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<break>break;</break>
	</block_content>}</block>
      <case>case <expr><name>IR_HIOP</name></expr>:</case>
	<expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nins</name></name><operator>--</operator></expr>;</expr_stmt>  <comment type="block">/* Drop joining HIOP. */</comment>
	<expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name><name>nir</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>hi</name> <operator>=</operator> <name><name>nir</name><operator>-&gt;</operator><name>op2</name></name></expr>;</expr_stmt>
	<break>break;</break>
      <default>default:</default>
	<expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>&lt;=</operator> <name>IR_NE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Comparisons. */</comment>
	<expr_stmt><expr><call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRTGI</name><argument_list>(<argument><expr><name>IR_HIOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>hiref</name></expr></argument>, <argument><expr><name><name>hisubst</name><index>[<expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
      </block_content>}</block></switch>
    </block_content>}</block></if> <if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_SOFTFP</name></expr></cpp:if>
    if <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_SLOAD</name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>nir</name><operator>-&gt;</operator><name>op2</name></name> <operator>&amp;</operator> <name>IRSLOAD_CONVERT</name><operator>)</operator></expr>)</condition> <block>{<block_content>  <comment type="block">/* Convert from number to int. */</comment>
	<expr_stmt><expr><name><name>nir</name><operator>-&gt;</operator><name>op2</name></name> <operator>&amp;=</operator> <operator>~</operator><name>IRSLOAD_CONVERT</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>nir</name><operator>-&gt;</operator><name>op2</name></name> <operator>&amp;</operator> <name>IRSLOAD_TYPECHECK</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><name><name>nir</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>irt</name></name> <operator>=</operator> <name>IRT_INT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Drop guard. */</comment>
	<expr_stmt><expr><call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_HIOP</name></expr></argument>, <argument><expr><name>IRT_SOFTFP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nref</name></expr></argument>, <argument><expr><name>nref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <call><name>split_num2int</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>nref</name></expr></argument>, <argument><expr><name>nref</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>irt_isguard</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_TOBIT</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>IRRef</name></type> <name>tmp</name></decl>, <decl><type ref="prev"/><name>op1</name> <init>= <expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nins</name></name><operator>--</operator></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_LE</name></expr></cpp:if>
      <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_CARG</name></expr></argument>, <argument><expr><name>IRT_NIL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>oir</name><index>[<expr><name>op1</name></expr>]</index></name><operator>.</operator><name>prev</name></expr></argument>, <argument><expr><name><name>hisubst</name><index>[<expr><name>op1</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_CARG</name></expr></argument>, <argument><expr><name>IRT_NIL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>hisubst</name><index>[<expr><name>op1</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>oir</name><index>[<expr><name>op1</name></expr>]</index></name><operator>.</operator><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRTI</name><argument_list>(<argument><expr><name>IR_CALLN</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>IRCALL_lj_vm_tobit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_TOSTR</name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>hisubst</name><index>[<expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr>]</index></name></expr>)</condition> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>irref_isk</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><name><name>nir</name><operator>-&gt;</operator><name>op1</name></name> <operator>=</operator> <name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
	  <expr_stmt><expr><call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_HIOP</name></expr></argument>, <argument><expr><name>IRT_NIL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>hisubst</name><index>[<expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>nref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_HREF</name> <operator>||</operator> <name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_NEWREF</name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>irref_isk</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>hisubst</name><index>[<expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name><name>nir</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    if <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_CONV</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* See above, too. */</comment>
      <decl_stmt><decl><type><name>IRType</name></type> <name>st</name> <init>= <expr><operator>(</operator><name>IRType</name><operator>)</operator><operator>(</operator><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name> <operator>&amp;</operator> <name>IRCONV_SRCMASK</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_32</name> <operator>&amp;&amp;</operator> <name>LJ_HASFFI</name></expr></cpp:if>
      <if_stmt><if>if <condition>(<expr><name>st</name> <operator>==</operator> <name>IRT_I64</name> <operator>||</operator> <name>st</name> <operator>==</operator> <name>IRT_U64</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Conversion from 64 bit int. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_SOFTFP</name></expr></cpp:if>
	<if_stmt><if>if <condition>(<expr><call><name>irt_isfloat</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><call><name>split_call_l</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>hisubst</name></expr></argument>, <argument><expr><name>oir</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>,
		       <argument><expr><ternary><condition><expr><name>st</name> <operator>==</operator> <name>IRT_I64</name></expr> ?</condition><then> <expr><name>IRCALL_fp64_l2f</name></expr> </then><else>: <expr><name>IRCALL_fp64_ul2f</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nins</name></name><operator>--</operator></expr>;</expr_stmt>  <comment type="block">/* Drop unused HIOP. */</comment>
	</block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<if_stmt><if>if <condition>(<expr><call><name>irt_isfp</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* 64 bit integer to FP conversion. */</comment>
	  <expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_HIOP</name></expr></argument>, <argument><expr><call><name>irt_type</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name><name>hisubst</name><index>[<expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>nref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<else>else <block>{<block_content>  <comment type="block">/* Truncate to lower 32 bits. */</comment>
	<label><name>fwdlo</name>:</label>
	  <expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name><name>nir</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt>  <comment type="block">/* Forward loword. */</comment>
	  <comment type="block">/* Replace with NOP to avoid messing up the snapshot logic. */</comment>
	  <expr_stmt><expr><name><name>nir</name><operator>-&gt;</operator><name>ot</name></name> <operator>=</operator> <call><name>IRT</name><argument_list>(<argument><expr><name>IR_NOP</name></expr></argument>, <argument><expr><name>IRT_NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>nir</name><operator>-&gt;</operator><name>op1</name></name> <operator>=</operator> <name><name>nir</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
      </block_content>}</block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_SOFTFP</name> <operator>&amp;&amp;</operator> <name>LJ_32</name> <operator>&amp;&amp;</operator> <name>LJ_HASFFI</name></expr></cpp:if>
      <if type="elseif">else if <condition>(<expr><call><name>irt_isfloat</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>st</name> <operator>==</operator> <name>IRT_NUM</name></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><call><name>split_call_l</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>hisubst</name></expr></argument>, <argument><expr><name>oir</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><name>IRCALL_softfp_d2f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nins</name></name><operator>--</operator></expr>;</expr_stmt>  <comment type="block">/* Drop unused HIOP. */</comment>
	</block_content>}</block></if> <else>else <block>{<block_content>
	  <expr_stmt><expr><name><name>nir</name><operator>-&gt;</operator><name>o</name></name> <operator>=</operator> <name>IR_CALLN</name></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>nir</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <ternary><condition><expr><name>st</name> <operator>==</operator> <name>IRT_INT</name></expr> ?</condition><then> <expr><name>IRCALL_softfp_i2f</name></expr> </then><else>: <expr><name>IRCALL_softfp_ui2f</name></expr></else></ternary></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>st</name> <operator>==</operator> <name>IRT_FLOAT</name></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name><name>nir</name><operator>-&gt;</operator><name>o</name></name> <operator>=</operator> <name>IR_CALLN</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nir</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <ternary><condition><expr><call><name>irt_isint</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>IRCALL_softfp_f2i</name></expr> </then><else>: <expr><name>IRCALL_softfp_f2ui</name></expr></else></ternary></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_SOFTFP</name></expr></cpp:if>
      if <condition>(<expr><name>st</name> <operator>==</operator> <name>IRT_NUM</name> <operator>||</operator> <operator>(</operator><name>LJ_32</name> <operator>&amp;&amp;</operator> <name>LJ_HASFFI</name> <operator>&amp;&amp;</operator> <name>st</name> <operator>==</operator> <name>IRT_FLOAT</name><operator>)</operator></expr>)</condition> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>irt_isguard</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>st</name> <operator>==</operator> <name>IRT_NUM</name> <operator>&amp;&amp;</operator> <call><name>irt_isint</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nins</name></name><operator>--</operator></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <call><name>split_num2int</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>nir</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>, <argument><expr><name><name>hisubst</name><index>[<expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
	  <expr_stmt><expr><call><name>split_call_l</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>hisubst</name></expr></argument>, <argument><expr><name>oir</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><ternary><condition><expr><name>LJ_32</name> <operator>&amp;&amp;</operator> <name>LJ_HASFFI</name></expr></condition></ternary></expr></cpp:if>
	    <argument><expr><ternary><condition><expr><name>st</name> <operator>==</operator> <name>IRT_NUM</name></expr> ?</condition><then>
	      <expr><operator>(</operator><ternary><condition><expr><call><name>irt_isint</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>IRCALL_softfp_d2i</name></expr> </then><else>: <expr><name>IRCALL_softfp_d2ui</name></expr></else></ternary><operator>)</operator></expr> </then><else>:
	      <expr><operator>(</operator><ternary><condition><expr><call><name>irt_isint</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>IRCALL_softfp_f2i</name></expr> </then><else>: <expr><name>IRCALL_softfp_f2ui</name></expr></else></ternary><operator>)</operator>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	    <name>IRCALL_softfp_d2i</name></expr></else></ternary></expr></argument>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	  )</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nins</name></name><operator>--</operator></expr>;</expr_stmt>  <comment type="block">/* Drop unused HIOP. */</comment>
	</block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_CALLXS</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>IRRef</name></type> <name>hiref</name></decl>;</decl_stmt>
    <label><name>split_call</name>:</label>
      <expr_stmt><expr><name>hiref</name> <operator>=</operator> <name><name>hisubst</name><index>[<expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr>]</index></name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>hiref</name></expr>)</condition> <block>{<block_content>
	<decl_stmt><decl><type><name>IROpT</name></type> <name>ot</name> <init>= <expr><name><name>nir</name><operator>-&gt;</operator><name>ot</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IRRef</name></type> <name>op2</name> <init>= <expr><name><name>nir</name><operator>-&gt;</operator><name>op2</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>nir</name><operator>-&gt;</operator><name>ot</name></name> <operator>=</operator> <call><name>IRT</name><argument_list>(<argument><expr><name>IR_CARG</name></expr></argument>, <argument><expr><name>IRT_NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_LE</name></expr></cpp:if>
	<expr_stmt><expr><name><name>nir</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <name>hiref</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name><name>nir</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <name><name>nir</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt> <expr_stmt><expr><name><name>nir</name><operator>-&gt;</operator><name>op1</name></name> <operator>=</operator> <name>hiref</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>nref</name> <operator>=</operator> <call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ot</name></expr></argument>, <argument><expr><name>nref</name></expr></argument>, <argument><expr><name>op2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><ternary><condition><expr><name>LJ_SOFTFP</name></expr> ?</condition><then> <expr><call><name>irt_is64</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>irt_isint64</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>,
	  <argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_HIOP</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>LJ_SOFTFP</name> <operator>&amp;&amp;</operator> <call><name>irt_isnum</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr> ?</condition><then> <expr><name>IRT_SOFTFP</name></expr> </then><else>: <expr><name>IRT_INT</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>,
	  <argument><expr><name>nref</name></expr></argument>, <argument><expr><name>nref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_CARG</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>IRRef</name></type> <name>hiref</name> <init>= <expr><name><name>hisubst</name><index>[<expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>hiref</name></expr>)</condition> <block>{<block_content>
	<decl_stmt><decl><type><name>IRRef</name></type> <name>op2</name> <init>= <expr><name><name>nir</name><operator>-&gt;</operator><name>op2</name></name></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_LE</name></expr></cpp:if>
	<expr_stmt><expr><name><name>nir</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <name>hiref</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name><name>nir</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <name><name>nir</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt> <expr_stmt><expr><name><name>nir</name><operator>-&gt;</operator><name>op1</name></name> <operator>=</operator> <name>hiref</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>nref</name> <operator>=</operator> <call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_CARG</name></expr></argument>, <argument><expr><name>IRT_NIL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nref</name></expr></argument>, <argument><expr><name>op2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nir</name> <operator>=</operator> <call><name>IR</name><argument_list>(<argument><expr><name>nref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>hiref</name> <operator>=</operator> <name><name>hisubst</name><index>[<expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr>]</index></name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>hiref</name></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>LJ_TARGET_X86</name></expr></cpp:if>
	<decl_stmt><decl><type><name>int</name></type> <name>carg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>cir</name></decl>;</decl_stmt>
	<for>for <control>(<init><expr><name>cir</name> <operator>=</operator> <call><name>IR</name><argument_list>(<argument><expr><name><name>nir</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name><name>cir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_CARG</name></expr>;</condition> <incr><expr><name>cir</name> <operator>=</operator> <call><name>IR</name><argument_list>(<argument><expr><name><name>cir</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call></expr></incr>)</control><block type="pseudo"><block_content>
	  <expr_stmt><expr><name>carg</name><operator>++</operator></expr>;</expr_stmt></block_content></block></for>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>carg</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* Align 64 bit arguments. */</comment>
	  <decl_stmt><decl><type><name>IRRef</name></type> <name>op2</name> <init>= <expr><name><name>nir</name><operator>-&gt;</operator><name>op2</name></name></expr></init></decl>;</decl_stmt>
	  <expr_stmt><expr><name><name>nir</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <name>REF_NIL</name></expr>;</expr_stmt>
	  <expr_stmt><expr><name>nref</name> <operator>=</operator> <call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_CARG</name></expr></argument>, <argument><expr><name>IRT_NIL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nref</name></expr></argument>, <argument><expr><name>op2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><name>nir</name> <operator>=</operator> <call><name>IR</name><argument_list>(<argument><expr><name>nref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_BE</name></expr></cpp:if>
	<block>{<block_content> <decl_stmt><decl><type><name>IRRef</name></type> <name>tmp</name> <init>= <expr><name><name>nir</name><operator>-&gt;</operator><name>op2</name></name></expr></init></decl>;</decl_stmt> <expr_stmt><expr><name><name>nir</name><operator>-&gt;</operator><name>op2</name></name> <operator>=</operator> <name>hiref</name></expr>;</expr_stmt> <expr_stmt><expr><name>hiref</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt> </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_CARG</name></expr></argument>, <argument><expr><name>IRT_NIL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nref</name></expr></argument>, <argument><expr><name>hiref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_CNEWI</name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>hisubst</name><index>[<expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>split_emit</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_HIOP</name></expr></argument>, <argument><expr><name>IRT_NIL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nref</name></expr></argument>, <argument><expr><name><name>hisubst</name><index>[<expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_LOOP</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>loopref</name></name> <operator>=</operator> <name>nref</name></expr>;</expr_stmt>  <comment type="block">/* Needed by assembler. */</comment>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>hisubst</name><index>[<expr><name>ref</name></expr>]</index></name> <operator>=</operator> <name>hi</name></expr>;</expr_stmt>  <comment type="block">/* Store hiword substitution. */</comment>
  </block_content>}</block></for>
  <if_stmt><if>if <condition>(<expr><name>snref</name> <operator>==</operator> <name>nins</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Substitution for last snapshot. */</comment>
    <expr_stmt><expr><name><name>snap</name><operator>-&gt;</operator><name>ref</name></name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nins</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>split_subst_snap</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>snap</name></expr></argument>, <argument><expr><name>oir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Add PHI marks. */</comment>
  <for>for <control>(<init><expr><name>ref</name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nins</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>ref</name> <operator>&gt;=</operator> <name>REF_FIRST</name></expr>;</condition> <incr><expr><name>ref</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name> <init>= <expr><call><name>IR</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>!=</operator> <name>IR_PHI</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>irref_isk</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>irt_setphi</name><argument_list>(<argument><expr><call><name>IR</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name> <operator>&gt;</operator> <name><name>J</name><operator>-&gt;</operator><name>loopref</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>irt_setphi</name><argument_list>(<argument><expr><call><name>IR</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* Protected callback for split pass. */</comment>
<function><type><specifier>static</specifier> <name>TValue</name> <modifier>*</modifier></type><name>cpsplit</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>lua_CFunction</name></type> <name>dummy</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ud</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name> <init>= <expr><operator>(</operator><name>jit_State</name> <operator>*</operator><operator>)</operator><name>ud</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>split_ir</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>dummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>LUA_USE_ASSERT</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>LJ_SOFTFP</name></expr></cpp:if>
<comment type="block">/* Slow, but sure way to check whether a SPLIT pass is needed. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>split_needsplit</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>irend</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IRRef</name></type> <name>ref</name></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>ir</name> <operator>=</operator> <call><name>IR</name><argument_list>(<argument><expr><name>REF_FIRST</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><name>irend</name> <operator>=</operator> <call><name>IR</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nins</name></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>ir</name> <operator>&lt;</operator> <name>irend</name></expr>;</condition> <incr><expr><name>ir</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <if_stmt><if>if <condition>(<expr><ternary><condition><expr><name>LJ_SOFTFP</name></expr> ?</condition><then> <expr><call><name>irt_is64orfp</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>irt_isint64</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>
  <if_stmt><if>if <condition>(<expr><name>LJ_SOFTFP</name></expr>)</condition> <block>{<block_content>
    <for>for <control>(<init><expr><name>ref</name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>chain</name><index>[<expr><name>IR_SLOAD</name></expr>]</index></name></expr>;</init> <condition><expr><name>ref</name></expr>;</condition> <incr><expr><name>ref</name> <operator>=</operator> <call><name>IR</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>prev</name></expr></incr>)</control><block type="pseudo"><block_content>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>IR</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>op2</name> <operator>&amp;</operator> <name>IRSLOAD_CONVERT</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>
    <if_stmt><if>if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>chain</name><index>[<expr><name>IR_TOBIT</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <for>for <control>(<init><expr><name>ref</name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>chain</name><index>[<expr><name>IR_CONV</name></expr>]</index></name></expr>;</init> <condition><expr><name>ref</name></expr>;</condition> <incr><expr><name>ref</name> <operator>=</operator> <call><name>IR</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>prev</name></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>IRType</name></type> <name>st</name> <init>= <expr><operator>(</operator><call><name>IR</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>op2</name> <operator>&amp;</operator> <name>IRCONV_SRCMASK</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>LJ_SOFTFP</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>st</name> <operator>==</operator> <name>IRT_NUM</name> <operator>||</operator> <name>st</name> <operator>==</operator> <name>IRT_FLOAT</name><operator>)</operator><operator>)</operator> <operator>||</operator>
	<name>st</name> <operator>==</operator> <name>IRT_I64</name> <operator>||</operator> <name>st</name> <operator>==</operator> <name>IRT_U64</name></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* Nope. */</comment>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* SPLIT pass. */</comment>
<function><type><name>void</name></type> <name>lj_opt_split</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_SOFTFP</name></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>J</name><operator>-&gt;</operator><name>needsplit</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>needsplit</name></name> <operator>=</operator> <call><name>split_needsplit</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>needsplit</name></name> <operator>&gt;=</operator> <call><name>split_needsplit</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Verify flag. */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>needsplit</name></name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>errcode</name> <init>= <expr><call><name>lj_vm_cpcall</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>J</name></expr></argument>, <argument><expr><name>cpsplit</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>errcode</name></expr>)</condition> <block>{<block_content>
      <comment type="block">/* Completely reset the trace to avoid inconsistent dump on abort. */</comment>
      <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nins</name></name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nk</name></name> <operator>=</operator> <name>REF_BASE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nsnap</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lj_err_throw</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>errcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Propagate errors. */</comment>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>IR</name></cpp:undef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
