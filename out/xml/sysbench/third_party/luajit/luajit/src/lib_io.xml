<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/sysbench/third_party/luajit/luajit/src/lib_io.c"><comment type="block">/*
** I/O library.
** Copyright (C) 2005-2020 Mike Pall. See Copyright Notice in luajit.h
**
** Major portions taken verbatim or adapted from the Lua interpreter.
** Copyright (C) 1994-2011 Lua.org, PUC-Rio. See Copyright Notice in lua.h
*/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lib_io_c</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUA_LIB</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lua.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lauxlib.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lualib.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_obj.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_gc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_err.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_buf.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_str.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_state.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_strfmt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_ff.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_lib.h"</cpp:file></cpp:include>

<comment type="block">/* Userdata payload for I/O file. */</comment>
<typedef>typedef <type><struct>struct <name>IOFileUD</name> <block>{
  <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl>;</decl_stmt>		<comment type="block">/* File handle. */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>type</name></decl>;</decl_stmt>	<comment type="block">/* File type. */</comment>
}</block></struct></type> <name>IOFileUD</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IOFILE_TYPE_FILE</name></cpp:macro>	<cpp:value>0</cpp:value></cpp:define>	<comment type="block">/* Regular file. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IOFILE_TYPE_PIPE</name></cpp:macro>	<cpp:value>1</cpp:value></cpp:define>	<comment type="block">/* Pipe. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IOFILE_TYPE_STDF</name></cpp:macro>	<cpp:value>2</cpp:value></cpp:define>	<comment type="block">/* Standard file handle. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IOFILE_TYPE_MASK</name></cpp:macro>	<cpp:value>3</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IOFILE_FLAG_CLOSE</name></cpp:macro>	<cpp:value>4</cpp:value></cpp:define>	<comment type="block">/* Close after io.lines() iterator. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IOSTDF_UD</name><parameter_list>(<parameter><type><name>L</name></type></parameter>, <parameter><type><name>id</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(&amp;gcref(G(L)-&gt;gcroot[(id)])-&gt;ud)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IOSTDF_IOF</name><parameter_list>(<parameter><type><name>L</name></type></parameter>, <parameter><type><name>id</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((IOFileUD *)uddata(IOSTDF_UD(L, (id))))</cpp:value></cpp:define>

<comment type="block">/* -- Open/close helpers -------------------------------------------------- */</comment>

<function><type><specifier>static</specifier> <name>IOFileUD</name> <modifier>*</modifier></type><name>io_tofilep</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>&lt;</operator> <name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>&amp;&amp;</operator> <call><name>tvisudata</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
	<call><name>udataV</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>udtype</name> <operator>==</operator> <name>UDTYPE_IO_FILE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_err_argtype</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"FILE*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><operator>(</operator><name>IOFileUD</name> <operator>*</operator><operator>)</operator><call><name>uddata</name><argument_list>(<argument><expr><call><name>udataV</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>IOFileUD</name> <modifier>*</modifier></type><name>io_tofile</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>IOFileUD</name> <modifier>*</modifier></type><name>iof</name> <init>= <expr><call><name>io_tofilep</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>iof</name><operator>-&gt;</operator><name>fp</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_err_caller</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LJ_ERR_IOCLFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>iof</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>FILE</name> <modifier>*</modifier></type><name>io_stdfile</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>ptrdiff_t</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>IOFileUD</name> <modifier>*</modifier></type><name>iof</name> <init>= <expr><call><name>IOSTDF_IOF</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>iof</name><operator>-&gt;</operator><name>fp</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_err_caller</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LJ_ERR_IOSTDCL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name><name>iof</name><operator>-&gt;</operator><name>fp</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>IOFileUD</name> <modifier>*</modifier></type><name>io_file_new</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>IOFileUD</name> <modifier>*</modifier></type><name>iof</name> <init>= <expr><operator>(</operator><name>IOFileUD</name> <operator>*</operator><operator>)</operator><call><name>lua_newuserdata</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IOFileUD</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GCudata</name> <modifier>*</modifier></type><name>ud</name> <init>= <expr><call><name>udataV</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>ud</name><operator>-&gt;</operator><name>udtype</name></name> <operator>=</operator> <name>UDTYPE_IO_FILE</name></expr>;</expr_stmt>
  <comment type="block">/* NOBARRIER: The GCudata is new (marked white). */</comment>
  <expr_stmt><expr><call><name>setgcrefr</name><argument_list>(<argument><expr><name><name>ud</name><operator>-&gt;</operator><name>metatable</name></name></expr></argument>, <argument><expr><call><name>curr_func</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>c</name><operator>.</operator><name>env</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>iof</name><operator>-&gt;</operator><name>fp</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>iof</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>IOFILE_TYPE_FILE</name></expr>;</expr_stmt>
  <return>return <expr><name>iof</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>IOFileUD</name> <modifier>*</modifier></type><name>io_file_open</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname</name> <init>= <expr><call><name>strdata</name><argument_list>(<argument><expr><call><name>lj_lib_checkstr</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IOFileUD</name> <modifier>*</modifier></type><name>iof</name> <init>= <expr><call><name>io_file_new</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>iof</name><operator>-&gt;</operator><name>fp</name></name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>iof</name><operator>-&gt;</operator><name>fp</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>luaL_argerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>lj_strfmt_pushf</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"%s: %s"</literal></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>iof</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>io_file_close</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>IOFileUD</name> <modifier>*</modifier></type><name>iof</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>ok</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>iof</name><operator>-&gt;</operator><name>type</name></name> <operator>&amp;</operator> <name>IOFILE_TYPE_MASK</name><operator>)</operator> <operator>==</operator> <name>IOFILE_TYPE_FILE</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>ok</name> <operator>=</operator> <operator>(</operator><call><name>fclose</name><argument_list>(<argument><expr><name><name>iof</name><operator>-&gt;</operator><name>fp</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>iof</name><operator>-&gt;</operator><name>type</name></name> <operator>&amp;</operator> <name>IOFILE_TYPE_MASK</name><operator>)</operator> <operator>==</operator> <name>IOFILE_TYPE_PIPE</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>stat</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_POSIX</name></expr></cpp:if>
    <expr_stmt><expr><name>stat</name> <operator>=</operator> <call><name>pclose</name><argument_list>(<argument><expr><name><name>iof</name><operator>-&gt;</operator><name>fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_WINDOWS</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>LJ_TARGET_XBOXONE</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>LJ_TARGET_UWP</name></expr></cpp:elif>
    <expr_stmt><expr><name>stat</name> <operator>=</operator> <call><name>_pclose</name><argument_list>(<argument><expr><name><name>iof</name><operator>-&gt;</operator><name>fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_52</name></expr></cpp:if>
    <expr_stmt><expr><name><name>iof</name><operator>-&gt;</operator><name>fp</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <return>return <expr><call><name>luaL_execresult</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>stat</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>ok</name> <operator>=</operator> <operator>(</operator><name>stat</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>iof</name><operator>-&gt;</operator><name>type</name></name> <operator>&amp;</operator> <name>IOFILE_TYPE_MASK</name><operator>)</operator> <operator>==</operator> <name>IOFILE_TYPE_STDF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setnilV</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lua_pushliteral</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"cannot close standard file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">2</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>iof</name><operator>-&gt;</operator><name>fp</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <return>return <expr><call><name>luaL_fileresult</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>ok</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -- Read/write helpers -------------------------------------------------- */</comment>

<function><type><specifier>static</specifier> <name>int</name></type> <name>io_file_readnum</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>lua_Number</name></type> <name>d</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>fscanf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>LUA_NUMBER_SCAN</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>d</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>LJ_DUALNUM</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><call><name>lj_num2int</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>d</name> <operator>==</operator> <operator>(</operator><name>lua_Number</name><operator>)</operator><name>i</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>tvismzero</name><argument_list>(<argument><expr><operator>(</operator><name>cTValue</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>d</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>setintV</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>++</operator></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">1</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>setnumV</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>++</operator></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>setnilV</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>io_file_readline</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>, <parameter><decl><type><name>MSize</name></type> <name>chop</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>MSize</name></type> <name>m</name> <init>= <expr><name>LUAL_BUFFERSIZE</name></expr></init></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>ok</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
  <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
    <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>lj_buf_tmp</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>fgets</name><argument_list>(<argument><expr><name>buf</name><operator>+</operator><name>n</name></expr></argument>, <argument><expr><name>m</name><operator>-</operator><name>n</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>n</name> <operator>+=</operator> <operator>(</operator><name>MSize</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>buf</name><operator>+</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ok</name> <operator>|=</operator> <name>n</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>n</name> <operator>&amp;&amp;</operator> <name><name>buf</name><index>[<expr><name>n</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>n</name> <operator>-=</operator> <name>chop</name></expr>;</expr_stmt> <break>break;</break> </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;=</operator> <name>m</name> <operator>-</operator> <literal type="number">64</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>m</name> <operator>+=</operator> <name>m</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>setstrV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>++</operator></expr></argument>, <argument><expr><call><name>lj_str_new</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lj_gc_check</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><name>ok</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>io_file_readall</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>MSize</name></type> <name>m</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>m</name> <operator>=</operator> <name>LUAL_BUFFERSIZE</name></expr><operator>,</operator> <expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition>;</condition> <incr><expr><name>m</name> <operator>+=</operator> <name>m</name></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>lj_buf_tmp</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>n</name> <operator>+=</operator> <operator>(</operator><name>MSize</name><operator>)</operator><call><name>fread</name><argument_list>(<argument><expr><name>buf</name><operator>+</operator><name>n</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>m</name><operator>-</operator><name>n</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>n</name> <operator>!=</operator> <name>m</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>setstrV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>++</operator></expr></argument>, <argument><expr><call><name>lj_str_new</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lj_gc_check</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>io_file_readlen</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>, <parameter><decl><type><name>MSize</name></type> <name>m</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>m</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>lj_buf_tmp</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MSize</name></type> <name>n</name> <init>= <expr><operator>(</operator><name>MSize</name><operator>)</operator><call><name>fread</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>setstrV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>++</operator></expr></argument>, <argument><expr><call><name>lj_str_new</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lj_gc_check</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>m</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><call><name>getc</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>ungetc</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setstrV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>++</operator></expr></argument>, <argument><expr><operator>&amp;</operator><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>strempty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><name>c</name> <operator>!=</operator> <name>EOF</name><operator>)</operator></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>io_file_read</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>start</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>ok</name></decl>, <decl><type ref="prev"/><name>n</name></decl>, <decl><type ref="prev"/><name>nargs</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>-</operator> <name><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>)</operator> <operator>-</operator> <name>start</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>clearerr</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>ok</name> <operator>=</operator> <call><name>io_file_readline</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <name>start</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* Return 1 result. */</comment>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <comment type="block">/* The results plus the buffers go on top of the args. */</comment>
    <expr_stmt><expr><call><name>luaL_checkstack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>nargs</name><operator>+</operator><name>LUA_MINSTACK</name></expr></argument>, <argument><expr><literal type="string">"too many arguments"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ok</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>n</name> <operator>=</operator> <name>start</name></expr>;</init> <condition><expr><name>nargs</name><operator>--</operator> <operator>&amp;&amp;</operator> <name>ok</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>tvisstr</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>+</operator><name>n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>strVdata</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>+</operator><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'n'</literal></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><name>ok</name> <operator>=</operator> <call><name>io_file_readnum</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <operator>~</operator><literal type="number">0x20</literal><operator>)</operator> <operator>==</operator> <literal type="char">'L'</literal></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><name>ok</name> <operator>=</operator> <call><name>io_file_readline</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><operator>(</operator><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'l'</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'a'</literal></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><call><name>io_file_readall</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
	  <expr_stmt><expr><call><name>lj_err_arg</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>n</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>LJ_ERR_INVFMT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>tvisnumber</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>+</operator><name>n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name>ok</name> <operator>=</operator> <call><name>io_file_readlen</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><operator>(</operator><name>MSize</name><operator>)</operator><call><name>lj_lib_checkint</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>n</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<expr_stmt><expr><call><name>lj_err_arg</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>n</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>LJ_ERR_INVOPT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>ferror</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>luaL_fileresult</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>setnilV</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Replace last result with nil. */</comment>
  <return>return <expr><name>n</name> <operator>-</operator> <name>start</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>io_file_write</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>start</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>tv</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>status</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>tv</name> <operator>=</operator> <name><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>+</operator><name>start</name></expr>;</init> <condition><expr><name>tv</name> <operator>&lt;</operator> <name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr>;</condition> <incr><expr><name>tv</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>MSize</name></type> <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>lj_strfmt_wstrnum</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>tv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>lj_err_argt</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>tv</name> <operator>-</operator> <name><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>LUA_TSTRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>status</name> <operator>=</operator> <name>status</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>fwrite</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>len</name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if <condition>(<expr><name>LJ_52</name> <operator>&amp;&amp;</operator> <name>status</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>start</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>setudataV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name></expr></argument>, <argument><expr><call><name>IOSTDF_UD</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>GCROOT_IO_OUTPUT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>luaL_fileresult</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>io_file_iter</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>GCfunc</name> <modifier>*</modifier></type><name>fn</name> <init>= <expr><call><name>curr_func</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IOFileUD</name> <modifier>*</modifier></type><name>iof</name> <init>= <expr><call><name>uddata</name><argument_list>(<argument><expr><call><name>udataV</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fn</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>upvalue</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><name><name>fn</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>nupvalues</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>iof</name><operator>-&gt;</operator><name>fp</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_err_caller</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LJ_ERR_IOCLFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name><name>L</name><operator>-&gt;</operator><name>base</name></name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>n</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Copy upvalues with options to stack. */</comment>
    <if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <name>LUAI_MAXCSTACK</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>lj_err_caller</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LJ_ERR_STKOV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>lj_state_checkstack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>(</operator><name>MSize</name><operator>)</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>fn</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>upvalue</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>n</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>TValue</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>io_file_read</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>iof</name><operator>-&gt;</operator><name>fp</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>ferror</name><argument_list>(<argument><expr><name><name>iof</name><operator>-&gt;</operator><name>fp</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_err_callermsg</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>strVdata</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>tvisnil</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>iof</name><operator>-&gt;</operator><name>type</name></name> <operator>&amp;</operator> <name>IOFILE_FLAG_CLOSE</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>io_file_close</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>iof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Return values are ignored. */</comment>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>io_file_lines</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>-</operator> <name><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <name>LJ_MAX_UPVAL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_err_caller</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LJ_ERR_UNPACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>lua_pushcclosure</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>io_file_iter</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -- I/O file methods ---------------------------------------------------- */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LJLIB_MODULE_io_method</name></cpp:macro></cpp:define>

<macro><name>LJLIB_CF</name><argument_list>(<argument>io_method_close</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>IOFileUD</name> <modifier>*</modifier></type><name>iof</name> <init>= <expr><ternary><condition><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>&lt;</operator> <name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr> ?</condition><then> <expr><call><name>io_tofile</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr> </then><else>:
		  <expr><call><name>IOSTDF_IOF</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>GCROOT_IO_OUTPUT</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>io_file_close</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>iof</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<macro><name>LJLIB_CF</name><argument_list>(<argument>io_method_read</argument>)</argument_list></macro>
<block>{<block_content>
  <return>return <expr><call><name>io_file_read</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>io_tofile</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>fp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<macro><name>LJLIB_CF</name><argument_list>(<argument>io_method_write</argument>)</argument_list></macro>		<macro><name>LJLIB_REC</name><argument_list>(<argument>io_write <literal type="number">0</literal></argument>)</argument_list></macro>
<block>{<block_content>
  <return>return <expr><call><name>io_file_write</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>io_tofile</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>fp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<macro><name>LJLIB_CF</name><argument_list>(<argument>io_method_flush</argument>)</argument_list></macro>		<macro><name>LJLIB_REC</name><argument_list>(<argument>io_flush <literal type="number">0</literal></argument>)</argument_list></macro>
<block>{<block_content>
  <return>return <expr><call><name>luaL_fileresult</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>fflush</name><argument_list>(<argument><expr><call><name>io_tofile</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>fp</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<macro><name>LJLIB_CF</name><argument_list>(<argument>io_method_seek</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name> <init>= <expr><call><name>io_tofile</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>fp</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>opt</name> <init>= <expr><call><name>lj_lib_checkopt</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"\3set\3cur\3end"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int64_t</name></type> <name>ofs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>o</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>opt</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>opt</name> <operator>=</operator> <name>SEEK_SET</name></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><name>opt</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>opt</name> <operator>=</operator> <name>SEEK_CUR</name></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><name>opt</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>opt</name> <operator>=</operator> <name>SEEK_END</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>o</name> <operator>=</operator> <name><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>+</operator><literal type="number">2</literal></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>o</name> <operator>&lt;</operator> <name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>tvisint</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>ofs</name> <operator>=</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><call><name>intV</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>tvisnum</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>ofs</name> <operator>=</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><call><name>numV</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>tvisnil</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>lj_err_argt</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>LUA_TNUMBER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_POSIX</name></expr></cpp:if>
  <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>fseeko</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>ofs</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>_MSC_VER</name> <operator>&gt;=</operator> <literal type="number">1400</literal></expr></cpp:elif>
  <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>_fseeki64</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>ofs</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__MINGW32__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
  <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>fseeko64</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>ofs</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>fseek</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator><name>ofs</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>luaL_fileresult</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_POSIX</name></expr></cpp:if>
  <expr_stmt><expr><name>ofs</name> <operator>=</operator> <call><name>ftello</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>_MSC_VER</name> <operator>&gt;=</operator> <literal type="number">1400</literal></expr></cpp:elif>
  <expr_stmt><expr><name>ofs</name> <operator>=</operator> <call><name>_ftelli64</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__MINGW32__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
  <expr_stmt><expr><name>ofs</name> <operator>=</operator> <call><name>ftello64</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name>ofs</name> <operator>=</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><call><name>ftell</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>setint64V</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>ofs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block>

<macro><name>LJLIB_CF</name><argument_list>(<argument>io_method_setvbuf</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name> <init>= <expr><call><name>io_tofile</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>fp</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>opt</name> <init>= <expr><call><name>lj_lib_checkopt</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"\4full\4line\2no"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>sz</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><call><name>lj_lib_optint</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>LUAL_BUFFERSIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>opt</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>opt</name> <operator>=</operator> <name>_IOFBF</name></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><name>opt</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>opt</name> <operator>=</operator> <name>_IOLBF</name></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><name>opt</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>opt</name> <operator>=</operator> <name>_IONBF</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><call><name>luaL_fileresult</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>setvbuf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<macro><name>LJLIB_CF</name><argument_list>(<argument>io_method_lines</argument>)</argument_list></macro>
<block>{<block_content>
  <expr_stmt><expr><call><name>io_tofile</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>io_file_lines</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<macro><name>LJLIB_CF</name><argument_list>(<argument>io_method___gc</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>IOFileUD</name> <modifier>*</modifier></type><name>iof</name> <init>= <expr><call><name>io_tofilep</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>iof</name><operator>-&gt;</operator><name>fp</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>iof</name><operator>-&gt;</operator><name>type</name></name> <operator>&amp;</operator> <name>IOFILE_TYPE_MASK</name><operator>)</operator> <operator>!=</operator> <name>IOFILE_TYPE_STDF</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>io_file_close</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>iof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block>

<macro><name>LJLIB_CF</name><argument_list>(<argument>io_method___tostring</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>IOFileUD</name> <modifier>*</modifier></type><name>iof</name> <init>= <expr><call><name>io_tofilep</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>iof</name><operator>-&gt;</operator><name>fp</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lua_pushfstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"file (%p)"</literal></expr></argument>, <argument><expr><name><name>iof</name><operator>-&gt;</operator><name>fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lua_pushliteral</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"file (closed)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block>

<macro><name>LJLIB_PUSH</name><argument_list>(<argument>top-<literal type="number">1</literal></argument>)</argument_list></macro> <macro><name>LJLIB_SET</name><argument_list>(<argument>__index</argument>)</argument_list></macro>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_libdef.h"</cpp:file></cpp:include>

<comment type="block">/* -- I/O library functions ----------------------------------------------- */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LJLIB_MODULE_io</name></cpp:macro></cpp:define>

<macro><name>LJLIB_PUSH</name><argument_list>(<argument>top-<literal type="number">2</literal></argument>)</argument_list></macro> <macro><name>LJLIB_SET</name><argument_list>(<argument>!</argument>)</argument_list></macro>  <comment type="block">/* Set environment. */</comment>

<macro><name>LJLIB_CF</name><argument_list>(<argument>io_open</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname</name> <init>= <expr><call><name>strdata</name><argument_list>(<argument><expr><call><name>lj_lib_checkstr</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>lj_lib_optstr</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mode</name> <init>= <expr><ternary><condition><expr><name>s</name></expr> ?</condition><then> <expr><call><name>strdata</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="string">"r"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IOFileUD</name> <modifier>*</modifier></type><name>iof</name> <init>= <expr><call><name>io_file_new</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>iof</name><operator>-&gt;</operator><name>fp</name></name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><ternary><condition><expr><name><name>iof</name><operator>-&gt;</operator><name>fp</name></name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><call><name>luaL_fileresult</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
</block_content>}</block>

<macro><name>LJLIB_CF</name><argument_list>(<argument>io_popen</argument>)</argument_list></macro>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_POSIX</name> <operator>||</operator> <operator>(</operator><name>LJ_TARGET_WINDOWS</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>LJ_TARGET_XBOXONE</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>LJ_TARGET_UWP</name><operator>)</operator></expr></cpp:if>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname</name> <init>= <expr><call><name>strdata</name><argument_list>(<argument><expr><call><name>lj_lib_checkstr</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>lj_lib_optstr</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mode</name> <init>= <expr><ternary><condition><expr><name>s</name></expr> ?</condition><then> <expr><call><name>strdata</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="string">"r"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IOFileUD</name> <modifier>*</modifier></type><name>iof</name> <init>= <expr><call><name>io_file_new</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>iof</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>IOFILE_TYPE_PIPE</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_POSIX</name></expr></cpp:if>
  <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>iof</name><operator>-&gt;</operator><name>fp</name></name> <operator>=</operator> <call><name>popen</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name><name>iof</name><operator>-&gt;</operator><name>fp</name></name> <operator>=</operator> <call><name>_popen</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><ternary><condition><expr><name><name>iof</name><operator>-&gt;</operator><name>fp</name></name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><call><name>luaL_fileresult</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <return>return <expr><call><name>luaL_error</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>LUA_QL</name><argument_list>(<argument><expr><literal type="string">"popen"</literal></expr></argument>)</argument_list></call> <literal type="string">" not supported"</literal></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block>

<macro><name>LJLIB_CF</name><argument_list>(<argument>io_tmpfile</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>IOFileUD</name> <modifier>*</modifier></type><name>iof</name> <init>= <expr><call><name>io_file_new</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_PS3</name> <operator>||</operator> <name>LJ_TARGET_PS4</name> <operator>||</operator> <name>LJ_TARGET_PSVITA</name></expr></cpp:if>
  <expr_stmt><expr><name><name>iof</name><operator>-&gt;</operator><name>fp</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOSYS</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name><name>iof</name><operator>-&gt;</operator><name>fp</name></name> <operator>=</operator> <call><name>tmpfile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><ternary><condition><expr><name><name>iof</name><operator>-&gt;</operator><name>fp</name></name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><call><name>luaL_fileresult</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
</block_content>}</block>

<macro><name>LJLIB_CF</name><argument_list>(<argument>io_close</argument>)</argument_list></macro>
<block>{<block_content>
  <return>return <expr><call><name>lj_cf_io_method_close</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<macro><name>LJLIB_CF</name><argument_list>(<argument>io_read</argument>)</argument_list></macro>
<block>{<block_content>
  <return>return <expr><call><name>io_file_read</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>io_stdfile</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>GCROOT_IO_INPUT</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<macro><name>LJLIB_CF</name><argument_list>(<argument>io_write</argument>)</argument_list></macro>		<macro><name>LJLIB_REC</name><argument_list>(<argument>io_write GCROOT_IO_OUTPUT</argument>)</argument_list></macro>
<block>{<block_content>
  <return>return <expr><call><name>io_file_write</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>io_stdfile</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>GCROOT_IO_OUTPUT</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<macro><name>LJLIB_CF</name><argument_list>(<argument>io_flush</argument>)</argument_list></macro>		<macro><name>LJLIB_REC</name><argument_list>(<argument>io_flush GCROOT_IO_OUTPUT</argument>)</argument_list></macro>
<block>{<block_content>
  <return>return <expr><call><name>luaL_fileresult</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>fflush</name><argument_list>(<argument><expr><call><name>io_stdfile</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>GCROOT_IO_OUTPUT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<function><type><specifier>static</specifier> <name>int</name></type> <name>io_std_getset</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>ptrdiff_t</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>&lt;</operator> <name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>tvisnil</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>tvisudata</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>io_tofile</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>io_file_open</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <comment type="block">/* NOBARRIER: The standard I/O handles are GC roots. */</comment>
    <expr_stmt><expr><call><name>setgcref</name><argument_list>(<argument><expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>gcroot</name><index>[<expr><name>id</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>gcV</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>setudataV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>++</operator></expr></argument>, <argument><expr><call><name>IOSTDF_UD</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<macro><name>LJLIB_CF</name><argument_list>(<argument>io_input</argument>)</argument_list></macro>
<block>{<block_content>
  <return>return <expr><call><name>io_std_getset</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>GCROOT_IO_INPUT</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<macro><name>LJLIB_CF</name><argument_list>(<argument>io_output</argument>)</argument_list></macro>
<block>{<block_content>
  <return>return <expr><call><name>io_std_getset</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>GCROOT_IO_OUTPUT</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<macro><name>LJLIB_CF</name><argument_list>(<argument>io_lines</argument>)</argument_list></macro>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>==</operator> <name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>setnilV</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tvisnil</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* io.lines(fname) */</comment>
    <decl_stmt><decl><type><name>IOFileUD</name> <modifier>*</modifier></type><name>iof</name> <init>= <expr><call><name>io_file_open</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>iof</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>IOFILE_TYPE_FILE</name><operator>|</operator><name>IOFILE_FLAG_CLOSE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setudataV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name></expr></argument>, <argument><expr><call><name>udataV</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* io.lines() iterates over stdin. */</comment>
    <expr_stmt><expr><call><name>setudataV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name></expr></argument>, <argument><expr><call><name>IOSTDF_UD</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>GCROOT_IO_INPUT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><call><name>io_file_lines</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<macro><name>LJLIB_CF</name><argument_list>(<argument>io_type</argument>)</argument_list></macro>
<block>{<block_content>
  <decl_stmt><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>lj_lib_checkany</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>tvisudata</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>udataV</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>udtype</name> <operator>==</operator> <name>UDTYPE_IO_FILE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>setnilV</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><operator>(</operator><operator>(</operator><name>IOFileUD</name> <operator>*</operator><operator>)</operator><call><name>uddata</name><argument_list>(<argument><expr><call><name>udataV</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>fp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lua_pushliteral</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lua_pushliteral</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"closed file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_libdef.h"</cpp:file></cpp:include>

<comment type="block">/* ------------------------------------------------------------------------ */</comment>

<function><type><specifier>static</specifier> <name>GCobj</name> <modifier>*</modifier></type><name>io_std_new</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>IOFileUD</name> <modifier>*</modifier></type><name>iof</name> <init>= <expr><operator>(</operator><name>IOFileUD</name> <operator>*</operator><operator>)</operator><call><name>lua_newuserdata</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IOFileUD</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GCudata</name> <modifier>*</modifier></type><name>ud</name> <init>= <expr><call><name>udataV</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>ud</name><operator>-&gt;</operator><name>udtype</name></name> <operator>=</operator> <name>UDTYPE_IO_FILE</name></expr>;</expr_stmt>
  <comment type="block">/* NOBARRIER: The GCudata is new (marked white). */</comment>
  <expr_stmt><expr><call><name>setgcref</name><argument_list>(<argument><expr><name><name>ud</name><operator>-&gt;</operator><name>metatable</name></name></expr></argument>, <argument><expr><call><name>gcV</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>iof</name><operator>-&gt;</operator><name>fp</name></name> <operator>=</operator> <name>fp</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>iof</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>IOFILE_TYPE_STDF</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_setfield</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>obj2gco</name><argument_list>(<argument><expr><name>ud</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>LUALIB_API</name> <name>int</name></type> <name>luaopen_io</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>LJ_LIB_REG</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>io_method</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_setfield</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LUA_REGISTRYINDEX</name></expr></argument>, <argument><expr><name>LUA_FILEHANDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>LJ_LIB_REG</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LUA_IOLIBNAME</name></expr></argument>, <argument><expr><name>io</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setgcref</name><argument_list>(<argument><expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>gcroot</name><index>[<expr><name>GCROOT_IO_INPUT</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>io_std_new</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>stdin</name></expr></argument>, <argument><expr><literal type="string">"stdin"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setgcref</name><argument_list>(<argument><expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>gcroot</name><index>[<expr><name>GCROOT_IO_OUTPUT</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>io_std_new</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>stdout</name></expr></argument>, <argument><expr><literal type="string">"stdout"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>io_std_new</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"stderr"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

</unit>
