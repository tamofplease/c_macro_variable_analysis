<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/sysbench/third_party/luajit/luajit/src/lj_cparse.c"><comment type="block">/*
** C declaration parser.
** Copyright (C) 2005-2020 Mike Pall. See Copyright Notice in luajit.h
*/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_obj.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_gc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_err.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_buf.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_ctype.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_cparse.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_frame.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_vm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_char.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_strscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_strfmt.h"</cpp:file></cpp:include>

<comment type="block">/*
** Important note: this is NOT a validating C parser! This is a minimal
** C declaration parser, solely for use by the LuaJIT FFI.
**
** It ought to return correct results for properly formed C declarations,
** but it may accept some invalid declarations, too (and return nonsense).
** Also, it shows rather generic error messages to avoid unnecessary bloat.
** If in doubt, please check the input against your favorite C compiler.
*/</comment>

<comment type="block">/* -- Miscellaneous ------------------------------------------------------- */</comment>

<comment type="block">/* Match string against a C literal. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>cp_str_is</name><parameter_list>(<parameter><type><name>str</name></type></parameter>, <parameter><type><name>k</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>((str)-&gt;len == sizeof(k)-1 &amp;&amp; !memcmp(strdata(str), k, sizeof(k)-1))</cpp:value></cpp:define>

<comment type="block">/* Check string against a linear list of matches. */</comment>
<function><type><name>int</name></type> <name>lj_cparse_case</name><parameter_list>(<parameter><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>match</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>MSize</name></type> <name>len</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
  <for>for  <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>len</name> <operator>=</operator> <operator>(</operator><name>MSize</name><operator>)</operator><operator>*</operator><name>match</name><operator>++</operator><operator>)</operator></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr><operator>,</operator> <expr><name>match</name> <operator>+=</operator> <name>len</name></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>str</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <name>len</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>memcmp</name><argument_list>(<argument><expr><name>match</name></expr></argument>, <argument><expr><call><name>strdata</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>n</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -- C lexer ------------------------------------------------------------- */</comment>

<comment type="block">/* C lexer token names. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>ctoknames</name><index>[]</index></name> <init>= <expr><block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTOKSTR</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>str</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>str,</cpp:value></cpp:define>
<macro><name>CTOKDEF</name><argument_list>(<argument>CTOKSTR</argument>)</argument_list></macro>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CTOKSTR</name></cpp:undef>
  <expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Forward declaration. */</comment>
<function_decl><type><name>LJ_NORET</name> <specifier>static</specifier> <name>void</name></type> <name>cp_err</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>ErrMsg</name></type> <name>em</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cp_tok2str</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>CPToken</name></type> <name>tok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>tok</name> <operator>&lt;</operator> <name>CTOK_FIRSTDECL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>tok</name> <operator>&gt;</operator> <name>CTOK_OFS</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name><name>ctoknames</name><index>[<expr><name>tok</name><operator>-</operator><name>CTOK_OFS</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</return></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>lj_char_iscntrl</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>lj_strfmt_pushf</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><literal type="string">"%c"</literal></expr></argument>, <argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <return>return <expr><call><name>lj_strfmt_pushf</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><literal type="string">"char(%d)"</literal></expr></argument>, <argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* End-of-line? */</comment>
<function><type><specifier>static</specifier> <name>LJ_AINLINE</name> <name>int</name></type> <name>cp_iseol</name><parameter_list>(<parameter><decl><type><name>CPChar</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><operator>(</operator><name>c</name> <operator>==</operator> <literal type="char">'\n'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'\r'</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Peek next raw character. */</comment>
<function><type><specifier>static</specifier> <name>LJ_AINLINE</name> <name>CPChar</name></type> <name>cp_rawpeek</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><operator>(</operator><name>CPChar</name><operator>)</operator><operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><operator>*</operator><name><name>cp</name><operator>-&gt;</operator><name>p</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>LJ_NOINLINE</name> <name>CPChar</name></type> <name>cp_get_bs</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Get next character. */</comment>
<function><type><specifier>static</specifier> <name>LJ_AINLINE</name> <name>CPChar</name></type> <name>cp_get</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>c</name></name> <operator>=</operator> <operator>(</operator><name>CPChar</name><operator>)</operator><operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><operator>*</operator><name><name>cp</name><operator>-&gt;</operator><name>p</name></name><operator>++</operator><operator>)</operator></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>LJ_LIKELY</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>c</name></name> <operator>!=</operator> <literal type="char">'\\'</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name><name>cp</name><operator>-&gt;</operator><name>c</name></name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><call><name>cp_get_bs</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Transparently skip backslash-escaped line breaks. */</comment>
<function><type><specifier>static</specifier> <name>LJ_NOINLINE</name> <name>CPChar</name></type> <name>cp_get_bs</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CPChar</name></type> <name>c2</name></decl>, <decl><type ref="prev"/><name>c</name> <init>= <expr><call><name>cp_rawpeek</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cp_iseol</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name><name>cp</name><operator>-&gt;</operator><name>c</name></name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>p</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>c2</name> <operator>=</operator> <call><name>cp_rawpeek</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>cp_iseol</name><argument_list>(<argument><expr><name>c2</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>c2</name> <operator>!=</operator> <name>c</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>p</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>linenumber</name></name><operator>++</operator></expr>;</expr_stmt>
  <return>return <expr><call><name>cp_get</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Save character in buffer. */</comment>
<function><type><specifier>static</specifier> <name>LJ_AINLINE</name> <name>void</name></type> <name>cp_save</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>CPChar</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>lj_buf_putb</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cp</name><operator>-&gt;</operator><name>sb</name></name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Skip line break. Handles "\n", "\r", "\r\n" or "\n\r". */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>cp_newline</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CPChar</name></type> <name>c</name> <init>= <expr><call><name>cp_rawpeek</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>cp_iseol</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name><name>cp</name><operator>-&gt;</operator><name>c</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>p</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>linenumber</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>LJ_NORET</name> <specifier>static</specifier> <name>void</name></type> <name>cp_errmsg</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>CPToken</name></type> <name>tok</name></decl></parameter>, <parameter><decl><type><name>ErrMsg</name></type> <name>em</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tokstr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>va_list</name></type> <name>argp</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>tok</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>tokstr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>tok</name> <operator>==</operator> <name>CTOK_IDENT</name> <operator>||</operator> <name>tok</name> <operator>==</operator> <name>CTOK_INTEGER</name> <operator>||</operator> <name>tok</name> <operator>==</operator> <name>CTOK_STRING</name> <operator>||</operator>
	     <name>tok</name> <operator>&gt;=</operator> <name>CTOK_FIRSTDECL</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>sbufP</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cp</name><operator>-&gt;</operator><name>sb</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>sbufB</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cp</name><operator>-&gt;</operator><name>sb</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>cp_save</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">'$'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>cp_save</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tokstr</name> <operator>=</operator> <call><name>sbufB</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cp</name><operator>-&gt;</operator><name>sb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name>tokstr</name> <operator>=</operator> <call><name>cp_tok2str</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>L</name> <operator>=</operator> <name><name>cp</name><operator>-&gt;</operator><name>L</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>argp</name></expr></argument>, <argument><expr><name>em</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>lj_strfmt_pushvf</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>err2msg</name><argument_list>(<argument><expr><name>em</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>argp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>argp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>tokstr</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>lj_strfmt_pushf</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>err2msg</name><argument_list>(<argument><expr><name>LJ_ERR_XNEAR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>tokstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>linenumber</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>lj_strfmt_pushf</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"%s at line %d"</literal></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name><name>cp</name><operator>-&gt;</operator><name>linenumber</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>lj_err_callermsg</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>LJ_NORET</name> <name>LJ_NOINLINE</name> <specifier>static</specifier> <name>void</name></type> <name>cp_err_token</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>CPToken</name></type> <name>tok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>cp_errmsg</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name><name>cp</name><operator>-&gt;</operator><name>tok</name></name></expr></argument>, <argument><expr><name>LJ_ERR_XTOKEN</name></expr></argument>, <argument><expr><call><name>cp_tok2str</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>LJ_NORET</name> <name>LJ_NOINLINE</name> <specifier>static</specifier> <name>void</name></type> <name>cp_err_badidx</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>lj_ctype_repr</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cts</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><call><name>ctype_typeid</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cts</name></name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>cp_errmsg</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>LJ_ERR_FFI_BADIDX</name></expr></argument>, <argument><expr><call><name>strdata</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>LJ_NORET</name> <name>LJ_NOINLINE</name> <specifier>static</specifier> <name>void</name></type> <name>cp_err</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>ErrMsg</name></type> <name>em</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>cp_errmsg</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>em</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* -- Main lexical scanner ------------------------------------------------ */</comment>

<comment type="block">/* Parse number literal. Only handles int32_t/uint32_t right now. */</comment>
<function><type><specifier>static</specifier> <name>CPToken</name></type> <name>cp_number</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>StrScanFmt</name></type> <name>fmt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TValue</name></type> <name>o</name></decl>;</decl_stmt>
  <do>do <block>{<block_content> <expr_stmt><expr><call><name>cp_save</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name><name>cp</name><operator>-&gt;</operator><name>c</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block> while <condition>(<expr><call><name>lj_char_isident</name><argument_list>(<argument><expr><call><name>cp_get</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>;</do>
  <expr_stmt><expr><call><name>cp_save</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>fmt</name> <operator>=</operator> <call><name>lj_strscan_scan</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>uint8_t</name> <operator>*</operator><operator>)</operator><call><name>sbufB</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cp</name><operator>-&gt;</operator><name>sb</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>sbuflen</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cp</name><operator>-&gt;</operator><name>sb</name></name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr></argument>,
			<argument><expr><operator>&amp;</operator><name>o</name></expr></argument>, <argument><expr><name>STRSCAN_OPT_C</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>fmt</name> <operator>==</operator> <name>STRSCAN_INT</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>id</name></name> <operator>=</operator> <name>CTID_INT32</name></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><name>fmt</name> <operator>==</operator> <name>STRSCAN_U32</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>id</name></name> <operator>=</operator> <name>CTID_UINT32</name></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>cp</name><operator>-&gt;</operator><name>mode</name></name> <operator>&amp;</operator> <name>CPARSE_MODE_SKIP</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>cp_errmsg</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>CTOK_INTEGER</name></expr></argument>, <argument><expr><name>LJ_ERR_XNUMBER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>u32</name></name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>o</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
  <return>return <expr><name>CTOK_INTEGER</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Parse identifier or keyword. */</comment>
<function><type><specifier>static</specifier> <name>CPToken</name></type> <name>cp_ident</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <do>do <block>{<block_content> <expr_stmt><expr><call><name>cp_save</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name><name>cp</name><operator>-&gt;</operator><name>c</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block> while <condition>(<expr><call><name>lj_char_isident</name><argument_list>(<argument><expr><call><name>cp_get</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>;</do>
  <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>str</name></name> <operator>=</operator> <call><name>lj_buf_str</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cp</name><operator>-&gt;</operator><name>sb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>id</name></name> <operator>=</operator> <call><name>lj_ctype_getname</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cts</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cp</name><operator>-&gt;</operator><name>ct</name></name></expr></argument>, <argument><expr><name><name>cp</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name><name>cp</name><operator>-&gt;</operator><name>tmask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>ctype_type</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CT_KW</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>ctype_cid</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name>CTOK_IDENT</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Parse parameter. */</comment>
<function><type><specifier>static</specifier> <name>CPToken</name></type> <name>cp_param</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CPChar</name></type> <name>c</name> <init>= <expr><call><name>cp_get</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><name><name>cp</name><operator>-&gt;</operator><name>param</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>lj_char_isident</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'$'</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* Reserve $xyz for future extensions. */</comment>
    <expr_stmt><expr><call><name>cp_errmsg</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>LJ_ERR_XSYNTAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>o</name> <operator>||</operator> <name>o</name> <operator>&gt;=</operator> <name><name>cp</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>top</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>cp_err</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>LJ_ERR_FFI_NUMPARAM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>param</name></name> <operator>=</operator> <name>o</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>tvisstr</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>str</name></name> <operator>=</operator> <call><name>strV</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>id</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>ct</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>cp</name><operator>-&gt;</operator><name>cts</name><operator>-&gt;</operator><name>tab</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <return>return <expr><name>CTOK_IDENT</name></expr>;</return>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>tvisnumber</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>i32</name></name> <operator>=</operator> <call><name>numberVint</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>id</name></name> <operator>=</operator> <name>CTID_INT32</name></expr>;</expr_stmt>
    <return>return <expr><name>CTOK_INTEGER</name></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>GCcdata</name> <modifier>*</modifier></type><name>cd</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tviscdata</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>lj_err_argtype</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>o</name><operator>-</operator><name><name>cp</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>)</operator><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"type parameter"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>cd</name> <operator>=</operator> <call><name>cdataV</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>cd</name><operator>-&gt;</operator><name>ctypeid</name></name> <operator>==</operator> <name>CTID_CTYPEID</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>id</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>CTypeID</name> <operator>*</operator><operator>)</operator><call><name>cdataptr</name><argument_list>(<argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>id</name></name> <operator>=</operator> <name><name>cd</name><operator>-&gt;</operator><name>ctypeid</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <return>return <expr><literal type="char">'$'</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Parse string or character constant. */</comment>
<function><type><specifier>static</specifier> <name>CPToken</name></type> <name>cp_string</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CPChar</name></type> <name>delim</name> <init>= <expr><name><name>cp</name><operator>-&gt;</operator><name>c</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>cp_get</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>c</name></name> <operator>!=</operator> <name>delim</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>CPChar</name></type> <name>c</name> <init>= <expr><name><name>cp</name><operator>-&gt;</operator><name>c</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>cp_errmsg</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>CTOK_EOF</name></expr></argument>, <argument><expr><name>LJ_ERR_XSTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>cp_get</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{<block_content>
      <case>case <expr><literal type="char">'\0'</literal></expr>:</case> <expr_stmt><expr><call><name>cp_errmsg</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>CTOK_EOF</name></expr></argument>, <argument><expr><name>LJ_ERR_XSTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
      <case>case <expr><literal type="char">'a'</literal></expr>:</case> <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'\a'</literal></expr>;</expr_stmt> <break>break;</break>
      <case>case <expr><literal type="char">'b'</literal></expr>:</case> <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'\b'</literal></expr>;</expr_stmt> <break>break;</break>
      <case>case <expr><literal type="char">'f'</literal></expr>:</case> <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'\f'</literal></expr>;</expr_stmt> <break>break;</break>
      <case>case <expr><literal type="char">'n'</literal></expr>:</case> <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'\n'</literal></expr>;</expr_stmt> <break>break;</break>
      <case>case <expr><literal type="char">'r'</literal></expr>:</case> <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'\r'</literal></expr>;</expr_stmt> <break>break;</break>
      <case>case <expr><literal type="char">'t'</literal></expr>:</case> <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'\t'</literal></expr>;</expr_stmt> <break>break;</break>
      <case>case <expr><literal type="char">'v'</literal></expr>:</case> <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'\v'</literal></expr>;</expr_stmt> <break>break;</break>
      <case>case <expr><literal type="char">'e'</literal></expr>:</case> <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">27</literal></expr>;</expr_stmt> <break>break;</break>
      <case>case <expr><literal type="char">'x'</literal></expr>:</case>
	<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><call><name>lj_char_isxdigit</name><argument_list>(<argument><expr><call><name>cp_get</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name>c</name><operator>&lt;&lt;</operator><literal type="number">4</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><ternary><condition><expr><call><name>lj_char_isdigit</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>c</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name><name>cp</name><operator>-&gt;</operator><name>c</name></name><operator>-</operator><literal type="char">'0'</literal></expr> </then><else>: <expr><operator>(</operator><name><name>cp</name><operator>-&gt;</operator><name>c</name></name><operator>&amp;</operator><literal type="number">15</literal><operator>)</operator><operator>+</operator><literal type="number">9</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt></block_content></block></while>
	<expr_stmt><expr><call><name>cp_save</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><operator>(</operator><name>c</name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<continue>continue;</continue>
      <default>default:</default>
	<if_stmt><if>if <condition>(<expr><call><name>lj_char_isdigit</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><name>c</name> <operator>-=</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
	  <if_stmt><if>if <condition>(<expr><call><name>lj_char_isdigit</name><argument_list>(<argument><expr><call><name>cp_get</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	    <expr_stmt><expr><name>c</name> <operator>=</operator> <name>c</name><operator>*</operator><literal type="number">8</literal> <operator>+</operator> <operator>(</operator><name><name>cp</name><operator>-&gt;</operator><name>c</name></name> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr>;</expr_stmt>
	    <if_stmt><if>if <condition>(<expr><call><name>lj_char_isdigit</name><argument_list>(<argument><expr><call><name>cp_get</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	      <expr_stmt><expr><name>c</name> <operator>=</operator> <name>c</name><operator>*</operator><literal type="number">8</literal> <operator>+</operator> <operator>(</operator><name><name>cp</name><operator>-&gt;</operator><name>c</name></name> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr>;</expr_stmt>
	      <expr_stmt><expr><call><name>cp_get</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    </block_content>}</block></if></if_stmt>
	  </block_content>}</block></if></if_stmt>
	  <expr_stmt><expr><call><name>cp_save</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><operator>(</operator><name>c</name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <continue>continue;</continue>
	</block_content>}</block></if></if_stmt>
	<break>break;</break>
      </block_content>}</block></switch>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>cp_save</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>cp_get</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>cp_get</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>delim</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>str</name></name> <operator>=</operator> <call><name>lj_buf_str</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cp</name><operator>-&gt;</operator><name>sb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>CTOK_STRING</name></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>sbuflen</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cp</name><operator>-&gt;</operator><name>sb</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>cp_err_token</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">'\''</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>i32</name></name> <operator>=</operator> <operator>(</operator><name>int32_t</name><operator>)</operator><operator>(</operator><name>char</name><operator>)</operator><operator>*</operator><call><name>sbufB</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cp</name><operator>-&gt;</operator><name>sb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>id</name></name> <operator>=</operator> <name>CTID_INT32</name></expr>;</expr_stmt>
    <return>return <expr><name>CTOK_INTEGER</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Skip C comment. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>cp_comment_c</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <do>do <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>cp_get</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition> <block>{<block_content>
      <do>do <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>cp_get</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition> <block>{<block_content> <expr_stmt><expr><call><name>cp_get</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return;</return> </block_content>}</block></if></if_stmt>
      </block_content>}</block> while <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>c</name></name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition>;</do>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>cp_iseol</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>c</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>cp_newline</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block> while <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>c</name></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>;</do>
</block_content>}</block></function>

<comment type="block">/* Skip C++ comment. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>cp_comment_cpp</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <while>while <condition>(<expr><operator>!</operator><call><name>cp_iseol</name><argument_list>(<argument><expr><call><name>cp_get</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>cp</name><operator>-&gt;</operator><name>c</name></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
    <empty_stmt>;</empty_stmt></block_content></block></while>
</block_content>}</block></function>

<comment type="block">/* Lexical scanner for C. Only a minimal subset is implemented. */</comment>
<function><type><specifier>static</specifier> <name>CPToken</name></type> <name>cp_next_</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>lj_buf_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cp</name><operator>-&gt;</operator><name>sb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>lj_char_isident</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>c</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><ternary><condition><expr><call><name>lj_char_isdigit</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>c</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>cp_number</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>cp_ident</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>
    <switch>switch <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>c</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><literal type="char">'\n'</literal></expr>:</case> <case>case <expr><literal type="char">'\r'</literal></expr>:</case> <expr_stmt><expr><call><name>cp_newline</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* fallthrough. */</comment>
    <case>case <expr><literal type="char">' '</literal></expr>:</case> <case>case <expr><literal type="char">'\t'</literal></expr>:</case> <case>case <expr><literal type="char">'\v'</literal></expr>:</case> <case>case <expr><literal type="char">'\f'</literal></expr>:</case> <expr_stmt><expr><call><name>cp_get</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><literal type="char">'"'</literal></expr>:</case> <case>case <expr><literal type="char">'\''</literal></expr>:</case> <return>return <expr><call><name>cp_string</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><literal type="char">'/'</literal></expr>:</case>
      <if_stmt><if>if <condition>(<expr><call><name>cp_get</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>cp_comment_c</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
      <if type="elseif">else if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>c</name></name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>cp_comment_cpp</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
      <else>else<block type="pseudo"><block_content> <return>return <expr><literal type="char">'/'</literal></expr>;</return></block_content></block></else></if_stmt>
      <break>break;</break>
    <case>case <expr><literal type="char">'|'</literal></expr>:</case>
      <if_stmt><if>if <condition>(<expr><call><name>cp_get</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="char">'|'</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="char">'|'</literal></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>cp_get</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>CTOK_OROR</name></expr>;</return>
    <case>case <expr><literal type="char">'&amp;'</literal></expr>:</case>
      <if_stmt><if>if <condition>(<expr><call><name>cp_get</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="char">'&amp;'</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="char">'&amp;'</literal></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>cp_get</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>CTOK_ANDAND</name></expr>;</return>
    <case>case <expr><literal type="char">'='</literal></expr>:</case>
      <if_stmt><if>if <condition>(<expr><call><name>cp_get</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="char">'='</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="char">'='</literal></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>cp_get</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>CTOK_EQ</name></expr>;</return>
    <case>case <expr><literal type="char">'!'</literal></expr>:</case>
      <if_stmt><if>if <condition>(<expr><call><name>cp_get</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="char">'='</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="char">'!'</literal></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>cp_get</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>CTOK_NE</name></expr>;</return>
    <case>case <expr><literal type="char">'&lt;'</literal></expr>:</case>
      <if_stmt><if>if <condition>(<expr><call><name>cp_get</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition> <block>{<block_content> <expr_stmt><expr><call><name>cp_get</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>CTOK_LE</name></expr>;</return> </block_content>}</block></if>
      <if type="elseif">else if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>c</name></name> <operator>==</operator> <literal type="char">'&lt;'</literal></expr>)</condition> <block>{<block_content> <expr_stmt><expr><call><name>cp_get</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>CTOK_SHL</name></expr>;</return> </block_content>}</block></if></if_stmt>
      <return>return <expr><literal type="char">'&lt;'</literal></expr>;</return>
    <case>case <expr><literal type="char">'&gt;'</literal></expr>:</case>
      <if_stmt><if>if <condition>(<expr><call><name>cp_get</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition> <block>{<block_content> <expr_stmt><expr><call><name>cp_get</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>CTOK_GE</name></expr>;</return> </block_content>}</block></if>
      <if type="elseif">else if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>c</name></name> <operator>==</operator> <literal type="char">'&gt;'</literal></expr>)</condition> <block>{<block_content> <expr_stmt><expr><call><name>cp_get</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>CTOK_SHR</name></expr>;</return> </block_content>}</block></if></if_stmt>
      <return>return <expr><literal type="char">'&gt;'</literal></expr>;</return>
    <case>case <expr><literal type="char">'-'</literal></expr>:</case>
      <if_stmt><if>if <condition>(<expr><call><name>cp_get</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="char">'&gt;'</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="char">'-'</literal></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>cp_get</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>CTOK_DEREF</name></expr>;</return>
    <case>case <expr><literal type="char">'$'</literal></expr>:</case>
      <return>return <expr><call><name>cp_param</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><literal type="char">'\0'</literal></expr>:</case> <return>return <expr><name>CTOK_EOF</name></expr>;</return>
    <default>default:</default> <block>{<block_content> <decl_stmt><decl><type><name>CPToken</name></type> <name>c</name> <init>= <expr><name><name>cp</name><operator>-&gt;</operator><name>c</name></name></expr></init></decl>;</decl_stmt> <expr_stmt><expr><call><name>cp_get</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>c</name></expr>;</return> </block_content>}</block>
    </block_content>}</block></switch>
  </block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>LJ_NOINLINE</name> <name>CPToken</name></type> <name>cp_next</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><operator>(</operator><name><name>cp</name><operator>-&gt;</operator><name>tok</name></name> <operator>=</operator> <call><name>cp_next_</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -- C parser ------------------------------------------------------------ */</comment>

<comment type="block">/* Namespaces for resolving identifiers. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CPNS_DEFAULT</name></cpp:macro> \
  <cpp:value>((1u&lt;&lt;CT_KW)|(1u&lt;&lt;CT_TYPEDEF)|(1u&lt;&lt;CT_FUNC)|(1u&lt;&lt;CT_EXTERN)|(1u&lt;&lt;CT_CONSTVAL))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CPNS_STRUCT</name></cpp:macro>	<cpp:value>((1u&lt;&lt;CT_KW)|(1u&lt;&lt;CT_STRUCT)|(1u&lt;&lt;CT_ENUM))</cpp:value></cpp:define>

<typedef>typedef <type><name>CTypeID</name></type> <name>CPDeclIdx</name>;</typedef>	<comment type="block">/* Index into declaration stack. */</comment>
<typedef>typedef <type><name>uint32_t</name></type> <name>CPscl</name>;</typedef>		<comment type="block">/* Storage class flags. */</comment>

<comment type="block">/* Type declaration context. */</comment>
<typedef>typedef <type><struct>struct <name>CPDecl</name> <block>{
  <decl_stmt><decl><type><name>CPDeclIdx</name></type> <name>top</name></decl>;</decl_stmt>	<comment type="block">/* Top of declaration stack. */</comment>
  <decl_stmt><decl><type><name>CPDeclIdx</name></type> <name>pos</name></decl>;</decl_stmt>	<comment type="block">/* Insertion position in declaration chain. */</comment>
  <decl_stmt><decl><type><name>CPDeclIdx</name></type> <name>specpos</name></decl>;</decl_stmt>	<comment type="block">/* Saved position for declaration specifier. */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>mode</name></decl>;</decl_stmt>	<comment type="block">/* Declarator mode. */</comment>
  <decl_stmt><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>		<comment type="block">/* C parser state. */</comment>
  <decl_stmt><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>		<comment type="block">/* Name of declared identifier (if direct). */</comment>
  <decl_stmt><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>redir</name></decl>;</decl_stmt>		<comment type="block">/* Redirected symbol name. */</comment>
  <decl_stmt><decl><type><name>CTypeID</name></type> <name>nameid</name></decl>;</decl_stmt>	<comment type="block">/* Existing typedef for declared identifier. */</comment>
  <decl_stmt><decl><type><name>CTInfo</name></type> <name>attr</name></decl>;</decl_stmt>		<comment type="block">/* Attributes. */</comment>
  <decl_stmt><decl><type><name>CTInfo</name></type> <name>fattr</name></decl>;</decl_stmt>		<comment type="block">/* Function attributes. */</comment>
  <decl_stmt><decl><type><name>CTInfo</name></type> <name>specattr</name></decl>;</decl_stmt>	<comment type="block">/* Saved attributes. */</comment>
  <decl_stmt><decl><type><name>CTInfo</name></type> <name>specfattr</name></decl>;</decl_stmt>	<comment type="block">/* Saved function attributes. */</comment>
  <decl_stmt><decl><type><name>CTSize</name></type> <name>bits</name></decl>;</decl_stmt>		<comment type="block">/* Field size in bits (if any). */</comment>
  <decl_stmt><decl><type><name>CType</name></type> <name><name>stack</name><index>[<expr><name>CPARSE_MAX_DECLSTACK</name></expr>]</index></name></decl>;</decl_stmt>  <comment type="block">/* Type declaration stack. */</comment>
}</block></struct></type> <name>CPDecl</name>;</typedef>

<comment type="block">/* Forward declarations. */</comment>
<function_decl><type><specifier>static</specifier> <name>CPscl</name></type> <name>cp_decl_spec</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>CPDecl</name> <modifier>*</modifier></type><name>decl</name></decl></parameter>, <parameter><decl><type><name>CPscl</name></type> <name>scl</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>cp_declarator</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>CPDecl</name> <modifier>*</modifier></type><name>decl</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>CTypeID</name></type> <name>cp_decl_abstract</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Initialize C parser state. Caller must set up: L, p, srcname, mode. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>cp_init</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>linenumber</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>depth</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>curpack</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>packstack</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">255</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lj_buf_init</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cp</name><operator>-&gt;</operator><name>sb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>p</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>cp_get</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Read-ahead first char. */</comment>
  <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>tok</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>tmask</name></name> <operator>=</operator> <name>CPNS_DEFAULT</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>cp_next</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Read-ahead first token. */</comment>
</block_content>}</block></function>

<comment type="block">/* Cleanup C parser state. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>cp_cleanup</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name> <init>= <expr><call><name>G</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>L</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lj_buf_free</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cp</name><operator>-&gt;</operator><name>sb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Check and consume optional token. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>cp_opt</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>CPToken</name></type> <name>tok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>tok</name></name> <operator>==</operator> <name>tok</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><call><name>cp_next</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><literal type="number">1</literal></expr>;</return> </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Check and consume token. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>cp_check</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>CPToken</name></type> <name>tok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>tok</name></name> <operator>!=</operator> <name>tok</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>cp_err_token</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>cp_next</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Check if the next token may start a type declaration. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>cp_istypedecl</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>tok</name></name> <operator>&gt;=</operator> <name>CTOK_FIRSTDECL</name> <operator>&amp;&amp;</operator> <name><name>cp</name><operator>-&gt;</operator><name>tok</name></name> <operator>&lt;=</operator> <name>CTOK_LASTDECL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>tok</name></name> <operator>==</operator> <name>CTOK_IDENT</name> <operator>&amp;&amp;</operator> <call><name>ctype_istypedef</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>tok</name></name> <operator>==</operator> <literal type="char">'$'</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -- Constant expression evaluator --------------------------------------- */</comment>

<comment type="block">/* Forward declarations. */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>cp_expr_unary</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>CPValue</name> <modifier>*</modifier></type><name>k</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>cp_expr_sub</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>CPValue</name> <modifier>*</modifier></type><name>k</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pri</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Please note that type handling is very weak here. Most ops simply
** assume integer operands. Accessors are only needed to compute types and
** return synthetic values. The only purpose of the expression evaluator
** is to compute the values of constant expressions one would typically
** find in C header files. And again: this is NOT a validating C parser!
*/</comment>

<comment type="block">/* Parse comma separated expression and return last result. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>cp_expr_comma</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>CPValue</name> <modifier>*</modifier></type><name>k</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <do>do <block>{<block_content> <expr_stmt><expr><call><name>cp_expr_sub</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block> while <condition>(<expr><call><name>cp_opt</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>)</condition>;</do>
</block_content>}</block></function>

<comment type="block">/* Parse sizeof/alignof operator. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>cp_expr_sizeof</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>CPValue</name> <modifier>*</modifier></type><name>k</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>wantsz</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CTSize</name></type> <name>sz</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTInfo</name></type> <name>info</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>cp_opt</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>cp_istypedecl</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <call><name>cp_decl_abstract</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>cp_expr_comma</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>cp_check</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>cp_expr_unary</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>lj_ctype_info</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cts</name></name></expr></argument>, <argument><expr><name><name>k</name><operator>-&gt;</operator><name>id</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>wantsz</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>sz</name> <operator>!=</operator> <name>CTSIZE_INVALID</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>u32</name></name> <operator>=</operator> <name>sz</name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name><name>k</name><operator>-&gt;</operator><name>id</name></name> <operator>!=</operator> <name>CTID_A_CCHAR</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* Special case for sizeof("string"). */</comment>
      <expr_stmt><expr><call><name>cp_err</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>LJ_ERR_FFI_INVSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>u32</name></name> <operator>=</operator> <literal type="number">1u</literal> <operator>&lt;&lt;</operator> <call><name>ctype_align</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <name>CTID_UINT32</name></expr>;</expr_stmt>  <comment type="block">/* Really size_t. */</comment>
</block_content>}</block></function>

<comment type="block">/* Parse prefix operators. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>cp_expr_prefix</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>CPValue</name> <modifier>*</modifier></type><name>k</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>tok</name></name> <operator>==</operator> <name>CTOK_INTEGER</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>k</name> <operator>=</operator> <name><name>cp</name><operator>-&gt;</operator><name>val</name></name></expr>;</expr_stmt> <expr_stmt><expr><call><name>cp_next</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>cp_opt</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">'+'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>cp_expr_unary</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Nothing to do (well, integer promotion). */</comment>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>cp_opt</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">'-'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>cp_expr_unary</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>i32</name></name> <operator>=</operator> <operator>-</operator><name><name>k</name><operator>-&gt;</operator><name>i32</name></name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>cp_opt</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">'~'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>cp_expr_unary</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>i32</name></name> <operator>=</operator> <operator>~</operator><name><name>k</name><operator>-&gt;</operator><name>i32</name></name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>cp_opt</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">'!'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>cp_expr_unary</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>i32</name></name> <operator>=</operator> <operator>!</operator><name><name>k</name><operator>-&gt;</operator><name>i32</name></name></expr>;</expr_stmt> <expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <name>CTID_INT32</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>cp_opt</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>cp_istypedecl</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Cast operator. */</comment>
      <decl_stmt><decl><type><name>CTypeID</name></type> <name>id</name> <init>= <expr><call><name>cp_decl_abstract</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>cp_check</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>cp_expr_unary</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <name>id</name></expr>;</expr_stmt>  <comment type="block">/* No conversion performed. */</comment>
    </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* Sub-expression. */</comment>
      <expr_stmt><expr><call><name>cp_expr_comma</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>cp_check</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>cp_opt</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">'*'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Indirection. */</comment>
    <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>cp_expr_unary</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>lj_ctype_rawref</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cts</name></name></expr></argument>, <argument><expr><name><name>k</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ctype_ispointer</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>cp_err_badidx</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>u32</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <call><name>ctype_cid</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>cp_opt</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">'&amp;'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Address operator. */</comment>
    <expr_stmt><expr><call><name>cp_expr_unary</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <call><name>lj_ctype_intern</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cts</name></name></expr></argument>, <argument><expr><call><name>CTINFO</name><argument_list>(<argument><expr><name>CT_PTR</name></expr></argument>, <argument><expr><name>CTALIGN_PTR</name><operator>+</operator><name><name>k</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr></argument>,
			    <argument><expr><name>CTSIZE_PTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>cp_opt</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>CTOK_SIZEOF</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>cp_expr_sizeof</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>cp_opt</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>CTOK_ALIGNOF</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>cp_expr_sizeof</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>tok</name></name> <operator>==</operator> <name>CTOK_IDENT</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>ctype_type</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CT_CONSTVAL</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>u32</name></name> <operator>=</operator> <name><name>cp</name><operator>-&gt;</operator><name>ct</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt> <expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <call><name>ctype_cid</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ctype_type</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CT_EXTERN</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>u32</name></name> <operator>=</operator> <name><name>cp</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>id</name></name></expr>;</expr_stmt> <expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <call><name>ctype_cid</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ctype_type</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CT_FUNC</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>u32</name></name> <operator>=</operator> <name><name>cp</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>id</name></name></expr>;</expr_stmt> <expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <name><name>cp</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>id</name></name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <goto>goto <name>err_expr</name>;</goto>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>cp_next</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>tok</name></name> <operator>==</operator> <name>CTOK_STRING</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>CTSize</name></type> <name>sz</name> <init>= <expr><name><name>cp</name><operator>-&gt;</operator><name>str</name><operator>-&gt;</operator><name>len</name></name></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><call><name>cp_next</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CTOK_STRING</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>sz</name> <operator>+=</operator> <name><name>cp</name><operator>-&gt;</operator><name>str</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt></block_content></block></while>
    <expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>u32</name></name> <operator>=</operator> <name>sz</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <name>CTID_A_CCHAR</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
  <label><name>err_expr</name>:</label>
    <expr_stmt><expr><call><name>cp_errmsg</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name><name>cp</name><operator>-&gt;</operator><name>tok</name></name></expr></argument>, <argument><expr><name>LJ_ERR_XSYMBOL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Parse postfix operators. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>cp_expr_postfix</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>CPValue</name> <modifier>*</modifier></type><name>k</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>cp_opt</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">'['</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Array/pointer index. */</comment>
      <decl_stmt><decl><type><name>CPValue</name></type> <name>k2</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>cp_expr_comma</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>k2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>lj_ctype_rawref</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cts</name></name></expr></argument>, <argument><expr><name><name>k</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ctype_ispointer</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>lj_ctype_rawref</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cts</name></name></expr></argument>, <argument><expr><name><name>k2</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ctype_ispointer</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><call><name>cp_err_badidx</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>cp_check</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">']'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>u32</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>tok</name></name> <operator>==</operator> <literal type="char">'.'</literal> <operator>||</operator> <name><name>cp</name><operator>-&gt;</operator><name>tok</name></name> <operator>==</operator> <name>CTOK_DEREF</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Struct deref. */</comment>
      <decl_stmt><decl><type><name>CTSize</name></type> <name>ofs</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>fct</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>lj_ctype_rawref</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cts</name></name></expr></argument>, <argument><expr><name><name>k</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>tok</name></name> <operator>==</operator> <name>CTOK_DEREF</name></expr>)</condition> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ctype_ispointer</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><call><name>cp_err_badidx</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>lj_ctype_rawref</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cts</name></name></expr></argument>, <argument><expr><call><name>ctype_cid</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>cp_next</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>tok</name></name> <operator>!=</operator> <name>CTOK_IDENT</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>cp_err_token</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>CTOK_IDENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ctype_isstruct</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>ct</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <name>CTSIZE_INVALID</name> <operator>||</operator>
	  <operator>!</operator><operator>(</operator><name>fct</name> <operator>=</operator> <call><name>lj_ctype_getfield</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cts</name></name></expr></argument>, <argument><expr><name>ct</name></expr></argument>, <argument><expr><name><name>cp</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ofs</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
	  <call><name>ctype_isbitfield</name><argument_list>(<argument><expr><name><name>fct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<decl_stmt><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>lj_ctype_repr</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cts</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><call><name>ctype_typeid</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cts</name></name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>cp_errmsg</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>LJ_ERR_FFI_BADMEMBER</name></expr></argument>, <argument><expr><call><name>strdata</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strdata</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>str</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>ct</name> <operator>=</operator> <name>fct</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>u32</name></name> <operator>=</operator> <ternary><condition><expr><call><name>ctype_isconstval</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name><name>ct</name><operator>-&gt;</operator><name>size</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>cp_next</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <return>return;</return>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <call><name>ctype_cid</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* Parse infix operators. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>cp_expr_infix</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>CPValue</name> <modifier>*</modifier></type><name>k</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pri</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CPValue</name></type> <name>k2</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>k2</name><operator>.</operator><name>u32</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <expr_stmt><expr><name><name>k2</name><operator>.</operator><name>id</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* Silence the compiler. */</comment>
  <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
    <switch>switch <condition>(<expr><name>pri</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><literal type="number">0</literal></expr>:</case>
      <if_stmt><if>if <condition>(<expr><call><name>cp_opt</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">'?'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<decl_stmt><decl><type><name>CPValue</name></type> <name>k3</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>cp_expr_comma</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>k2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Right-associative. */</comment>
	<expr_stmt><expr><call><name>cp_check</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>cp_expr_sub</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>k3</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>u32</name></name> <operator>=</operator> <ternary><condition><expr><name><name>k</name><operator>-&gt;</operator><name>u32</name></name></expr> ?</condition><then> <expr><name><name>k2</name><operator>.</operator><name>u32</name></name></expr> </then><else>: <expr><name><name>k3</name><operator>.</operator><name>u32</name></name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <ternary><condition><expr><name><name>k2</name><operator>.</operator><name>id</name></name> <operator>&gt;</operator> <name><name>k3</name><operator>.</operator><name>id</name></name></expr> ?</condition><then> <expr><name><name>k2</name><operator>.</operator><name>id</name></name></expr> </then><else>: <expr><name><name>k3</name><operator>.</operator><name>id</name></name></expr></else></ternary></expr>;</expr_stmt>
	<continue>continue;</continue>
      </block_content>}</block></if></if_stmt>
      <comment type="block">/* fallthrough */</comment>
    <case>case <expr><literal type="number">1</literal></expr>:</case>
      <if_stmt><if>if <condition>(<expr><call><name>cp_opt</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>CTOK_OROR</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>cp_expr_sub</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>k2</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>i32</name></name> <operator>=</operator> <name><name>k</name><operator>-&gt;</operator><name>u32</name></name> <operator>||</operator> <name><name>k2</name><operator>.</operator><name>u32</name></name></expr>;</expr_stmt> <expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <name>CTID_INT32</name></expr>;</expr_stmt>
	<continue>continue;</continue>
      </block_content>}</block></if></if_stmt>
      <comment type="block">/* fallthrough */</comment>
    <case>case <expr><literal type="number">2</literal></expr>:</case>
      <if_stmt><if>if <condition>(<expr><call><name>cp_opt</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>CTOK_ANDAND</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>cp_expr_sub</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>k2</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>i32</name></name> <operator>=</operator> <name><name>k</name><operator>-&gt;</operator><name>u32</name></name> <operator>&amp;&amp;</operator> <name><name>k2</name><operator>.</operator><name>u32</name></name></expr>;</expr_stmt> <expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <name>CTID_INT32</name></expr>;</expr_stmt>
	<continue>continue;</continue>
      </block_content>}</block></if></if_stmt>
      <comment type="block">/* fallthrough */</comment>
    <case>case <expr><literal type="number">3</literal></expr>:</case>
      <if_stmt><if>if <condition>(<expr><call><name>cp_opt</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">'|'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>cp_expr_sub</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>k2</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>u32</name></name> <operator>=</operator> <name><name>k</name><operator>-&gt;</operator><name>u32</name></name> <operator>|</operator> <name><name>k2</name><operator>.</operator><name>u32</name></name></expr>;</expr_stmt> <goto>goto <name>arith_result</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <comment type="block">/* fallthrough */</comment>
    <case>case <expr><literal type="number">4</literal></expr>:</case>
      <if_stmt><if>if <condition>(<expr><call><name>cp_opt</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">'^'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>cp_expr_sub</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>k2</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>u32</name></name> <operator>=</operator> <name><name>k</name><operator>-&gt;</operator><name>u32</name></name> <operator>^</operator> <name><name>k2</name><operator>.</operator><name>u32</name></name></expr>;</expr_stmt> <goto>goto <name>arith_result</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <comment type="block">/* fallthrough */</comment>
    <case>case <expr><literal type="number">5</literal></expr>:</case>
      <if_stmt><if>if <condition>(<expr><call><name>cp_opt</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">'&amp;'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>cp_expr_sub</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>k2</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>u32</name></name> <operator>=</operator> <name><name>k</name><operator>-&gt;</operator><name>u32</name></name> <operator>&amp;</operator> <name><name>k2</name><operator>.</operator><name>u32</name></name></expr>;</expr_stmt> <goto>goto <name>arith_result</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <comment type="block">/* fallthrough */</comment>
    <case>case <expr><literal type="number">6</literal></expr>:</case>
      <if_stmt><if>if <condition>(<expr><call><name>cp_opt</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>CTOK_EQ</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>cp_expr_sub</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>k2</name></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>i32</name></name> <operator>=</operator> <name><name>k</name><operator>-&gt;</operator><name>u32</name></name> <operator>==</operator> <name><name>k2</name><operator>.</operator><name>u32</name></name></expr>;</expr_stmt> <expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <name>CTID_INT32</name></expr>;</expr_stmt>
	<continue>continue;</continue>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>cp_opt</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>CTOK_NE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>cp_expr_sub</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>k2</name></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>i32</name></name> <operator>=</operator> <name><name>k</name><operator>-&gt;</operator><name>u32</name></name> <operator>!=</operator> <name><name>k2</name><operator>.</operator><name>u32</name></name></expr>;</expr_stmt> <expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <name>CTID_INT32</name></expr>;</expr_stmt>
	<continue>continue;</continue>
      </block_content>}</block></if></if_stmt>
      <comment type="block">/* fallthrough */</comment>
    <case>case <expr><literal type="number">7</literal></expr>:</case>
      <if_stmt><if>if <condition>(<expr><call><name>cp_opt</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">'&lt;'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>cp_expr_sub</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>k2</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>k</name><operator>-&gt;</operator><name>id</name></name> <operator>==</operator> <name>CTID_INT32</name> <operator>&amp;&amp;</operator> <name><name>k2</name><operator>.</operator><name>id</name></name> <operator>==</operator> <name>CTID_INT32</name></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>i32</name></name> <operator>=</operator> <name><name>k</name><operator>-&gt;</operator><name>i32</name></name> <operator>&lt;</operator> <name><name>k2</name><operator>.</operator><name>i32</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
	  <expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>i32</name></name> <operator>=</operator> <name><name>k</name><operator>-&gt;</operator><name>u32</name></name> <operator>&lt;</operator> <name><name>k2</name><operator>.</operator><name>u32</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <name>CTID_INT32</name></expr>;</expr_stmt>
	<continue>continue;</continue>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>cp_opt</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">'&gt;'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>cp_expr_sub</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>k2</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>k</name><operator>-&gt;</operator><name>id</name></name> <operator>==</operator> <name>CTID_INT32</name> <operator>&amp;&amp;</operator> <name><name>k2</name><operator>.</operator><name>id</name></name> <operator>==</operator> <name>CTID_INT32</name></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>i32</name></name> <operator>=</operator> <name><name>k</name><operator>-&gt;</operator><name>i32</name></name> <operator>&gt;</operator> <name><name>k2</name><operator>.</operator><name>i32</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
	  <expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>i32</name></name> <operator>=</operator> <name><name>k</name><operator>-&gt;</operator><name>u32</name></name> <operator>&gt;</operator> <name><name>k2</name><operator>.</operator><name>u32</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <name>CTID_INT32</name></expr>;</expr_stmt>
	<continue>continue;</continue>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>cp_opt</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>CTOK_LE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>cp_expr_sub</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>k2</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>k</name><operator>-&gt;</operator><name>id</name></name> <operator>==</operator> <name>CTID_INT32</name> <operator>&amp;&amp;</operator> <name><name>k2</name><operator>.</operator><name>id</name></name> <operator>==</operator> <name>CTID_INT32</name></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>i32</name></name> <operator>=</operator> <name><name>k</name><operator>-&gt;</operator><name>i32</name></name> <operator>&lt;=</operator> <name><name>k2</name><operator>.</operator><name>i32</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
	  <expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>i32</name></name> <operator>=</operator> <name><name>k</name><operator>-&gt;</operator><name>u32</name></name> <operator>&lt;=</operator> <name><name>k2</name><operator>.</operator><name>u32</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <name>CTID_INT32</name></expr>;</expr_stmt>
	<continue>continue;</continue>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>cp_opt</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>CTOK_GE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>cp_expr_sub</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>k2</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>k</name><operator>-&gt;</operator><name>id</name></name> <operator>==</operator> <name>CTID_INT32</name> <operator>&amp;&amp;</operator> <name><name>k2</name><operator>.</operator><name>id</name></name> <operator>==</operator> <name>CTID_INT32</name></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>i32</name></name> <operator>=</operator> <name><name>k</name><operator>-&gt;</operator><name>i32</name></name> <operator>&gt;=</operator> <name><name>k2</name><operator>.</operator><name>i32</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
	  <expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>i32</name></name> <operator>=</operator> <name><name>k</name><operator>-&gt;</operator><name>u32</name></name> <operator>&gt;=</operator> <name><name>k2</name><operator>.</operator><name>u32</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <name>CTID_INT32</name></expr>;</expr_stmt>
	<continue>continue;</continue>
      </block_content>}</block></if></if_stmt>
      <comment type="block">/* fallthrough */</comment>
    <case>case <expr><literal type="number">8</literal></expr>:</case>
      <if_stmt><if>if <condition>(<expr><call><name>cp_opt</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>CTOK_SHL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>cp_expr_sub</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>k2</name></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>u32</name></name> <operator>=</operator> <name><name>k</name><operator>-&gt;</operator><name>u32</name></name> <operator>&lt;&lt;</operator> <name><name>k2</name><operator>.</operator><name>u32</name></name></expr>;</expr_stmt>
	<continue>continue;</continue>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>cp_opt</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>CTOK_SHR</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>cp_expr_sub</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>k2</name></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>k</name><operator>-&gt;</operator><name>id</name></name> <operator>==</operator> <name>CTID_INT32</name></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>i32</name></name> <operator>=</operator> <name><name>k</name><operator>-&gt;</operator><name>i32</name></name> <operator>&gt;&gt;</operator> <name><name>k2</name><operator>.</operator><name>i32</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
	  <expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>u32</name></name> <operator>=</operator> <name><name>k</name><operator>-&gt;</operator><name>u32</name></name> <operator>&gt;&gt;</operator> <name><name>k2</name><operator>.</operator><name>u32</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<continue>continue;</continue>
      </block_content>}</block></if></if_stmt>
      <comment type="block">/* fallthrough */</comment>
    <case>case <expr><literal type="number">9</literal></expr>:</case>
      <if_stmt><if>if <condition>(<expr><call><name>cp_opt</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">'+'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>cp_expr_sub</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>k2</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>u32</name></name> <operator>=</operator> <name><name>k</name><operator>-&gt;</operator><name>u32</name></name> <operator>+</operator> <name><name>k2</name><operator>.</operator><name>u32</name></name></expr>;</expr_stmt>
      <label><name>arith_result</name>:</label>
	<if_stmt><if>if <condition>(<expr><name><name>k2</name><operator>.</operator><name>id</name></name> <operator>&gt;</operator> <name><name>k</name><operator>-&gt;</operator><name>id</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <name><name>k2</name><operator>.</operator><name>id</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Trivial promotion to unsigned. */</comment>
	<continue>continue;</continue>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>cp_opt</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">'-'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>cp_expr_sub</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>k2</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>u32</name></name> <operator>=</operator> <name><name>k</name><operator>-&gt;</operator><name>u32</name></name> <operator>-</operator> <name><name>k2</name><operator>.</operator><name>u32</name></name></expr>;</expr_stmt> <goto>goto <name>arith_result</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <comment type="block">/* fallthrough */</comment>
    <case>case <expr><literal type="number">10</literal></expr>:</case>
      <if_stmt><if>if <condition>(<expr><call><name>cp_opt</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">'*'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>cp_expr_unary</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>k2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>u32</name></name> <operator>=</operator> <name><name>k</name><operator>-&gt;</operator><name>u32</name></name> <operator>*</operator> <name><name>k2</name><operator>.</operator><name>u32</name></name></expr>;</expr_stmt> <goto>goto <name>arith_result</name>;</goto>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>cp_opt</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>cp_expr_unary</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>k2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>k2</name><operator>.</operator><name>id</name></name> <operator>&gt;</operator> <name><name>k</name><operator>-&gt;</operator><name>id</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <name><name>k2</name><operator>.</operator><name>id</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Trivial promotion to unsigned. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>k2</name><operator>.</operator><name>u32</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
	    <operator>(</operator><name><name>k</name><operator>-&gt;</operator><name>id</name></name> <operator>==</operator> <name>CTID_INT32</name> <operator>&amp;&amp;</operator> <name><name>k</name><operator>-&gt;</operator><name>u32</name></name> <operator>==</operator> <literal type="number">0x80000000u</literal> <operator>&amp;&amp;</operator> <name><name>k2</name><operator>.</operator><name>i32</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><call><name>cp_err</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>LJ_ERR_BADVAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>k</name><operator>-&gt;</operator><name>id</name></name> <operator>==</operator> <name>CTID_INT32</name></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>i32</name></name> <operator>=</operator> <name><name>k</name><operator>-&gt;</operator><name>i32</name></name> <operator>/</operator> <name><name>k2</name><operator>.</operator><name>i32</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
	  <expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>u32</name></name> <operator>=</operator> <name><name>k</name><operator>-&gt;</operator><name>u32</name></name> <operator>/</operator> <name><name>k2</name><operator>.</operator><name>u32</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<continue>continue;</continue>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>cp_opt</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">'%'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>cp_expr_unary</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>k2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>k2</name><operator>.</operator><name>id</name></name> <operator>&gt;</operator> <name><name>k</name><operator>-&gt;</operator><name>id</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <name><name>k2</name><operator>.</operator><name>id</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Trivial promotion to unsigned. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>k2</name><operator>.</operator><name>u32</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
	    <operator>(</operator><name><name>k</name><operator>-&gt;</operator><name>id</name></name> <operator>==</operator> <name>CTID_INT32</name> <operator>&amp;&amp;</operator> <name><name>k</name><operator>-&gt;</operator><name>u32</name></name> <operator>==</operator> <literal type="number">0x80000000u</literal> <operator>&amp;&amp;</operator> <name><name>k2</name><operator>.</operator><name>i32</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><call><name>cp_err</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>LJ_ERR_BADVAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>k</name><operator>-&gt;</operator><name>id</name></name> <operator>==</operator> <name>CTID_INT32</name></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>i32</name></name> <operator>=</operator> <name><name>k</name><operator>-&gt;</operator><name>i32</name></name> <operator>%</operator> <name><name>k2</name><operator>.</operator><name>i32</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
	  <expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>u32</name></name> <operator>=</operator> <name><name>k</name><operator>-&gt;</operator><name>u32</name></name> <operator>%</operator> <name><name>k2</name><operator>.</operator><name>u32</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<continue>continue;</continue>
      </block_content>}</block></if></if_stmt>
    <default>default:</default>
      <return>return;</return>
    </block_content>}</block></switch>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* Parse and evaluate unary expression. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>cp_expr_unary</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>CPValue</name> <modifier>*</modifier></type><name>k</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>++</operator><name><name>cp</name><operator>-&gt;</operator><name>depth</name></name> <operator>&gt;</operator> <name>CPARSE_MAX_DECLDEPTH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>cp_err</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>LJ_ERR_XLEVELS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>cp_expr_prefix</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>cp_expr_postfix</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>depth</name></name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Parse and evaluate sub-expression. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>cp_expr_sub</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>CPValue</name> <modifier>*</modifier></type><name>k</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pri</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>cp_expr_unary</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>cp_expr_infix</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>pri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Parse constant integer expression. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>cp_expr_kint</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>CPValue</name> <modifier>*</modifier></type><name>k</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>cp_expr_sub</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>ctype_raw</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cts</name></name></expr></argument>, <argument><expr><name><name>k</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ctype_isinteger</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>cp_err</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>LJ_ERR_BADVAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Parse (non-negative) size expression. */</comment>
<function><type><specifier>static</specifier> <name>CTSize</name></type> <name>cp_expr_ksize</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CPValue</name></type> <name>k</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>cp_expr_kint</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>k</name><operator>.</operator><name>u32</name></name> <operator>&gt;=</operator> <literal type="number">0x80000000u</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>cp_err</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>LJ_ERR_FFI_INVSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name><name>k</name><operator>.</operator><name>u32</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -- Type declaration stack management ----------------------------------- */</comment>

<comment type="block">/* Add declaration element behind the insertion position. */</comment>
<function><type><specifier>static</specifier> <name>CPDeclIdx</name></type> <name>cp_add</name><parameter_list>(<parameter><decl><type><name>CPDecl</name> <modifier>*</modifier></type><name>decl</name></decl></parameter>, <parameter><decl><type><name>CTInfo</name></type> <name>info</name></decl></parameter>, <parameter><decl><type><name>CTSize</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CPDeclIdx</name></type> <name>top</name> <init>= <expr><name><name>decl</name><operator>-&gt;</operator><name>top</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>top</name> <operator>&gt;=</operator> <name>CPARSE_MAX_DECLSTACK</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>cp_err</name><argument_list>(<argument><expr><name><name>decl</name><operator>-&gt;</operator><name>cp</name></name></expr></argument>, <argument><expr><name>LJ_ERR_XLEVELS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>decl</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>top</name></expr>]</index></name><operator>.</operator><name>info</name> <operator>=</operator> <name>info</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>decl</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>top</name></expr>]</index></name><operator>.</operator><name>size</name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>decl</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>top</name></expr>]</index></name><operator>.</operator><name>sib</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setgcrefnull</name><argument_list>(<argument><expr><name><name>decl</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>top</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>decl</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>top</name></expr>]</index></name><operator>.</operator><name>next</name> <operator>=</operator> <name><name>decl</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name><name>decl</name><operator>-&gt;</operator><name>pos</name></name></expr>]</index></name><operator>.</operator><name>next</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>decl</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name><name>decl</name><operator>-&gt;</operator><name>pos</name></name></expr>]</index></name><operator>.</operator><name>next</name> <operator>=</operator> <operator>(</operator><name>CTypeID1</name><operator>)</operator><name>top</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>decl</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name>top</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <return>return <expr><name>top</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Push declaration element before the insertion position. */</comment>
<function><type><specifier>static</specifier> <name>CPDeclIdx</name></type> <name>cp_push</name><parameter_list>(<parameter><decl><type><name>CPDecl</name> <modifier>*</modifier></type><name>decl</name></decl></parameter>, <parameter><decl><type><name>CTInfo</name></type> <name>info</name></decl></parameter>, <parameter><decl><type><name>CTSize</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><operator>(</operator><name><name>decl</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <call><name>cp_add</name><argument_list>(<argument><expr><name>decl</name></expr></argument>, <argument><expr><name>info</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Push or merge attributes. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>cp_push_attributes</name><parameter_list>(<parameter><decl><type><name>CPDecl</name> <modifier>*</modifier></type><name>decl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name> <init>= <expr><operator>&amp;</operator><name><name>decl</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name><name>decl</name><operator>-&gt;</operator><name>pos</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>ctype_isfunc</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Ok to modify in-place. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_X86</name></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>decl</name><operator>-&gt;</operator><name>fattr</name></name> <operator>&amp;</operator> <name>CTFP_CCONV</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name> <operator>=</operator> <operator>(</operator><name><name>ct</name><operator>-&gt;</operator><name>info</name></name> <operator>&amp;</operator> <operator>(</operator><name>CTMASK_NUM</name><operator>|</operator><name>CTF_VARARG</name><operator>|</operator><name>CTMASK_CID</name><operator>)</operator><operator>)</operator> <operator>+</operator>
		 <operator>(</operator><name><name>decl</name><operator>-&gt;</operator><name>fattr</name></name> <operator>&amp;</operator> <operator>~</operator><name>CTMASK_CID</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>decl</name><operator>-&gt;</operator><name>attr</name></name> <operator>&amp;</operator> <name>CTFP_ALIGNED</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>decl</name><operator>-&gt;</operator><name>mode</name></name> <operator>&amp;</operator> <name>CPARSE_MODE_FIELD</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>cp_push</name><argument_list>(<argument><expr><name>decl</name></expr></argument>, <argument><expr><call><name>CTINFO</name><argument_list>(<argument><expr><name>CT_ATTRIB</name></expr></argument>, <argument><expr><call><name>CTATTRIB</name><argument_list>(<argument><expr><name>CTA_ALIGN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
	      <argument><expr><call><name>ctype_align</name><argument_list>(<argument><expr><name><name>decl</name><operator>-&gt;</operator><name>attr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Push unrolled type to declaration stack and merge qualifiers. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>cp_push_type</name><parameter_list>(<parameter><decl><type><name>CPDecl</name> <modifier>*</modifier></type><name>decl</name></decl></parameter>, <parameter><decl><type><name>CTypeID</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name> <init>= <expr><call><name>ctype_get</name><argument_list>(<argument><expr><name><name>decl</name><operator>-&gt;</operator><name>cp</name><operator>-&gt;</operator><name>cts</name></name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTInfo</name></type> <name>info</name> <init>= <expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTSize</name></type> <name>size</name> <init>= <expr><name><name>ct</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl>;</decl_stmt>
  <switch>switch <condition>(<expr><call><name>ctype_type</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
  <case>case <expr><name>CT_STRUCT</name></expr>:</case> <case>case <expr><name>CT_ENUM</name></expr>:</case>
    <expr_stmt><expr><call><name>cp_push</name><argument_list>(<argument><expr><name>decl</name></expr></argument>, <argument><expr><call><name>CTINFO</name><argument_list>(<argument><expr><name>CT_TYPEDEF</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Don't copy unique types. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>decl</name><operator>-&gt;</operator><name>attr</name></name> <operator>&amp;</operator> <name>CTF_QUAL</name><operator>)</operator></expr>)</condition> <block>{<block_content>  <comment type="block">/* Push unmerged qualifiers. */</comment>
      <expr_stmt><expr><call><name>cp_push</name><argument_list>(<argument><expr><name>decl</name></expr></argument>, <argument><expr><call><name>CTINFO</name><argument_list>(<argument><expr><name>CT_ATTRIB</name></expr></argument>, <argument><expr><call><name>CTATTRIB</name><argument_list>(<argument><expr><name>CTA_QUAL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
	      <argument><expr><operator>(</operator><name><name>decl</name><operator>-&gt;</operator><name>attr</name></name> <operator>&amp;</operator> <name>CTF_QUAL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>decl</name><operator>-&gt;</operator><name>attr</name></name> <operator>&amp;=</operator> <operator>~</operator><name>CTF_QUAL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <break>break;</break>
  <case>case <expr><name>CT_ATTRIB</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><call><name>ctype_isxattrib</name><argument_list>(<argument><expr><name>info</name></expr></argument>, <argument><expr><name>CTA_QUAL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>decl</name><operator>-&gt;</operator><name>attr</name></name> <operator>&amp;=</operator> <operator>~</operator><name>size</name></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Remove redundant qualifiers. */</comment>
    <expr_stmt><expr><call><name>cp_push_type</name><argument_list>(<argument><expr><name>decl</name></expr></argument>, <argument><expr><call><name>ctype_cid</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Unroll. */</comment>
    <expr_stmt><expr><call><name>cp_push</name><argument_list>(<argument><expr><name>decl</name></expr></argument>, <argument><expr><name>info</name> <operator>&amp;</operator> <operator>~</operator><name>CTMASK_CID</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Copy type. */</comment>
    <break>break;</break>
  <case>case <expr><name>CT_ARRAY</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ct</name><operator>-&gt;</operator><name>info</name></name> <operator>&amp;</operator> <operator>(</operator><name>CTF_VECTOR</name><operator>|</operator><name>CTF_COMPLEX</name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>info</name> <operator>|=</operator> <operator>(</operator><name><name>decl</name><operator>-&gt;</operator><name>attr</name></name> <operator>&amp;</operator> <name>CTF_QUAL</name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>decl</name><operator>-&gt;</operator><name>attr</name></name> <operator>&amp;=</operator> <operator>~</operator><name>CTF_QUAL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>cp_push_type</name><argument_list>(<argument><expr><name>decl</name></expr></argument>, <argument><expr><call><name>ctype_cid</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Unroll. */</comment>
    <expr_stmt><expr><call><name>cp_push</name><argument_list>(<argument><expr><name>decl</name></expr></argument>, <argument><expr><name>info</name> <operator>&amp;</operator> <operator>~</operator><name>CTMASK_CID</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Copy type. */</comment>
    <expr_stmt><expr><name><name>decl</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name><name>decl</name><operator>-&gt;</operator><name>pos</name></name></expr>]</index></name><operator>.</operator><name>sib</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* Mark as already checked and sized. */</comment>
    <comment type="block">/* Note: this is not copied to the ct-&gt;sib in the C type table. */</comment>
    <break>break;</break>
  <case>case <expr><name>CT_FUNC</name></expr>:</case>
    <comment type="block">/* Copy type, link parameters (shared). */</comment>
    <expr_stmt><expr><name><name>decl</name><operator>-&gt;</operator><name>stack</name><index>[<expr><call><name>cp_push</name><argument_list>(<argument><expr><name>decl</name></expr></argument>, <argument><expr><name>info</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>]</index></name><operator>.</operator><name>sib</name> <operator>=</operator> <name><name>ct</name><operator>-&gt;</operator><name>sib</name></name></expr>;</expr_stmt>
    <break>break;</break>
  <default>default:</default>
    <comment type="block">/* Copy type, merge common qualifiers. */</comment>
    <expr_stmt><expr><call><name>cp_push</name><argument_list>(<argument><expr><name>decl</name></expr></argument>, <argument><expr><name>info</name><operator>|</operator><operator>(</operator><name><name>decl</name><operator>-&gt;</operator><name>attr</name></name> <operator>&amp;</operator> <name>CTF_QUAL</name><operator>)</operator></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>decl</name><operator>-&gt;</operator><name>attr</name></name> <operator>&amp;=</operator> <operator>~</operator><name>CTF_QUAL</name></expr>;</expr_stmt>
    <break>break;</break>
  </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/* Consume the declaration element chain and intern the C type. */</comment>
<function><type><specifier>static</specifier> <name>CTypeID</name></type> <name>cp_decl_intern</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>CPDecl</name> <modifier>*</modifier></type><name>decl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CTypeID</name></type> <name>id</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CPDeclIdx</name></type> <name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTSize</name></type> <name>csize</name> <init>= <expr><name>CTSIZE_INVALID</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTSize</name></type> <name>cinfo</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <do>do <block>{<block_content>
    <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name> <init>= <expr><operator>&amp;</operator><name><name>decl</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>idx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CTInfo</name></type> <name>info</name> <init>= <expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CTInfo</name></type> <name>size</name> <init>= <expr><name><name>ct</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* The cid is already part of info for copies of pointers/functions. */</comment>
    <expr_stmt><expr><name>idx</name> <operator>=</operator> <name><name>ct</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ctype_istypedef</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>id</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>ctype_cid</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* Always refetch info/size, since struct/enum may have been completed. */</comment>
      <expr_stmt><expr><name>cinfo</name> <operator>=</operator> <call><name>ctype_get</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cts</name></name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>info</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>csize</name> <operator>=</operator> <call><name>ctype_get</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cts</name></name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>size</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>ctype_isstruct</name><argument_list>(<argument><expr><name>cinfo</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ctype_isenum</name><argument_list>(<argument><expr><name>cinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ctype_isfunc</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Intern function. */</comment>
      <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>fct</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>CTypeID</name></type> <name>fid</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>CTypeID</name></type> <name>sib</name></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>id</name></expr>)</condition> <block>{<block_content>
	<decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>refct</name> <init>= <expr><call><name>ctype_raw</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cts</name></name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="block">/* Reject function or refarray return types. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ctype_isfunc</name><argument_list>(<argument><expr><name><name>refct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ctype_isrefarray</name><argument_list>(<argument><expr><name><name>refct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><call><name>cp_err</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>LJ_ERR_FFI_INVTYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <comment type="block">/* No intervening attributes allowed, skip forward. */</comment>
      <while>while <condition>(<expr><name>idx</name></expr>)</condition> <block>{<block_content>
	<decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ctn</name> <init>= <expr><operator>&amp;</operator><name><name>decl</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>idx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ctype_isattrib</name><argument_list>(<argument><expr><name><name>ctn</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>idx</name> <operator>=</operator> <name><name>ctn</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>  <comment type="block">/* Skip attribute. */</comment>
      </block_content>}</block></while>
      <expr_stmt><expr><name>sib</name> <operator>=</operator> <name><name>ct</name><operator>-&gt;</operator><name>sib</name></name></expr>;</expr_stmt>  <comment type="block">/* Next line may reallocate the C type table. */</comment>
      <expr_stmt><expr><name>fid</name> <operator>=</operator> <call><name>lj_ctype_new</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cts</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>csize</name> <operator>=</operator> <name>CTSIZE_INVALID</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>fct</name><operator>-&gt;</operator><name>info</name></name> <operator>=</operator> <name>cinfo</name> <operator>=</operator> <name>info</name> <operator>+</operator> <name>id</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>fct</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>fct</name><operator>-&gt;</operator><name>sib</name></name> <operator>=</operator> <name>sib</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>id</name> <operator>=</operator> <name>fid</name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ctype_isattrib</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>ctype_isxattrib</name><argument_list>(<argument><expr><name>info</name></expr></argument>, <argument><expr><name>CTA_QUAL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>cinfo</name> <operator>|=</operator> <name>size</name></expr>;</expr_stmt></block_content></block></if>
      <if type="elseif">else if <condition>(<expr><call><name>ctype_isxattrib</name><argument_list>(<argument><expr><name>info</name></expr></argument>, <argument><expr><name>CTA_ALIGN</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>CTF_INSERT</name><argument_list>(<argument><expr><name>cinfo</name></expr></argument>, <argument><expr><name>ALIGN</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>lj_ctype_intern</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cts</name></name></expr></argument>, <argument><expr><name>info</name><operator>+</operator><name>id</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* Inherit csize/cinfo from original type. */</comment>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>ctype_isnum</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Handle mode/vector-size attributes. */</comment>
	<expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>id</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>info</name> <operator>&amp;</operator> <name>CTF_BOOL</name><operator>)</operator></expr>)</condition> <block>{<block_content>
	  <decl_stmt><decl><type><name>CTSize</name></type> <name>msize</name> <init>= <expr><call><name>ctype_msizeP</name><argument_list>(<argument><expr><name><name>decl</name><operator>-&gt;</operator><name>attr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	  <decl_stmt><decl><type><name>CTSize</name></type> <name>vsize</name> <init>= <expr><call><name>ctype_vsizeP</name><argument_list>(<argument><expr><name><name>decl</name><operator>-&gt;</operator><name>attr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	  <if_stmt><if>if <condition>(<expr><name>msize</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><operator>(</operator><name>info</name> <operator>&amp;</operator> <name>CTF_FP</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>msize</name> <operator>==</operator> <literal type="number">4</literal> <operator>||</operator> <name>msize</name> <operator>==</operator> <literal type="number">8</literal><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
	    <decl_stmt><decl><type><name>CTSize</name></type> <name>malign</name> <init>= <expr><call><name>lj_fls</name><argument_list>(<argument><expr><name>msize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	    <if_stmt><if>if <condition>(<expr><name>malign</name> <operator>&gt;</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>malign</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Limit alignment. */</comment>
	    <expr_stmt><expr><call><name>CTF_INSERT</name><argument_list>(<argument><expr><name>info</name></expr></argument>, <argument><expr><name>ALIGN</name></expr></argument>, <argument><expr><name>malign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>size</name> <operator>=</operator> <name>msize</name></expr>;</expr_stmt>  <comment type="block">/* Override size via mode. */</comment>
	  </block_content>}</block></if></if_stmt>
	  <if_stmt><if>if <condition>(<expr><name>vsize</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Vector size set? */</comment>
	    <decl_stmt><decl><type><name>CTSize</name></type> <name>esize</name> <init>= <expr><call><name>lj_fls</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	    <if_stmt><if>if <condition>(<expr><name>vsize</name> <operator>&gt;=</operator> <name>esize</name></expr>)</condition> <block>{<block_content>
	      <comment type="block">/* Intern the element type first. */</comment>
	      <expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>lj_ctype_intern</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cts</name></name></expr></argument>, <argument><expr><name>info</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <comment type="block">/* Then create a vector (array) with vsize alignment. */</comment>
	      <expr_stmt><expr><name>size</name> <operator>=</operator> <operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <name>vsize</name><operator>)</operator></expr>;</expr_stmt>
	      <if_stmt><if>if <condition>(<expr><name>vsize</name> <operator>&gt;</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>vsize</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Limit alignment. */</comment>
	      <if_stmt><if>if <condition>(<expr><call><name>ctype_align</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>vsize</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>vsize</name> <operator>=</operator> <call><name>ctype_align</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	      <expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>CTINFO</name><argument_list>(<argument><expr><name>CT_ARRAY</name></expr></argument>, <argument><expr><operator>(</operator><name>info</name> <operator>&amp;</operator> <name>CTF_QUAL</name><operator>)</operator> <operator>+</operator> <name>CTF_VECTOR</name> <operator>+</operator>
				      <call><name>CTALIGN</name><argument_list>(<argument><expr><name>vsize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    </block_content>}</block></if></if_stmt>
	  </block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ctype_isptr</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<comment type="block">/* Reject pointer/ref to ref. */</comment>
	<if_stmt><if>if <condition>(<expr><name>id</name> <operator>&amp;&amp;</operator> <call><name>ctype_isref</name><argument_list>(<argument><expr><call><name>ctype_raw</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cts</name></name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>info</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><call><name>cp_err</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>LJ_ERR_FFI_INVTYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>ctype_isref</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><name>info</name> <operator>&amp;=</operator> <operator>~</operator><name>CTF_VOLATILE</name></expr>;</expr_stmt>  <comment type="block">/* Refs are always const, never volatile. */</comment>
	  <comment type="block">/* No intervening attributes allowed, skip forward. */</comment>
	  <while>while <condition>(<expr><name>idx</name></expr>)</condition> <block>{<block_content>
	    <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ctn</name> <init>= <expr><operator>&amp;</operator><name><name>decl</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>idx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ctype_isattrib</name><argument_list>(<argument><expr><name><name>ctn</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
	    <expr_stmt><expr><name>idx</name> <operator>=</operator> <name><name>ctn</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>  <comment type="block">/* Skip attribute. */</comment>
	  </block_content>}</block></while>
	</block_content>}</block></if></if_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ctype_isarray</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Check for valid array size etc. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ct</name><operator>-&gt;</operator><name>sib</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* Only check/size arrays not copied by unroll. */</comment>
	  <if_stmt><if>if <condition>(<expr><call><name>ctype_isref</name><argument_list>(<argument><expr><name>cinfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* Reject arrays of refs. */</comment>
	    <expr_stmt><expr><call><name>cp_err</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>LJ_ERR_FFI_INVTYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	  <comment type="block">/* Reject VLS or unknown-sized types. */</comment>
	  <if_stmt><if>if <condition>(<expr><call><name>ctype_isvltype</name><argument_list>(<argument><expr><name>cinfo</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>csize</name> <operator>==</operator> <name>CTSIZE_INVALID</name></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><call><name>cp_err</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>LJ_ERR_FFI_INVSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	  <comment type="block">/* a[] and a[?] keep their invalid size. */</comment>
	  <if_stmt><if>if <condition>(<expr><name>size</name> <operator>!=</operator> <name>CTSIZE_INVALID</name></expr>)</condition> <block>{<block_content>
	    <decl_stmt><decl><type><name>uint64_t</name></type> <name>xsz</name> <init>= <expr><operator>(</operator><name>uint64_t</name><operator>)</operator><name>size</name> <operator>*</operator> <name>csize</name></expr></init></decl>;</decl_stmt>
	    <if_stmt><if>if <condition>(<expr><name>xsz</name> <operator>&gt;=</operator> <literal type="number">0x80000000u</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>cp_err</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>LJ_ERR_FFI_INVSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	    <expr_stmt><expr><name>size</name> <operator>=</operator> <operator>(</operator><name>CTSize</name><operator>)</operator><name>xsz</name></expr>;</expr_stmt>
	  </block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>cinfo</name> <operator>&amp;</operator> <name>CTF_ALIGN</name><operator>)</operator> <operator>&gt;</operator> <operator>(</operator><name>info</name> <operator>&amp;</operator> <name>CTF_ALIGN</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* Find max. align. */</comment>
	  <expr_stmt><expr><name>info</name> <operator>=</operator> <operator>(</operator><name>info</name> <operator>&amp;</operator> <operator>~</operator><name>CTF_ALIGN</name><operator>)</operator> <operator>|</operator> <operator>(</operator><name>cinfo</name> <operator>&amp;</operator> <name>CTF_ALIGN</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>info</name> <operator>|=</operator> <operator>(</operator><name>cinfo</name> <operator>&amp;</operator> <name>CTF_QUAL</name><operator>)</operator></expr>;</expr_stmt>  <comment type="block">/* Inherit qual. */</comment>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>ctype_isvoid</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name>csize</name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>cinfo</name> <operator>=</operator> <name>info</name><operator>+</operator><name>id</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>lj_ctype_intern</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cts</name></name></expr></argument>, <argument><expr><name>info</name><operator>+</operator><name>id</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block> while <condition>(<expr><name>idx</name></expr>)</condition>;</do>
  <return>return <expr><name>id</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -- C declaration parser ------------------------------------------------ */</comment>

<comment type="block">/* Reset declaration state to declaration specifier. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>cp_decl_reset</name><parameter_list>(<parameter><decl><type><name>CPDecl</name> <modifier>*</modifier></type><name>decl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><name><name>decl</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <name><name>decl</name><operator>-&gt;</operator><name>specpos</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>decl</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name><name>decl</name><operator>-&gt;</operator><name>specpos</name></name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>decl</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name><name>decl</name><operator>-&gt;</operator><name>specpos</name></name></expr>]</index></name><operator>.</operator><name>next</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>decl</name><operator>-&gt;</operator><name>attr</name></name> <operator>=</operator> <name><name>decl</name><operator>-&gt;</operator><name>specattr</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>decl</name><operator>-&gt;</operator><name>fattr</name></name> <operator>=</operator> <name><name>decl</name><operator>-&gt;</operator><name>specfattr</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>decl</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>decl</name><operator>-&gt;</operator><name>redir</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Parse constant initializer. */</comment>
<comment type="block">/* NYI: FP constants and strings as initializers. */</comment>
<function><type><specifier>static</specifier> <name>CTypeID</name></type> <name>cp_decl_constinit</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>CType</name> <modifier>*</modifier><modifier>*</modifier></type><name>ctp</name></decl></parameter>, <parameter><decl><type><name>CTypeID</name></type> <name>ctypeid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ctt</name> <init>= <expr><call><name>ctype_get</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cts</name></name></expr></argument>, <argument><expr><name>ctypeid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTInfo</name></type> <name>info</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTSize</name></type> <name>size</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CPValue</name></type> <name>k</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTypeID</name></type> <name>constid</name></decl>;</decl_stmt>
  <while>while <condition>(<expr><call><name>ctype_isattrib</name><argument_list>(<argument><expr><name><name>ctt</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Skip attributes. */</comment>
    <expr_stmt><expr><name>ctypeid</name> <operator>=</operator> <call><name>ctype_cid</name><argument_list>(<argument><expr><name><name>ctt</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Update ID, too. */</comment>
    <expr_stmt><expr><name>ctt</name> <operator>=</operator> <call><name>ctype_get</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cts</name></name></expr></argument>, <argument><expr><name>ctypeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><name>info</name> <operator>=</operator> <name><name>ctt</name><operator>-&gt;</operator><name>info</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>size</name> <operator>=</operator> <name><name>ctt</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ctype_isinteger</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><operator>(</operator><name>info</name> <operator>&amp;</operator> <name>CTF_CONST</name><operator>)</operator> <operator>||</operator> <name>size</name> <operator>&gt;</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>cp_err</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>LJ_ERR_FFI_INVTYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>cp_check</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>cp_expr_sub</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>k</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>constid</name> <operator>=</operator> <call><name>lj_ctype_new</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cts</name></name></expr></argument>, <argument><expr><name>ctp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>ctp</name><operator>)</operator><operator>-&gt;</operator><name>info</name></name> <operator>=</operator> <call><name>CTINFO</name><argument_list>(<argument><expr><name>CT_CONSTVAL</name></expr></argument>, <argument><expr><name>CTF_CONST</name><operator>|</operator><name>ctypeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>k</name><operator>.</operator><name>u32</name></name> <operator>&lt;&lt;=</operator> <literal type="number">8</literal><operator>*</operator><operator>(</operator><literal type="number">4</literal><operator>-</operator><name>size</name><operator>)</operator></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>info</name> <operator>&amp;</operator> <name>CTF_UNSIGNED</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>k</name><operator>.</operator><name>u32</name></name> <operator>&gt;&gt;=</operator> <literal type="number">8</literal><operator>*</operator><operator>(</operator><literal type="number">4</literal><operator>-</operator><name>size</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>k</name><operator>.</operator><name>u32</name></name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><operator>(</operator><name>int32_t</name><operator>)</operator><name><name>k</name><operator>.</operator><name>u32</name></name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>*</operator><operator>(</operator><literal type="number">4</literal><operator>-</operator><name>size</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
  <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>ctp</name><operator>)</operator><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name><name>k</name><operator>.</operator><name>u32</name></name></expr>;</expr_stmt>
  <return>return <expr><name>constid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Parse size in parentheses as part of attribute. */</comment>
<function><type><specifier>static</specifier> <name>CTSize</name></type> <name>cp_decl_sizeattr</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CTSize</name></type> <name>sz</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>oldtmask</name> <init>= <expr><name><name>cp</name><operator>-&gt;</operator><name>tmask</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>tmask</name></name> <operator>=</operator> <name>CPNS_DEFAULT</name></expr>;</expr_stmt>  <comment type="block">/* Required for expression evaluator. */</comment>
  <expr_stmt><expr><call><name>cp_check</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>cp_expr_ksize</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>tmask</name></name> <operator>=</operator> <name>oldtmask</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>cp_check</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>sz</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Parse alignment attribute. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>cp_decl_align</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>CPDecl</name> <modifier>*</modifier></type><name>decl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CTSize</name></type> <name>al</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* Unspecified alignment is 16 bytes. */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>tok</name></name> <operator>==</operator> <literal type="char">'('</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>al</name> <operator>=</operator> <call><name>cp_decl_sizeattr</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>al</name> <operator>=</operator> <ternary><condition><expr><name>al</name></expr> ?</condition><then> <expr><call><name>lj_fls</name><argument_list>(<argument><expr><name>al</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>CTF_INSERT</name><argument_list>(<argument><expr><name><name>decl</name><operator>-&gt;</operator><name>attr</name></name></expr></argument>, <argument><expr><name>ALIGN</name></expr></argument>, <argument><expr><name>al</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>decl</name><operator>-&gt;</operator><name>attr</name></name> <operator>|=</operator> <name>CTFP_ALIGNED</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Parse GCC asm("name") redirect. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>cp_decl_asm</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>CPDecl</name> <modifier>*</modifier></type><name>decl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>decl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>cp_next</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>cp_check</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>tok</name></name> <operator>==</operator> <name>CTOK_STRING</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><name><name>cp</name><operator>-&gt;</operator><name>str</name></name></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><call><name>cp_next</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CTOK_STRING</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>lj_strfmt_pushf</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><call><name>strdata</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strdata</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>str</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>--</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>strV</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><name><name>decl</name><operator>-&gt;</operator><name>redir</name></name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>cp_check</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Parse GCC __attribute__((mode(...))). */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>cp_decl_mode</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>CPDecl</name> <modifier>*</modifier></type><name>decl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>cp_check</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>tok</name></name> <operator>==</operator> <name>CTOK_IDENT</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>strdata</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>str</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CTSize</name></type> <name>sz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>vlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'_'</literal> <operator>&amp;&amp;</operator> <name><name>s</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'_'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>s</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'V'</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>vlen</name> <operator>=</operator> <operator>*</operator><name>s</name><operator>++</operator> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>s</name> <operator>&lt;=</operator> <literal type="char">'9'</literal></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>vlen</name> <operator>=</operator> <name>vlen</name><operator>*</operator><literal type="number">10</literal> <operator>+</operator> <operator>(</operator><operator>*</operator><name>s</name><operator>++</operator> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <switch>switch <condition>(<expr><operator>*</operator><name>s</name><operator>++</operator></expr>)</condition> <block>{<block_content>
    <case>case <expr><literal type="char">'Q'</literal></expr>:</case> <expr_stmt><expr><name>sz</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><literal type="char">'H'</literal></expr>:</case> <expr_stmt><expr><name>sz</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><literal type="char">'S'</literal></expr>:</case> <expr_stmt><expr><name>sz</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><literal type="char">'D'</literal></expr>:</case> <expr_stmt><expr><name>sz</name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><literal type="char">'T'</literal></expr>:</case> <expr_stmt><expr><name>sz</name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><literal type="char">'O'</literal></expr>:</case> <expr_stmt><expr><name>sz</name> <operator>=</operator> <literal type="number">32</literal></expr>;</expr_stmt> <break>break;</break>
    <default>default:</default> <goto>goto <name>bad_size</name>;</goto>
    </block_content>}</block></switch>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'I'</literal> <operator>||</operator> <operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'F'</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>CTF_INSERT</name><argument_list>(<argument><expr><name><name>decl</name><operator>-&gt;</operator><name>attr</name></name></expr></argument>, <argument><expr><name>MSIZEP</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>vlen</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>CTF_INSERT</name><argument_list>(<argument><expr><name><name>decl</name><operator>-&gt;</operator><name>attr</name></name></expr></argument>, <argument><expr><name>VSIZEP</name></expr></argument>, <argument><expr><call><name>lj_fls</name><argument_list>(<argument><expr><name>vlen</name><operator>*</operator><name>sz</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  <label><name>bad_size</name>:</label>
    <expr_stmt><expr><call><name>cp_next</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>cp_check</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Parse GCC __attribute__((...)). */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>cp_decl_gccattribute</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>CPDecl</name> <modifier>*</modifier></type><name>decl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>cp_next</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>cp_check</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>cp_check</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>tok</name></name> <operator>!=</operator> <literal type="char">')'</literal></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>tok</name></name> <operator>==</operator> <name>CTOK_IDENT</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>attrstr</name> <init>= <expr><name><name>cp</name><operator>-&gt;</operator><name>str</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>cp_next</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <switch>switch <condition>(<expr><call><name>lj_cparse_case</name><argument_list>(<argument><expr><name>attrstr</name></expr></argument>,
		<argument><expr><literal type="string">"\007aligned"</literal> <literal type="string">"\013__aligned__"</literal>
		<literal type="string">"\006packed"</literal> <literal type="string">"\012__packed__"</literal>
		<literal type="string">"\004mode"</literal> <literal type="string">"\010__mode__"</literal>
		<literal type="string">"\013vector_size"</literal> <literal type="string">"\017__vector_size__"</literal>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_X86</name></expr></cpp:if>
		<literal type="string">"\007regparm"</literal> <literal type="string">"\013__regparm__"</literal>
		<literal type="string">"\005cdecl"</literal>  <literal type="string">"\011__cdecl__"</literal>
		<literal type="string">"\010thiscall"</literal> <literal type="string">"\014__thiscall__"</literal>
		<literal type="string">"\010fastcall"</literal> <literal type="string">"\014__fastcall__"</literal>
		<literal type="string">"\007stdcall"</literal> <literal type="string">"\013__stdcall__"</literal>
		<literal type="string">"\012sseregparm"</literal> <literal type="string">"\016__sseregparm__"</literal></expr></argument>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	      )</argument_list></call></expr>)</condition> <block>{<block_content>
      <case>case <expr><literal type="number">0</literal></expr>:</case> <case>case <expr><literal type="number">1</literal></expr>:</case> <comment type="block">/* aligned */</comment>
	<expr_stmt><expr><call><name>cp_decl_align</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>decl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
      <case>case <expr><literal type="number">2</literal></expr>:</case> <case>case <expr><literal type="number">3</literal></expr>:</case> <comment type="block">/* packed */</comment>
	<expr_stmt><expr><name><name>decl</name><operator>-&gt;</operator><name>attr</name></name> <operator>|=</operator> <name>CTFP_PACKED</name></expr>;</expr_stmt>
	<break>break;</break>
      <case>case <expr><literal type="number">4</literal></expr>:</case> <case>case <expr><literal type="number">5</literal></expr>:</case> <comment type="block">/* mode */</comment>
	<expr_stmt><expr><call><name>cp_decl_mode</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>decl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
      <case>case <expr><literal type="number">6</literal></expr>:</case> <case>case <expr><literal type="number">7</literal></expr>:</case> <comment type="block">/* vector_size */</comment>
	<block>{<block_content>
	  <decl_stmt><decl><type><name>CTSize</name></type> <name>vsize</name> <init>= <expr><call><name>cp_decl_sizeattr</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	  <if_stmt><if>if <condition>(<expr><name>vsize</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>CTF_INSERT</name><argument_list>(<argument><expr><name><name>decl</name><operator>-&gt;</operator><name>attr</name></name></expr></argument>, <argument><expr><name>VSIZEP</name></expr></argument>, <argument><expr><call><name>lj_fls</name><argument_list>(<argument><expr><name>vsize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
	<break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_X86</name></expr></cpp:if>
      <case>case <expr><literal type="number">8</literal></expr>:</case> <case>case <expr><literal type="number">9</literal></expr>:</case> <comment type="block">/* regparm */</comment>
	<expr_stmt><expr><call><name>CTF_INSERT</name><argument_list>(<argument><expr><name><name>decl</name><operator>-&gt;</operator><name>fattr</name></name></expr></argument>, <argument><expr><name>REGPARM</name></expr></argument>, <argument><expr><call><name>cp_decl_sizeattr</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>decl</name><operator>-&gt;</operator><name>fattr</name></name> <operator>|=</operator> <name>CTFP_CCONV</name></expr>;</expr_stmt>
	<break>break;</break>
      <case>case <expr><literal type="number">10</literal></expr>:</case> <case>case <expr><literal type="number">11</literal></expr>:</case> <comment type="block">/* cdecl */</comment>
	<expr_stmt><expr><call><name>CTF_INSERT</name><argument_list>(<argument><expr><name><name>decl</name><operator>-&gt;</operator><name>fattr</name></name></expr></argument>, <argument><expr><name>CCONV</name></expr></argument>, <argument><expr><name>CTCC_CDECL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>decl</name><operator>-&gt;</operator><name>fattr</name></name> <operator>|=</operator> <name>CTFP_CCONV</name></expr>;</expr_stmt>
	<break>break;</break>
      <case>case <expr><literal type="number">12</literal></expr>:</case> <case>case <expr><literal type="number">13</literal></expr>:</case> <comment type="block">/* thiscall */</comment>
	<expr_stmt><expr><call><name>CTF_INSERT</name><argument_list>(<argument><expr><name><name>decl</name><operator>-&gt;</operator><name>fattr</name></name></expr></argument>, <argument><expr><name>CCONV</name></expr></argument>, <argument><expr><name>CTCC_THISCALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>decl</name><operator>-&gt;</operator><name>fattr</name></name> <operator>|=</operator> <name>CTFP_CCONV</name></expr>;</expr_stmt>
	<break>break;</break>
      <case>case <expr><literal type="number">14</literal></expr>:</case> <case>case <expr><literal type="number">15</literal></expr>:</case> <comment type="block">/* fastcall */</comment>
	<expr_stmt><expr><call><name>CTF_INSERT</name><argument_list>(<argument><expr><name><name>decl</name><operator>-&gt;</operator><name>fattr</name></name></expr></argument>, <argument><expr><name>CCONV</name></expr></argument>, <argument><expr><name>CTCC_FASTCALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>decl</name><operator>-&gt;</operator><name>fattr</name></name> <operator>|=</operator> <name>CTFP_CCONV</name></expr>;</expr_stmt>
	<break>break;</break>
      <case>case <expr><literal type="number">16</literal></expr>:</case> <case>case <expr><literal type="number">17</literal></expr>:</case> <comment type="block">/* stdcall */</comment>
	<expr_stmt><expr><call><name>CTF_INSERT</name><argument_list>(<argument><expr><name><name>decl</name><operator>-&gt;</operator><name>fattr</name></name></expr></argument>, <argument><expr><name>CCONV</name></expr></argument>, <argument><expr><name>CTCC_STDCALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>decl</name><operator>-&gt;</operator><name>fattr</name></name> <operator>|=</operator> <name>CTFP_CCONV</name></expr>;</expr_stmt>
	<break>break;</break>
      <case>case <expr><literal type="number">18</literal></expr>:</case> <case>case <expr><literal type="number">19</literal></expr>:</case> <comment type="block">/* sseregparm */</comment>
	<expr_stmt><expr><name><name>decl</name><operator>-&gt;</operator><name>fattr</name></name> <operator>|=</operator> <name>CTF_SSEREGPARM</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>decl</name><operator>-&gt;</operator><name>fattr</name></name> <operator>|=</operator> <name>CTFP_CCONV</name></expr>;</expr_stmt>
	<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <default>default:</default>  <comment type="block">/* Skip all other attributes. */</comment>
	<goto>goto <name>skip_attr</name>;</goto>
      </block_content>}</block></switch>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>tok</name></name> <operator>&gt;=</operator> <name>CTOK_FIRSTDECL</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* For __attribute((const)) etc. */</comment>
      <expr_stmt><expr><call><name>cp_next</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <label><name>skip_attr</name>:</label>
      <if_stmt><if>if <condition>(<expr><call><name>cp_opt</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<while>while <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>tok</name></name> <operator>!=</operator> <literal type="char">')'</literal> <operator>&amp;&amp;</operator> <name><name>cp</name><operator>-&gt;</operator><name>tok</name></name> <operator>!=</operator> <name>CTOK_EOF</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>cp_next</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
	<expr_stmt><expr><call><name>cp_check</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <break>break;</break>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cp_opt</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>cp_check</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>cp_check</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Parse MSVC __declspec(...). */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>cp_decl_msvcattribute</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>CPDecl</name> <modifier>*</modifier></type><name>decl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>cp_next</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>cp_check</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>tok</name></name> <operator>==</operator> <name>CTOK_IDENT</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>attrstr</name> <init>= <expr><name><name>cp</name><operator>-&gt;</operator><name>str</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>cp_next</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>cp_str_is</name><argument_list>(<argument><expr><name>attrstr</name></expr></argument>, <argument><expr><literal type="string">"align"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>cp_decl_align</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>decl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* Ignore all other attributes. */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>cp_opt</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<while>while <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>tok</name></name> <operator>!=</operator> <literal type="char">')'</literal> <operator>&amp;&amp;</operator> <name><name>cp</name><operator>-&gt;</operator><name>tok</name></name> <operator>!=</operator> <name>CTOK_EOF</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>cp_next</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
	<expr_stmt><expr><call><name>cp_check</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>cp_check</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Parse declaration attributes (and common qualifiers). */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>cp_decl_attributes</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>CPDecl</name> <modifier>*</modifier></type><name>decl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
    <switch>switch <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>tok</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>CTOK_CONST</name></expr>:</case> <expr_stmt><expr><name><name>decl</name><operator>-&gt;</operator><name>attr</name></name> <operator>|=</operator> <name>CTF_CONST</name></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>CTOK_VOLATILE</name></expr>:</case> <expr_stmt><expr><name><name>decl</name><operator>-&gt;</operator><name>attr</name></name> <operator>|=</operator> <name>CTF_VOLATILE</name></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>CTOK_RESTRICT</name></expr>:</case> <break>break;</break>  <comment type="block">/* Ignore. */</comment>
    <case>case <expr><name>CTOK_EXTENSION</name></expr>:</case> <break>break;</break>  <comment type="block">/* Ignore. */</comment>
    <case>case <expr><name>CTOK_ATTRIBUTE</name></expr>:</case> <expr_stmt><expr><call><name>cp_decl_gccattribute</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>decl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <continue>continue;</continue>
    <case>case <expr><name>CTOK_ASM</name></expr>:</case> <expr_stmt><expr><call><name>cp_decl_asm</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>decl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <continue>continue;</continue>
    <case>case <expr><name>CTOK_DECLSPEC</name></expr>:</case> <expr_stmt><expr><call><name>cp_decl_msvcattribute</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>decl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <continue>continue;</continue>
    <case>case <expr><name>CTOK_CCDECL</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_X86</name></expr></cpp:if>
      <expr_stmt><expr><call><name>CTF_INSERT</name><argument_list>(<argument><expr><name><name>decl</name><operator>-&gt;</operator><name>fattr</name></name></expr></argument>, <argument><expr><name>CCONV</name></expr></argument>, <argument><expr><name><name>cp</name><operator>-&gt;</operator><name>ct</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>decl</name><operator>-&gt;</operator><name>fattr</name></name> <operator>|=</operator> <name>CTFP_CCONV</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <break>break;</break>
    <case>case <expr><name>CTOK_PTRSZ</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_64</name></expr></cpp:if>
      <expr_stmt><expr><call><name>CTF_INSERT</name><argument_list>(<argument><expr><name><name>decl</name><operator>-&gt;</operator><name>attr</name></name></expr></argument>, <argument><expr><name>MSIZEP</name></expr></argument>, <argument><expr><name><name>cp</name><operator>-&gt;</operator><name>ct</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <break>break;</break>
    <default>default:</default> <return>return;</return>
    </block_content>}</block></switch>
    <expr_stmt><expr><call><name>cp_next</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* Parse struct/union/enum name. */</comment>
<function><type><specifier>static</specifier> <name>CTypeID</name></type> <name>cp_struct_name</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>CPDecl</name> <modifier>*</modifier></type><name>sdecl</name></decl></parameter>, <parameter><decl><type><name>CTInfo</name></type> <name>info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CTypeID</name></type> <name>sid</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>tmask</name></name> <operator>=</operator> <name>CPNS_STRUCT</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>cp_next</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>cp_decl_attributes</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>sdecl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>tmask</name></name> <operator>=</operator> <name>CPNS_DEFAULT</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>tok</name></name> <operator>!=</operator> <literal type="char">'{'</literal></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>tok</name></name> <operator>!=</operator> <name>CTOK_IDENT</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>cp_err_token</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>CTOK_IDENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>id</name></name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Name of existing struct/union/enum. */</comment>
      <expr_stmt><expr><name>sid</name> <operator>=</operator> <name><name>cp</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>id</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>ct</name> <operator>=</operator> <name><name>cp</name><operator>-&gt;</operator><name>ct</name></name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ct</name><operator>-&gt;</operator><name>info</name></name> <operator>^</operator> <name>info</name><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>CTMASK_NUM</name><operator>|</operator><name>CTF_UNION</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* Wrong type. */</comment>
	<expr_stmt><expr><call><name>cp_errmsg</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>LJ_ERR_FFI_REDEF</name></expr></argument>, <argument><expr><call><name>strdata</name><argument_list>(<argument><expr><call><name>gco2str</name><argument_list>(<argument><expr><call><name>gcref</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* Create named, incomplete struct/union/enum. */</comment>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>cp</name><operator>-&gt;</operator><name>mode</name></name> <operator>&amp;</operator> <name>CPARSE_MODE_NOIMPLICIT</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>cp_errmsg</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>LJ_ERR_FFI_BADTAG</name></expr></argument>, <argument><expr><call><name>strdata</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>str</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>sid</name> <operator>=</operator> <call><name>lj_ctype_new</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cts</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name> <operator>=</operator> <name>info</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>ct</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>CTSIZE_INVALID</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>ctype_setname</name><argument_list>(<argument><expr><name>ct</name></expr></argument>, <argument><expr><name><name>cp</name><operator>-&gt;</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lj_ctype_addname</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cts</name></name></expr></argument>, <argument><expr><name>ct</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>cp_next</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* Create anonymous, incomplete struct/union/enum. */</comment>
    <expr_stmt><expr><name>sid</name> <operator>=</operator> <call><name>lj_ctype_new</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cts</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name> <operator>=</operator> <name>info</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ct</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>CTSIZE_INVALID</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>tok</name></name> <operator>==</operator> <literal type="char">'{'</literal></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>ct</name><operator>-&gt;</operator><name>size</name></name> <operator>!=</operator> <name>CTSIZE_INVALID</name> <operator>||</operator> <name><name>ct</name><operator>-&gt;</operator><name>sib</name></name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>cp_errmsg</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>LJ_ERR_FFI_REDEF</name></expr></argument>, <argument><expr><call><name>strdata</name><argument_list>(<argument><expr><call><name>gco2str</name><argument_list>(<argument><expr><call><name>gcref</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>ct</name><operator>-&gt;</operator><name>sib</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* Indicate the type is currently being defined. */</comment>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>sid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Determine field alignment. */</comment>
<function><type><specifier>static</specifier> <name>CTSize</name></type> <name>cp_field_align</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name></decl></parameter>, <parameter><decl><type><name>CTInfo</name></type> <name>info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CTSize</name></type> <name>align</name> <init>= <expr><call><name>ctype_align</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>LJ_TARGET_X86</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>LJ_ABI_WIN</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>LJ_TARGET_ARM</name> <operator>&amp;&amp;</operator> <name>__APPLE__</name><operator>)</operator></expr></cpp:if>
  <comment type="block">/* The SYSV i386 and iOS ABIs limit alignment of non-vector fields to 2^2. */</comment>
  <if_stmt><if>if <condition>(<expr><name>align</name> <operator>&gt;</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>info</name> <operator>&amp;</operator> <name>CTFP_ALIGNED</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>ctype_isarray</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>info</name> <operator>&amp;</operator> <name>CTF_VECTOR</name><operator>)</operator></expr>)</condition> <block>{<block_content>
      <do>do <block>{<block_content>
	<expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>ctype_rawchild</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cts</name></name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>info</name> <operator>=</operator> <name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr>;</expr_stmt>
      </block_content>}</block> while <condition>(<expr><call><name>ctype_isarray</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>info</name> <operator>&amp;</operator> <name>CTF_VECTOR</name><operator>)</operator></expr>)</condition>;</do>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ctype_isnum</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ctype_isenum</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>align</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>align</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Layout struct/union fields. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>cp_struct_layout</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>CTypeID</name></type> <name>sid</name></decl></parameter>, <parameter><decl><type><name>CTInfo</name></type> <name>sattr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CTSize</name></type> <name>bofs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>bmaxofs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* Bit offset and max. bit offset. */</comment>
  <decl_stmt><decl><type><name>CTSize</name></type> <name>maxalign</name> <init>= <expr><call><name>ctype_align</name><argument_list>(<argument><expr><name>sattr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>sct</name> <init>= <expr><call><name>ctype_get</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cts</name></name></expr></argument>, <argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTInfo</name></type> <name>sinfo</name> <init>= <expr><name><name>sct</name><operator>-&gt;</operator><name>info</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTypeID</name></type> <name>fieldid</name> <init>= <expr><name><name>sct</name><operator>-&gt;</operator><name>sib</name></name></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><name>fieldid</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name> <init>= <expr><call><name>ctype_get</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cts</name></name></expr></argument>, <argument><expr><name>fieldid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CTInfo</name></type> <name>attr</name> <init>= <expr><name><name>ct</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* Field declaration attributes (temp.). */</comment>

    <if_stmt><if>if <condition>(<expr><call><name>ctype_isfield</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
	<operator>(</operator><call><name>ctype_isxattrib</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>, <argument><expr><name>CTA_SUBTYPE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>attr</name><operator>)</operator></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>CTSize</name></type> <name>align</name></decl>, <decl><type ref="prev"/><name>amask</name></decl>;</decl_stmt>  <comment type="block">/* Alignment (pow2) and alignment mask (bits). */</comment>
      <decl_stmt><decl><type><name>CTSize</name></type> <name>sz</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>CTInfo</name></type> <name>info</name> <init>= <expr><call><name>lj_ctype_info</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cts</name></name></expr></argument>, <argument><expr><call><name>ctype_cid</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>CTSize</name></type> <name>bsz</name></decl>, <decl><type ref="prev"/><name>csz</name> <init>= <expr><literal type="number">8</literal><operator>*</operator><name>sz</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* Field size and container size (in bits). */</comment>
      <expr_stmt><expr><name>sinfo</name> <operator>|=</operator> <operator>(</operator><name>info</name> <operator>&amp;</operator> <operator>(</operator><name>CTF_QUAL</name><operator>|</operator><name>CTF_VLA</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>  <comment type="block">/* Merge pseudo-qualifiers. */</comment>

      <comment type="block">/* Check for size overflow and determine alignment. */</comment>
      <if_stmt><if>if <condition>(<expr><name>sz</name> <operator>&gt;=</operator> <literal type="number">0x20000000u</literal> <operator>||</operator> <name>bofs</name> <operator>+</operator> <name>csz</name> <operator>&lt;</operator> <name>bofs</name> <operator>||</operator> <operator>(</operator><name>info</name> <operator>&amp;</operator> <name>CTF_VLA</name><operator>)</operator></expr>)</condition> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>sz</name> <operator>==</operator> <name>CTSIZE_INVALID</name> <operator>&amp;&amp;</operator> <call><name>ctype_isarray</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
	      <operator>!</operator><operator>(</operator><name>sinfo</name> <operator>&amp;</operator> <name>CTF_UNION</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><call><name>cp_err</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>LJ_ERR_FFI_INVSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>csz</name> <operator>=</operator> <name>sz</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* Treat a[] and a[?] as zero-sized. */</comment>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>align</name> <operator>=</operator> <call><name>cp_field_align</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>attr</name><operator>|</operator><name>sattr</name><operator>)</operator> <operator>&amp;</operator> <name>CTFP_PACKED</name><operator>)</operator> <operator>||</operator>
	  <operator>(</operator><operator>(</operator><name>attr</name> <operator>&amp;</operator> <name>CTFP_ALIGNED</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>ctype_align</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>align</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>align</name> <operator>=</operator> <call><name>ctype_align</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>packstack</name><index>[<expr><name><name>cp</name><operator>-&gt;</operator><name>curpack</name></name></expr>]</index></name> <operator>&lt;</operator> <name>align</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>align</name> <operator>=</operator> <name><name>cp</name><operator>-&gt;</operator><name>packstack</name><index>[<expr><name><name>cp</name><operator>-&gt;</operator><name>curpack</name></name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>align</name> <operator>&gt;</operator> <name>maxalign</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>maxalign</name> <operator>=</operator> <name>align</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>amask</name> <operator>=</operator> <operator>(</operator><literal type="number">8u</literal> <operator>&lt;&lt;</operator> <name>align</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

      <expr_stmt><expr><name>bsz</name> <operator>=</operator> <call><name>ctype_bitcsz</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Bitfield size (temp.). */</comment>
      <if_stmt><if>if <condition>(<expr><name>bsz</name> <operator>==</operator> <name>CTBSZ_FIELD</name> <operator>||</operator> <operator>!</operator><call><name>ctype_isfield</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name>bsz</name> <operator>=</operator> <name>csz</name></expr>;</expr_stmt>  <comment type="block">/* Regular fields or subtypes always fill the container. */</comment>
	<expr_stmt><expr><name>bofs</name> <operator>=</operator> <operator>(</operator><name>bofs</name> <operator>+</operator> <name>amask</name><operator>)</operator> <operator>&amp;</operator> <operator>~</operator><name>amask</name></expr>;</expr_stmt>  <comment type="block">/* Start new aligned field. */</comment>
	<expr_stmt><expr><name><name>ct</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <operator>(</operator><name>bofs</name> <operator>&gt;&gt;</operator> <literal type="number">3</literal><operator>)</operator></expr>;</expr_stmt>  <comment type="block">/* Store field offset. */</comment>
      </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* Bitfield. */</comment>
	<if_stmt><if>if <condition>(<expr><name>bsz</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>attr</name> <operator>&amp;</operator> <name>CTFP_ALIGNED</name><operator>)</operator> <operator>||</operator>
	    <operator>(</operator><operator>!</operator><operator>(</operator><operator>(</operator><name>attr</name><operator>|</operator><name>sattr</name><operator>)</operator> <operator>&amp;</operator> <name>CTFP_PACKED</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>bofs</name> <operator>&amp;</operator> <name>amask</name><operator>)</operator> <operator>+</operator> <name>bsz</name> <operator>&gt;</operator> <name>csz</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><name>bofs</name> <operator>=</operator> <operator>(</operator><name>bofs</name> <operator>+</operator> <name>amask</name><operator>)</operator> <operator>&amp;</operator> <operator>~</operator><name>amask</name></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Start new aligned field. */</comment>

	<comment type="block">/* Prefer regular field over bitfield. */</comment>
	<if_stmt><if>if <condition>(<expr><name>bsz</name> <operator>==</operator> <name>csz</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>bofs</name> <operator>&amp;</operator> <name>amask</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name> <operator>=</operator> <call><name>CTINFO</name><argument_list>(<argument><expr><name>CT_FIELD</name></expr></argument>, <argument><expr><call><name>ctype_cid</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>ct</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <operator>(</operator><name>bofs</name> <operator>&gt;&gt;</operator> <literal type="number">3</literal><operator>)</operator></expr>;</expr_stmt>  <comment type="block">/* Store field offset. */</comment>
	</block_content>}</block></if> <else>else <block>{<block_content>
	  <expr_stmt><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name> <operator>=</operator> <call><name>CTINFO</name><argument_list>(<argument><expr><name>CT_BITFIELD</name></expr></argument>,
	    <argument><expr><operator>(</operator><name>info</name> <operator>&amp;</operator> <operator>(</operator><name>CTF_QUAL</name><operator>|</operator><name>CTF_UNSIGNED</name><operator>|</operator><name>CTF_BOOL</name><operator>)</operator><operator>)</operator> <operator>+</operator>
	    <operator>(</operator><name>csz</name> <operator>&lt;&lt;</operator> <operator>(</operator><name>CTSHIFT_BITCSZ</name><operator>-</operator><literal type="number">3</literal><operator>)</operator><operator>)</operator> <operator>+</operator> <operator>(</operator><name>bsz</name> <operator>&lt;&lt;</operator> <name>CTSHIFT_BITBSZ</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_BE</name></expr></cpp:if>
	  <expr_stmt><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name> <operator>+=</operator> <operator>(</operator><operator>(</operator><name>csz</name> <operator>-</operator> <operator>(</operator><name>bofs</name> <operator>&amp;</operator> <operator>(</operator><name>csz</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>-</operator> <name>bsz</name><operator>)</operator> <operator>&lt;&lt;</operator> <name>CTSHIFT_BITPOS</name><operator>)</operator></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	  <expr_stmt><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name> <operator>+=</operator> <operator>(</operator><operator>(</operator><name>bofs</name> <operator>&amp;</operator> <operator>(</operator><name>csz</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>&lt;&lt;</operator> <name>CTSHIFT_BITPOS</name><operator>)</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	  <expr_stmt><expr><name><name>ct</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>bofs</name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>csz</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">3</literal><operator>)</operator></expr>;</expr_stmt>  <comment type="block">/* Store container offset. */</comment>
	</block_content>}</block></else></if_stmt>
      </block_content>}</block></else></if_stmt>

      <comment type="block">/* Determine next offset or max. offset. */</comment>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>sinfo</name> <operator>&amp;</operator> <name>CTF_UNION</name><operator>)</operator></expr>)</condition> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>bsz</name> <operator>&gt;</operator> <name>bmaxofs</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>bmaxofs</name> <operator>=</operator> <name>bsz</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<expr_stmt><expr><name>bofs</name> <operator>+=</operator> <name>bsz</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>  <comment type="block">/* All other fields in the chain are already set up. */</comment>

    <expr_stmt><expr><name>fieldid</name> <operator>=</operator> <name><name>ct</name><operator>-&gt;</operator><name>sib</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>

  <comment type="block">/* Complete struct/union. */</comment>
  <expr_stmt><expr><name><name>sct</name><operator>-&gt;</operator><name>info</name></name> <operator>=</operator> <name>sinfo</name> <operator>+</operator> <call><name>CTALIGN</name><argument_list>(<argument><expr><name>maxalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>bofs</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>sinfo</name> <operator>&amp;</operator> <name>CTF_UNION</name><operator>)</operator></expr> ?</condition><then> <expr><name>bmaxofs</name></expr> </then><else>: <expr><name>bofs</name></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><name>maxalign</name> <operator>=</operator> <operator>(</operator><literal type="number">8u</literal> <operator>&lt;&lt;</operator> <name>maxalign</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sct</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>bofs</name> <operator>+</operator> <name>maxalign</name><operator>)</operator> <operator>&amp;</operator> <operator>~</operator><name>maxalign</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">3</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Parse struct/union declaration. */</comment>
<function><type><specifier>static</specifier> <name>CTypeID</name></type> <name>cp_decl_struct</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>CPDecl</name> <modifier>*</modifier></type><name>sdecl</name></decl></parameter>, <parameter><decl><type><name>CTInfo</name></type> <name>sinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CTypeID</name></type> <name>sid</name> <init>= <expr><call><name>cp_struct_name</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>sdecl</name></expr></argument>, <argument><expr><name>sinfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>cp_opt</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">'{'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Struct/union definition. */</comment>
    <decl_stmt><decl><type><name>CTypeID</name></type> <name>lastid</name> <init>= <expr><name>sid</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>lastdecl</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>tok</name></name> <operator>!=</operator> <literal type="char">'}'</literal></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>CPDecl</name></type> <name>decl</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>CPscl</name></type> <name>scl</name> <init>= <expr><call><name>cp_decl_spec</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>decl</name></expr></argument>, <argument><expr><name>CDF_STATIC</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>decl</name><operator>.</operator><name>mode</name></name> <operator>=</operator> <ternary><condition><expr><name>scl</name></expr> ?</condition><then> <expr><name>CPARSE_MODE_DIRECT</name></expr> </then><else>:
	<expr><name>CPARSE_MODE_DIRECT</name><operator>|</operator><name>CPARSE_MODE_ABSTRACT</name><operator>|</operator><name>CPARSE_MODE_FIELD</name></expr></else></ternary></expr>;</expr_stmt>

      <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
	<decl_stmt><decl><type><name>CTypeID</name></type> <name>ctypeid</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>lastdecl</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>cp_err_token</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">'}'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Parse field declarator. */</comment>
	<expr_stmt><expr><name><name>decl</name><operator>.</operator><name>bits</name></name> <operator>=</operator> <name>CTSIZE_INVALID</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>cp_declarator</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>decl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ctypeid</name> <operator>=</operator> <call><name>cp_decl_intern</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>decl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>scl</name> <operator>&amp;</operator> <name>CDF_STATIC</name><operator>)</operator></expr>)</condition> <block>{<block_content>  <comment type="block">/* Static constant in struct namespace. */</comment>
	  <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name></decl>;</decl_stmt>
	  <decl_stmt><decl><type><name>CTypeID</name></type> <name>fieldid</name> <init>= <expr><call><name>cp_decl_constinit</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ct</name></expr></argument>, <argument><expr><name>ctypeid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	  <expr_stmt><expr><call><name>ctype_get</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cts</name></name></expr></argument>, <argument><expr><name>lastid</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>sib</name> <operator>=</operator> <name>fieldid</name></expr>;</expr_stmt>
	  <expr_stmt><expr><name>lastid</name> <operator>=</operator> <name>fieldid</name></expr>;</expr_stmt>
	  <expr_stmt><expr><call><name>ctype_setname</name><argument_list>(<argument><expr><name>ct</name></expr></argument>, <argument><expr><name><name>decl</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
	  <decl_stmt><decl><type><name>CTSize</name></type> <name>bsz</name> <init>= <expr><name>CTBSZ_FIELD</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* Temp. for layout phase. */</comment>
	  <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name></decl>;</decl_stmt>
	  <decl_stmt><decl><type><name>CTypeID</name></type> <name>fieldid</name> <init>= <expr><call><name>lj_ctype_new</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cts</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ct</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* Do this first. */</comment>
	  <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>tct</name> <init>= <expr><call><name>ctype_raw</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cts</name></name></expr></argument>, <argument><expr><name>ctypeid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	  <if_stmt><if>if <condition>(<expr><name><name>decl</name><operator>.</operator><name>bits</name></name> <operator>==</operator> <name>CTSIZE_INVALID</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Regular field. */</comment>
	    <if_stmt><if>if <condition>(<expr><call><name>ctype_isarray</name><argument_list>(<argument><expr><name><name>tct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>tct</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <name>CTSIZE_INVALID</name></expr>)</condition><block type="pseudo"><block_content>
	      <expr_stmt><expr><name>lastdecl</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* a[] or a[?] must be the last declared field. */</comment>

	    <comment type="block">/* Accept transparent struct/union/enum. */</comment>
	    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>decl</name><operator>.</operator><name>name</name></name></expr>)</condition> <block>{<block_content>
	      <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><call><name>ctype_isstruct</name><argument_list>(<argument><expr><name><name>tct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>tct</name><operator>-&gt;</operator><name>info</name></name> <operator>&amp;</operator> <name>CTF_VLA</name><operator>)</operator><operator>)</operator> <operator>||</operator>
		    <call><name>ctype_isenum</name><argument_list>(<argument><expr><name><name>tct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>cp_err_token</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>CTOK_IDENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	      <expr_stmt><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name> <operator>=</operator> <call><name>CTINFO</name><argument_list>(<argument><expr><name>CT_ATTRIB</name></expr></argument>, <argument><expr><call><name>CTATTRIB</name><argument_list>(<argument><expr><name>CTA_SUBTYPE</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>ctypeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <expr_stmt><expr><name><name>ct</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <ternary><condition><expr><call><name>ctype_isstruct</name><argument_list>(<argument><expr><name><name>tct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then>
			 <expr><operator>(</operator><name><name>decl</name><operator>.</operator><name>attr</name></name><operator>|</operator><literal type="number">0x80000000u</literal><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>  <comment type="block">/* For layout phase. */</comment>
	      <goto>goto <name>add_field</name>;</goto>
	    </block_content>}</block></if></if_stmt>
	  </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* Bitfield. */</comment>
	    <expr_stmt><expr><name>bsz</name> <operator>=</operator> <name><name>decl</name><operator>.</operator><name>bits</name></name></expr>;</expr_stmt>
	    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ctype_isinteger_or_bool</name><argument_list>(<argument><expr><name><name>tct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
		<operator>(</operator><name>bsz</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>decl</name><operator>.</operator><name>name</name></name><operator>)</operator> <operator>||</operator> <literal type="number">8</literal><operator>*</operator><name><name>tct</name><operator>-&gt;</operator><name>size</name></name> <operator>&gt;</operator> <name>CTBSZ_MAX</name> <operator>||</operator>
		<name>bsz</name> <operator>&gt;</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>tct</name><operator>-&gt;</operator><name>info</name></name> <operator>&amp;</operator> <name>CTF_BOOL</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">8</literal><operator>*</operator><name><name>tct</name><operator>-&gt;</operator><name>size</name></name></expr></else></ternary><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	      <expr_stmt><expr><call><name>cp_errmsg</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>, <argument><expr><name>LJ_ERR_BADVAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	  </block_content>}</block></else></if_stmt>

	  <comment type="block">/* Create temporary field for layout phase. */</comment>
	  <expr_stmt><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name> <operator>=</operator> <call><name>CTINFO</name><argument_list>(<argument><expr><name>CT_FIELD</name></expr></argument>, <argument><expr><name>ctypeid</name> <operator>+</operator> <operator>(</operator><name>bsz</name> <operator>&lt;&lt;</operator> <name>CTSHIFT_BITCSZ</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>ct</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name><name>decl</name><operator>.</operator><name>attr</name></name></expr>;</expr_stmt>
	  <if_stmt><if>if <condition>(<expr><name><name>decl</name><operator>.</operator><name>name</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ctype_setname</name><argument_list>(<argument><expr><name>ct</name></expr></argument>, <argument><expr><name><name>decl</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<label><name>add_field</name>:</label>
	  <expr_stmt><expr><call><name>ctype_get</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cts</name></name></expr></argument>, <argument><expr><name>lastid</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>sib</name> <operator>=</operator> <name>fieldid</name></expr>;</expr_stmt>
	  <expr_stmt><expr><name>lastid</name> <operator>=</operator> <name>fieldid</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cp_opt</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>cp_decl_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>decl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>cp_check</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">';'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>cp_check</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">'}'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ctype_get</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cts</name></name></expr></argument>, <argument><expr><name>lastid</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>sib</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* Drop sib = 1 for empty structs. */</comment>
    <expr_stmt><expr><call><name>cp_decl_attributes</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>sdecl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Layout phase needs postfix attributes. */</comment>
    <expr_stmt><expr><call><name>cp_struct_layout</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name><name>sdecl</name><operator>-&gt;</operator><name>attr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>sid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Parse enum declaration. */</comment>
<function><type><specifier>static</specifier> <name>CTypeID</name></type> <name>cp_decl_enum</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>CPDecl</name> <modifier>*</modifier></type><name>sdecl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CTypeID</name></type> <name>eid</name> <init>= <expr><call><name>cp_struct_name</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>sdecl</name></expr></argument>, <argument><expr><call><name>CTINFO</name><argument_list>(<argument><expr><name>CT_ENUM</name></expr></argument>, <argument><expr><name>CTID_VOID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTInfo</name></type> <name>einfo</name> <init>= <expr><call><name>CTINFO</name><argument_list>(<argument><expr><name>CT_ENUM</name></expr></argument>, <argument><expr><call><name>CTALIGN</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>+</operator> <name>CTID_UINT32</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTSize</name></type> <name>esize</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* Only 32 bit enums are supported. */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>cp_opt</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">'{'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Enum definition. */</comment>
    <decl_stmt><decl><type><name>CPValue</name></type> <name>k</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CTypeID</name></type> <name>lastid</name> <init>= <expr><name>eid</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>k</name><operator>.</operator><name>u32</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>k</name><operator>.</operator><name>id</name></name> <operator>=</operator> <name>CTID_INT32</name></expr>;</expr_stmt>
    <do>do <block>{<block_content>
      <decl_stmt><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name><name>cp</name><operator>-&gt;</operator><name>str</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>tok</name></name> <operator>!=</operator> <name>CTOK_IDENT</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>cp_err_token</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>CTOK_IDENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>id</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>cp_errmsg</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>LJ_ERR_FFI_REDEF</name></expr></argument>, <argument><expr><call><name>strdata</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>cp_next</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>cp_opt</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>cp_expr_kint</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>k</name><operator>.</operator><name>id</name></name> <operator>==</operator> <name>CTID_UINT32</name></expr>)</condition> <block>{<block_content>
	  <comment type="block">/* C99 says that enum constants are always (signed) integers.
	  ** But since unsigned constants like 0x80000000 are quite common,
	  ** those are left as uint32_t.
	  */</comment>
	  <if_stmt><if>if <condition>(<expr><name><name>k</name><operator>.</operator><name>i32</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>k</name><operator>.</operator><name>id</name></name> <operator>=</operator> <name>CTID_INT32</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
	  <comment type="block">/* OTOH it's common practice and even mandated by some ABIs
	  ** that the enum type itself is unsigned, unless there are any
	  ** negative constants.
	  */</comment>
	  <expr_stmt><expr><name><name>k</name><operator>.</operator><name>id</name></name> <operator>=</operator> <name>CTID_INT32</name></expr>;</expr_stmt>
	  <if_stmt><if>if <condition>(<expr><name><name>k</name><operator>.</operator><name>i32</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>einfo</name> <operator>=</operator> <call><name>CTINFO</name><argument_list>(<argument><expr><name>CT_ENUM</name></expr></argument>, <argument><expr><call><name>CTALIGN</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>+</operator> <name>CTID_INT32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
      <comment type="block">/* Add named enum constant. */</comment>
      <block>{<block_content>
	<decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CTypeID</name></type> <name>constid</name> <init>= <expr><call><name>lj_ctype_new</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cts</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ct</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ctype_get</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cts</name></name></expr></argument>, <argument><expr><name>lastid</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>sib</name> <operator>=</operator> <name>constid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>lastid</name> <operator>=</operator> <name>constid</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ctype_setname</name><argument_list>(<argument><expr><name>ct</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name> <operator>=</operator> <call><name>CTINFO</name><argument_list>(<argument><expr><name>CT_CONSTVAL</name></expr></argument>, <argument><expr><name>CTF_CONST</name><operator>|</operator><name><name>k</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ct</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name><name>k</name><operator>.</operator><name>u32</name></name><operator>++</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>k</name><operator>.</operator><name>u32</name></name> <operator>==</operator> <literal type="number">0x80000000u</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>k</name><operator>.</operator><name>id</name></name> <operator>=</operator> <name>CTID_UINT32</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>lj_ctype_addname</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cts</name></name></expr></argument>, <argument><expr><name>ct</name></expr></argument>, <argument><expr><name>constid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cp_opt</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block> while <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>tok</name></name> <operator>!=</operator> <literal type="char">'}'</literal></expr>)</condition>;</do>  <comment type="block">/* Trailing ',' is ok. */</comment>
    <expr_stmt><expr><call><name>cp_check</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">'}'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Complete enum. */</comment>
    <expr_stmt><expr><call><name>ctype_get</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cts</name></name></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>info</name> <operator>=</operator> <name>einfo</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ctype_get</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cts</name></name></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>size</name> <operator>=</operator> <name>esize</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>eid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Parse declaration specifiers. */</comment>
<function><type><specifier>static</specifier> <name>CPscl</name></type> <name>cp_decl_spec</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>CPDecl</name> <modifier>*</modifier></type><name>decl</name></decl></parameter>, <parameter><decl><type><name>CPscl</name></type> <name>scl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>cds</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>sz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTypeID</name></type> <name>tdef</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>decl</name><operator>-&gt;</operator><name>cp</name></name> <operator>=</operator> <name>cp</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>decl</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name><name>cp</name><operator>-&gt;</operator><name>mode</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>decl</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>decl</name><operator>-&gt;</operator><name>redir</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>decl</name><operator>-&gt;</operator><name>attr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>decl</name><operator>-&gt;</operator><name>fattr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>decl</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <name><name>decl</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>decl</name><operator>-&gt;</operator><name>stack</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>next</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>  <comment type="block">/* Parse basic types. */</comment>
    <expr_stmt><expr><call><name>cp_decl_attributes</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>decl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>tok</name></name> <operator>&gt;=</operator> <name>CTOK_FIRSTDECL</name> <operator>&amp;&amp;</operator> <name><name>cp</name><operator>-&gt;</operator><name>tok</name></name> <operator>&lt;=</operator> <name>CTOK_LASTDECLFLAG</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>cbit</name></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>ct</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>sz</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>end_decl</name>;</goto></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>sz</name> <operator>=</operator> <name><name>cp</name><operator>-&gt;</operator><name>ct</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>cbit</name> <operator>=</operator> <operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name><name>cp</name><operator>-&gt;</operator><name>tok</name></name> <operator>-</operator> <name>CTOK_FIRSTDECL</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>cds</name> <operator>=</operator> <name>cds</name> <operator>|</operator> <name>cbit</name> <operator>|</operator> <operator>(</operator><operator>(</operator><name>cbit</name> <operator>&amp;</operator> <name>cds</name> <operator>&amp;</operator> <name>CDF_LONG</name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>tok</name></name> <operator>&gt;=</operator> <name>CTOK_FIRSTSCL</name></expr>)</condition> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>scl</name> <operator>&amp;</operator> <name>cbit</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>cp_errmsg</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name><name>cp</name><operator>-&gt;</operator><name>tok</name></name></expr></argument>, <argument><expr><name>LJ_ERR_FFI_BADSCL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>tdef</name></expr>)</condition> <block>{<block_content>
	<goto>goto <name>end_decl</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>cp_next</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>sz</name> <operator>||</operator> <name>tdef</name> <operator>||</operator>
	<operator>(</operator><name>cds</name> <operator>&amp;</operator> <operator>(</operator><name>CDF_SHORT</name><operator>|</operator><name>CDF_LONG</name><operator>|</operator><name>CDF_SIGNED</name><operator>|</operator><name>CDF_UNSIGNED</name><operator>|</operator><name>CDF_COMPLEX</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
      <break>break;</break></block_content></block></if></if_stmt>
    <switch>switch <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>tok</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>CTOK_STRUCT</name></expr>:</case>
      <expr_stmt><expr><name>tdef</name> <operator>=</operator> <call><name>cp_decl_struct</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>decl</name></expr></argument>, <argument><expr><call><name>CTINFO</name><argument_list>(<argument><expr><name>CT_STRUCT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <continue>continue;</continue>
    <case>case <expr><name>CTOK_UNION</name></expr>:</case>
      <expr_stmt><expr><name>tdef</name> <operator>=</operator> <call><name>cp_decl_struct</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>decl</name></expr></argument>, <argument><expr><call><name>CTINFO</name><argument_list>(<argument><expr><name>CT_STRUCT</name></expr></argument>, <argument><expr><name>CTF_UNION</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <continue>continue;</continue>
    <case>case <expr><name>CTOK_ENUM</name></expr>:</case>
      <expr_stmt><expr><name>tdef</name> <operator>=</operator> <call><name>cp_decl_enum</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>decl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <continue>continue;</continue>
    <case>case <expr><name>CTOK_IDENT</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><call><name>ctype_istypedef</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name>tdef</name> <operator>=</operator> <call><name>ctype_cid</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Get typedef. */</comment>
	<expr_stmt><expr><call><name>cp_next</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<continue>continue;</continue>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    <case>case <expr><literal type="char">'$'</literal></expr>:</case>
      <expr_stmt><expr><name>tdef</name> <operator>=</operator> <name><name>cp</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>id</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>cp_next</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <continue>continue;</continue>
    <default>default:</default>
      <break>break;</break>
    </block_content>}</block></switch>
    <break>break;</break>
  </block_content>}</block></for>
<label><name>end_decl</name>:</label>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>cds</name> <operator>&amp;</operator> <name>CDF_COMPLEX</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* Use predefined complex types. */</comment>
    <expr_stmt><expr><name>tdef</name> <operator>=</operator> <ternary><condition><expr><name>sz</name> <operator>==</operator> <literal type="number">4</literal></expr> ?</condition><then> <expr><name>CTID_COMPLEX_FLOAT</name></expr> </then><else>: <expr><name>CTID_COMPLEX_DOUBLE</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>tdef</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>cp_push_type</name><argument_list>(<argument><expr><name>decl</name></expr></argument>, <argument><expr><name>tdef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>cds</name> <operator>&amp;</operator> <name>CDF_VOID</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>cp_push</name><argument_list>(<argument><expr><name>decl</name></expr></argument>, <argument><expr><call><name>CTINFO</name><argument_list>(<argument><expr><name>CT_VOID</name></expr></argument>, <argument><expr><operator>(</operator><name><name>decl</name><operator>-&gt;</operator><name>attr</name></name> <operator>&amp;</operator> <name>CTF_QUAL</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>CTSIZE_INVALID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>decl</name><operator>-&gt;</operator><name>attr</name></name> <operator>&amp;=</operator> <operator>~</operator><name>CTF_QUAL</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <comment type="block">/* Determine type info and size. */</comment>
    <decl_stmt><decl><type><name>CTInfo</name></type> <name>info</name> <init>= <expr><call><name>CTINFO</name><argument_list>(<argument><expr><name>CT_NUM</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>cds</name> <operator>&amp;</operator> <name>CDF_UNSIGNED</name><operator>)</operator></expr> ?</condition><then> <expr><name>CTF_UNSIGNED</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>cds</name> <operator>&amp;</operator> <name>CDF_BOOL</name><operator>)</operator></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>cds</name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>CDF_SCL</name><operator>|</operator><name>CDF_BOOL</name><operator>|</operator><name>CDF_INT</name><operator>|</operator><name>CDF_SIGNED</name><operator>|</operator><name>CDF_UNSIGNED</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>cp_errmsg</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>LJ_ERR_FFI_INVTYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>info</name> <operator>|=</operator> <name>CTF_BOOL</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>cds</name> <operator>&amp;</operator> <name>CDF_SIGNED</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>info</name> <operator>|=</operator> <name>CTF_UNSIGNED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>sz</name></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name>sz</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>cds</name> <operator>&amp;</operator> <name>CDF_FP</name><operator>)</operator></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>CTINFO</name><argument_list>(<argument><expr><name>CT_NUM</name></expr></argument>, <argument><expr><name>CTF_FP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>cds</name> <operator>&amp;</operator> <name>CDF_LONG</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>sz</name> <operator>=</operator> sizeof<operator>(</operator><name>long</name> <name>double</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>cds</name> <operator>&amp;</operator> <name>CDF_CHAR</name><operator>)</operator></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>cds</name> <operator>&amp;</operator> <operator>(</operator><name>CDF_CHAR</name><operator>|</operator><name>CDF_SIGNED</name><operator>|</operator><name>CDF_UNSIGNED</name><operator>)</operator><operator>)</operator> <operator>==</operator> <name>CDF_CHAR</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>info</name> <operator>|=</operator> <name>CTF_UCHAR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Handle platforms where char is unsigned. */</comment>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>cds</name> <operator>&amp;</operator> <name>CDF_SHORT</name><operator>)</operator></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>sz</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>short</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>cds</name> <operator>&amp;</operator> <name>CDF_LONGLONG</name><operator>)</operator></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>sz</name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>cds</name> <operator>&amp;</operator> <name>CDF_LONG</name><operator>)</operator></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>info</name> <operator>|=</operator> <name>CTF_LONG</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>sz</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>long</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>sz</name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>cds</name> <operator>&amp;</operator> <operator>(</operator><name>CDF_SIGNED</name><operator>|</operator><name>CDF_UNSIGNED</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>cp_errmsg</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name><name>cp</name><operator>-&gt;</operator><name>tok</name></name></expr></argument>, <argument><expr><name>LJ_ERR_FFI_DECLSPEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>sz</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>sz</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>info</name> <operator>+=</operator> <call><name>CTALIGN</name><argument_list>(<argument><expr><call><name>lj_fls</name><argument_list>(<argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Use natural alignment. */</comment>
    <expr_stmt><expr><name>info</name> <operator>+=</operator> <operator>(</operator><name><name>decl</name><operator>-&gt;</operator><name>attr</name></name> <operator>&amp;</operator> <name>CTF_QUAL</name><operator>)</operator></expr>;</expr_stmt>  <comment type="block">/* Merge qualifiers. */</comment>
    <expr_stmt><expr><call><name>cp_push</name><argument_list>(<argument><expr><name>decl</name></expr></argument>, <argument><expr><name>info</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>decl</name><operator>-&gt;</operator><name>attr</name></name> <operator>&amp;=</operator> <operator>~</operator><name>CTF_QUAL</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>decl</name><operator>-&gt;</operator><name>specpos</name></name> <operator>=</operator> <name><name>decl</name><operator>-&gt;</operator><name>pos</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>decl</name><operator>-&gt;</operator><name>specattr</name></name> <operator>=</operator> <name><name>decl</name><operator>-&gt;</operator><name>attr</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>decl</name><operator>-&gt;</operator><name>specfattr</name></name> <operator>=</operator> <name><name>decl</name><operator>-&gt;</operator><name>fattr</name></name></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><name>cds</name> <operator>&amp;</operator> <name>CDF_SCL</name><operator>)</operator></expr>;</return>  <comment type="block">/* Return storage class. */</comment>
</block_content>}</block></function>

<comment type="block">/* Parse array declaration. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>cp_decl_array</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>CPDecl</name> <modifier>*</modifier></type><name>decl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CTInfo</name></type> <name>info</name> <init>= <expr><call><name>CTINFO</name><argument_list>(<argument><expr><name>CT_ARRAY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTSize</name></type> <name>nelem</name> <init>= <expr><name>CTSIZE_INVALID</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* Default size for a[] or a[?]. */</comment>
  <expr_stmt><expr><call><name>cp_decl_attributes</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>decl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>cp_opt</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">'?'</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>info</name> <operator>|=</operator> <name>CTF_VLA</name></expr>;</expr_stmt></block_content></block></if>  <comment type="block">/* Create variable-length array a[?]. */</comment>
  <if type="elseif">else if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>tok</name></name> <operator>!=</operator> <literal type="char">']'</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>nelem</name> <operator>=</operator> <call><name>cp_expr_ksize</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>cp_check</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">']'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>cp_add</name><argument_list>(<argument><expr><name>decl</name></expr></argument>, <argument><expr><name>info</name></expr></argument>, <argument><expr><name>nelem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Parse function declaration. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>cp_decl_func</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>CPDecl</name> <modifier>*</modifier></type><name>fdecl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CTSize</name></type> <name>nargs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTInfo</name></type> <name>info</name> <init>= <expr><call><name>CTINFO</name><argument_list>(<argument><expr><name>CT_FUNC</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTypeID</name></type> <name>lastid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>anchor</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>tok</name></name> <operator>!=</operator> <literal type="char">')'</literal></expr>)</condition> <block>{<block_content>
    <do>do <block>{<block_content>
      <decl_stmt><decl><type><name>CPDecl</name></type> <name>decl</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>CTypeID</name></type> <name>ctypeid</name></decl>, <decl><type ref="prev"/><name>fieldid</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>cp_opt</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Vararg function. */</comment>
	<expr_stmt><expr><call><name>cp_check</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Workaround for the minimalistic lexer. */</comment>
	<expr_stmt><expr><call><name>cp_check</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>info</name> <operator>|=</operator> <name>CTF_VARARG</name></expr>;</expr_stmt>
	<break>break;</break>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>cp_decl_spec</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>decl</name></expr></argument>, <argument><expr><name>CDF_REGISTER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>decl</name><operator>.</operator><name>mode</name></name> <operator>=</operator> <name>CPARSE_MODE_DIRECT</name><operator>|</operator><name>CPARSE_MODE_ABSTRACT</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>cp_declarator</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>decl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>ctypeid</name> <operator>=</operator> <call><name>cp_decl_intern</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>decl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>ctype_raw</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cts</name></name></expr></argument>, <argument><expr><name>ctypeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>ctype_isvoid</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	<break>break;</break></block_content></block></if>
      <if type="elseif">else if <condition>(<expr><call><name>ctype_isrefarray</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>ctypeid</name> <operator>=</operator> <call><name>lj_ctype_intern</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cts</name></name></expr></argument>,
	  <argument><expr><call><name>CTINFO</name><argument_list>(<argument><expr><name>CT_PTR</name></expr></argument>, <argument><expr><name>CTALIGN_PTR</name><operator>|</operator><call><name>ctype_cid</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>CTSIZE_PTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
      <if type="elseif">else if <condition>(<expr><call><name>ctype_isfunc</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>ctypeid</name> <operator>=</operator> <call><name>lj_ctype_intern</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cts</name></name></expr></argument>,
	  <argument><expr><call><name>CTINFO</name><argument_list>(<argument><expr><name>CT_PTR</name></expr></argument>, <argument><expr><name>CTALIGN_PTR</name><operator>|</operator><name>ctypeid</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>CTSIZE_PTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <comment type="block">/* Add new parameter. */</comment>
      <expr_stmt><expr><name>fieldid</name> <operator>=</operator> <call><name>lj_ctype_new</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cts</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>anchor</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>ctype_get</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cts</name></name></expr></argument>, <argument><expr><name>lastid</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>sib</name> <operator>=</operator> <name>fieldid</name></expr>;</expr_stmt></block_content></block></if>
      <else>else<block type="pseudo"><block_content>
	<expr_stmt><expr><name>anchor</name> <operator>=</operator> <name>fieldid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
      <expr_stmt><expr><name>lastid</name> <operator>=</operator> <name>fieldid</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>decl</name><operator>.</operator><name>name</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ctype_setname</name><argument_list>(<argument><expr><name>ct</name></expr></argument>, <argument><expr><name><name>decl</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name> <operator>=</operator> <call><name>CTINFO</name><argument_list>(<argument><expr><name>CT_FIELD</name></expr></argument>, <argument><expr><name>ctypeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>ct</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>nargs</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block> while <condition>(<expr><call><name>cp_opt</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>)</condition>;</do>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>cp_check</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>cp_opt</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">'{'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Skip function definition. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>level</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>mode</name></name> <operator>|=</operator> <name>CPARSE_MODE_SKIP</name></expr>;</expr_stmt>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>tok</name></name> <operator>==</operator> <literal type="char">'{'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>level</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
      <if type="elseif">else if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>tok</name></name> <operator>==</operator> <literal type="char">'}'</literal> <operator>&amp;&amp;</operator> <operator>--</operator><name>level</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if>
      <if type="elseif">else if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>tok</name></name> <operator>==</operator> <name>CTOK_EOF</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>cp_err_token</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">'}'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>cp_next</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>mode</name></name> <operator>&amp;=</operator> <operator>~</operator><name>CPARSE_MODE_SKIP</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>tok</name></name> <operator>=</operator> <literal type="char">';'</literal></expr>;</expr_stmt>  <comment type="block">/* Ok for cp_decl_multi(), error in cp_decl_single(). */</comment>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>info</name> <operator>|=</operator> <operator>(</operator><name><name>fdecl</name><operator>-&gt;</operator><name>fattr</name></name> <operator>&amp;</operator> <operator>~</operator><name>CTMASK_CID</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fdecl</name><operator>-&gt;</operator><name>fattr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fdecl</name><operator>-&gt;</operator><name>stack</name><index>[<expr><call><name>cp_add</name><argument_list>(<argument><expr><name>fdecl</name></expr></argument>, <argument><expr><name>info</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>)</argument_list></call></expr>]</index></name><operator>.</operator><name>sib</name> <operator>=</operator> <name>anchor</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Parse declarator. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>cp_declarator</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>CPDecl</name> <modifier>*</modifier></type><name>decl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>++</operator><name><name>cp</name><operator>-&gt;</operator><name>depth</name></name> <operator>&gt;</operator> <name>CPARSE_MAX_DECLDEPTH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>cp_err</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>LJ_ERR_XLEVELS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>  <comment type="block">/* Head of declarator. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>cp_opt</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">'*'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Pointer. */</comment>
      <decl_stmt><decl><type><name>CTSize</name></type> <name>sz</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>CTInfo</name></type> <name>info</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>cp_decl_attributes</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>decl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>sz</name> <operator>=</operator> <name>CTSIZE_PTR</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>CTINFO</name><argument_list>(<argument><expr><name>CT_PTR</name></expr></argument>, <argument><expr><name>CTALIGN_PTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_64</name></expr></cpp:if>
      <if_stmt><if>if <condition>(<expr><call><name>ctype_msizeP</name><argument_list>(<argument><expr><name><name>decl</name><operator>-&gt;</operator><name>attr</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name>sz</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>CTINFO</name><argument_list>(<argument><expr><name>CT_PTR</name></expr></argument>, <argument><expr><call><name>CTALIGN</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><name>info</name> <operator>+=</operator> <operator>(</operator><name><name>decl</name><operator>-&gt;</operator><name>attr</name></name> <operator>&amp;</operator> <operator>(</operator><name>CTF_QUAL</name><operator>|</operator><name>CTF_REF</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>decl</name><operator>-&gt;</operator><name>attr</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>CTF_QUAL</name><operator>|</operator><operator>(</operator><name>CTMASK_MSIZEP</name><operator>&lt;&lt;</operator><name>CTSHIFT_MSIZEP</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>cp_push</name><argument_list>(<argument><expr><name>decl</name></expr></argument>, <argument><expr><name>info</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>cp_opt</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">'&amp;'</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>cp_opt</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>CTOK_ANDAND</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Reference. */</comment>
      <expr_stmt><expr><name><name>decl</name><operator>-&gt;</operator><name>attr</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>CTF_QUAL</name><operator>|</operator><operator>(</operator><name>CTMASK_MSIZEP</name><operator>&lt;&lt;</operator><name>CTSHIFT_MSIZEP</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>cp_push</name><argument_list>(<argument><expr><name>decl</name></expr></argument>, <argument><expr><call><name>CTINFO_REF</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>CTSIZE_PTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <break>break;</break>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if <condition>(<expr><call><name>cp_opt</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Inner declarator. */</comment>
    <decl_stmt><decl><type><name>CPDeclIdx</name></type> <name>pos</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>cp_decl_attributes</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>decl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Resolve ambiguity between inner declarator and 1st function parameter. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>decl</name><operator>-&gt;</operator><name>mode</name></name> <operator>&amp;</operator> <name>CPARSE_MODE_ABSTRACT</name><operator>)</operator> <operator>&amp;&amp;</operator>
	<operator>(</operator><name><name>cp</name><operator>-&gt;</operator><name>tok</name></name> <operator>==</operator> <literal type="char">')'</literal> <operator>||</operator> <call><name>cp_istypedecl</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>func_decl</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pos</name> <operator>=</operator> <name><name>decl</name><operator>-&gt;</operator><name>pos</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>cp_declarator</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>decl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>cp_check</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>decl</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <name>pos</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>tok</name></name> <operator>==</operator> <name>CTOK_IDENT</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Direct declarator. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>decl</name><operator>-&gt;</operator><name>mode</name></name> <operator>&amp;</operator> <name>CPARSE_MODE_DIRECT</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>cp_err_token</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>CTOK_EOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>decl</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name><name>cp</name><operator>-&gt;</operator><name>str</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>decl</name><operator>-&gt;</operator><name>nameid</name></name> <operator>=</operator> <name><name>cp</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>id</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>cp_next</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* Abstract declarator. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>decl</name><operator>-&gt;</operator><name>mode</name></name> <operator>&amp;</operator> <name>CPARSE_MODE_ABSTRACT</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>cp_err_token</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>CTOK_IDENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>  <comment type="block">/* Tail of declarator. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>cp_opt</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">'['</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Array. */</comment>
      <expr_stmt><expr><call><name>cp_decl_array</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>decl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>cp_opt</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Function. */</comment>
    <label><name>func_decl</name>:</label>
      <expr_stmt><expr><call><name>cp_decl_func</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>decl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <break>break;</break>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>decl</name><operator>-&gt;</operator><name>mode</name></name> <operator>&amp;</operator> <name>CPARSE_MODE_FIELD</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>cp_opt</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* Field width. */</comment>
    <expr_stmt><expr><name><name>decl</name><operator>-&gt;</operator><name>bits</name></name> <operator>=</operator> <call><name>cp_expr_ksize</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* Process postfix attributes. */</comment>
  <expr_stmt><expr><call><name>cp_decl_attributes</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>decl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>cp_push_attributes</name><argument_list>(<argument><expr><name>decl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>depth</name></name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Parse an abstract type declaration and return it's C type ID. */</comment>
<function><type><specifier>static</specifier> <name>CTypeID</name></type> <name>cp_decl_abstract</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CPDecl</name></type> <name>decl</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>cp_decl_spec</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>decl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>decl</name><operator>.</operator><name>mode</name></name> <operator>=</operator> <name>CPARSE_MODE_ABSTRACT</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>cp_declarator</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>decl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>cp_decl_intern</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>decl</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Handle pragmas. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>cp_pragma</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>BCLine</name></type> <name>pragmaline</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>cp_next</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>tok</name></name> <operator>==</operator> <name>CTOK_IDENT</name> <operator>&amp;&amp;</operator> <call><name>cp_str_is</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"pack"</literal></expr></argument>)</argument_list></call></expr>)</condition>  <block>{<block_content>
    <expr_stmt><expr><call><name>cp_next</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>cp_check</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>tok</name></name> <operator>==</operator> <name>CTOK_IDENT</name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>cp_str_is</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"push"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>curpack</name></name> <operator>&lt;</operator> <name>CPARSE_MAX_PACKSTACK</name></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>packstack</name><index>[<expr><name><name>cp</name><operator>-&gt;</operator><name>curpack</name></name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>cp</name><operator>-&gt;</operator><name>packstack</name><index>[<expr><name><name>cp</name><operator>-&gt;</operator><name>curpack</name></name></expr>]</index></name></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>curpack</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>cp_str_is</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"pop"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>curpack</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>curpack</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<expr_stmt><expr><call><name>cp_errmsg</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name><name>cp</name><operator>-&gt;</operator><name>tok</name></name></expr></argument>, <argument><expr><name>LJ_ERR_XSYMBOL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>cp_next</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cp_opt</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>end_pack</name>;</goto></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>tok</name></name> <operator>==</operator> <name>CTOK_INTEGER</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>packstack</name><index>[<expr><name><name>cp</name><operator>-&gt;</operator><name>curpack</name></name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name><name>cp</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>u32</name></name></expr> ?</condition><then> <expr><call><name>lj_fls</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>u32</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>cp_next</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>packstack</name><index>[<expr><name><name>cp</name><operator>-&gt;</operator><name>curpack</name></name></expr>]</index></name> <operator>=</operator> <literal type="number">255</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  <label><name>end_pack</name>:</label>
    <expr_stmt><expr><call><name>cp_check</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* Ignore all other pragmas. */</comment>
    <while>while <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>tok</name></name> <operator>!=</operator> <name>CTOK_EOF</name> <operator>&amp;&amp;</operator> <name><name>cp</name><operator>-&gt;</operator><name>linenumber</name></name> <operator>==</operator> <name>pragmaline</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>cp_next</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Handle line number. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>cp_line</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>BCLine</name></type> <name>hashline</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>BCLine</name></type> <name>newline</name> <init>= <expr><name><name>cp</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>u32</name></name></expr></init></decl>;</decl_stmt>
  <comment type="block">/* TODO: Handle file name and include it in error messages. */</comment>
  <while>while <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>tok</name></name> <operator>!=</operator> <name>CTOK_EOF</name> <operator>&amp;&amp;</operator> <name><name>cp</name><operator>-&gt;</operator><name>linenumber</name></name> <operator>==</operator> <name>hashline</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>cp_next</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
  <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>linenumber</name></name> <operator>=</operator> <name>newline</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Parse multiple C declarations of types or extern identifiers. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>cp_decl_multi</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>first</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>tok</name></name> <operator>!=</operator> <name>CTOK_EOF</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>CPDecl</name></type> <name>decl</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CPscl</name></type> <name>scl</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>cp_opt</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">';'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Skip empty statements. */</comment>
      <expr_stmt><expr><name>first</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>tok</name></name> <operator>==</operator> <literal type="char">'#'</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* Workaround, since we have no preprocessor, yet. */</comment>
      <decl_stmt><decl><type><name>BCLine</name></type> <name>hashline</name> <init>= <expr><name><name>cp</name><operator>-&gt;</operator><name>linenumber</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>CPToken</name></type> <name>tok</name> <init>= <expr><call><name>cp_next</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>tok</name> <operator>==</operator> <name>CTOK_INTEGER</name></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>cp_line</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>hashline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<continue>continue;</continue>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>tok</name> <operator>==</operator> <name>CTOK_IDENT</name> <operator>&amp;&amp;</operator> <call><name>cp_str_is</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"line"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>cp_next</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CTOK_INTEGER</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>cp_err_token</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>cp_line</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>hashline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<continue>continue;</continue>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>tok</name> <operator>==</operator> <name>CTOK_IDENT</name> <operator>&amp;&amp;</operator> <call><name>cp_str_is</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"pragma"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>cp_pragma</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>hashline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<continue>continue;</continue>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<expr_stmt><expr><call><name>cp_errmsg</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name><name>cp</name><operator>-&gt;</operator><name>tok</name></name></expr></argument>, <argument><expr><name>LJ_ERR_XSYMBOL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>scl</name> <operator>=</operator> <call><name>cp_decl_spec</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>decl</name></expr></argument>, <argument><expr><name>CDF_TYPEDEF</name><operator>|</operator><name>CDF_EXTERN</name><operator>|</operator><name>CDF_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>cp</name><operator>-&gt;</operator><name>tok</name></name> <operator>==</operator> <literal type="char">';'</literal> <operator>||</operator> <name><name>cp</name><operator>-&gt;</operator><name>tok</name></name> <operator>==</operator> <name>CTOK_EOF</name><operator>)</operator> <operator>&amp;&amp;</operator>
	<call><name>ctype_istypedef</name><argument_list>(<argument><expr><name><name>decl</name><operator>.</operator><name>stack</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>info</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>CTInfo</name></type> <name>info</name> <init>= <expr><call><name>ctype_rawchild</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cts</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>decl</name><operator>.</operator><name>stack</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>info</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>ctype_isstruct</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ctype_isenum</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	<goto>goto <name>decl_end</name>;</goto></block_content></block></if></if_stmt>  <comment type="block">/* Accept empty declaration of struct/union/enum. */</comment>
    </block_content>}</block></if></if_stmt>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
      <decl_stmt><decl><type><name>CTypeID</name></type> <name>ctypeid</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>cp_declarator</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>decl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>ctypeid</name> <operator>=</operator> <call><name>cp_decl_intern</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>decl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>decl</name><operator>.</operator><name>name</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>decl</name><operator>.</operator><name>nameid</name></name></expr>)</condition> <block>{<block_content>  <comment type="block">/* NYI: redeclarations are ignored. */</comment>
	<decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CTypeID</name></type> <name>id</name></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>scl</name> <operator>&amp;</operator> <name>CDF_TYPEDEF</name><operator>)</operator></expr>)</condition> <block>{<block_content>  <comment type="block">/* Create new typedef. */</comment>
	  <expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>lj_ctype_new</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cts</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name> <operator>=</operator> <call><name>CTINFO</name><argument_list>(<argument><expr><name>CT_TYPEDEF</name></expr></argument>, <argument><expr><name>ctypeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <goto>goto <name>noredir</name>;</goto>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ctype_isfunc</name><argument_list>(<argument><expr><call><name>ctype_get</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cts</name></name></expr></argument>, <argument><expr><name>ctypeid</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>info</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	  <comment type="block">/* Treat both static and extern function declarations as extern. */</comment>
	  <expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>ctype_get</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cts</name></name></expr></argument>, <argument><expr><name>ctypeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <comment type="block">/* We always get new anonymous functions (typedefs are copied). */</comment>
	  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>gcref</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><name>id</name> <operator>=</operator> <name>ctypeid</name></expr>;</expr_stmt>  <comment type="block">/* Just name it. */</comment>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>scl</name> <operator>&amp;</operator> <name>CDF_STATIC</name><operator>)</operator></expr>)</condition> <block>{<block_content>  <comment type="block">/* Accept static constants. */</comment>
	  <expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>cp_decl_constinit</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ct</name></expr></argument>, <argument><expr><name>ctypeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <goto>goto <name>noredir</name>;</goto>
	</block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* External references have extern or no storage class. */</comment>
	  <expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>lj_ctype_new</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cts</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name> <operator>=</operator> <call><name>CTINFO</name><argument_list>(<argument><expr><name>CT_EXTERN</name></expr></argument>, <argument><expr><name>ctypeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>decl</name><operator>.</operator><name>redir</name></name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Add attribute for redirected symbol name. */</comment>
	  <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>cta</name></decl>;</decl_stmt>
	  <decl_stmt><decl><type><name>CTypeID</name></type> <name>aid</name> <init>= <expr><call><name>lj_ctype_new</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cts</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cta</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	  <expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>ctype_get</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cts</name></name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Table may have been reallocated. */</comment>
	  <expr_stmt><expr><name><name>cta</name><operator>-&gt;</operator><name>info</name></name> <operator>=</operator> <call><name>CTINFO</name><argument_list>(<argument><expr><name>CT_ATTRIB</name></expr></argument>, <argument><expr><call><name>CTATTRIB</name><argument_list>(<argument><expr><name>CTA_REDIR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>cta</name><operator>-&gt;</operator><name>sib</name></name> <operator>=</operator> <name><name>ct</name><operator>-&gt;</operator><name>sib</name></name></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>ct</name><operator>-&gt;</operator><name>sib</name></name> <operator>=</operator> <name>aid</name></expr>;</expr_stmt>
	  <expr_stmt><expr><call><name>ctype_setname</name><argument_list>(<argument><expr><name>cta</name></expr></argument>, <argument><expr><name><name>decl</name><operator>.</operator><name>redir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
      <label><name>noredir</name>:</label>
	<expr_stmt><expr><call><name>ctype_setname</name><argument_list>(<argument><expr><name>ct</name></expr></argument>, <argument><expr><name><name>decl</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lj_ctype_addname</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cts</name></name></expr></argument>, <argument><expr><name>ct</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cp_opt</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>cp_decl_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>decl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  <label><name>decl_end</name>:</label>
    <if_stmt><if>if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>tok</name></name> <operator>==</operator> <name>CTOK_EOF</name> <operator>&amp;&amp;</operator> <name>first</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>  <comment type="block">/* May omit ';' for 1 decl. */</comment>
    <expr_stmt><expr><name>first</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>cp_check</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">';'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/* Parse a single C type declaration. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>cp_decl_single</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CPDecl</name></type> <name>decl</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>cp_decl_spec</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>decl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>cp_declarator</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>decl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>id</name></name> <operator>=</operator> <call><name>cp_decl_intern</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>decl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>tok</name></name> <operator>!=</operator> <name>CTOK_EOF</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>cp_err_token</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>CTOK_EOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ------------------------------------------------------------------------ */</comment>

<comment type="block">/* Protected callback for C parser. */</comment>
<function><type><specifier>static</specifier> <name>TValue</name> <modifier>*</modifier></type><name>cpcparser</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>lua_CFunction</name></type> <name>dummy</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ud</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name> <init>= <expr><operator>(</operator><name>CPState</name> <operator>*</operator><operator>)</operator><name>ud</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>dummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>cframe_errfunc</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>cframe</name></name></expr></argument>)</argument_list></call> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* Inherit error function. */</comment>
  <expr_stmt><expr><call><name>cp_init</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>cp</name><operator>-&gt;</operator><name>mode</name></name> <operator>&amp;</operator> <name>CPARSE_MODE_MULTI</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>cp_decl_multi</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>cp_decl_single</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>param</name></name> <operator>&amp;&amp;</operator> <name><name>cp</name><operator>-&gt;</operator><name>param</name></name> <operator>!=</operator> <name><name>cp</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>top</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>cp_err</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>LJ_ERR_FFI_NUMPARAM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>depth</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* C parser. */</comment>
<function><type><name>int</name></type> <name>lj_cparse</name><parameter_list>(<parameter><decl><type><name>CPState</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>LJ_CTYPE_SAVE</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>errcode</name> <init>= <expr><call><name>lj_vm_cpcall</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>, <argument><expr><name>cpcparser</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>errcode</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>LJ_CTYPE_RESTORE</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>cp_cleanup</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>errcode</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
