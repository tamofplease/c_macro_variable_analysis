<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/sysbench/third_party/luajit/luajit/src/lj_strscan.c"><comment type="block">/*
** String scanning.
** Copyright (C) 2005-2020 Mike Pall. See Copyright Notice in luajit.h
*/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lj_strscan_c</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUA_CORE</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_obj.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_char.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_strscan.h"</cpp:file></cpp:include>

<comment type="block">/* -- Scanning numbers ---------------------------------------------------- */</comment>

<comment type="block">/*
** Rationale for the builtin string to number conversion library:
**
** It removes a dependency on libc's strtod(), which is a true portability
** nightmare. Mainly due to the plethora of supported OS and toolchain
** combinations. Sadly, the various implementations
** a) are often buggy, incomplete (no hex floats) and/or imprecise,
** b) sometimes crash or hang on certain inputs,
** c) return non-standard NaNs that need to be filtered out, and
** d) fail if the locale-specific decimal separator is not a dot,
**    which can only be fixed with atrocious workarounds.
**
** Also, most of the strtod() implementations are hopelessly bloated,
** which is not just an I-cache hog, but a problem for static linkage
** on embedded systems, too.
**
** OTOH the builtin conversion function is very compact. Even though it
** does a lot more, like parsing long longs, octal or imaginary numbers
** and returning the result in different formats:
** a) It needs less than 3 KB (!) of machine code (on x64 with -Os),
** b) it doesn't perform any dynamic allocation and,
** c) it needs only around 600 bytes of stack space.
**
** The builtin function is faster than strtod() for typical inputs, e.g.
** "123", "1.5" or "1e6". Arguably, it's slower for very large exponents,
** which are not very common (this could be fixed, if needed).
**
** And most importantly, the builtin function is equally precise on all
** platforms. It correctly converts and rounds any input to a double.
** If this is not the case, please send a bug report -- but PLEASE verify
** that the implementation you're comparing to is not the culprit!
**
** The implementation quickly pre-scans the entire string first and
** handles simple integers on-the-fly. Otherwise, it dispatches to the
** base-specific parser. Hex and octal is straightforward.
**
** Decimal to binary conversion uses a fixed-length circular buffer in
** base 100. Some simple cases are handled directly. For other cases, the
** number in the buffer is up-scaled or down-scaled until the integer part
** is in the proper range. Then the integer part is rounded and converted
** to a double which is finally rescaled to the result. Denormals need
** special treatment to prevent incorrect 'double rounding'.
*/</comment>

<comment type="block">/* Definitions for circular decimal digit buffer (base 100 = 2 digits/byte). */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRSCAN_DIG</name></cpp:macro>	<cpp:value>1024</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRSCAN_MAXDIG</name></cpp:macro>	<cpp:value>800</cpp:value></cpp:define>		<comment type="block">/* 772 + extra are sufficient. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRSCAN_DDIG</name></cpp:macro>	<cpp:value>(STRSCAN_DIG/2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRSCAN_DMASK</name></cpp:macro>	<cpp:value>(STRSCAN_DDIG-1)</cpp:value></cpp:define>

<comment type="block">/* Helpers for circular buffer. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DNEXT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(((a)+1) &amp; STRSCAN_DMASK)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DPREV</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(((a)-1) &amp; STRSCAN_DMASK)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DLEN</name><parameter_list>(<parameter><type><name>lo</name></type></parameter>, <parameter><type><name>hi</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((int32_t)(((lo)-(hi)) &amp; STRSCAN_DMASK))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>casecmp</name><parameter_list>(<parameter><type><name>c</name></type></parameter>, <parameter><type><name>k</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(((c) | 0x20) == k)</cpp:value></cpp:define>

<comment type="block">/* Final conversion to double. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>strscan_double</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>TValue</name> <modifier>*</modifier></type><name>o</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>ex2</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>neg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>double</name></type> <name>n</name></decl>;</decl_stmt>

  <comment type="block">/* Avoid double rounding for denormals. */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>LJ_UNLIKELY</name><argument_list>(<argument><expr><name>ex2</name> <operator>&lt;=</operator> <operator>-</operator><literal type="number">1075</literal> <operator>&amp;&amp;</operator> <name>x</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <comment type="block">/* NYI: all of this generates way too much code on 32 bit CPUs. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>LJ_64</name></expr></cpp:if>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>b</name> <init>= <expr><operator>(</operator><name>int32_t</name><operator>)</operator><operator>(</operator><call><name>__builtin_clzll</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call><operator>^</operator><literal type="number">63</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>b</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>x</name><operator>&gt;&gt;</operator><literal type="number">32</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">32</literal><operator>+</operator><operator>(</operator><name>int32_t</name><operator>)</operator><call><name>lj_fls</name><argument_list>(<argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>x</name><operator>&gt;&gt;</operator><literal type="number">32</literal><operator>)</operator></expr></argument>)</argument_list></call></expr> </then><else>:
			  <expr><operator>(</operator><name>int32_t</name><operator>)</operator><call><name>lj_fls</name><argument_list>(<argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>x</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>int32_t</name><operator>)</operator><name>b</name> <operator>+</operator> <name>ex2</name> <operator>&lt;=</operator> <operator>-</operator><literal type="number">1023</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>int32_t</name><operator>)</operator><name>b</name> <operator>+</operator> <name>ex2</name> <operator>&gt;=</operator> <operator>-</operator><literal type="number">1075</literal></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>uint64_t</name></type> <name>rb</name> <init>= <expr><operator>(</operator><name>uint64_t</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><operator>-</operator><literal type="number">1075</literal><operator>-</operator><name>ex2</name><operator>)</operator></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>x</name> <operator>&amp;</operator> <name>rb</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>x</name> <operator>&amp;</operator> <operator>(</operator><name>rb</name><operator>+</operator><name>rb</name><operator>+</operator><name>rb</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>x</name> <operator>+=</operator> <name>rb</name><operator>+</operator><name>rb</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>x</name> <operator>=</operator> <operator>(</operator><name>x</name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>rb</name><operator>+</operator><name>rb</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Convert to double using a signed int64_t conversion, then rescale. */</comment>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><operator>(</operator><name>int64_t</name><operator>)</operator><name>x</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator><operator>(</operator><name>int64_t</name><operator>)</operator><name>x</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>neg</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name> <operator>=</operator> <operator>-</operator><name>n</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>ex2</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>ldexp</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>ex2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Parse hexadecimal number. */</comment>
<function><type><specifier>static</specifier> <name>StrScanFmt</name></type> <name>strscan_hex</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>TValue</name> <modifier>*</modifier></type><name>o</name></decl></parameter>,
			      <parameter><decl><type><name>StrScanFmt</name></type> <name>fmt</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>opt</name></decl></parameter>,
			      <parameter><decl><type><name>int32_t</name></type> <name>ex2</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>neg</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>dig</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint64_t</name></type> <name>x</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>;</decl_stmt>

  <comment type="block">/* Scan hex digits. */</comment>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <ternary><condition><expr><name>dig</name> <operator>&gt;</operator> <literal type="number">16</literal></expr> ?</condition><then> <expr><literal type="number">16</literal></expr> </then><else>: <expr><name>dig</name></expr></else></ternary></expr> ;</init> <condition><expr><name>i</name></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr><operator>,</operator> <expr><name>p</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>d</name> <init>= <expr><operator>(</operator><ternary><condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'.'</literal></expr> ?</condition><then> <expr><operator>*</operator><name>p</name></expr> </then><else>: <expr><operator>*</operator><operator>++</operator><name>p</name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt> <if_stmt><if>if <condition>(<expr><name>d</name> <operator>&gt;</operator> <literal type="char">'9'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>d</name> <operator>+=</operator> <literal type="number">9</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>x</name> <operator>=</operator> <operator>(</operator><name>x</name> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>d</name> <operator>&amp;</operator> <literal type="number">15</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Summarize rounding-effect of excess digits. */</comment>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">16</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>dig</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>p</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <expr_stmt><expr><name>x</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><ternary><condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'.'</literal></expr> ?</condition><then> <expr><operator>*</operator><name>p</name></expr> </then><else>: <expr><operator>*</operator><operator>++</operator><name>p</name></expr></else></ternary><operator>)</operator> <operator>!=</operator> <literal type="char">'0'</literal><operator>)</operator></expr><operator>,</operator> <expr><name>ex2</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></for>

  <comment type="block">/* Format-specific handling. */</comment>
  <switch>switch <condition>(<expr><name>fmt</name></expr>)</condition> <block>{<block_content>
  <case>case <expr><name>STRSCAN_INT</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>opt</name> <operator>&amp;</operator> <name>STRSCAN_OPT_TONUM</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>x</name> <operator>&lt;</operator> <literal type="number">0x80000000u</literal><operator>+</operator><name>neg</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>i</name></name> <operator>=</operator> <ternary><condition><expr><name>neg</name></expr> ?</condition><then> <expr><operator>-</operator><operator>(</operator><name>int32_t</name><operator>)</operator><name>x</name></expr> </then><else>: <expr><operator>(</operator><name>int32_t</name><operator>)</operator><name>x</name></expr></else></ternary></expr>;</expr_stmt>
      <return>return <expr><name>STRSCAN_INT</name></expr>;</return>  <comment type="block">/* Fast path for 32 bit integers. */</comment>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>opt</name> <operator>&amp;</operator> <name>STRSCAN_OPT_C</name><operator>)</operator></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>fmt</name> <operator>=</operator> <name>STRSCAN_NUM</name></expr>;</expr_stmt> <break>break;</break> </block_content>}</block></if></if_stmt>
    <comment type="block">/* fallthrough */</comment>
  <case>case <expr><name>STRSCAN_U32</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>dig</name> <operator>&gt;</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>STRSCAN_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>i</name></name> <operator>=</operator> <ternary><condition><expr><name>neg</name></expr> ?</condition><then> <expr><operator>-</operator><operator>(</operator><name>int32_t</name><operator>)</operator><name>x</name></expr> </then><else>: <expr><operator>(</operator><name>int32_t</name><operator>)</operator><name>x</name></expr></else></ternary></expr>;</expr_stmt>
    <return>return <expr><name>STRSCAN_U32</name></expr>;</return>
  <case>case <expr><name>STRSCAN_I64</name></expr>:</case>
  <case>case <expr><name>STRSCAN_U64</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>dig</name> <operator>&gt;</operator> <literal type="number">16</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>STRSCAN_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>u64</name></name> <operator>=</operator> <ternary><condition><expr><name>neg</name></expr> ?</condition><then> <expr><operator>(</operator><name>uint64_t</name><operator>)</operator><operator>-</operator><operator>(</operator><name>int64_t</name><operator>)</operator><name>x</name></expr> </then><else>: <expr><name>x</name></expr></else></ternary></expr>;</expr_stmt>
    <return>return <expr><name>fmt</name></expr>;</return>
  <default>default:</default>
    <break>break;</break>
  </block_content>}</block></switch>

  <comment type="block">/* Reduce range, then convert to double. */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>x</name> <operator>&amp;</operator> <call><name>U64x</name><argument_list>(<argument><expr><name>c0000000</name></expr></argument>,<argument><expr><literal type="number">0000000</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>x</name> <operator>=</operator> <operator>(</operator><name>x</name> <operator>&gt;&gt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name>x</name> <operator>&amp;</operator> <literal type="number">3</literal><operator>)</operator></expr>;</expr_stmt> <expr_stmt><expr><name>ex2</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>strscan_double</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><name>ex2</name></expr></argument>, <argument><expr><name>neg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>fmt</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Parse octal number. */</comment>
<function><type><specifier>static</specifier> <name>StrScanFmt</name></type> <name>strscan_oct</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>TValue</name> <modifier>*</modifier></type><name>o</name></decl></parameter>,
			      <parameter><decl><type><name>StrScanFmt</name></type> <name>fmt</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>neg</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>dig</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint64_t</name></type> <name>x</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Scan octal digits. */</comment>
  <if_stmt><if>if <condition>(<expr><name>dig</name> <operator>&gt;</operator> <literal type="number">22</literal> <operator>||</operator> <operator>(</operator><name>dig</name> <operator>==</operator> <literal type="number">22</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>&gt;</operator> <literal type="char">'1'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>STRSCAN_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
  <while>while <condition>(<expr><name>dig</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>*</operator><name>p</name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>&lt;=</operator> <literal type="char">'7'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>STRSCAN_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>x</name> <operator>=</operator> <operator>(</operator><name>x</name> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><operator>*</operator><name>p</name><operator>++</operator> <operator>&amp;</operator> <literal type="number">7</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></while>

  <comment type="block">/* Format-specific handling. */</comment>
  <switch>switch <condition>(<expr><name>fmt</name></expr>)</condition> <block>{<block_content>
  <case>case <expr><name>STRSCAN_INT</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>x</name> <operator>&gt;=</operator> <literal type="number">0x80000000u</literal><operator>+</operator><name>neg</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>fmt</name> <operator>=</operator> <name>STRSCAN_U32</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <comment type="block">/* fallthrough */</comment>
  <case>case <expr><name>STRSCAN_U32</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>x</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>STRSCAN_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>i</name></name> <operator>=</operator> <ternary><condition><expr><name>neg</name></expr> ?</condition><then> <expr><operator>-</operator><operator>(</operator><name>int32_t</name><operator>)</operator><name>x</name></expr> </then><else>: <expr><operator>(</operator><name>int32_t</name><operator>)</operator><name>x</name></expr></else></ternary></expr>;</expr_stmt>
    <break>break;</break>
  <default>default:</default>
  <case>case <expr><name>STRSCAN_I64</name></expr>:</case>
  <case>case <expr><name>STRSCAN_U64</name></expr>:</case>
    <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>u64</name></name> <operator>=</operator> <ternary><condition><expr><name>neg</name></expr> ?</condition><then> <expr><operator>(</operator><name>uint64_t</name><operator>)</operator><operator>-</operator><operator>(</operator><name>int64_t</name><operator>)</operator><name>x</name></expr> </then><else>: <expr><name>x</name></expr></else></ternary></expr>;</expr_stmt>
    <break>break;</break>
  </block_content>}</block></switch>
  <return>return <expr><name>fmt</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Parse decimal number. */</comment>
<function><type><specifier>static</specifier> <name>StrScanFmt</name></type> <name>strscan_dec</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>TValue</name> <modifier>*</modifier></type><name>o</name></decl></parameter>,
			      <parameter><decl><type><name>StrScanFmt</name></type> <name>fmt</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>opt</name></decl></parameter>,
			      <parameter><decl><type><name>int32_t</name></type> <name>ex10</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>neg</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>dig</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name><name>xi</name><index>[<expr><name>STRSCAN_DDIG</name></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>xip</name> <init>= <expr><name>xi</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>dig</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name> <init>= <expr><name>dig</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <name>STRSCAN_MAXDIG</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>ex10</name> <operator>+=</operator> <operator>(</operator><name>int32_t</name><operator>)</operator><operator>(</operator><name>i</name> <operator>-</operator> <name>STRSCAN_MAXDIG</name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>i</name> <operator>=</operator> <name>STRSCAN_MAXDIG</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Scan unaligned leading digit. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>ex10</name><operator>^</operator><name>i</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><operator>*</operator><name>xip</name><operator>++</operator> <operator>=</operator> <operator>(</operator><operator>(</operator><ternary><condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'.'</literal></expr> ?</condition><then> <expr><operator>*</operator><name>p</name></expr> </then><else>: <expr><operator>*</operator><operator>++</operator><name>p</name></expr></else></ternary><operator>)</operator> <operator>&amp;</operator> <literal type="number">15</literal><operator>)</operator></expr><operator>,</operator> <expr><name>i</name><operator>--</operator></expr><operator>,</operator> <expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <comment type="block">/* Scan aligned double-digits. */</comment>
    <for>for <control>( <init>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name> <operator>-=</operator> <literal type="number">2</literal></expr></incr>)</control> <block>{<block_content>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>d</name> <init>= <expr><literal type="number">10</literal> <operator>*</operator> <operator>(</operator><operator>(</operator><ternary><condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'.'</literal></expr> ?</condition><then> <expr><operator>*</operator><name>p</name></expr> </then><else>: <expr><operator>*</operator><operator>++</operator><name>p</name></expr></else></ternary><operator>)</operator> <operator>&amp;</operator> <literal type="number">15</literal><operator>)</operator></expr></init></decl>;</decl_stmt> <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>xip</name><operator>++</operator> <operator>=</operator> <name>d</name> <operator>+</operator> <operator>(</operator><operator>(</operator><ternary><condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'.'</literal></expr> ?</condition><then> <expr><operator>*</operator><name>p</name></expr> </then><else>: <expr><operator>*</operator><operator>++</operator><name>p</name></expr></else></ternary><operator>)</operator> <operator>&amp;</operator> <literal type="number">15</literal><operator>)</operator></expr>;</expr_stmt> <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>
    <comment type="block">/* Scan and realign trailing digit. */</comment>
    <if_stmt><if>if <condition>(<expr><name>i</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>xip</name><operator>++</operator> <operator>=</operator> <literal type="number">10</literal> <operator>*</operator> <operator>(</operator><operator>(</operator><ternary><condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'.'</literal></expr> ?</condition><then> <expr><operator>*</operator><name>p</name></expr> </then><else>: <expr><operator>*</operator><operator>++</operator><name>p</name></expr></else></ternary><operator>)</operator> <operator>&amp;</operator> <literal type="number">15</literal><operator>)</operator></expr><operator>,</operator> <expr><name>ex10</name><operator>--</operator></expr><operator>,</operator> <expr><name>dig</name><operator>++</operator></expr><operator>,</operator> <expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Summarize rounding-effect of excess digits. */</comment>
    <if_stmt><if>if <condition>(<expr><name>dig</name> <operator>&gt;</operator> <name>STRSCAN_MAXDIG</name></expr>)</condition> <block>{<block_content>
      <do>do <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><ternary><condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'.'</literal></expr> ?</condition><then> <expr><operator>*</operator><name>p</name></expr> </then><else>: <expr><operator>*</operator><operator>++</operator><name>p</name></expr></else></ternary><operator>)</operator> <operator>!=</operator> <literal type="char">'0'</literal></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name><name>xip</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>|=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <break>break;</break> </block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block> while <condition>(<expr><operator>--</operator><name>dig</name> <operator>&gt;</operator> <name>STRSCAN_MAXDIG</name></expr>)</condition>;</do>
      <expr_stmt><expr><name>dig</name> <operator>=</operator> <name>STRSCAN_MAXDIG</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* Simplify exponent. */</comment>
      <while>while <condition>(<expr><name>ex10</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>dig</name> <operator>&lt;=</operator> <literal type="number">18</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>xip</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>ex10</name> <operator>-=</operator> <literal type="number">2</literal></expr><operator>,</operator> <expr><name>dig</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></while>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* Only got zeros. */</comment>
    <expr_stmt><expr><name>ex10</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>xi</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Fast path for numbers in integer format (but handles e.g. 1e6, too). */</comment>
  <if_stmt><if>if <condition>(<expr><name>dig</name> <operator>&lt;=</operator> <literal type="number">20</literal> <operator>&amp;&amp;</operator> <name>ex10</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>xis</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>x</name> <init>= <expr><name><name>xi</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>n</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>xis</name> <operator>=</operator> <name>xi</name><operator>+</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>xis</name> <operator>&lt;</operator> <name>xip</name></expr>;</condition> <incr><expr><name>xis</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name>x</name> <operator>=</operator> <name>x</name> <operator>*</operator> <literal type="number">100</literal> <operator>+</operator> <operator>*</operator><name>xis</name></expr>;</expr_stmt></block_content></block></for>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>dig</name> <operator>==</operator> <literal type="number">20</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>xi</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;</operator> <literal type="number">18</literal> <operator>||</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><name>x</name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>  <comment type="block">/* No overflow? */</comment>
      <comment type="block">/* Format-specific handling. */</comment>
      <switch>switch <condition>(<expr><name>fmt</name></expr>)</condition> <block>{<block_content>
      <case>case <expr><name>STRSCAN_INT</name></expr>:</case>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>opt</name> <operator>&amp;</operator> <name>STRSCAN_OPT_TONUM</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>x</name> <operator>&lt;</operator> <literal type="number">0x80000000u</literal><operator>+</operator><name>neg</name></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>i</name></name> <operator>=</operator> <ternary><condition><expr><name>neg</name></expr> ?</condition><then> <expr><operator>-</operator><operator>(</operator><name>int32_t</name><operator>)</operator><name>x</name></expr> </then><else>: <expr><operator>(</operator><name>int32_t</name><operator>)</operator><name>x</name></expr></else></ternary></expr>;</expr_stmt>
	  <return>return <expr><name>STRSCAN_INT</name></expr>;</return>  <comment type="block">/* Fast path for 32 bit integers. */</comment>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>opt</name> <operator>&amp;</operator> <name>STRSCAN_OPT_C</name><operator>)</operator></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>fmt</name> <operator>=</operator> <name>STRSCAN_NUM</name></expr>;</expr_stmt> <goto>goto <name>plainnumber</name>;</goto> </block_content>}</block></if></if_stmt>
	<comment type="block">/* fallthrough */</comment>
      <case>case <expr><name>STRSCAN_U32</name></expr>:</case>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>x</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>STRSCAN_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>i</name></name> <operator>=</operator> <ternary><condition><expr><name>neg</name></expr> ?</condition><then> <expr><operator>-</operator><operator>(</operator><name>int32_t</name><operator>)</operator><name>x</name></expr> </then><else>: <expr><operator>(</operator><name>int32_t</name><operator>)</operator><name>x</name></expr></else></ternary></expr>;</expr_stmt>
	<return>return <expr><name>STRSCAN_U32</name></expr>;</return>
      <case>case <expr><name>STRSCAN_I64</name></expr>:</case>
      <case>case <expr><name>STRSCAN_U64</name></expr>:</case>
	<expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>u64</name></name> <operator>=</operator> <ternary><condition><expr><name>neg</name></expr> ?</condition><then> <expr><operator>(</operator><name>uint64_t</name><operator>)</operator><operator>-</operator><operator>(</operator><name>int64_t</name><operator>)</operator><name>x</name></expr> </then><else>: <expr><name>x</name></expr></else></ternary></expr>;</expr_stmt>
	<return>return <expr><name>fmt</name></expr>;</return>
      <default>default:</default>
      <label><name>plainnumber</name>:</label>  <comment type="block">/* Fast path for plain numbers &lt; 2^63. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>int64_t</name><operator>)</operator><name>x</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator><operator>(</operator><name>int64_t</name><operator>)</operator><name>x</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>neg</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name> <operator>=</operator> <operator>-</operator><name>n</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
	<return>return <expr><name>fmt</name></expr>;</return>
      </block_content>}</block></switch>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Slow non-integer path. */</comment>
  <if_stmt><if>if <condition>(<expr><name>fmt</name> <operator>==</operator> <name>STRSCAN_INT</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>opt</name> <operator>&amp;</operator> <name>STRSCAN_OPT_C</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>STRSCAN_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>fmt</name> <operator>=</operator> <name>STRSCAN_NUM</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>fmt</name> <operator>&gt;</operator> <name>STRSCAN_INT</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>STRSCAN_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <block>{<block_content>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>hi</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>lo</name> <init>= <expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>xip</name><operator>-</operator><name>xi</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>ex2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>idig</name> <init>= <expr><operator>(</operator><name>int32_t</name><operator>)</operator><name>lo</name> <operator>+</operator> <operator>(</operator><name>ex10</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>lo</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>ex10</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Handle simple overflow/underflow. */</comment>
    <if_stmt><if>if <condition>(<expr><name>idig</name> <operator>&gt;</operator> <literal type="number">310</literal><operator>/</operator><literal type="number">2</literal></expr>)</condition> <block>{<block_content> <if_stmt><if>if <condition>(<expr><name>neg</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>setminfV</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if> <else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>setpinfV</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt> <return>return <expr><name>fmt</name></expr>;</return> </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>idig</name> <operator>&lt;</operator> <operator>-</operator><literal type="number">326</literal><operator>/</operator><literal type="number">2</literal></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <ternary><condition><expr><name>neg</name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">0.0</literal></expr> </then><else>: <expr><literal type="number">0.0</literal></expr></else></ternary></expr>;</expr_stmt> <return>return <expr><name>fmt</name></expr>;</return> </block_content>}</block></if></if_stmt>

    <comment type="block">/* Scale up until we have at least 17 or 18 integer part digits. */</comment>
    <while>while <condition>(<expr><name>idig</name> <operator>&lt;</operator> <literal type="number">9</literal> <operator>&amp;&amp;</operator> <name>idig</name> <operator>&lt;</operator> <call><name>DLEN</name><argument_list>(<argument><expr><name>lo</name></expr></argument>, <argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>cy</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>ex2</name> <operator>-=</operator> <literal type="number">6</literal></expr>;</expr_stmt>
      <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <call><name>DPREV</name><argument_list>(<argument><expr><name>lo</name></expr></argument>)</argument_list></call></expr>;</init> <condition>;</condition> <incr><expr><name>i</name> <operator>=</operator> <call><name>DPREV</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name>d</name> <init>= <expr><operator>(</operator><name><name>xi</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">6</literal><operator>)</operator> <operator>+</operator> <name>cy</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>cy</name> <operator>=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>d</name> <operator>&gt;&gt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>*</operator> <literal type="number">5243</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">17</literal><operator>)</operator></expr>;</expr_stmt> <expr_stmt><expr><name>d</name> <operator>=</operator> <name>d</name> <operator>-</operator> <name>cy</name> <operator>*</operator> <literal type="number">100</literal></expr>;</expr_stmt>  <comment type="block">/* Div/mod 100. */</comment>
	<expr_stmt><expr><name><name>xi</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name>d</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>hi</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>d</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name> <operator>==</operator> <call><name>DPREV</name><argument_list>(<argument><expr><name>lo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>lo</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if <condition>(<expr><name>cy</name></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>DPREV</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>xi</name><index>[<expr><call><name>DPREV</name><argument_list>(<argument><expr><name>lo</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>lo</name> <operator>=</operator> <call><name>DPREV</name><argument_list>(<argument><expr><name>lo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>hi</name> <operator>==</operator> <name>lo</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>lo</name> <operator>=</operator> <call><name>DPREV</name><argument_list>(<argument><expr><name>lo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>xi</name><index>[<expr><call><name>DPREV</name><argument_list>(<argument><expr><name>lo</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>|=</operator> <name><name>xi</name><index>[<expr><name>lo</name></expr>]</index></name></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>xi</name><index>[<expr><name>hi</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name>cy</name></expr>;</expr_stmt> <expr_stmt><expr><name>idig</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>

    <comment type="block">/* Scale down until no more than 17 or 18 integer part digits remain. */</comment>
    <while>while <condition>(<expr><name>idig</name> <operator>&gt;</operator> <literal type="number">9</literal></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name> <init>= <expr><name>hi</name></expr></init></decl>, <decl><type ref="prev"/><name>cy</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>ex2</name> <operator>+=</operator> <literal type="number">6</literal></expr>;</expr_stmt>
      <do>do <block>{<block_content>
	<expr_stmt><expr><name>cy</name> <operator>+=</operator> <name><name>xi</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xi</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>cy</name> <operator>&gt;&gt;</operator> <literal type="number">6</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>cy</name> <operator>=</operator> <literal type="number">100</literal> <operator>*</operator> <operator>(</operator><name>cy</name> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>xi</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name> <operator>==</operator> <name>hi</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>DNEXT</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><name>idig</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>DNEXT</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block> while <condition>(<expr><name>i</name> <operator>!=</operator> <name>lo</name></expr>)</condition>;</do>
      <while>while <condition>(<expr><name>cy</name></expr>)</condition> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>hi</name> <operator>==</operator> <name>lo</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name><name>xi</name><index>[<expr><call><name>DPREV</name><argument_list>(<argument><expr><name>lo</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>|=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <break>break;</break> </block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>xi</name><index>[<expr><name>lo</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>cy</name> <operator>&gt;&gt;</operator> <literal type="number">6</literal><operator>)</operator></expr>;</expr_stmt> <expr_stmt><expr><name>lo</name> <operator>=</operator> <call><name>DNEXT</name><argument_list>(<argument><expr><name>lo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cy</name> <operator>=</operator> <literal type="number">100</literal> <operator>*</operator> <operator>(</operator><name>cy</name> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></while>
    </block_content>}</block></while>

    <comment type="block">/* Collect integer part digits and convert to rescaled double. */</comment>
    <block>{<block_content>
      <decl_stmt><decl><type><name>uint64_t</name></type> <name>x</name> <init>= <expr><name><name>xi</name><index>[<expr><name>hi</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>;</decl_stmt>
      <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <call><name>DNEXT</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><operator>--</operator><name>idig</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name> <operator>!=</operator> <name>lo</name></expr>;</condition> <incr><expr><name>i</name> <operator>=</operator> <call><name>DNEXT</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></incr>)</control><block type="pseudo"><block_content>
	<expr_stmt><expr><name>x</name> <operator>=</operator> <name>x</name> <operator>*</operator> <literal type="number">100</literal> <operator>+</operator> <name><name>xi</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
      <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>lo</name></expr>)</condition> <block>{<block_content>
	<while>while <condition>(<expr><operator>--</operator><name>idig</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>x</name> <operator>=</operator> <name>x</name> <operator>*</operator> <literal type="number">100</literal></expr>;</expr_stmt></block_content></block></while>
      </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* Gather round bit from remaining digits. */</comment>
	<expr_stmt><expr><name>x</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <expr_stmt><expr><name>ex2</name><operator>--</operator></expr>;</expr_stmt>
	<do>do <block>{<block_content>
	  <if_stmt><if>if <condition>(<expr><name><name>xi</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>x</name> <operator>|=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <break>break;</break> </block_content>}</block></if></if_stmt>
	  <expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>DNEXT</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block> while <condition>(<expr><name>i</name> <operator>!=</operator> <name>lo</name></expr>)</condition>;</do>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>strscan_double</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><name>ex2</name></expr></argument>, <argument><expr><name>neg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
  </block_content>}</block>
  <return>return <expr><name>fmt</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Parse binary number. */</comment>
<function><type><specifier>static</specifier> <name>StrScanFmt</name></type> <name>strscan_bin</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>TValue</name> <modifier>*</modifier></type><name>o</name></decl></parameter>,
			      <parameter><decl><type><name>StrScanFmt</name></type> <name>fmt</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>opt</name></decl></parameter>,
			      <parameter><decl><type><name>int32_t</name></type> <name>ex2</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>neg</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>dig</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint64_t</name></type> <name>x</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>ex2</name> <operator>||</operator> <name>dig</name> <operator>&gt;</operator> <literal type="number">64</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>STRSCAN_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Scan binary digits. */</comment>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>dig</name></expr>;</init> <condition><expr><name>i</name></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr><operator>,</operator> <expr><name>p</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>p</name> <operator>&amp;</operator> <operator>~</operator><literal type="number">1</literal><operator>)</operator> <operator>!=</operator> <literal type="char">'0'</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>STRSCAN_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>x</name> <operator>=</operator> <operator>(</operator><name>x</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><operator>*</operator><name>p</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Format-specific handling. */</comment>
  <switch>switch <condition>(<expr><name>fmt</name></expr>)</condition> <block>{<block_content>
  <case>case <expr><name>STRSCAN_INT</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>opt</name> <operator>&amp;</operator> <name>STRSCAN_OPT_TONUM</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>x</name> <operator>&lt;</operator> <literal type="number">0x80000000u</literal><operator>+</operator><name>neg</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>i</name></name> <operator>=</operator> <ternary><condition><expr><name>neg</name></expr> ?</condition><then> <expr><operator>-</operator><operator>(</operator><name>int32_t</name><operator>)</operator><name>x</name></expr> </then><else>: <expr><operator>(</operator><name>int32_t</name><operator>)</operator><name>x</name></expr></else></ternary></expr>;</expr_stmt>
      <return>return <expr><name>STRSCAN_INT</name></expr>;</return>  <comment type="block">/* Fast path for 32 bit integers. */</comment>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>opt</name> <operator>&amp;</operator> <name>STRSCAN_OPT_C</name><operator>)</operator></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>fmt</name> <operator>=</operator> <name>STRSCAN_NUM</name></expr>;</expr_stmt> <break>break;</break> </block_content>}</block></if></if_stmt>
    <comment type="block">/* fallthrough */</comment>
  <case>case <expr><name>STRSCAN_U32</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>dig</name> <operator>&gt;</operator> <literal type="number">32</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>STRSCAN_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>i</name></name> <operator>=</operator> <ternary><condition><expr><name>neg</name></expr> ?</condition><then> <expr><operator>-</operator><operator>(</operator><name>int32_t</name><operator>)</operator><name>x</name></expr> </then><else>: <expr><operator>(</operator><name>int32_t</name><operator>)</operator><name>x</name></expr></else></ternary></expr>;</expr_stmt>
    <return>return <expr><name>STRSCAN_U32</name></expr>;</return>
  <case>case <expr><name>STRSCAN_I64</name></expr>:</case>
  <case>case <expr><name>STRSCAN_U64</name></expr>:</case>
    <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>u64</name></name> <operator>=</operator> <ternary><condition><expr><name>neg</name></expr> ?</condition><then> <expr><operator>(</operator><name>uint64_t</name><operator>)</operator><operator>-</operator><operator>(</operator><name>int64_t</name><operator>)</operator><name>x</name></expr> </then><else>: <expr><name>x</name></expr></else></ternary></expr>;</expr_stmt>
    <return>return <expr><name>fmt</name></expr>;</return>
  <default>default:</default>
    <break>break;</break>
  </block_content>}</block></switch>

  <comment type="block">/* Reduce range, then convert to double. */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>x</name> <operator>&amp;</operator> <call><name>U64x</name><argument_list>(<argument><expr><name>c0000000</name></expr></argument>,<argument><expr><literal type="number">0000000</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>x</name> <operator>=</operator> <operator>(</operator><name>x</name> <operator>&gt;&gt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name>x</name> <operator>&amp;</operator> <literal type="number">3</literal><operator>)</operator></expr>;</expr_stmt> <expr_stmt><expr><name>ex2</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>strscan_double</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><name>ex2</name></expr></argument>, <argument><expr><name>neg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>fmt</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Scan string containing a number. Returns format. Returns value in o. */</comment>
<function><type><name>StrScanFmt</name></type> <name>lj_strscan_scan</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>MSize</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>TValue</name> <modifier>*</modifier></type><name>o</name></decl></parameter>,
			   <parameter><decl><type><name>uint32_t</name></type> <name>opt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>neg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>pe</name> <init>= <expr><name>p</name> <operator>+</operator> <name>len</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Remove leading space, parse sign and non-numbers. */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>LJ_UNLIKELY</name><argument_list>(<argument><expr><operator>!</operator><call><name>lj_char_isdigit</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <while>while <condition>(<expr><call><name>lj_char_isspace</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'+'</literal> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>neg</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>p</name><operator>++</operator> <operator>==</operator> <literal type="char">'-'</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>LJ_UNLIKELY</name><argument_list>(<argument><expr><operator>*</operator><name>p</name> <operator>&gt;=</operator> <literal type="char">'A'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Parse "inf", "infinity" or "nan". */</comment>
      <decl_stmt><decl><type><name>TValue</name></type> <name>tmp</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>setnanV</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>casecmp</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="char">'i'</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>casecmp</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="char">'n'</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>casecmp</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="char">'f'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>neg</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>setminfV</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if> <else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>setpinfV</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>casecmp</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="char">'i'</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>casecmp</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="char">'n'</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>casecmp</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="char">'i'</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
	    <call><name>casecmp</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="char">'t'</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>casecmp</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="char">'y'</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">5</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>casecmp</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="char">'n'</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>casecmp</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="char">'a'</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>casecmp</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="char">'n'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <while>while <condition>(<expr><call><name>lj_char_isspace</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
      <if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>||</operator> <name>p</name> <operator>&lt;</operator> <name>pe</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>STRSCAN_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>u64</name></name> <operator>=</operator> <name><name>tmp</name><operator>.</operator><name>u64</name></name></expr>;</expr_stmt>
      <return>return <expr><name>STRSCAN_NUM</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Parse regular number. */</comment>
  <block>{<block_content>
    <decl_stmt><decl><type><name>StrScanFmt</name></type> <name>fmt</name> <init>= <expr><name>STRSCAN_INT</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>cmask</name> <init>= <expr><name>LJ_CHAR_DIGIT</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>base</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>opt</name> <operator>&amp;</operator> <name>STRSCAN_OPT_C</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'0'</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">10</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>sp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>dp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>dig</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>hasdig</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>x</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>ex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Determine base and skip leading zeros. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>LJ_UNLIKELY</name><argument_list>(<argument><expr><operator>*</operator><name>p</name> <operator>&lt;=</operator> <literal type="char">'0'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'0'</literal></expr>)</condition> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>casecmp</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="char">'x'</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><name>base</name> <operator>=</operator> <literal type="number">16</literal></expr><operator>,</operator> <expr><name>cmask</name> <operator>=</operator> <name>LJ_CHAR_XDIGIT</name></expr><operator>,</operator> <expr><name>p</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>casecmp</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="char">'b'</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><name>base</name> <operator>=</operator> <literal type="number">2</literal></expr><operator>,</operator> <expr><name>cmask</name> <operator>=</operator> <name>LJ_CHAR_DIGIT</name></expr><operator>,</operator> <expr><name>p</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <for>for <control>( <init>;</init> <condition>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'0'</literal></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><name>hasdig</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition> <block>{<block_content>
	  <if_stmt><if>if <condition>(<expr><name>dp</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>STRSCAN_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
	  <expr_stmt><expr><name>dp</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
	  <break>break;</break>
	</block_content>}</block></else></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Preliminary digit and decimal point scan. */</comment>
    <for>for <control>(<init><expr><name>sp</name> <operator>=</operator> <name>p</name></expr>;</init> <condition>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>LJ_LIKELY</name><argument_list>(<argument><expr><call><name>lj_char_isa</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>, <argument><expr><name>cmask</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name>x</name> <operator>=</operator> <name>x</name> <operator>*</operator> <literal type="number">10</literal> <operator>+</operator> <operator>(</operator><operator>*</operator><name>p</name> <operator>&amp;</operator> <literal type="number">15</literal><operator>)</operator></expr>;</expr_stmt>  <comment type="block">/* For fast path below. */</comment>
	<expr_stmt><expr><name>dig</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>dp</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>STRSCAN_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>dp</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<break>break;</break>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>hasdig</name> <operator>|</operator> <name>dig</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>STRSCAN_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Handle decimal point. */</comment>
    <if_stmt><if>if <condition>(<expr><name>dp</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>fmt</name> <operator>=</operator> <name>STRSCAN_NUM</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>dig</name></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name>ex</name> <operator>=</operator> <operator>(</operator><name>int32_t</name><operator>)</operator><operator>(</operator><name>dp</name><operator>-</operator><operator>(</operator><name>p</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt> <expr_stmt><expr><name>dp</name> <operator>=</operator> <name>p</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>ex</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>dp</name><operator>--</operator> <operator>==</operator> <literal type="char">'0'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ex</name><operator>++</operator></expr><operator>,</operator> <expr><name>dig</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>  <comment type="block">/* Skip trailing zeros. */</comment>
	<if_stmt><if>if <condition>(<expr><name>base</name> <operator>==</operator> <literal type="number">16</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ex</name> <operator>*=</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Parse exponent. */</comment>
    <if_stmt><if>if <condition>(<expr><name>base</name> <operator>&gt;=</operator> <literal type="number">10</literal> <operator>&amp;&amp;</operator> <call><name>casecmp</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><ternary><condition><expr><name>base</name> <operator>==</operator> <literal type="number">16</literal></expr> ?</condition><then> <expr><literal type="char">'p'</literal></expr> </then><else>: <expr><literal type="char">'e'</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>xx</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>negx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>fmt</name> <operator>=</operator> <name>STRSCAN_NUM</name></expr>;</expr_stmt> <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'+'</literal> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>negx</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>p</name><operator>++</operator> <operator>==</operator> <literal type="char">'-'</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lj_char_isdigit</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>STRSCAN_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>xx</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>p</name><operator>++</operator> <operator>&amp;</operator> <literal type="number">15</literal><operator>)</operator></expr>;</expr_stmt>
      <while>while <condition>(<expr><call><name>lj_char_isdigit</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>xx</name> <operator>&lt;</operator> <literal type="number">65536</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>xx</name> <operator>=</operator> <name>xx</name> <operator>*</operator> <literal type="number">10</literal> <operator>+</operator> <operator>(</operator><operator>*</operator><name>p</name> <operator>&amp;</operator> <literal type="number">15</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></while>
      <expr_stmt><expr><name>ex</name> <operator>+=</operator> <ternary><condition><expr><name>negx</name></expr> ?</condition><then> <expr><operator>-</operator><operator>(</operator><name>int32_t</name><operator>)</operator><name>xx</name></expr> </then><else>: <expr><operator>(</operator><name>int32_t</name><operator>)</operator><name>xx</name></expr></else></ternary></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Parse suffix. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name></expr>)</condition> <block>{<block_content>
      <comment type="block">/* I (IMAG), U (U32), LL (I64), ULL/LLU (U64), L (long), UL/LU (ulong). */</comment>
      <comment type="block">/* NYI: f (float). Not needed until cp_number() handles non-integers. */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>casecmp</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>opt</name> <operator>&amp;</operator> <name>STRSCAN_OPT_IMAG</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>STRSCAN_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>fmt</name> <operator>=</operator> <name>STRSCAN_IMAG</name></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>fmt</name> <operator>==</operator> <name>STRSCAN_INT</name></expr>)</condition> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>casecmp</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>, <argument><expr><literal type="char">'u'</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name><operator>++</operator></expr><operator>,</operator> <expr><name>fmt</name> <operator>=</operator> <name>STRSCAN_U32</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>casecmp</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>, <argument><expr><literal type="char">'l'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
	  <if_stmt><if>if <condition>(<expr><call><name>casecmp</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>, <argument><expr><literal type="char">'l'</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name><operator>++</operator></expr><operator>,</operator> <expr><name>fmt</name> <operator>+=</operator> <name>STRSCAN_I64</name> <operator>-</operator> <name>STRSCAN_INT</name></expr>;</expr_stmt></block_content></block></if>
	  <if type="elseif">else if <condition>(<expr><operator>!</operator><operator>(</operator><name>opt</name> <operator>&amp;</operator> <name>STRSCAN_OPT_C</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>STRSCAN_ERROR</name></expr>;</return></block_content></block></if>
	  <if type="elseif">else if <condition>(<expr><sizeof>sizeof<argument_list>(<argument><expr><name>long</name></expr></argument>)</argument_list></sizeof> <operator>==</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>fmt</name> <operator>+=</operator> <name>STRSCAN_I64</name> <operator>-</operator> <name>STRSCAN_INT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>casecmp</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>, <argument><expr><literal type="char">'u'</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>fmt</name> <operator>==</operator> <name>STRSCAN_INT</name> <operator>||</operator> <name>fmt</name> <operator>==</operator> <name>STRSCAN_I64</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><name>p</name><operator>++</operator></expr><operator>,</operator> <expr><name>fmt</name> <operator>+=</operator> <name>STRSCAN_U32</name> <operator>-</operator> <name>STRSCAN_INT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fmt</name> <operator>==</operator> <name>STRSCAN_U32</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>opt</name> <operator>&amp;</operator> <name>STRSCAN_OPT_C</name><operator>)</operator><operator>)</operator> <operator>||</operator>
	    <operator>(</operator><name>fmt</name> <operator>&gt;=</operator> <name>STRSCAN_I64</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>opt</name> <operator>&amp;</operator> <name>STRSCAN_OPT_LL</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	  <return>return <expr><name>STRSCAN_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <while>while <condition>(<expr><call><name>lj_char_isspace</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
      <if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>STRSCAN_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>pe</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>STRSCAN_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Fast path for decimal 32 bit integers. */</comment>
    <if_stmt><if>if <condition>(<expr><name>fmt</name> <operator>==</operator> <name>STRSCAN_INT</name> <operator>&amp;&amp;</operator> <name>base</name> <operator>==</operator> <literal type="number">10</literal> <operator>&amp;&amp;</operator>
	<operator>(</operator><name>dig</name> <operator>&lt;</operator> <literal type="number">10</literal> <operator>||</operator> <operator>(</operator><name>dig</name> <operator>==</operator> <literal type="number">10</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>sp</name> <operator>&lt;=</operator> <literal type="char">'2'</literal> <operator>&amp;&amp;</operator> <name>x</name> <operator>&lt;</operator> <literal type="number">0x80000000u</literal><operator>+</operator><name>neg</name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>opt</name> <operator>&amp;</operator> <name>STRSCAN_OPT_TONUM</name><operator>)</operator></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <ternary><condition><expr><name>neg</name></expr> ?</condition><then> <expr><operator>-</operator><operator>(</operator><name>double</name><operator>)</operator><name>x</name></expr> </then><else>: <expr><operator>(</operator><name>double</name><operator>)</operator><name>x</name></expr></else></ternary></expr>;</expr_stmt>
	<return>return <expr><name>STRSCAN_NUM</name></expr>;</return>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>i</name></name> <operator>=</operator> <ternary><condition><expr><name>neg</name></expr> ?</condition><then> <expr><operator>-</operator><operator>(</operator><name>int32_t</name><operator>)</operator><name>x</name></expr> </then><else>: <expr><operator>(</operator><name>int32_t</name><operator>)</operator><name>x</name></expr></else></ternary></expr>;</expr_stmt>
	<return>return <expr><name>STRSCAN_INT</name></expr>;</return>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Dispatch to base-specific parser. */</comment>
    <if_stmt><if>if <condition>(<expr><name>base</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>fmt</name> <operator>==</operator> <name>STRSCAN_NUM</name> <operator>||</operator> <name>fmt</name> <operator>==</operator> <name>STRSCAN_IMAG</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><call><name>strscan_oct</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>neg</name></expr></argument>, <argument><expr><name>dig</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>base</name> <operator>==</operator> <literal type="number">16</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>fmt</name> <operator>=</operator> <call><name>strscan_hex</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>, <argument><expr><name>ex</name></expr></argument>, <argument><expr><name>neg</name></expr></argument>, <argument><expr><name>dig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>base</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>fmt</name> <operator>=</operator> <call><name>strscan_bin</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>, <argument><expr><name>ex</name></expr></argument>, <argument><expr><name>neg</name></expr></argument>, <argument><expr><name>dig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><name>fmt</name> <operator>=</operator> <call><name>strscan_dec</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>, <argument><expr><name>ex</name></expr></argument>, <argument><expr><name>neg</name></expr></argument>, <argument><expr><name>dig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/* Try to convert number to integer, if requested. */</comment>
    <if_stmt><if>if <condition>(<expr><name>fmt</name> <operator>==</operator> <name>STRSCAN_NUM</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>opt</name> <operator>&amp;</operator> <name>STRSCAN_OPT_TOINT</name><operator>)</operator></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>double</name></type> <name>n</name> <init>= <expr><name><name>o</name><operator>-&gt;</operator><name>n</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><call><name>lj_num2int</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <operator>(</operator><name>lua_Number</name><operator>)</operator><name>i</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>i</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt> <return>return <expr><name>STRSCAN_INT</name></expr>;</return> </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>fmt</name></expr>;</return>
  </block_content>}</block>
</block_content>}</block></function>

<function><type><name>int</name> <name>LJ_FASTCALL</name></type> <name>lj_strscan_num</name><parameter_list>(<parameter><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>TValue</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>StrScanFmt</name></type> <name>fmt</name> <init>= <expr><call><name>lj_strscan_scan</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>uint8_t</name> <operator>*</operator><operator>)</operator><call><name>strdata</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>str</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name>o</name></expr></argument>,
				   <argument><expr><name>STRSCAN_OPT_TONUM</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>fmt</name> <operator>==</operator> <name>STRSCAN_ERROR</name> <operator>||</operator> <name>fmt</name> <operator>==</operator> <name>STRSCAN_NUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><name>fmt</name> <operator>!=</operator> <name>STRSCAN_ERROR</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_DUALNUM</name></expr></cpp:if>
<function><type><name>int</name> <name>LJ_FASTCALL</name></type> <name>lj_strscan_number</name><parameter_list>(<parameter><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>TValue</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>StrScanFmt</name></type> <name>fmt</name> <init>= <expr><call><name>lj_strscan_scan</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>uint8_t</name> <operator>*</operator><operator>)</operator><call><name>strdata</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>str</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name>o</name></expr></argument>,
				   <argument><expr><name>STRSCAN_OPT_TOINT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>fmt</name> <operator>==</operator> <name>STRSCAN_ERROR</name> <operator>||</operator> <name>fmt</name> <operator>==</operator> <name>STRSCAN_NUM</name> <operator>||</operator> <name>fmt</name> <operator>==</operator> <name>STRSCAN_INT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>fmt</name> <operator>==</operator> <name>STRSCAN_INT</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>setitype</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><name>LJ_TISNUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><operator>(</operator><name>fmt</name> <operator>!=</operator> <name>STRSCAN_ERROR</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>DNEXT</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>DPREV</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>DLEN</name></cpp:undef>

</unit>
