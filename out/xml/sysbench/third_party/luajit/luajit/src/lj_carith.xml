<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/sysbench/third_party/luajit/luajit/src/lj_carith.c"><comment type="block">/*
** C data arithmetic.
** Copyright (C) 2005-2020 Mike Pall. See Copyright Notice in luajit.h
*/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_obj.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_gc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_err.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_tab.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_meta.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_ir.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_ctype.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_cconv.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_cdata.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_carith.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_strscan.h"</cpp:file></cpp:include>

<comment type="block">/* -- C data arithmetic --------------------------------------------------- */</comment>

<comment type="block">/* Binary operands of an operator converted to ctypes. */</comment>
<typedef>typedef <type><struct>struct <name>CDArith</name> <block>{
  <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name><name>ct</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>CDArith</name>;</typedef>

<comment type="block">/* Check arguments for arithmetic metamethods. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>carith_checkarg</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name></decl></parameter>, <parameter><decl><type><name>CDArith</name> <modifier>*</modifier></type><name>ca</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ok</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MSize</name></type> <name>i</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>o</name><operator>+</operator><literal type="number">1</literal> <operator>&gt;=</operator> <name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_err_argt</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>LUA_TCDATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>o</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>tviscdata</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>GCcdata</name> <modifier>*</modifier></type><name>cd</name> <init>= <expr><call><name>cdataV</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>CTypeID</name></type> <name>id</name> <init>= <expr><operator>(</operator><name>CTypeID</name><operator>)</operator><name><name>cd</name><operator>-&gt;</operator><name>ctypeid</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name> <init>= <expr><call><name>ctype_raw</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><call><name>cdataptr</name><argument_list>(<argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>ctype_isptr</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><call><name>cdata_getptr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>ct</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>ctype_isref</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>ctype_rawchild</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ctype_isfunc</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>*</operator><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>p</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>,
	  <argument><expr><call><name>lj_ctype_intern</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><call><name>CTINFO</name><argument_list>(<argument><expr><name>CT_PTR</name></expr></argument>, <argument><expr><name>CTALIGN_PTR</name><operator>|</operator><name>id</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>CTSIZE_PTR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>ctype_isenum</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>ctype_child</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>ca</name><operator>-&gt;</operator><name>ct</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>ct</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>ca</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>tvisint</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>ca</name><operator>-&gt;</operator><name>ct</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>CTID_INT32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>ca</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>o</name><operator>-&gt;</operator><name>i</name></name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>tvisnum</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>ca</name><operator>-&gt;</operator><name>ct</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>CTID_DOUBLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>ca</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>o</name><operator>-&gt;</operator><name>n</name></name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>tvisnil</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>ca</name><operator>-&gt;</operator><name>ct</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>CTID_P_VOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>ca</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>tvisstr</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>o2</name> <init>= <expr><ternary><condition><expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>o</name><operator>+</operator><literal type="number">1</literal></expr> </then><else>: <expr><name>o</name><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name> <init>= <expr><call><name>ctype_raw</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><call><name>cdataV</name><argument_list>(<argument><expr><name>o2</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ctypeid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>ca</name><operator>-&gt;</operator><name>ct</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>ca</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><call><name>strVdata</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>ok</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>ctype_isenum</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<decl_stmt><decl><type><name>CTSize</name></type> <name>ofs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>cct</name> <init>= <expr><call><name>lj_ctype_getfield</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>, <argument><expr><call><name>strV</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>ofs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>cct</name> <operator>&amp;&amp;</operator> <call><name>ctype_isconstval</name><argument_list>(<argument><expr><name><name>cct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><name><name>ca</name><operator>-&gt;</operator><name>ct</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>ctype_child</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>cct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>ca</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>cct</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>  <comment type="block">/* Assumes ct does not grow. */</comment>
	  <expr_stmt><expr><name>ok</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
	  <expr_stmt><expr><name><name>ca</name><operator>-&gt;</operator><name>ct</name><index>[<expr><literal type="number">1</literal><operator>-</operator><name>i</name></expr>]</index></name> <operator>=</operator> <name>ct</name></expr>;</expr_stmt>  <comment type="block">/* Use enum to improve error message. */</comment>
	  <expr_stmt><expr><name><name>ca</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal><operator>-</operator><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	  <break>break;</break>
	</block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name><name>ca</name><operator>-&gt;</operator><name>ct</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>ca</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>intptr_t</name><operator>)</operator><literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* To make it unequal. */</comment>
      <expr_stmt><expr><name>ok</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>ok</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Pointer arithmetic. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>carith_ptr</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name></decl></parameter>, <parameter><decl><type><name>CDArith</name> <modifier>*</modifier></type><name>ca</name></decl></parameter>, <parameter><decl><type><name>MMS</name></type> <name>mm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ctp</name> <init>= <expr><name><name>ca</name><operator>-&gt;</operator><name>ct</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pp</name> <init>= <expr><name><name>ca</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>idx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTSize</name></type> <name>sz</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTypeID</name></type> <name>id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GCcdata</name> <modifier>*</modifier></type><name>cd</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>ctype_isptr</name><argument_list>(<argument><expr><name><name>ctp</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ctype_isrefarray</name><argument_list>(<argument><expr><name><name>ctp</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>mm</name> <operator>==</operator> <name>MM_sub</name> <operator>||</operator> <name>mm</name> <operator>==</operator> <name>MM_eq</name> <operator>||</operator> <name>mm</name> <operator>==</operator> <name>MM_lt</name> <operator>||</operator> <name>mm</name> <operator>==</operator> <name>MM_le</name><operator>)</operator> <operator>&amp;&amp;</operator>
	<operator>(</operator><call><name>ctype_isptr</name><argument_list>(<argument><expr><name><name>ca</name><operator>-&gt;</operator><name>ct</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>info</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ctype_isrefarray</name><argument_list>(<argument><expr><name><name>ca</name><operator>-&gt;</operator><name>ct</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>info</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pp2</name> <init>= <expr><name><name>ca</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>mm</name> <operator>==</operator> <name>MM_eq</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Pointer equality. Incompatible pointers are ok. */</comment>
	<expr_stmt><expr><call><name>setboolV</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>pp</name> <operator>==</operator> <name>pp2</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">1</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lj_cconv_compatptr</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ctp</name></expr></argument>, <argument><expr><name><name>ca</name><operator>-&gt;</operator><name>ct</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>CCF_IGNQUAL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>mm</name> <operator>==</operator> <name>MM_sub</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Pointer difference. */</comment>
	<decl_stmt><decl><type><name>intptr_t</name></type> <name>diff</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>lj_ctype_size</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><call><name>ctype_cid</name><argument_list>(<argument><expr><name><name>ctp</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Element size. */</comment>
	<if_stmt><if>if <condition>(<expr><name>sz</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>sz</name> <operator>==</operator> <name>CTSIZE_INVALID</name></expr>)</condition><block type="pseudo"><block_content>
	  <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>diff</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>intptr_t</name><operator>)</operator><name>pp</name> <operator>-</operator> <operator>(</operator><name>intptr_t</name><operator>)</operator><name>pp2</name><operator>)</operator> <operator>/</operator> <operator>(</operator><name>int32_t</name><operator>)</operator><name>sz</name></expr>;</expr_stmt>
	<comment type="block">/* All valid pointer differences on x64 are in (-2^47, +2^47),
	** which fits into a double without loss of precision.
	*/</comment>
	<expr_stmt><expr><call><name>setintptrV</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><name>diff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">1</literal></expr>;</return>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>mm</name> <operator>==</operator> <name>MM_lt</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Pointer comparison (unsigned). */</comment>
	<expr_stmt><expr><call><name>setboolV</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>pp</name> <operator>&lt;</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><name>pp2</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">1</literal></expr>;</return>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>mm</name> <operator>==</operator> <name>MM_le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>setboolV</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>pp</name> <operator>&lt;=</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><name>pp2</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">1</literal></expr>;</return>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><name>mm</name> <operator>==</operator> <name>MM_add</name> <operator>||</operator> <name>mm</name> <operator>==</operator> <name>MM_sub</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>ctype_isnum</name><argument_list>(<argument><expr><name><name>ca</name><operator>-&gt;</operator><name>ct</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>info</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>lj_cconv_ct_ct</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>CTID_INT_PSZ</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ca</name><operator>-&gt;</operator><name>ct</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
		   <argument><expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>idx</name></expr></argument>, <argument><expr><name><name>ca</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>mm</name> <operator>==</operator> <name>MM_sub</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>idx</name> <operator>=</operator> <operator>-</operator><name>idx</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>mm</name> <operator>==</operator> <name>MM_add</name> <operator>&amp;&amp;</operator> <call><name>ctype_isnum</name><argument_list>(<argument><expr><name><name>ctp</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
      <operator>(</operator><call><name>ctype_isptr</name><argument_list>(<argument><expr><name><name>ca</name><operator>-&gt;</operator><name>ct</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>info</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ctype_isrefarray</name><argument_list>(<argument><expr><name><name>ca</name><operator>-&gt;</operator><name>ct</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>info</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
    <comment type="block">/* Swap pointer and index. */</comment>
    <expr_stmt><expr><name>ctp</name> <operator>=</operator> <name><name>ca</name><operator>-&gt;</operator><name>ct</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt> <expr_stmt><expr><name>pp</name> <operator>=</operator> <name><name>ca</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lj_cconv_ct_ct</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>CTID_INT_PSZ</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ca</name><operator>-&gt;</operator><name>ct</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
		   <argument><expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>idx</name></expr></argument>, <argument><expr><name><name>ca</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>lj_ctype_size</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><call><name>ctype_cid</name><argument_list>(<argument><expr><name><name>ctp</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Element size. */</comment>
  <if_stmt><if>if <condition>(<expr><name>sz</name> <operator>==</operator> <name>CTSIZE_INVALID</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pp</name> <operator>+=</operator> <name>idx</name><operator>*</operator><operator>(</operator><name>int32_t</name><operator>)</operator><name>sz</name></expr>;</expr_stmt>  <comment type="block">/* Compute pointer + index. */</comment>
  <expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>lj_ctype_intern</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><call><name>CTINFO</name><argument_list>(<argument><expr><name>CT_PTR</name></expr></argument>, <argument><expr><name>CTALIGN_PTR</name><operator>|</operator><call><name>ctype_cid</name><argument_list>(<argument><expr><name><name>ctp</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
		       <argument><expr><name>CTSIZE_PTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>cd</name> <operator>=</operator> <call><name>lj_cdata_new</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>CTSIZE_PTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>cdataptr</name><argument_list>(<argument><expr><name>cd</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>pp</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setcdataV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lj_gc_check</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 64 bit integer arithmetic. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>carith_int64</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name></decl></parameter>, <parameter><decl><type><name>CDArith</name> <modifier>*</modifier></type><name>ca</name></decl></parameter>, <parameter><decl><type><name>MMS</name></type> <name>mm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>ctype_isnum</name><argument_list>(<argument><expr><name><name>ca</name><operator>-&gt;</operator><name>ct</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>info</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>ca</name><operator>-&gt;</operator><name>ct</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>size</name> <operator>&lt;=</operator> <literal type="number">8</literal> <operator>&amp;&amp;</operator>
      <call><name>ctype_isnum</name><argument_list>(<argument><expr><name><name>ca</name><operator>-&gt;</operator><name>ct</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>info</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>ca</name><operator>-&gt;</operator><name>ct</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>size</name> <operator>&lt;=</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>CTypeID</name></type> <name>id</name> <init>= <expr><ternary><condition><expr><operator>(</operator><operator>(</operator><operator>(</operator><name><name>ca</name><operator>-&gt;</operator><name>ct</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>info</name> <operator>&amp;</operator> <name>CTF_UNSIGNED</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>ca</name><operator>-&gt;</operator><name>ct</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>size</name> <operator>==</operator> <literal type="number">8</literal><operator>)</operator> <operator>||</operator>
		  <operator>(</operator><operator>(</operator><name><name>ca</name><operator>-&gt;</operator><name>ct</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>info</name> <operator>&amp;</operator> <name>CTF_UNSIGNED</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>ca</name><operator>-&gt;</operator><name>ct</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>size</name> <operator>==</operator> <literal type="number">8</literal><operator>)</operator><operator>)</operator></expr> ?</condition><then>
		 <expr><name>CTID_UINT64</name></expr> </then><else>: <expr><name>CTID_INT64</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name> <init>= <expr><call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GCcdata</name> <modifier>*</modifier></type><name>cd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>u0</name></decl>, <decl><type ref="prev"/><name>u1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>up</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>lj_cconv_ct_ct</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>, <argument><expr><name><name>ca</name><operator>-&gt;</operator><name>ct</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>u0</name></expr></argument>, <argument><expr><name><name>ca</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>mm</name> <operator>!=</operator> <name>MM_unm</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>lj_cconv_ct_ct</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>, <argument><expr><name><name>ca</name><operator>-&gt;</operator><name>ct</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>u1</name></expr></argument>, <argument><expr><name><name>ca</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <switch>switch <condition>(<expr><name>mm</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>MM_eq</name></expr>:</case>
      <expr_stmt><expr><call><name>setboolV</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>u0</name> <operator>==</operator> <name>u1</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    <case>case <expr><name>MM_lt</name></expr>:</case>
      <expr_stmt><expr><call><name>setboolV</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>,
	       <argument><expr><ternary><condition><expr><name>id</name> <operator>==</operator> <name>CTID_INT64</name></expr> ?</condition><then> <expr><operator>(</operator><operator>(</operator><name>int64_t</name><operator>)</operator><name>u0</name> <operator>&lt;</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><name>u1</name><operator>)</operator></expr> </then><else>: <expr><operator>(</operator><name>u0</name> <operator>&lt;</operator> <name>u1</name><operator>)</operator></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    <case>case <expr><name>MM_le</name></expr>:</case>
      <expr_stmt><expr><call><name>setboolV</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>,
	       <argument><expr><ternary><condition><expr><name>id</name> <operator>==</operator> <name>CTID_INT64</name></expr> ?</condition><then> <expr><operator>(</operator><operator>(</operator><name>int64_t</name><operator>)</operator><name>u0</name> <operator>&lt;=</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><name>u1</name><operator>)</operator></expr> </then><else>: <expr><operator>(</operator><name>u0</name> <operator>&lt;=</operator> <name>u1</name><operator>)</operator></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    <default>default:</default> <break>break;</break>
    </block_content>}</block></switch>
    <expr_stmt><expr><name>cd</name> <operator>=</operator> <call><name>lj_cdata_new</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>up</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator><call><name>cdataptr</name><argument_list>(<argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setcdataV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <switch>switch <condition>(<expr><name>mm</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>MM_add</name></expr>:</case> <expr_stmt><expr><operator>*</operator><name>up</name> <operator>=</operator> <name>u0</name> <operator>+</operator> <name>u1</name></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>MM_sub</name></expr>:</case> <expr_stmt><expr><operator>*</operator><name>up</name> <operator>=</operator> <name>u0</name> <operator>-</operator> <name>u1</name></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>MM_mul</name></expr>:</case> <expr_stmt><expr><operator>*</operator><name>up</name> <operator>=</operator> <name>u0</name> <operator>*</operator> <name>u1</name></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>MM_div</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>id</name> <operator>==</operator> <name>CTID_INT64</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><operator>*</operator><name>up</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><call><name>lj_carith_divi64</name><argument_list>(<argument><expr><operator>(</operator><name>int64_t</name><operator>)</operator><name>u0</name></expr></argument>, <argument><expr><operator>(</operator><name>int64_t</name><operator>)</operator><name>u1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
      <else>else<block type="pseudo"><block_content>
	<expr_stmt><expr><operator>*</operator><name>up</name> <operator>=</operator> <call><name>lj_carith_divu64</name><argument_list>(<argument><expr><name>u0</name></expr></argument>, <argument><expr><name>u1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
      <break>break;</break>
    <case>case <expr><name>MM_mod</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>id</name> <operator>==</operator> <name>CTID_INT64</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><operator>*</operator><name>up</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><call><name>lj_carith_modi64</name><argument_list>(<argument><expr><operator>(</operator><name>int64_t</name><operator>)</operator><name>u0</name></expr></argument>, <argument><expr><operator>(</operator><name>int64_t</name><operator>)</operator><name>u1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
      <else>else<block type="pseudo"><block_content>
	<expr_stmt><expr><operator>*</operator><name>up</name> <operator>=</operator> <call><name>lj_carith_modu64</name><argument_list>(<argument><expr><name>u0</name></expr></argument>, <argument><expr><name>u1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
      <break>break;</break>
    <case>case <expr><name>MM_pow</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>id</name> <operator>==</operator> <name>CTID_INT64</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><operator>*</operator><name>up</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><call><name>lj_carith_powi64</name><argument_list>(<argument><expr><operator>(</operator><name>int64_t</name><operator>)</operator><name>u0</name></expr></argument>, <argument><expr><operator>(</operator><name>int64_t</name><operator>)</operator><name>u1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
      <else>else<block type="pseudo"><block_content>
	<expr_stmt><expr><operator>*</operator><name>up</name> <operator>=</operator> <call><name>lj_carith_powu64</name><argument_list>(<argument><expr><name>u0</name></expr></argument>, <argument><expr><name>u1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
      <break>break;</break>
    <case>case <expr><name>MM_unm</name></expr>:</case> <expr_stmt><expr><operator>*</operator><name>up</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><operator>-</operator><operator>(</operator><name>int64_t</name><operator>)</operator><name>u0</name></expr>;</expr_stmt> <break>break;</break>
    <default>default:</default> <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    </block_content>}</block></switch>
    <expr_stmt><expr><call><name>lj_gc_check</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Handle ctype arithmetic metamethods. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lj_carith_meta</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name></decl></parameter>, <parameter><decl><type><name>CDArith</name> <modifier>*</modifier></type><name>ca</name></decl></parameter>, <parameter><decl><type><name>MMS</name></type> <name>mm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>tv</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>tviscdata</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>CTypeID</name></type> <name>id</name> <init>= <expr><call><name>cdataV</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ctypeid</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name> <init>= <expr><call><name>ctype_raw</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ctype_isptr</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>ctype_cid</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>tv</name> <operator>=</operator> <call><name>lj_ctype_meta</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>mm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>tv</name> <operator>&amp;&amp;</operator> <name><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>+</operator><literal type="number">1</literal> <operator>&lt;</operator> <name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>&amp;&amp;</operator> <call><name>tviscdata</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>CTypeID</name></type> <name>id</name> <init>= <expr><call><name>cdataV</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ctypeid</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name> <init>= <expr><call><name>ctype_raw</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ctype_isptr</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>ctype_cid</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>tv</name> <operator>=</operator> <call><name>lj_ctype_meta</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>mm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>tv</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>repr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>isenum</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>isstr</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>mm</name> <operator>==</operator> <name>MM_eq</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Equality checks never raise an error. */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>eq</name> <init>= <expr><name><name>ca</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name><name>ca</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>setboolV</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>eq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>setboolV</name><argument_list>(<argument><expr><operator>&amp;</operator><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>tmptv2</name></expr></argument>, <argument><expr><name>eq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Remember for trace recorder. */</comment>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>ca</name><operator>-&gt;</operator><name>ct</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <call><name>tviscdata</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>+</operator><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>ctype_isenum</name><argument_list>(<argument><expr><name><name>ca</name><operator>-&gt;</operator><name>ct</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>info</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>isenum</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>repr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>strdata</name><argument_list>(<argument><expr><call><name>lj_ctype_repr</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>ctype_typeid</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name><name>ca</name><operator>-&gt;</operator><name>ct</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>tvisstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>L</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>isstr</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>repr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>lj_typename</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>L</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>isenum</name> <operator>^</operator> <name>isstr</name><operator>)</operator> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>lj_err_callerv</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LJ_ERR_FFI_BADCONV</name></expr></argument>, <argument><expr><name><name>repr</name><index>[<expr><name>isstr</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>repr</name><index>[<expr><name>isenum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>lj_err_callerv</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><ternary><condition><expr><name>mm</name> <operator>==</operator> <name>MM_len</name></expr> ?</condition><then> <expr><name>LJ_ERR_FFI_BADLEN</name></expr> </then><else>:
		      <expr><ternary><condition><expr><name>mm</name> <operator>==</operator> <name>MM_concat</name></expr> ?</condition><then> <expr><name>LJ_ERR_FFI_BADCONCAT</name></expr> </then><else>:
		      <expr><ternary><condition><expr><name>mm</name> <operator>&lt;</operator> <name>MM_add</name></expr> ?</condition><then> <expr><name>LJ_ERR_FFI_BADCOMP</name></expr> </then><else>: <expr><name>LJ_ERR_FFI_BADARITH</name></expr></else></ternary></expr></else></ternary></expr></else></ternary></expr></argument>,
		   <argument><expr><name><name>repr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>repr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>lj_meta_tailcall</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Arithmetic operators for cdata. */</comment>
<function><type><name>int</name></type> <name>lj_carith_op</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>MMS</name></type> <name>mm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name> <init>= <expr><call><name>ctype_cts</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CDArith</name></type> <name>ca</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>carith_checkarg</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>cts</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ca</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>mm</name> <operator>!=</operator> <name>MM_len</name> <operator>&amp;&amp;</operator> <name>mm</name> <operator>!=</operator> <name>MM_concat</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>carith_int64</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>cts</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ca</name></expr></argument>, <argument><expr><name>mm</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>carith_ptr</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>cts</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ca</name></expr></argument>, <argument><expr><name>mm</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>&amp;</operator><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>tmptv2</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Remember for trace recorder. */</comment>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>lj_carith_meta</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>cts</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ca</name></expr></argument>, <argument><expr><name>mm</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -- 64 bit bit operations helpers --------------------------------------- */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_64</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>B64DEF</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>static LJ_AINLINE uint64_t lj_carith_##name(uint64_t x, int32_t sh)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<comment type="block">/* Not inlined on 32 bit archs, since some of these are quite lengthy. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>B64DEF</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>uint64_t LJ_NOINLINE lj_carith_##name(uint64_t x, int32_t sh)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<macro><name>B64DEF</name><argument_list>(<argument>shl64</argument>)</argument_list></macro> <block>{<block_content> <return>return <expr><name>x</name> <operator>&lt;&lt;</operator> <operator>(</operator><name>sh</name><operator>&amp;</operator><literal type="number">63</literal><operator>)</operator></expr>;</return> </block_content>}</block>
<macro><name>B64DEF</name><argument_list>(<argument>shr64</argument>)</argument_list></macro> <block>{<block_content> <return>return <expr><name>x</name> <operator>&gt;&gt;</operator> <operator>(</operator><name>sh</name><operator>&amp;</operator><literal type="number">63</literal><operator>)</operator></expr>;</return> </block_content>}</block>
<macro><name>B64DEF</name><argument_list>(<argument>sar64</argument>)</argument_list></macro> <block>{<block_content> <return>return <expr><operator>(</operator><name>uint64_t</name><operator>)</operator><operator>(</operator><operator>(</operator><name>int64_t</name><operator>)</operator><name>x</name> <operator>&gt;&gt;</operator> <operator>(</operator><name>sh</name><operator>&amp;</operator><literal type="number">63</literal><operator>)</operator><operator>)</operator></expr>;</return> </block_content>}</block>
<macro><name>B64DEF</name><argument_list>(<argument>rol64</argument>)</argument_list></macro> <block>{<block_content> <return>return <expr><call><name>lj_rol</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><operator>(</operator><name>sh</name><operator>&amp;</operator><literal type="number">63</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block>
<macro><name>B64DEF</name><argument_list>(<argument>ror64</argument>)</argument_list></macro> <block>{<block_content> <return>return <expr><call><name>lj_ror</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><operator>(</operator><name>sh</name><operator>&amp;</operator><literal type="number">63</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>B64DEF</name></cpp:undef>

<function><type><name>uint64_t</name></type> <name>lj_carith_shift64</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>sh</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{<block_content>
  <case>case <expr><name>IR_BSHL</name><operator>-</operator><name>IR_BSHL</name></expr>:</case> <expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>lj_carith_shl64</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>sh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_BSHR</name><operator>-</operator><name>IR_BSHL</name></expr>:</case> <expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>lj_carith_shr64</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>sh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_BSAR</name><operator>-</operator><name>IR_BSHL</name></expr>:</case> <expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>lj_carith_sar64</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>sh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_BROL</name><operator>-</operator><name>IR_BSHL</name></expr>:</case> <expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>lj_carith_rol64</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>sh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>IR_BROR</name><operator>-</operator><name>IR_BSHL</name></expr>:</case> <expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>lj_carith_ror64</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>sh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <default>default:</default> <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  </block_content>}</block></switch>
  <return>return <expr><name>x</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Equivalent to lj_lib_checkbit(), but handles cdata. */</comment>
<function><type><name>uint64_t</name></type> <name>lj_carith_check64</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>narg</name></decl></parameter>, <parameter><decl><type><name>CTypeID</name> <modifier>*</modifier></type><name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>+</operator> <name>narg</name><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>o</name> <operator>&gt;=</operator> <name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr>)</condition> <block>{<block_content>
  <label><name>err</name>:</label>
    <expr_stmt><expr><call><name>lj_err_argt</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>narg</name></expr></argument>, <argument><expr><name>LUA_TNUMBER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>LJ_LIKELY</name><argument_list>(<argument><expr><call><name>tvisnumber</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <comment type="block">/* Handled below. */</comment>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>tviscdata</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name> <init>= <expr><call><name>ctype_cts</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>sp</name> <init>= <expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><call><name>cdataptr</name><argument_list>(<argument><expr><call><name>cdataV</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CTypeID</name></type> <name>sid</name> <init>= <expr><call><name>cdataV</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ctypeid</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>x</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ctype_isref</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>sp</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>sp</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>sid</name> <operator>=</operator> <call><name>ctype_cid</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>ctype_raw</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ctype_isenum</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>ctype_child</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>info</name></name> <operator>&amp;</operator> <operator>(</operator><name>CTMASK_NUM</name><operator>|</operator><name>CTF_BOOL</name><operator>|</operator><name>CTF_FP</name><operator>|</operator><name>CTF_UNSIGNED</name><operator>)</operator><operator>)</operator> <operator>==</operator>
	<call><name>CTINFO</name><argument_list>(<argument><expr><name>CT_NUM</name></expr></argument>, <argument><expr><name>CTF_UNSIGNED</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><operator>*</operator><name>id</name> <operator>=</operator> <name>CTID_UINT64</name></expr>;</expr_stmt></block_content></block></if>  <comment type="block">/* Use uint64_t, since it has the highest rank. */</comment>
    <if type="elseif">else if <condition>(<expr><operator>!</operator><operator>*</operator><name>id</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><operator>*</operator><name>id</name> <operator>=</operator> <name>CTID_INT64</name></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Use int64_t, unless already set. */</comment>
    <expr_stmt><expr><call><name>lj_cconv_ct_ct</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><operator>*</operator><name>id</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>s</name></expr></argument>,
		   <argument><expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><call><name>CCF_ARG</name><argument_list>(<argument><expr><name>narg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>x</name></expr>;</return>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>tvisstr</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>lj_strscan_number</name><argument_list>(<argument><expr><call><name>strV</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
    <goto>goto <name>err</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>LJ_LIKELY</name><argument_list>(<argument><expr><call><name>tvisint</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><operator>(</operator><name>uint32_t</name><operator>)</operator><call><name>intV</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><call><name>lj_num2bit</name><argument_list>(<argument><expr><call><name>numV</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>LJ_DUALNUM</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>setintV</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>i</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* -- 64 bit integer arithmetic helpers ----------------------------------- */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_32</name> <operator>&amp;&amp;</operator> <name>LJ_HASJIT</name></expr></cpp:if>
<comment type="block">/* Signed/unsigned 64 bit multiplication. */</comment>
<function><type><name>int64_t</name></type> <name>lj_carith_mul64</name><parameter_list>(<parameter><decl><type><name>int64_t</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><name>a</name> <operator>*</operator> <name>b</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Unsigned 64 bit division. */</comment>
<function><type><name>uint64_t</name></type> <name>lj_carith_divu64</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>b</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>U64x</name><argument_list>(<argument><expr><literal type="number">80000000</literal></expr></argument>,<argument><expr><literal type="number">00000000</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name>a</name> <operator>/</operator> <name>b</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Signed 64 bit division. */</comment>
<function><type><name>int64_t</name></type> <name>lj_carith_divi64</name><parameter_list>(<parameter><decl><type><name>int64_t</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>b</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>a</name> <operator>==</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><call><name>U64x</name><argument_list>(<argument><expr><literal type="number">80000000</literal></expr></argument>,<argument><expr><literal type="number">00000000</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>b</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>U64x</name><argument_list>(<argument><expr><literal type="number">80000000</literal></expr></argument>,<argument><expr><literal type="number">00000000</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name>a</name> <operator>/</operator> <name>b</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Unsigned 64 bit modulo. */</comment>
<function><type><name>uint64_t</name></type> <name>lj_carith_modu64</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>b</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>U64x</name><argument_list>(<argument><expr><literal type="number">80000000</literal></expr></argument>,<argument><expr><literal type="number">00000000</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name>a</name> <operator>%</operator> <name>b</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Signed 64 bit modulo. */</comment>
<function><type><name>int64_t</name></type> <name>lj_carith_modi64</name><parameter_list>(<parameter><decl><type><name>int64_t</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>b</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>U64x</name><argument_list>(<argument><expr><literal type="number">80000000</literal></expr></argument>,<argument><expr><literal type="number">00000000</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>a</name> <operator>==</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><call><name>U64x</name><argument_list>(<argument><expr><literal type="number">80000000</literal></expr></argument>,<argument><expr><literal type="number">00000000</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>b</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name>a</name> <operator>%</operator> <name>b</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Unsigned 64 bit x^k. */</comment>
<function><type><name>uint64_t</name></type> <name>lj_carith_powu64</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>k</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint64_t</name></type> <name>y</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>k</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <for>for <control>(<init>;</init> <condition><expr><operator>(</operator><name>k</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>k</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name>x</name> <operator>*=</operator> <name>x</name></expr>;</expr_stmt></block_content></block></for>
  <expr_stmt><expr><name>y</name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>k</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
      <expr_stmt><expr><name>x</name> <operator>*=</operator> <name>x</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>k</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>k</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>y</name> <operator>*=</operator> <name>x</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>k</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>y</name> <operator>*=</operator> <name>x</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>y</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Signed 64 bit x^k. */</comment>
<function><type><name>int64_t</name></type> <name>lj_carith_powi64</name><parameter_list>(<parameter><decl><type><name>int64_t</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>k</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>k</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>k</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>x</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><call><name>U64x</name><argument_list>(<argument><expr><literal type="number">7fffffff</literal></expr></argument>,<argument><expr><name>ffffffff</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>x</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>x</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><ternary><condition><expr><operator>(</operator><name>k</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><operator>(</operator><name>int64_t</name><operator>)</operator><call><name>lj_carith_powu64</name><argument_list>(<argument><expr><operator>(</operator><name>uint64_t</name><operator>)</operator><name>x</name></expr></argument>, <argument><expr><operator>(</operator><name>uint64_t</name><operator>)</operator><name>k</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
