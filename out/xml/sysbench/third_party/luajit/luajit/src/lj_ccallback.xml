<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/sysbench/third_party/luajit/luajit/src/lj_ccallback.c"><comment type="block">/*
** FFI C callback handling.
** Copyright (C) 2005-2020 Mike Pall. See Copyright Notice in luajit.h
*/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_obj.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_gc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_err.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_tab.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_state.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_frame.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_ctype.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_cconv.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_ccall.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_ccallback.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_target.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_mcode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_trace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_vm.h"</cpp:file></cpp:include>

<comment type="block">/* -- Target-specific handling of callback slots -------------------------- */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALLBACK_MCODE_SIZE</name></cpp:macro>	<cpp:value>(LJ_PAGESIZE * LJ_NUM_CBPAGE)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_OS_NOJIT</name></expr></cpp:if>

<comment type="block">/* Callbacks disabled. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALLBACK_SLOT2OFS</name><parameter_list>(<parameter><type><name>slot</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(0*(slot))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALLBACK_OFS2SLOT</name><parameter_list>(<parameter><type><name>ofs</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(0*(ofs))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALLBACK_MAX_SLOT</name></cpp:macro>	<cpp:value>0</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_X86ORX64</name></expr></cpp:elif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALLBACK_MCODE_HEAD</name></cpp:macro>	<cpp:value>(LJ_64 ? 8 : 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALLBACK_MCODE_GROUP</name></cpp:macro>	<cpp:value>(-2+1+2+(LJ_GC64 ? 10 : 5)+(LJ_64 ? 6 : 5))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALLBACK_SLOT2OFS</name><parameter_list>(<parameter><type><name>slot</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>(CALLBACK_MCODE_HEAD + CALLBACK_MCODE_GROUP*((slot)/32) + 4*(slot))</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>MSize</name></type> <name>CALLBACK_OFS2SLOT</name><parameter_list>(<parameter><decl><type><name>MSize</name></type> <name>ofs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>MSize</name></type> <name>group</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>ofs</name> <operator>-=</operator> <name>CALLBACK_MCODE_HEAD</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>group</name> <operator>=</operator> <name>ofs</name> <operator>/</operator> <operator>(</operator><literal type="number">32</literal><operator>*</operator><literal type="number">4</literal> <operator>+</operator> <name>CALLBACK_MCODE_GROUP</name><operator>)</operator></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><name>ofs</name> <operator>%</operator> <operator>(</operator><literal type="number">32</literal><operator>*</operator><literal type="number">4</literal> <operator>+</operator> <name>CALLBACK_MCODE_GROUP</name><operator>)</operator><operator>)</operator><operator>/</operator><literal type="number">4</literal> <operator>+</operator> <name>group</name><operator>*</operator><literal type="number">32</literal></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALLBACK_MAX_SLOT</name></cpp:macro> \
  <cpp:value>(((CALLBACK_MCODE_SIZE-CALLBACK_MCODE_HEAD)/(CALLBACK_MCODE_GROUP+4*32))*32)</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_ARM</name></expr></cpp:elif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALLBACK_MCODE_HEAD</name></cpp:macro>		<cpp:value>32</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_ARM64</name></expr></cpp:elif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALLBACK_MCODE_HEAD</name></cpp:macro>		<cpp:value>32</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_PPC</name></expr></cpp:elif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_ARCH_PPC64</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALLBACK_MCODE_HEAD</name></cpp:macro>		<cpp:value>40</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>  <comment type="block">/* PPC 32bits */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALLBACK_MCODE_HEAD</name></cpp:macro>		<cpp:value>24</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_MIPS32</name></expr></cpp:elif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALLBACK_MCODE_HEAD</name></cpp:macro>		<cpp:value>20</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_MIPS64</name></expr></cpp:elif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALLBACK_MCODE_HEAD</name></cpp:macro>		<cpp:value>52</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<comment type="block">/* Missing support for this architecture. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALLBACK_SLOT2OFS</name><parameter_list>(<parameter><type><name>slot</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(0*(slot))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALLBACK_OFS2SLOT</name><parameter_list>(<parameter><type><name>ofs</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(0*(ofs))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALLBACK_MAX_SLOT</name></cpp:macro>	<cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>CALLBACK_SLOT2OFS</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALLBACK_SLOT2OFS</name><parameter_list>(<parameter><type><name>slot</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>(CALLBACK_MCODE_HEAD + 8*(slot))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALLBACK_OFS2SLOT</name><parameter_list>(<parameter><type><name>ofs</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>(((ofs)-CALLBACK_MCODE_HEAD)/8)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALLBACK_MAX_SLOT</name></cpp:macro>		<cpp:value>(CALLBACK_OFS2SLOT(CALLBACK_MCODE_SIZE))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Convert callback slot number to callback function pointer. */</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>callback_slot2ptr</name><parameter_list>(<parameter><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name></decl></parameter>, <parameter><decl><type><name>MSize</name></type> <name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name><name>cts</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>mcode</name></name> <operator>+</operator> <call><name>CALLBACK_SLOT2OFS</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Convert callback function pointer to slot number. */</comment>
<function><type><name>MSize</name></type> <name>lj_ccallback_ptr2slot</name><parameter_list>(<parameter><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uintptr_t</name></type> <name>ofs</name> <init>= <expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><operator>(</operator><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>p</name> <operator>-</operator><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name><name>cts</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>mcode</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>ofs</name> <operator>&lt;</operator> <name>CALLBACK_MCODE_SIZE</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>MSize</name></type> <name>slot</name> <init>= <expr><call><name>CALLBACK_OFS2SLOT</name><argument_list>(<argument><expr><operator>(</operator><name>MSize</name><operator>)</operator><name>ofs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>CALLBACK_SLOT2OFS</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>(</operator><name>MSize</name><operator>)</operator><name>ofs</name></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>slot</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><operator>~</operator><literal type="number">0u</literal></expr>;</return>  <comment type="block">/* Not a known callback function pointer. */</comment>
</block_content>}</block></function>

<comment type="block">/* Initialize machine code for callback function pointers. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_OS_NOJIT</name></expr></cpp:if>
<comment type="block">/* Disabled callback support. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>callback_mcode_init</name><parameter_list>(<parameter><type><name>g</name></type></parameter>, <parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>UNUSED(p)</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_X86ORX64</name></expr></cpp:elif>
<function><type><specifier>static</specifier> <name>void</name></type> <name>callback_mcode_init</name><parameter_list>(<parameter><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>page</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>page</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>target</name> <init>= <expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>lj_vm_ffi_callback</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MSize</name></type> <name>slot</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_64</name></expr></cpp:if>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>p</name> <operator>=</operator> <name>target</name></expr>;</expr_stmt> <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <for>for <control>(<init><expr><name>slot</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>slot</name> <operator>&lt;</operator> <name>CALLBACK_MAX_SLOT</name></expr>;</condition> <incr><expr><name>slot</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <comment type="block">/* mov al, slot; jmp group */</comment>
    <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>XI_MOVrib</name> <operator>|</operator> <name>RID_EAX</name></expr>;</expr_stmt> <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name>slot</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>slot</name> <operator>&amp;</operator> <literal type="number">31</literal><operator>)</operator> <operator>==</operator> <literal type="number">31</literal> <operator>||</operator> <name>slot</name> <operator>==</operator> <name>CALLBACK_MAX_SLOT</name><operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
      <comment type="block">/* push ebp/rbp; mov ah, slot&gt;&gt;8; mov ebp, &amp;g. */</comment>
      <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>XI_PUSH</name> <operator>+</operator> <name>RID_EBP</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>XI_MOVrib</name> <operator>|</operator> <operator>(</operator><name>RID_EAX</name><operator>+</operator><literal type="number">4</literal><operator>)</operator></expr>;</expr_stmt> <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><name>slot</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_GC64</name></expr></cpp:if>
      <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="number">0x48</literal></expr>;</expr_stmt> <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>XI_MOVri</name> <operator>|</operator> <name>RID_EBP</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator><name>p</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><operator>(</operator><name>g</name><operator>)</operator></expr>;</expr_stmt> <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>XI_MOVri</name> <operator>|</operator> <name>RID_EBP</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>int32_t</name> <operator>*</operator><operator>)</operator><name>p</name> <operator>=</operator> <call><name>i32ptr</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_64</name></expr></cpp:if>
      <comment type="block">/* jmp [rip-pageofs] where lj_vm_ffi_callback is stored. */</comment>
      <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>XI_GROUP5</name></expr>;</expr_stmt> <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>XM_OFS0</name> <operator>+</operator> <operator>(</operator><name>XOg_JMP</name><operator>&lt;&lt;</operator><literal type="number">3</literal><operator>)</operator> <operator>+</operator> <name>RID_EBP</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>int32_t</name> <operator>*</operator><operator>)</operator><name>p</name> <operator>=</operator> <operator>(</operator><name>int32_t</name><operator>)</operator><operator>(</operator><name>page</name><operator>-</operator><operator>(</operator><name>p</name><operator>+</operator><literal type="number">4</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt> <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <comment type="block">/* jmp lj_vm_ffi_callback. */</comment>
      <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>XI_JMP</name></expr>;</expr_stmt> <expr_stmt><expr><operator>*</operator><operator>(</operator><name>int32_t</name> <operator>*</operator><operator>)</operator><name>p</name> <operator>=</operator> <name>target</name><operator>-</operator><operator>(</operator><name>p</name><operator>+</operator><literal type="number">4</literal><operator>)</operator></expr>;</expr_stmt> <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>XI_JMPs</name></expr>;</expr_stmt> <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><operator>(</operator><literal type="number">2</literal><operator>+</operator><literal type="number">2</literal><operator>)</operator><operator>*</operator><operator>(</operator><literal type="number">31</literal><operator>-</operator><operator>(</operator><name>slot</name><operator>&amp;</operator><literal type="number">31</literal><operator>)</operator><operator>)</operator> <operator>-</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>p</name> <operator>-</operator> <name>page</name> <operator>&lt;=</operator> <name>CALLBACK_MCODE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_ARM</name></expr></cpp:elif>
<function><type><specifier>static</specifier> <name>void</name></type> <name>callback_mcode_init</name><parameter_list>(<parameter><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>page</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>page</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>target</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>lj_vm_ffi_callback</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MSize</name></type> <name>slot</name></decl>;</decl_stmt>
  <comment type="block">/* This must match with the saveregs macro in buildvm_arm.dasc. */</comment>
  <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>ARMI_SUB</name><operator>|</operator><call><name>ARMF_D</name><argument_list>(<argument><expr><name>RID_R12</name></expr></argument>)</argument_list></call><operator>|</operator><call><name>ARMF_N</name><argument_list>(<argument><expr><name>RID_R12</name></expr></argument>)</argument_list></call><operator>|</operator><call><name>ARMF_M</name><argument_list>(<argument><expr><name>RID_PC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>ARMI_PUSH</name><operator>|</operator><call><name>ARMF_N</name><argument_list>(<argument><expr><name>RID_SP</name></expr></argument>)</argument_list></call><operator>|</operator><call><name>RSET_RANGE</name><argument_list>(<argument><expr><name>RID_R4</name></expr></argument>,<argument><expr><name>RID_R11</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>|</operator><call><name>RID2RSET</name><argument_list>(<argument><expr><name>RID_LR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>ARMI_SUB</name><operator>|</operator><name>ARMI_K12</name><operator>|</operator><call><name>ARMF_D</name><argument_list>(<argument><expr><name>RID_R12</name></expr></argument>)</argument_list></call><operator>|</operator><call><name>ARMF_N</name><argument_list>(<argument><expr><name>RID_R12</name></expr></argument>)</argument_list></call><operator>|</operator><name>CALLBACK_MCODE_HEAD</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>ARMI_STR</name><operator>|</operator><name>ARMI_LS_P</name><operator>|</operator><name>ARMI_LS_W</name><operator>|</operator><call><name>ARMF_D</name><argument_list>(<argument><expr><name>RID_R12</name></expr></argument>)</argument_list></call><operator>|</operator><call><name>ARMF_N</name><argument_list>(<argument><expr><name>RID_SP</name></expr></argument>)</argument_list></call><operator>|</operator><operator>(</operator><name>CFRAME_SIZE</name><operator>-</operator><literal type="number">4</literal><operator>*</operator><literal type="number">9</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>ARMI_LDR</name><operator>|</operator><name>ARMI_LS_P</name><operator>|</operator><name>ARMI_LS_U</name><operator>|</operator><call><name>ARMF_D</name><argument_list>(<argument><expr><name>RID_R12</name></expr></argument>)</argument_list></call><operator>|</operator><call><name>ARMF_N</name><argument_list>(<argument><expr><name>RID_PC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>ARMI_LDR</name><operator>|</operator><name>ARMI_LS_P</name><operator>|</operator><name>ARMI_LS_U</name><operator>|</operator><call><name>ARMF_D</name><argument_list>(<argument><expr><name>RID_PC</name></expr></argument>)</argument_list></call><operator>|</operator><call><name>ARMF_N</name><argument_list>(<argument><expr><name>RID_PC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <call><name>u32ptr</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <call><name>u32ptr</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>slot</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>slot</name> <operator>&lt;</operator> <name>CALLBACK_MAX_SLOT</name></expr>;</condition> <incr><expr><name>slot</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>ARMI_MOV</name><operator>|</operator><call><name>ARMF_D</name><argument_list>(<argument><expr><name>RID_R12</name></expr></argument>)</argument_list></call><operator>|</operator><call><name>ARMF_M</name><argument_list>(<argument><expr><name>RID_PC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name>ARMI_B</name> <operator>|</operator> <operator>(</operator><operator>(</operator><name>page</name><operator>-</operator><name>p</name><operator>-</operator><literal type="number">2</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x00ffffffu</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>p</name> <operator>-</operator> <name>page</name> <operator>&lt;=</operator> <name>CALLBACK_MCODE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_ARM64</name></expr></cpp:elif>
<function><type><specifier>static</specifier> <name>void</name></type> <name>callback_mcode_init</name><parameter_list>(<parameter><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>page</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>page</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>target</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>lj_vm_ffi_callback</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MSize</name></type> <name>slot</name></decl>;</decl_stmt>
  <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <call><name>A64I_LE</name><argument_list>(<argument><expr><name>A64I_LDRLx</name> <operator>|</operator> <call><name>A64F_D</name><argument_list>(<argument><expr><name>RID_X11</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>A64F_S19</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <call><name>A64I_LE</name><argument_list>(<argument><expr><name>A64I_LDRLx</name> <operator>|</operator> <call><name>A64F_D</name><argument_list>(<argument><expr><name>RID_X10</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>A64F_S19</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <call><name>A64I_LE</name><argument_list>(<argument><expr><name>A64I_BR</name> <operator>|</operator> <call><name>A64F_N</name><argument_list>(<argument><expr><name>RID_X11</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <call><name>A64I_LE</name><argument_list>(<argument><expr><name>A64I_NOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>p</name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>p</name><operator>)</operator><index>[<expr><literal type="number">1</literal></expr>]</index> <operator>=</operator> <name>g</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>slot</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>slot</name> <operator>&lt;</operator> <name>CALLBACK_MAX_SLOT</name></expr>;</condition> <incr><expr><name>slot</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <call><name>A64I_LE</name><argument_list>(<argument><expr><name>A64I_MOVZw</name> <operator>|</operator> <call><name>A64F_D</name><argument_list>(<argument><expr><name>RID_X9</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>A64F_U16</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <call><name>A64I_LE</name><argument_list>(<argument><expr><name>A64I_B</name> <operator>|</operator> <call><name>A64F_S26</name><argument_list>(<argument><expr><operator>(</operator><name>page</name><operator>-</operator><name>p</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x03ffffffu</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>p</name> <operator>-</operator> <name>page</name> <operator>&lt;=</operator> <name>CALLBACK_MCODE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_PPC</name></expr></cpp:elif>
<function><type><specifier>static</specifier> <name>void</name></type> <name>callback_mcode_init</name><parameter_list>(<parameter><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>page</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>page</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>target</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>lj_vm_ffi_callback</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MSize</name></type> <name>slot</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_ARCH_PPC64</name></expr></cpp:if>
  <comment type="line">// Store on R0 the global state and point R12 to the function so TOC is calculated correctly.</comment>
  <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>PPCI_LI</name> <operator>|</operator> <call><name>PPCF_T</name><argument_list>(<argument><expr><name>RID_R12</name></expr></argument>)</argument_list></call> <operator>|</operator> <operator>(</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>intptr_t</name><operator>)</operator><name>target</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xffff</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>PPCI_LI</name> <operator>|</operator> <call><name>PPCF_T</name><argument_list>(<argument><expr><name>RID_TMP</name></expr></argument>)</argument_list></call> <operator>|</operator> <operator>(</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>intptr_t</name><operator>)</operator><name>g</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xffff</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>PPCI_RLDICR</name> <operator>|</operator> <call><name>PPCF_T</name><argument_list>(<argument><expr><name>RID_R12</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>PPCF_A</name><argument_list>(<argument><expr><name>RID_R12</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>PPCF_SH</name><argument_list>(<argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>PPCF_M6</name><argument_list>(<argument><expr><literal type="number">63</literal><operator>-</operator><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* sldi */</comment>
  <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>PPCI_RLDICR</name> <operator>|</operator> <call><name>PPCF_T</name><argument_list>(<argument><expr><name>RID_TMP</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>PPCF_A</name><argument_list>(<argument><expr><name>RID_TMP</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>PPCF_SH</name><argument_list>(<argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>PPCF_M6</name><argument_list>(<argument><expr><literal type="number">63</literal><operator>-</operator><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* sldi */</comment>
  <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>PPCI_ORIS</name> <operator>|</operator> <call><name>PPCF_A</name><argument_list>(<argument><expr><name>RID_R12</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>PPCF_T</name><argument_list>(<argument><expr><name>RID_R12</name></expr></argument>)</argument_list></call> <operator>|</operator> <operator>(</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>intptr_t</name><operator>)</operator><name>target</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xffff</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>PPCI_ORIS</name> <operator>|</operator> <call><name>PPCF_A</name><argument_list>(<argument><expr><name>RID_TMP</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>PPCF_T</name><argument_list>(<argument><expr><name>RID_TMP</name></expr></argument>)</argument_list></call> <operator>|</operator> <operator>(</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>intptr_t</name><operator>)</operator><name>g</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xffff</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>PPCI_ORI</name> <operator>|</operator> <call><name>PPCF_A</name><argument_list>(<argument><expr><name>RID_R12</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>PPCF_T</name><argument_list>(<argument><expr><name>RID_R12</name></expr></argument>)</argument_list></call> <operator>|</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>intptr_t</name><operator>)</operator><name>target</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xffff</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>PPCI_ORI</name> <operator>|</operator> <call><name>PPCF_A</name><argument_list>(<argument><expr><name>RID_TMP</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>PPCF_T</name><argument_list>(<argument><expr><name>RID_TMP</name></expr></argument>)</argument_list></call> <operator>|</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>intptr_t</name><operator>)</operator><name>g</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xffff</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>PPCI_MTCTR</name> <operator>|</operator> <call><name>PPCF_T</name><argument_list>(<argument><expr><name>RID_R12</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>  <comment type="block">/* PPC 32bits */</comment>
  <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>PPCI_LIS</name> <operator>|</operator> <call><name>PPCF_T</name><argument_list>(<argument><expr><name>RID_TMP</name></expr></argument>)</argument_list></call> <operator>|</operator> <operator>(</operator><call><name>u32ptr</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>PPCI_LIS</name> <operator>|</operator> <call><name>PPCF_T</name><argument_list>(<argument><expr><name>RID_R12</name></expr></argument>)</argument_list></call> <operator>|</operator> <operator>(</operator><call><name>u32ptr</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>PPCI_ORI</name> <operator>|</operator> <call><name>PPCF_A</name><argument_list>(<argument><expr><name>RID_TMP</name></expr></argument>)</argument_list></call><operator>|</operator><call><name>PPCF_T</name><argument_list>(<argument><expr><name>RID_TMP</name></expr></argument>)</argument_list></call> <operator>|</operator> <operator>(</operator><call><name>u32ptr</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <literal type="number">0xffff</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>PPCI_ORI</name> <operator>|</operator> <call><name>PPCF_A</name><argument_list>(<argument><expr><name>RID_R12</name></expr></argument>)</argument_list></call><operator>|</operator><call><name>PPCF_T</name><argument_list>(<argument><expr><name>RID_R12</name></expr></argument>)</argument_list></call> <operator>|</operator> <operator>(</operator><call><name>u32ptr</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <literal type="number">0xffff</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>PPCI_MTCTR</name> <operator>|</operator> <call><name>PPCF_T</name><argument_list>(<argument><expr><name>RID_TMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>PPCI_BCTR</name></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>slot</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>slot</name> <operator>&lt;</operator> <name>CALLBACK_MAX_SLOT</name></expr>;</condition> <incr><expr><name>slot</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>PPCI_LI</name> <operator>|</operator> <call><name>PPCF_T</name><argument_list>(<argument><expr><name>RID_R11</name></expr></argument>)</argument_list></call> <operator>|</operator> <name>slot</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name>PPCI_B</name> <operator>|</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>page</name><operator>-</operator><name>p</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x00ffffffu</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>p</name> <operator>-</operator> <name>page</name> <operator>&lt;=</operator> <name>CALLBACK_MCODE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_MIPS</name></expr></cpp:elif>
<function><type><specifier>static</specifier> <name>void</name></type> <name>callback_mcode_init</name><parameter_list>(<parameter><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>page</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>page</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uintptr_t</name></type> <name>target</name> <init>= <expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>lj_vm_ffi_callback</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uintptr_t</name></type> <name>ug</name> <init>= <expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>g</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MSize</name></type> <name>slot</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_MIPS32</name></expr></cpp:if>
  <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>MIPSI_LUI</name> <operator>|</operator> <call><name>MIPSF_T</name><argument_list>(<argument><expr><name>RID_R3</name></expr></argument>)</argument_list></call> <operator>|</operator> <operator>(</operator><name>target</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>MIPSI_LUI</name> <operator>|</operator> <call><name>MIPSF_T</name><argument_list>(<argument><expr><name>RID_R2</name></expr></argument>)</argument_list></call> <operator>|</operator> <operator>(</operator><name>ug</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>MIPSI_LUI</name>  <operator>|</operator> <call><name>MIPSF_T</name><argument_list>(<argument><expr><name>RID_R3</name></expr></argument>)</argument_list></call> <operator>|</operator> <operator>(</operator><name>target</name> <operator>&gt;&gt;</operator> <literal type="number">48</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>MIPSI_LUI</name>  <operator>|</operator> <call><name>MIPSF_T</name><argument_list>(<argument><expr><name>RID_R2</name></expr></argument>)</argument_list></call> <operator>|</operator> <operator>(</operator><name>ug</name> <operator>&gt;&gt;</operator> <literal type="number">48</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>MIPSI_ORI</name>  <operator>|</operator> <call><name>MIPSF_T</name><argument_list>(<argument><expr><name>RID_R3</name></expr></argument>)</argument_list></call><operator>|</operator><call><name>MIPSF_S</name><argument_list>(<argument><expr><name>RID_R3</name></expr></argument>)</argument_list></call> <operator>|</operator> <operator>(</operator><operator>(</operator><name>target</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xffff</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>MIPSI_ORI</name>  <operator>|</operator> <call><name>MIPSF_T</name><argument_list>(<argument><expr><name>RID_R2</name></expr></argument>)</argument_list></call><operator>|</operator><call><name>MIPSF_S</name><argument_list>(<argument><expr><name>RID_R2</name></expr></argument>)</argument_list></call> <operator>|</operator> <operator>(</operator><operator>(</operator><name>ug</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xffff</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>MIPSI_DSLL</name> <operator>|</operator> <call><name>MIPSF_D</name><argument_list>(<argument><expr><name>RID_R3</name></expr></argument>)</argument_list></call><operator>|</operator><call><name>MIPSF_T</name><argument_list>(<argument><expr><name>RID_R3</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>MIPSF_A</name><argument_list>(<argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>MIPSI_DSLL</name> <operator>|</operator> <call><name>MIPSF_D</name><argument_list>(<argument><expr><name>RID_R2</name></expr></argument>)</argument_list></call><operator>|</operator><call><name>MIPSF_T</name><argument_list>(<argument><expr><name>RID_R2</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>MIPSF_A</name><argument_list>(<argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>MIPSI_ORI</name>  <operator>|</operator> <call><name>MIPSF_T</name><argument_list>(<argument><expr><name>RID_R3</name></expr></argument>)</argument_list></call><operator>|</operator><call><name>MIPSF_S</name><argument_list>(<argument><expr><name>RID_R3</name></expr></argument>)</argument_list></call> <operator>|</operator> <operator>(</operator><operator>(</operator><name>target</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xffff</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>MIPSI_ORI</name>  <operator>|</operator> <call><name>MIPSF_T</name><argument_list>(<argument><expr><name>RID_R2</name></expr></argument>)</argument_list></call><operator>|</operator><call><name>MIPSF_S</name><argument_list>(<argument><expr><name>RID_R2</name></expr></argument>)</argument_list></call> <operator>|</operator> <operator>(</operator><operator>(</operator><name>ug</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xffff</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>MIPSI_DSLL</name> <operator>|</operator> <call><name>MIPSF_D</name><argument_list>(<argument><expr><name>RID_R3</name></expr></argument>)</argument_list></call><operator>|</operator><call><name>MIPSF_T</name><argument_list>(<argument><expr><name>RID_R3</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>MIPSF_A</name><argument_list>(<argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>MIPSI_DSLL</name> <operator>|</operator> <call><name>MIPSF_D</name><argument_list>(<argument><expr><name>RID_R2</name></expr></argument>)</argument_list></call><operator>|</operator><call><name>MIPSF_T</name><argument_list>(<argument><expr><name>RID_R2</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>MIPSF_A</name><argument_list>(<argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>MIPSI_ORI</name>  <operator>|</operator> <call><name>MIPSF_T</name><argument_list>(<argument><expr><name>RID_R3</name></expr></argument>)</argument_list></call><operator>|</operator><call><name>MIPSF_S</name><argument_list>(<argument><expr><name>RID_R3</name></expr></argument>)</argument_list></call> <operator>|</operator> <operator>(</operator><name>target</name> <operator>&amp;</operator> <literal type="number">0xffff</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>MIPSI_JR</name> <operator>|</operator> <call><name>MIPSF_S</name><argument_list>(<argument><expr><name>RID_R3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>MIPSI_ORI</name> <operator>|</operator> <call><name>MIPSF_T</name><argument_list>(<argument><expr><name>RID_R2</name></expr></argument>)</argument_list></call><operator>|</operator><call><name>MIPSF_S</name><argument_list>(<argument><expr><name>RID_R2</name></expr></argument>)</argument_list></call> <operator>|</operator> <operator>(</operator><name>ug</name> <operator>&amp;</operator> <literal type="number">0xffff</literal><operator>)</operator></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>slot</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>slot</name> <operator>&lt;</operator> <name>CALLBACK_MAX_SLOT</name></expr>;</condition> <incr><expr><name>slot</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name>MIPSI_B</name> <operator>|</operator> <operator>(</operator><operator>(</operator><name>page</name><operator>-</operator><name>p</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x0000ffffu</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>MIPSI_LI</name> <operator>|</operator> <call><name>MIPSF_T</name><argument_list>(<argument><expr><name>RID_R1</name></expr></argument>)</argument_list></call> <operator>|</operator> <name>slot</name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>p</name> <operator>-</operator> <name>page</name> <operator>&lt;=</operator> <name>CALLBACK_MCODE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<comment type="block">/* Missing support for this architecture. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>callback_mcode_init</name><parameter_list>(<parameter><type><name>g</name></type></parameter>, <parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>UNUSED(p)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* -- Machine code management --------------------------------------------- */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_WINDOWS</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WIN32_LEAN_AND_MEAN</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_POSIX</name></expr></cpp:elif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/mman.h&gt;</cpp:file></cpp:include>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>MAP_ANONYMOUS</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAP_ANONYMOUS</name></cpp:macro>   <cpp:value>MAP_ANON</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Allocate and initialize area for callback function pointers. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>callback_mcode_new</name><parameter_list>(<parameter><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>size_t</name></type> <name>sz</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><name>CALLBACK_MCODE_SIZE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>CALLBACK_MAX_SLOT</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_err_caller</name><argument_list>(<argument><expr><name><name>cts</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>LJ_ERR_FFI_CBACKOV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_WINDOWS</name></expr></cpp:if>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>LJ_WIN_VALLOC</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name>MEM_RESERVE</name><operator>|</operator><name>MEM_COMMIT</name></expr></argument>, <argument><expr><name>PAGE_READWRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_err_caller</name><argument_list>(<argument><expr><name><name>cts</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>LJ_ERR_FFI_CBACKOV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_POSIX</name></expr></cpp:elif>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>mmap</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><operator>(</operator><name>PROT_READ</name><operator>|</operator><name>PROT_WRITE</name><operator>)</operator></expr></argument>, <argument><expr><name>MAP_PRIVATE</name><operator>|</operator><name>MAP_ANONYMOUS</name></expr></argument>,
	   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>MAP_FAILED</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_err_caller</name><argument_list>(<argument><expr><name><name>cts</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>LJ_ERR_FFI_CBACKOV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <comment type="block">/* Fallback allocator. Fails if memory is not executable by default. */</comment>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lj_mem_new</name><argument_list>(<argument><expr><name><name>cts</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name><name>cts</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>mcode</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>callback_mcode_init</name><argument_list>(<argument><expr><name><name>cts</name><operator>-&gt;</operator><name>g</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lj_mcode_sync</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>p</name> <operator>+</operator> <name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_WINDOWS</name></expr></cpp:if>
  <block>{<block_content>
    <decl_stmt><decl><type><name>DWORD</name></type> <name>oprot</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>LJ_WIN_VPROTECT</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name>PAGE_EXECUTE_READ</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oprot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_POSIX</name></expr></cpp:elif>
  <expr_stmt><expr><call><name>mprotect</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><operator>(</operator><name>PROT_READ</name><operator>|</operator><name>PROT_EXEC</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/* Free area for callback function pointers. */</comment>
<function><type><name>void</name></type> <name>lj_ccallback_mcode_free</name><parameter_list>(<parameter><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>size_t</name></type> <name>sz</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><name>CALLBACK_MCODE_SIZE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>cts</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>mcode</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_WINDOWS</name></expr></cpp:if>
  <expr_stmt><expr><call><name>VirtualFree</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>MEM_RELEASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_POSIX</name></expr></cpp:elif>
  <expr_stmt><expr><call><name>munmap</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>lj_mem_free</name><argument_list>(<argument><expr><name><name>cts</name><operator>-&gt;</operator><name>g</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/* -- C callback entry ---------------------------------------------------- */</comment>

<comment type="block">/* Target-specific handling of register arguments. Similar to lj_ccall.c. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_X86</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALLBACK_HANDLE_REGARG</name></cpp:macro> \
  <cpp:value>if (!isfp) {  <comment type="block">/* Only non-FP values may be passed in registers. */</comment> \
    if (n &gt; 1) {  <comment type="block">/* Anything &gt; 32 bit is passed on the stack. */</comment> \
      if (!LJ_ABI_WIN) ngpr = maxgpr;  <comment type="block">/* Prevent reordering. */</comment> \
    } else if (ngpr + 1 &lt;= maxgpr) { \
      sp = &amp;cts-&gt;cb.gpr[ngpr]; \
      ngpr += n; \
      goto done; \
    } \
  }</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_X64</name> <operator>&amp;&amp;</operator> <name>LJ_ABI_WIN</name></expr></cpp:elif>

<comment type="block">/* Windows/x64 argument registers are strictly positional (use ngpr). */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALLBACK_HANDLE_REGARG</name></cpp:macro> \
  <cpp:value>if (isfp) { \
    if (ngpr &lt; maxgpr) { sp = &amp;cts-&gt;cb.fpr[ngpr++]; UNUSED(nfpr); goto done; } \
  } else { \
    if (ngpr &lt; maxgpr) { sp = &amp;cts-&gt;cb.gpr[ngpr++]; goto done; } \
  }</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_X64</name></expr></cpp:elif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALLBACK_HANDLE_REGARG</name></cpp:macro> \
  <cpp:value>if (isfp) { \
    if (nfpr + n &lt;= CCALL_NARG_FPR) { \
      sp = &amp;cts-&gt;cb.fpr[nfpr]; \
      nfpr += n; \
      goto done; \
    } \
  } else { \
    if (ngpr + n &lt;= maxgpr) { \
      sp = &amp;cts-&gt;cb.gpr[ngpr]; \
      ngpr += n; \
      goto done; \
    } \
  }</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_ARM</name></expr></cpp:elif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_ABI_SOFTFP</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALLBACK_HANDLE_REGARG_FP1</name></cpp:macro>	<cpp:value>UNUSED(isfp);</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALLBACK_HANDLE_REGARG_FP2</name></cpp:macro></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALLBACK_HANDLE_REGARG_FP1</name></cpp:macro> \
  <cpp:value>if (isfp) { \
    if (n == 1) { \
      if (fprodd) { \
	sp = &amp;cts-&gt;cb.fpr[fprodd-1]; \
	fprodd = 0; \
	goto done; \
      } else if (nfpr + 1 &lt;= CCALL_NARG_FPR) { \
	sp = &amp;cts-&gt;cb.fpr[nfpr++]; \
	fprodd = nfpr; \
	goto done; \
      } \
    } else { \
      if (nfpr + 1 &lt;= CCALL_NARG_FPR) { \
	sp = &amp;cts-&gt;cb.fpr[nfpr++]; \
	goto done; \
      } \
    } \
    fprodd = 0;  <comment type="block">/* No reordering after the first FP value is on stack. */</comment> \
  } else {</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALLBACK_HANDLE_REGARG_FP2</name></cpp:macro>	<cpp:value>}</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALLBACK_HANDLE_REGARG</name></cpp:macro> \
  <cpp:value>CALLBACK_HANDLE_REGARG_FP1 \
  if (n &gt; 1) ngpr = (ngpr + 1u) &amp; ~1u;  <comment type="block">/* Align to regpair. */</comment> \
  if (ngpr + n &lt;= maxgpr) { \
    sp = &amp;cts-&gt;cb.gpr[ngpr]; \
    ngpr += n; \
    goto done; \
  } CALLBACK_HANDLE_REGARG_FP2</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_ARM64</name></expr></cpp:elif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALLBACK_HANDLE_REGARG</name></cpp:macro> \
  <cpp:value>if (isfp) { \
    if (nfpr + n &lt;= CCALL_NARG_FPR) { \
      sp = &amp;cts-&gt;cb.fpr[nfpr]; \
      nfpr += n; \
      goto done; \
    } else { \
      nfpr = CCALL_NARG_FPR;  <comment type="block">/* Prevent reordering. */</comment> \
    } \
  } else { \
    if (!LJ_TARGET_IOS &amp;&amp; n &gt; 1) \
      ngpr = (ngpr + 1u) &amp; ~1u;  <comment type="block">/* Align to regpair. */</comment> \
    if (ngpr + n &lt;= maxgpr) { \
      sp = &amp;cts-&gt;cb.gpr[ngpr]; \
      ngpr += n; \
      goto done; \
    } else { \
      ngpr = CCALL_NARG_GPR;  <comment type="block">/* Prevent reordering. */</comment> \
    } \
  }</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_PPC</name></expr></cpp:elif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALLBACK_HANDLE_GPR</name></cpp:macro> \
  <cpp:value>if (n &gt; 1) { \
    lua_assert(((LJ_ABI_SOFTFP &amp;&amp; ctype_isnum(cta-&gt;info)) ||  <comment type="block">/* double. */</comment> \
		ctype_isinteger(cta-&gt;info)) &amp;&amp; n == 2);  <comment type="block">/* int64_t. */</comment> \
    ngpr = (ngpr + 1u) &amp; ~1u;  <comment type="block">/* Align int64_t to regpair. */</comment> \
  } \
  if (ngpr + n &lt;= maxgpr) { \
    sp = &amp;cts-&gt;cb.gpr[ngpr]; \
    ngpr += n; \
    goto done; \
  }</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_ABI_SOFTFP</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALLBACK_HANDLE_REGARG</name></cpp:macro> \
  <cpp:value>CALLBACK_HANDLE_GPR \
  UNUSED(isfp);</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALLBACK_HANDLE_REGARG</name></cpp:macro> \
  <cpp:value>if (isfp) { \
    if (nfpr + 1 &lt;= CCALL_NARG_FPR) { \
      sp = &amp;cts-&gt;cb.fpr[nfpr++]; \
      cta = ctype_get(cts, CTID_DOUBLE);  <comment type="block">/* FPRs always hold doubles. */</comment> \
      goto done; \
    } \
  } else {  <comment type="block">/* Try to pass argument in GPRs. */</comment> \
    CALLBACK_HANDLE_GPR \
  }</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>LJ_ABI_SOFTFP</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALLBACK_HANDLE_RET</name></cpp:macro> \
  <cpp:value>if (ctype_isfp(ctr-&gt;info) &amp;&amp; ctr-&gt;size == sizeof(float)) \
    *(double *)dp = *(float *)dp;</cpp:value></cpp:define>  <comment type="block">/* FPRs always hold doubles. */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_MIPS32</name></expr></cpp:elif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALLBACK_HANDLE_GPR</name></cpp:macro> \
  <cpp:value>if (n &gt; 1) ngpr = (ngpr + 1u) &amp; ~1u;  <comment type="block">/* Align to regpair. */</comment> \
  if (ngpr + n &lt;= maxgpr) { \
    sp = &amp;cts-&gt;cb.gpr[ngpr]; \
    ngpr += n; \
    goto done; \
  }</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>LJ_ABI_SOFTFP</name></expr></cpp:if>	<comment type="block">/* MIPS32 hard-float */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALLBACK_HANDLE_REGARG</name></cpp:macro> \
  <cpp:value>if (isfp &amp;&amp; nfpr &lt; CCALL_NARG_FPR) {  <comment type="block">/* Try to pass argument in FPRs. */</comment> \
    sp = (void *)((uint8_t *)&amp;cts-&gt;cb.fpr[nfpr] + ((LJ_BE &amp;&amp; n==1) ? 4 : 0)); \
    nfpr++; ngpr += n; \
    goto done; \
  } else {  <comment type="block">/* Try to pass argument in GPRs. */</comment> \
    nfpr = CCALL_NARG_FPR; \
    CALLBACK_HANDLE_GPR \
  }</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>			<comment type="block">/* MIPS32 soft-float */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALLBACK_HANDLE_REGARG</name></cpp:macro> \
  <cpp:value>CALLBACK_HANDLE_GPR \
  UNUSED(isfp);</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALLBACK_HANDLE_RET</name></cpp:macro> \
  <cpp:value>if (ctype_isfp(ctr-&gt;info) &amp;&amp; ctr-&gt;size == sizeof(float)) \
    ((float *)dp)[1] = *(float *)dp;</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_MIPS64</name></expr></cpp:elif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>LJ_ABI_SOFTFP</name></expr></cpp:if>	<comment type="block">/* MIPS64 hard-float */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALLBACK_HANDLE_REGARG</name></cpp:macro> \
  <cpp:value>if (ngpr + n &lt;= maxgpr) { \
    sp = isfp ? (void*) &amp;cts-&gt;cb.fpr[ngpr] : (void*) &amp;cts-&gt;cb.gpr[ngpr]; \
    ngpr += n; \
    goto done; \
  }</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>			<comment type="block">/* MIPS64 soft-float */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALLBACK_HANDLE_REGARG</name></cpp:macro> \
  <cpp:value>if (ngpr + n &lt;= maxgpr) { \
    UNUSED(isfp); \
    sp = (void*) &amp;cts-&gt;cb.gpr[ngpr]; \
    ngpr += n; \
    goto done; \
  }</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALLBACK_HANDLE_RET</name></cpp:macro> \
  <cpp:value>if (ctype_isfp(ctr-&gt;info) &amp;&amp; ctr-&gt;size == sizeof(float)) \
    ((float *)dp)[1] = *(float *)dp;</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#<cpp:directive>error</cpp:directive> <cpp:literal>"Missing calling convention definitions for this architecture"</cpp:literal></cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Convert and push callback arguments to Lua stack. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>callback_conv_args</name><parameter_list>(<parameter><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name></decl></parameter>, <parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>intptr_t</name> <modifier>*</modifier></type><name>stack</name> <init>= <expr><name><name>cts</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>stack</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MSize</name></type> <name>slot</name> <init>= <expr><name><name>cts</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>slot</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTypeID</name></type> <name>id</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>rid</name></decl>, <decl><type ref="prev"/><name>fid</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>gcsteps</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GCfunc</name> <modifier>*</modifier></type><name>fn</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>fntp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MSize</name></type> <name>ngpr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>nsp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>maxgpr</name> <init>= <expr><name>CCALL_NARG_GPR</name></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CCALL_NARG_FPR</name></expr></cpp:if>
  <decl_stmt><decl><type><name>MSize</name></type> <name>nfpr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_ARM</name></expr></cpp:if>
  <decl_stmt><decl><type><name>MSize</name></type> <name>fprodd</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if_stmt><if>if <condition>(<expr><name>slot</name> <operator>&lt;</operator> <name><name>cts</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>sizeid</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>id</name> <operator>=</operator> <name><name>cts</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>cbid</name><index>[<expr><name>slot</name></expr>]</index></name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rid</name> <operator>=</operator> <call><name>ctype_cid</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Return type. x86: +(spadj&lt;&lt;16). */</comment>
    <expr_stmt><expr><name>fn</name> <operator>=</operator> <call><name>funcV</name><argument_list>(<argument><expr><call><name>lj_tab_getint</name><argument_list>(<argument><expr><name><name>cts</name><operator>-&gt;</operator><name>miscmap</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>fntp</name> <operator>=</operator> <name>LJ_TFUNC</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* Must set up frame first, before throwing the error. */</comment>
    <expr_stmt><expr><name>ct</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>fn</name> <operator>=</operator> <operator>(</operator><name>GCfunc</name> <operator>*</operator><operator>)</operator><name>L</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>fntp</name> <operator>=</operator> <name>LJ_TTHREAD</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <comment type="block">/* Continuation returns from callback. */</comment>
  <if_stmt><if>if <condition>(<expr><name>LJ_FR2</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>(</operator><name>o</name><operator>++</operator><operator>)</operator><operator>-&gt;</operator><name>u64</name> <operator>=</operator> <name>LJ_CONT_FFI_CALLBACK</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>o</name><operator>++</operator><operator>)</operator><operator>-&gt;</operator><name>u64</name> <operator>=</operator> <name>rid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>o</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>u32</name><operator>.</operator><name>lo</name></name> <operator>=</operator> <name>LJ_CONT_FFI_CALLBACK</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>u32</name><operator>.</operator><name>hi</name></name> <operator>=</operator> <name>rid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>o</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>setframe_gc</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><call><name>obj2gco</name><argument_list>(<argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fntp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setframe_ftsz</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>o</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>-</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>)</operator> <operator>+</operator> <name>FRAME_CONT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <operator>++</operator><name>o</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ct</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_err_caller</name><argument_list>(<argument><expr><name><name>cts</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>LJ_ERR_FFI_BADCBACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>isluafunc</name><argument_list>(<argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>setcframe_pc</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>cframe</name></name></expr></argument>, <argument><expr><call><name>proto_bc</name><argument_list>(<argument><expr><call><name>funcproto</name><argument_list>(<argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>lj_state_checkstack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LUA_MINSTACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* May throw. */</comment>
  <expr_stmt><expr><name>o</name> <operator>=</operator> <name><name>L</name><operator>-&gt;</operator><name>base</name></name></expr>;</expr_stmt>  <comment type="block">/* Might have been reallocated. */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_X86</name></expr></cpp:if>
  <comment type="block">/* x86 has several different calling conventions. */</comment>
  <switch>switch <condition>(<expr><call><name>ctype_cconv</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
  <case>case <expr><name>CTCC_FASTCALL</name></expr>:</case> <expr_stmt><expr><name>maxgpr</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>CTCC_THISCALL</name></expr>:</case> <expr_stmt><expr><name>maxgpr</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <break>break;</break>
  <default>default:</default> <expr_stmt><expr><name>maxgpr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <break>break;</break>
  </block_content>}</block></switch>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name>fid</name> <operator>=</operator> <name><name>ct</name><operator>-&gt;</operator><name>sib</name></name></expr>;</expr_stmt>
  <while>while <condition>(<expr><name>fid</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ctf</name> <init>= <expr><call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>fid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ctype_isattrib</name><argument_list>(<argument><expr><name><name>ctf</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>cta</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>sp</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>CTSize</name></type> <name>sz</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>isfp</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>MSize</name></type> <name>n</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>ctype_isfield</name><argument_list>(<argument><expr><name><name>ctf</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>cta</name> <operator>=</operator> <call><name>ctype_rawchild</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ctf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>isfp</name> <operator>=</operator> <call><name>ctype_isfp</name><argument_list>(<argument><expr><name><name>cta</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>sz</name> <operator>=</operator> <operator>(</operator><name><name>cta</name><operator>-&gt;</operator><name>size</name></name> <operator>+</operator> <name>CTSIZE_PTR</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>CTSIZE_PTR</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>n</name> <operator>=</operator> <name>sz</name> <operator>/</operator> <name>CTSIZE_PTR</name></expr>;</expr_stmt>  <comment type="block">/* Number of GPRs or stack slots needed. */</comment>

      <macro><name>CALLBACK_HANDLE_REGARG</name></macro>  <comment type="block">/* Handle register arguments. */</comment>

      <comment type="block">/* Otherwise pass argument on stack. */</comment>
      <if_stmt><if>if <condition>(<expr><name>CCALL_ALIGN_STACKARG</name> <operator>&amp;&amp;</operator> <name>LJ_32</name> <operator>&amp;&amp;</operator> <name>sz</name> <operator>==</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>nsp</name> <operator>=</operator> <operator>(</operator><name>nsp</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;</operator> <operator>~</operator><literal type="number">1u</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Align 64 bit argument on stack. */</comment>
      <expr_stmt><expr><name>sp</name> <operator>=</operator> <operator>&amp;</operator><name><name>stack</name><index>[<expr><name>nsp</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>nsp</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>

    <label><name>done</name>:</label>
      <if_stmt><if>if <condition>(<expr><name>LJ_BE</name> <operator>&amp;&amp;</operator> <name><name>cta</name><operator>-&gt;</operator><name>size</name></name> <operator>&lt;</operator> <name>CTSIZE_PTR</name>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_MIPS64</name></expr></cpp:if>
	  <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>isfp</name> <operator>&amp;&amp;</operator> <name>nsp</name><operator>)</operator></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	 )</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>sp</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>sp</name> <operator>+</operator> <name>CTSIZE_PTR</name><operator>-</operator><name><name>cta</name><operator>-&gt;</operator><name>size</name></name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>gcsteps</name> <operator>+=</operator> <call><name>lj_cconv_tv_ct</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>cta</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>o</name><operator>++</operator></expr></argument>, <argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>fid</name> <operator>=</operator> <name><name>ctf</name><operator>-&gt;</operator><name>sib</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name>o</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_X86</name></expr></cpp:if>
  <comment type="block">/* Store stack adjustment for returns from non-cdecl callbacks. */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>ctype_cconv</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CTCC_CDECL</name></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_FR2</name></expr></cpp:if>
    <expr_stmt><expr><operator>(</operator><name><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>-</operator><literal type="number">3</literal><operator>)</operator><operator>-&gt;</operator><name>u64</name> <operator>|=</operator> <operator>(</operator><name>nsp</name> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">16</literal><operator>+</operator><literal type="number">2</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><operator>(</operator><name><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>-</operator><literal type="number">2</literal><operator>)</operator><operator>-&gt;</operator><name><name>u32</name><operator>.</operator><name>hi</name></name> <operator>|=</operator> <operator>(</operator><name>nsp</name> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">16</literal><operator>+</operator><literal type="number">2</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <while>while <condition>(<expr><name>gcsteps</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_gc_check</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></function>

<comment type="block">/* Convert Lua object to callback result. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>callback_conv_result</name><parameter_list>(<parameter><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name></decl></parameter>, <parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>TValue</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_FR2</name></expr></cpp:if>
  <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ctr</name> <init>= <expr><call><name>ctype_raw</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><operator>(</operator><name>uint16_t</name><operator>)</operator><operator>(</operator><name><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>-</operator><literal type="number">3</literal><operator>)</operator><operator>-&gt;</operator><name>u64</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ctr</name> <init>= <expr><call><name>ctype_raw</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><operator>(</operator><name>uint16_t</name><operator>)</operator><operator>(</operator><name><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>-</operator><literal type="number">2</literal><operator>)</operator><operator>-&gt;</operator><name><name>u32</name><operator>.</operator><name>hi</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_X86</name></expr></cpp:if>
  <expr_stmt><expr><name><name>cts</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>gpr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ctype_isvoid</name><argument_list>(<argument><expr><name><name>ctr</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>dp</name> <init>= <expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>cts</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>gpr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CCALL_NUM_FPR</name></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><call><name>ctype_isfp</name><argument_list>(<argument><expr><name><name>ctr</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>dp</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>cts</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>fpr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_ARM64</name> <operator>&amp;&amp;</operator> <name>LJ_BE</name></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><call><name>ctype_isfp</name><argument_list>(<argument><expr><name><name>ctr</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>ctr</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>float</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>dp</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>cts</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>fpr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>f</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>lj_cconv_ct_tv</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ctr</name></expr></argument>, <argument><expr><name>dp</name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CALLBACK_HANDLE_RET</name></cpp:ifdef>
    <macro><name>CALLBACK_HANDLE_RET</name></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/* Extend returned integers to (at least) 32 bits. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ctype_isinteger_or_bool</name><argument_list>(<argument><expr><name><name>ctr</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>ctr</name><operator>-&gt;</operator><name>size</name></name> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>ctr</name><operator>-&gt;</operator><name>info</name></name> <operator>&amp;</operator> <name>CTF_UNSIGNED</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><name>dp</name> <operator>=</operator> <ternary><condition><expr><name><name>ctr</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>*</operator><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>dp</name></expr> </then><else>:
					   <expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>*</operator><operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator><name>dp</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if>
      <else>else<block type="pseudo"><block_content>
	<expr_stmt><expr><operator>*</operator><operator>(</operator><name>int32_t</name> <operator>*</operator><operator>)</operator><name>dp</name> <operator>=</operator> <ternary><condition><expr><name><name>ctr</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><operator>(</operator><name>int32_t</name><operator>)</operator><operator>*</operator><operator>(</operator><name>int8_t</name> <operator>*</operator><operator>)</operator><name>dp</name></expr> </then><else>:
					  <expr><operator>(</operator><name>int32_t</name><operator>)</operator><operator>*</operator><operator>(</operator><name>int16_t</name> <operator>*</operator><operator>)</operator><name>dp</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_MIPS64</name> <operator>||</operator> <operator>(</operator><name>LJ_TARGET_ARM64</name> <operator>&amp;&amp;</operator> <name>LJ_BE</name><operator>)</operator></expr></cpp:if>
    <comment type="block">/* Always sign-extend results to 64 bits. Even a soft-fp 'float'. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>ctr</name><operator>-&gt;</operator><name>size</name></name> <operator>&lt;=</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator>
	<operator>(</operator><name>LJ_ABI_SOFTFP</name> <operator>||</operator> <call><name>ctype_isinteger_or_bool</name><argument_list>(<argument><expr><name><name>ctr</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator><name>dp</name> <operator>=</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><operator>*</operator><operator>(</operator><name>int32_t</name> <operator>*</operator><operator>)</operator><name>dp</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_X86</name></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><call><name>ctype_isfp</name><argument_list>(<argument><expr><name><name>ctr</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>cts</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>gpr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name><name>ctr</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>float</name></expr></argument>)</argument_list></sizeof></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">2</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Enter callback. */</comment>
<function><type><name>lua_State</name> <modifier>*</modifier> <name>LJ_FASTCALL</name></type> <name>lj_ccallback_enter</name><parameter_list>(<parameter><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name> <init>= <expr><name><name>cts</name><operator>-&gt;</operator><name>L</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name> <init>= <expr><name><name>cts</name><operator>-&gt;</operator><name>g</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>L</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>tvref</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>jit_base</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>setstrV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>++</operator></expr></argument>, <argument><expr><call><name>lj_err_str</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LJ_ERR_FFI_BADCBACK</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>panic</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name><name>g</name><operator>-&gt;</operator><name>panic</name></name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>lj_trace_abort</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Never record across callback. */</comment>
  <comment type="block">/* Setup C frame. */</comment>
  <expr_stmt><expr><call><name>cframe_prev</name><argument_list>(<argument><expr><name>cf</name></expr></argument>)</argument_list></call> <operator>=</operator> <name><name>L</name><operator>-&gt;</operator><name>cframe</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setcframe_L</name><argument_list>(<argument><expr><name>cf</name></expr></argument>, <argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>cframe_errfunc</name><argument_list>(<argument><expr><name>cf</name></expr></argument>)</argument_list></call> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>cframe_nres</name><argument_list>(<argument><expr><name>cf</name></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>cframe</name></name> <operator>=</operator> <name>cf</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>callback_conv_args</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>L</name></expr>;</return>  <comment type="block">/* Now call the function on this stack. */</comment>
</block_content>}</block></function>

<comment type="block">/* Leave callback. */</comment>
<function><type><name>void</name> <name>LJ_FASTCALL</name></type> <name>lj_ccallback_leave</name><parameter_list>(<parameter><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name></decl></parameter>, <parameter><decl><type><name>TValue</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name> <init>= <expr><name><name>cts</name><operator>-&gt;</operator><name>L</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GCfunc</name> <modifier>*</modifier></type><name>fn</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>obase</name> <init>= <expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr>;</expr_stmt>  <comment type="block">/* Keep continuation frame for throwing errors. */</comment>
  <if_stmt><if>if <condition>(<expr><name>o</name> <operator>&gt;=</operator> <name><name>L</name><operator>-&gt;</operator><name>base</name></name></expr>)</condition> <block>{<block_content>
    <comment type="block">/* PC of RET* is lost. Point to last line for result conv. errors. */</comment>
    <expr_stmt><expr><name>fn</name> <operator>=</operator> <call><name>curr_func</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>isluafunc</name><argument_list>(<argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>GCproto</name> <modifier>*</modifier></type><name>pt</name> <init>= <expr><call><name>funcproto</name><argument_list>(<argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>setcframe_pc</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>cframe</name></name></expr></argument>, <argument><expr><call><name>proto_bc</name><argument_list>(<argument><expr><name>pt</name></expr></argument>)</argument_list></call><operator>+</operator><name><name>pt</name><operator>-&gt;</operator><name>sizebc</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>callback_conv_result</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>L</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Finally drop C frame and continuation frame. */</comment>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>-=</operator> <literal type="number">2</literal><operator>+</operator><literal type="number">2</literal><operator>*</operator><name>LJ_FR2</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <name>obase</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>cframe</name></name> <operator>=</operator> <call><name>cframe_prev</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>cframe</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cts</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* Blacklist C function that called the callback. */</comment>
</block_content>}</block></function>

<comment type="block">/* -- C callback management ----------------------------------------------- */</comment>

<comment type="block">/* Get an unused slot in the callback slot table. */</comment>
<function><type><specifier>static</specifier> <name>MSize</name></type> <name>callback_slot_new</name><parameter_list>(<parameter><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name></decl></parameter>, <parameter><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CTypeID</name></type> <name>id</name> <init>= <expr><call><name>ctype_typeid</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTypeID1</name> <modifier>*</modifier></type><name>cbid</name> <init>= <expr><name><name>cts</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>cbid</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MSize</name></type> <name>top</name></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>top</name> <operator>=</operator> <name><name>cts</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>topid</name></name></expr>;</init> <condition><expr><name>top</name> <operator>&lt;</operator> <name><name>cts</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>sizeid</name></name></expr>;</condition> <incr><expr><name>top</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <if_stmt><if>if <condition>(<expr><call><name>LJ_LIKELY</name><argument_list>(<argument><expr><name><name>cbid</name><index>[<expr><name>top</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <goto>goto <name>found</name>;</goto></block_content></block></if></if_stmt></block_content></block></for>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CALLBACK_MAX_SLOT</name></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><name>top</name> <operator>&gt;=</operator> <name>CALLBACK_MAX_SLOT</name></expr>)</condition><block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>lj_err_caller</name><argument_list>(<argument><expr><name><name>cts</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>LJ_ERR_FFI_CBACKOV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cts</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>mcode</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>callback_mcode_new</name><argument_list>(<argument><expr><name>cts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>lj_mem_growvec</name><argument_list>(<argument><expr><name><name>cts</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>cbid</name></expr></argument>, <argument><expr><name><name>cts</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>sizeid</name></name></expr></argument>, <argument><expr><name>CALLBACK_MAX_SLOT</name></expr></argument>, <argument><expr><name>CTypeID1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cts</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>cbid</name></name> <operator>=</operator> <name>cbid</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>cbid</name><operator>+</operator><name>top</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name><name>cts</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>sizeid</name></name><operator>-</operator><name>top</name><operator>)</operator><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>CTypeID1</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>found</name>:</label>
  <expr_stmt><expr><name><name>cbid</name><index>[<expr><name>top</name></expr>]</index></name> <operator>=</operator> <name>id</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cts</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>topid</name></name> <operator>=</operator> <name>top</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <return>return <expr><name>top</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Check for function pointer and supported argument/result types. */</comment>
<function><type><specifier>static</specifier> <name>CType</name> <modifier>*</modifier></type><name>callback_checkfunc</name><parameter_list>(<parameter><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name></decl></parameter>, <parameter><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>narg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ctype_isptr</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name>LJ_64</name> <operator>&amp;&amp;</operator> <name><name>ct</name><operator>-&gt;</operator><name>size</name></name> <operator>!=</operator> <name>CTSIZE_PTR</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>ctype_rawchild</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>ctype_isfunc</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ctr</name> <init>= <expr><call><name>ctype_rawchild</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CTypeID</name></type> <name>fid</name> <init>= <expr><name><name>ct</name><operator>-&gt;</operator><name>sib</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>ctype_isvoid</name><argument_list>(<argument><expr><name><name>ctr</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ctype_isenum</name><argument_list>(<argument><expr><name><name>ctr</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
	  <call><name>ctype_isptr</name><argument_list>(<argument><expr><name><name>ctr</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><call><name>ctype_isnum</name><argument_list>(<argument><expr><name><name>ctr</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>ctr</name><operator>-&gt;</operator><name>size</name></name> <operator>&lt;=</operator> <literal type="number">8</literal><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ct</name><operator>-&gt;</operator><name>info</name></name> <operator>&amp;</operator> <name>CTF_VARARG</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <while>while <condition>(<expr><name>fid</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ctf</name> <init>= <expr><call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>fid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ctype_isattrib</name><argument_list>(<argument><expr><name><name>ctf</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>cta</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>ctype_isfield</name><argument_list>(<argument><expr><name><name>ctf</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cta</name> <operator>=</operator> <call><name>ctype_rawchild</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ctf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>ctype_isenum</name><argument_list>(<argument><expr><name><name>cta</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ctype_isptr</name><argument_list>(<argument><expr><name><name>cta</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
	      <operator>(</operator><call><name>ctype_isnum</name><argument_list>(<argument><expr><name><name>cta</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>cta</name><operator>-&gt;</operator><name>size</name></name> <operator>&lt;=</operator> <literal type="number">8</literal><operator>)</operator><operator>)</operator> <operator>||</operator>
	    <operator>++</operator><name>narg</name> <operator>&gt;=</operator> <name>LUA_MINSTACK</name><operator>-</operator><literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
	  <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>fid</name> <operator>=</operator> <name><name>ctf</name><operator>-&gt;</operator><name>sib</name></name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <return>return <expr><name>ct</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Create a new callback and return the callback function pointer. */</comment>
<function><type><name>void</name> <modifier>*</modifier></type><name>lj_ccallback_new</name><parameter_list>(<parameter><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name></decl></parameter>, <parameter><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name></decl></parameter>, <parameter><decl><type><name>GCfunc</name> <modifier>*</modifier></type><name>fn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>callback_checkfunc</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>ct</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>MSize</name></type> <name>slot</name> <init>= <expr><call><name>callback_slot_new</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GCtab</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><name><name>cts</name><operator>-&gt;</operator><name>miscmap</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>setfuncV</name><argument_list>(<argument><expr><name><name>cts</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><call><name>lj_tab_setint</name><argument_list>(<argument><expr><name><name>cts</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><name>slot</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lj_gc_anybarriert</name><argument_list>(<argument><expr><name><name>cts</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>callback_slot2ptr</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>NULL</name></expr>;</return>  <comment type="block">/* Bad conversion. */</comment>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
