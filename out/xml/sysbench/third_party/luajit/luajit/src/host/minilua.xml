<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/sysbench/third_party/luajit/luajit/src/host/minilua.c"><comment type="block">/* This is a heavily customized and minimized copy of Lua 5.1.5. */</comment>
<comment type="block">/* It's only used to build LuaJIT. It does NOT have all standard functions! */</comment>
<comment type="block" format="doxygen">/******************************************************************************
* Copyright (C) 1994-2012 Lua.org, PUC-Rio.  All rights reserved.
*
* Permission is hereby granted, free of charge, to any person obtaining
* a copy of this software and associated documentation files (the
* "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Software, and to
* permit persons to whom the Software is furnished to do so, subject to
* the following conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
******************************************************************************/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MSC_VER</name></cpp:ifdef>
<typedef>typedef <type><name>unsigned</name> <name>__int64</name></type> <name>U64</name>;</typedef>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<typedef>typedef <type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>U64</name>;</typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>int</name></type> <name>_CRT_glob</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stddef.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;setjmp.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<typedef>typedef <type><enum>enum<block>{
<decl><name>TM_INDEX</name></decl>,
<decl><name>TM_NEWINDEX</name></decl>,
<decl><name>TM_GC</name></decl>,
<decl><name>TM_MODE</name></decl>,
<decl><name>TM_EQ</name></decl>,
<decl><name>TM_ADD</name></decl>,
<decl><name>TM_SUB</name></decl>,
<decl><name>TM_MUL</name></decl>,
<decl><name>TM_DIV</name></decl>,
<decl><name>TM_MOD</name></decl>,
<decl><name>TM_POW</name></decl>,
<decl><name>TM_UNM</name></decl>,
<decl><name>TM_LEN</name></decl>,
<decl><name>TM_LT</name></decl>,
<decl><name>TM_LE</name></decl>,
<decl><name>TM_CONCAT</name></decl>,
<decl><name>TM_CALL</name></decl>,
<decl><name>TM_N</name></decl>
}</block></enum></type><name>TMS</name>;</typedef>
<enum>enum <name>OpMode</name><block>{<decl><name>iABC</name></decl>,<decl><name>iABx</name></decl>,<decl><name>iAsBx</name></decl>}</block>;</enum>
<typedef>typedef <type><enum>enum<block>{
<decl><name>OP_MOVE</name></decl>,
<decl><name>OP_LOADK</name></decl>,
<decl><name>OP_LOADBOOL</name></decl>,
<decl><name>OP_LOADNIL</name></decl>,
<decl><name>OP_GETUPVAL</name></decl>,
<decl><name>OP_GETGLOBAL</name></decl>,
<decl><name>OP_GETTABLE</name></decl>,
<decl><name>OP_SETGLOBAL</name></decl>,
<decl><name>OP_SETUPVAL</name></decl>,
<decl><name>OP_SETTABLE</name></decl>,
<decl><name>OP_NEWTABLE</name></decl>,
<decl><name>OP_SELF</name></decl>,
<decl><name>OP_ADD</name></decl>,
<decl><name>OP_SUB</name></decl>,
<decl><name>OP_MUL</name></decl>,
<decl><name>OP_DIV</name></decl>,
<decl><name>OP_MOD</name></decl>,
<decl><name>OP_POW</name></decl>,
<decl><name>OP_UNM</name></decl>,
<decl><name>OP_NOT</name></decl>,
<decl><name>OP_LEN</name></decl>,
<decl><name>OP_CONCAT</name></decl>,
<decl><name>OP_JMP</name></decl>,
<decl><name>OP_EQ</name></decl>,
<decl><name>OP_LT</name></decl>,
<decl><name>OP_LE</name></decl>,
<decl><name>OP_TEST</name></decl>,
<decl><name>OP_TESTSET</name></decl>,
<decl><name>OP_CALL</name></decl>,
<decl><name>OP_TAILCALL</name></decl>,
<decl><name>OP_RETURN</name></decl>,
<decl><name>OP_FORLOOP</name></decl>,
<decl><name>OP_FORPREP</name></decl>,
<decl><name>OP_TFORLOOP</name></decl>,
<decl><name>OP_SETLIST</name></decl>,
<decl><name>OP_CLOSE</name></decl>,
<decl><name>OP_CLOSURE</name></decl>,
<decl><name>OP_VARARG</name></decl>
}</block></enum></type><name>OpCode</name>;</typedef>
<enum>enum <name>OpArgMask</name><block>{
<decl><name>OpArgN</name></decl>,
<decl><name>OpArgU</name></decl>,
<decl><name>OpArgR</name></decl>,
<decl><name>OpArgK</name></decl>
}</block>;</enum>
<typedef>typedef <type><enum>enum<block>{
<decl><name>VVOID</name></decl>,
<decl><name>VNIL</name></decl>,
<decl><name>VTRUE</name></decl>,
<decl><name>VFALSE</name></decl>,
<decl><name>VK</name></decl>,
<decl><name>VKNUM</name></decl>,
<decl><name>VLOCAL</name></decl>,
<decl><name>VUPVAL</name></decl>,
<decl><name>VGLOBAL</name></decl>,
<decl><name>VINDEXED</name></decl>,
<decl><name>VJMP</name></decl>,
<decl><name>VRELOCABLE</name></decl>,
<decl><name>VNONRELOC</name></decl>,
<decl><name>VCALL</name></decl>,
<decl><name>VVARARG</name></decl>
}</block></enum></type><name>expkind</name>;</typedef>
<enum>enum <name>RESERVED</name><block>{
<decl><name>TK_AND</name><init>=<expr><literal type="number">257</literal></expr></init></decl>,<decl><name>TK_BREAK</name></decl>,
<decl><name>TK_DO</name></decl>,<decl><name>TK_ELSE</name></decl>,<decl><name>TK_ELSEIF</name></decl>,<decl><name>TK_END</name></decl>,<decl><name>TK_FALSE</name></decl>,<decl><name>TK_FOR</name></decl>,<decl><name>TK_FUNCTION</name></decl>,
<decl><name>TK_IF</name></decl>,<decl><name>TK_IN</name></decl>,<decl><name>TK_LOCAL</name></decl>,<decl><name>TK_NIL</name></decl>,<decl><name>TK_NOT</name></decl>,<decl><name>TK_OR</name></decl>,<decl><name>TK_REPEAT</name></decl>,
<decl><name>TK_RETURN</name></decl>,<decl><name>TK_THEN</name></decl>,<decl><name>TK_TRUE</name></decl>,<decl><name>TK_UNTIL</name></decl>,<decl><name>TK_WHILE</name></decl>,
<decl><name>TK_CONCAT</name></decl>,<decl><name>TK_DOTS</name></decl>,<decl><name>TK_EQ</name></decl>,<decl><name>TK_GE</name></decl>,<decl><name>TK_LE</name></decl>,<decl><name>TK_NE</name></decl>,<decl><name>TK_NUMBER</name></decl>,
<decl><name>TK_NAME</name></decl>,<decl><name>TK_STRING</name></decl>,<decl><name>TK_EOS</name></decl>
}</block>;</enum>
<typedef>typedef <type><enum>enum <name>BinOpr</name><block>{
<decl><name>OPR_ADD</name></decl>,<decl><name>OPR_SUB</name></decl>,<decl><name>OPR_MUL</name></decl>,<decl><name>OPR_DIV</name></decl>,<decl><name>OPR_MOD</name></decl>,<decl><name>OPR_POW</name></decl>,
<decl><name>OPR_CONCAT</name></decl>,
<decl><name>OPR_NE</name></decl>,<decl><name>OPR_EQ</name></decl>,
<decl><name>OPR_LT</name></decl>,<decl><name>OPR_LE</name></decl>,<decl><name>OPR_GT</name></decl>,<decl><name>OPR_GE</name></decl>,
<decl><name>OPR_AND</name></decl>,<decl><name>OPR_OR</name></decl>,
<decl><name>OPR_NOBINOPR</name></decl>
}</block></enum></type><name>BinOpr</name>;</typedef>
<typedef>typedef <type><enum>enum <name>UnOpr</name><block>{<decl><name>OPR_MINUS</name></decl>,<decl><name>OPR_NOT</name></decl>,<decl><name>OPR_LEN</name></decl>,<decl><name>OPR_NOUNOPR</name></decl>}</block></enum></type><name>UnOpr</name>;</typedef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUA_QL</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>"'"x"'"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>luai_apicheck</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>o</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>{(void)L;}</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lua_number2str</name><parameter_list>(<parameter><type><name>s</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>sprintf((s),"%.14g",(n))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lua_str2number</name><parameter_list>(<parameter><type><name>s</name></type></parameter>,<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>strtod((s),(p))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>luai_numadd</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((a)+(b))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>luai_numsub</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((a)-(b))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>luai_nummul</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((a)*(b))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>luai_numdiv</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((a)/(b))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>luai_nummod</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((a)-floor((a)/(b))*(b))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>luai_numpow</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(pow(a,b))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>luai_numunm</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(-(a))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>luai_numeq</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((a)==(b))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>luai_numlt</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((a)&lt;(b))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>luai_numle</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((a)&lt;=(b))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>luai_numisnan</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(!luai_numeq((a),(a)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lua_number2int</name><parameter_list>(<parameter><type><name>i</name></type></parameter>,<parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((i)=(int)(d))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lua_number2integer</name><parameter_list>(<parameter><type><name>i</name></type></parameter>,<parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((i)=(lua_Integer)(d))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUAI_THROW</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>longjmp((c)-&gt;b,1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUAI_TRY</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>if(setjmp((c)-&gt;b)==0){a}</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lua_pclose</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>file</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((void)((void)L,file),0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lua_upvalueindex</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((-10002)-(i))</cpp:value></cpp:define>
<typedef>typedef <type><name><name>struct</name> <name>lua_State</name></name></type> <name>lua_State</name>;</typedef>
<typedef>typedef <function_decl><type><name>int</name></type>(<modifier>*</modifier><name>lua_CFunction</name>)<parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list>;</function_decl></typedef>
<typedef>typedef <function_decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type>(<modifier>*</modifier><name>lua_Reader</name>)<parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>void</name><modifier>*</modifier></type><name>ud</name></decl></parameter>,<parameter><decl><type><name>size_t</name><modifier>*</modifier></type><name>sz</name></decl></parameter>)</parameter_list>;</function_decl></typedef>
<typedef>typedef <function_decl><type><name>void</name><modifier>*</modifier></type>(<modifier>*</modifier><name>lua_Alloc</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type><name>ud</name></decl></parameter>,<parameter><decl><type><name>void</name><modifier>*</modifier></type><name>ptr</name></decl></parameter>,<parameter><decl><type><name>size_t</name></type> <name>osize</name></decl></parameter>,<parameter><decl><type><name>size_t</name></type> <name>nsize</name></decl></parameter>)</parameter_list>;</function_decl></typedef>
<typedef>typedef <type><name>double</name></type> <name>lua_Number</name>;</typedef>
<typedef>typedef <type><name>ptrdiff_t</name></type> <name>lua_Integer</name>;</typedef>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>lua_settop</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>lua_type</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>lua_tolstring</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>,<parameter><decl><type><name>size_t</name><modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>size_t</name></type> <name>lua_objlen</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>lua_pushlstring</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>s</name></decl></parameter>,<parameter><decl><type><name>size_t</name></type> <name>l</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>lua_pushcclosure</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>lua_CFunction</name></type> <name>fn</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>lua_createtable</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>narr</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>nrec</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>lua_setfield</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>k</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lua_pop</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>lua_settop(L,-(n)-1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lua_newtable</name><parameter_list>(<parameter><type><name>L</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>lua_createtable(L,0,0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lua_pushcfunction</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>f</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>lua_pushcclosure(L,(f),0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lua_strlen</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>lua_objlen(L,(i))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lua_isfunction</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(lua_type(L,(n))==6)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lua_istable</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(lua_type(L,(n))==5)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lua_isnil</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(lua_type(L,(n))==0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lua_isboolean</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(lua_type(L,(n))==1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lua_isnone</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(lua_type(L,(n))==(-1))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lua_isnoneornil</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(lua_type(L,(n))&lt;=0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lua_pushliteral</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>lua_pushlstring(L,""s,(sizeof(s)/sizeof(char))-1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lua_setglobal</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>lua_setfield(L,(-10002),(s))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lua_tostring</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>lua_tolstring(L,(i),NULL)</cpp:value></cpp:define>
<typedef>typedef <type><name><name>struct</name> <name>lua_Debug</name></name></type> <name>lua_Debug</name>;</typedef>
<typedef>typedef <function_decl><type><name>void</name></type>(<modifier>*</modifier><name>lua_Hook</name>)<parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>lua_Debug</name><modifier>*</modifier></type><name>ar</name></decl></parameter>)</parameter_list>;</function_decl></typedef>
<struct>struct <name>lua_Debug</name><block>{
<decl_stmt><decl><type><name>int</name></type> <name>event</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>namewhat</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>what</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>source</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>currentline</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nups</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>linedefined</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>lastlinedefined</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>short_src</name><index>[<expr><literal type="number">60</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i_ci</name></decl>;</decl_stmt>
}</block>;</struct>
<typedef>typedef <type><name>unsigned</name> <name>int</name></type> <name>lu_int32</name>;</typedef>
<typedef>typedef <type><name>size_t</name></type> <name>lu_mem</name>;</typedef>
<typedef>typedef <type><name>ptrdiff_t</name></type> <name>l_mem</name>;</typedef>
<typedef>typedef <type><name>unsigned</name> <name>char</name></type> <name>lu_byte</name>;</typedef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IntPoint</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((unsigned int)(lu_mem)(p))</cpp:value></cpp:define>
<typedef>typedef <type><union>union<block>{<decl_stmt><decl><type><name>double</name></type> <name>u</name></decl>;</decl_stmt><decl_stmt><decl><type><name>void</name><modifier>*</modifier></type><name>s</name></decl>;</decl_stmt><decl_stmt><decl><type><name>long</name></type> <name>l</name></decl>;</decl_stmt>}</block></union></type><name>L_Umaxalign</name>;</typedef>
<typedef>typedef <type><name>double</name></type> <name>l_uacNumber</name>;</typedef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>check_exp</name><parameter_list>(<parameter><type><name>c</name></type></parameter>,<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(e)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNUSED</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((void)(x))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>cast</name><parameter_list>(<parameter><type><name>t</name></type></parameter>,<parameter><type><name>exp</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((t)(exp))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>cast_byte</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>cast(lu_byte,(i))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>cast_num</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>cast(lua_Number,(i))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>cast_int</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>cast(int,(i))</cpp:value></cpp:define>
<typedef>typedef <type><name>lu_int32</name></type> <name>Instruction</name>;</typedef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>condhardstacktests</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((void)0)</cpp:value></cpp:define>
<typedef>typedef <type><name><name>union</name> <name>GCObject</name></name></type> <name>GCObject</name>;</typedef>
<typedef>typedef <type><struct>struct <name>GCheader</name><block>{
<decl_stmt><decl><type><name>GCObject</name><modifier>*</modifier></type><name>next</name></decl>;</decl_stmt><decl_stmt><decl><type><name>lu_byte</name></type> <name>tt</name></decl>;</decl_stmt><decl_stmt><decl><type><name>lu_byte</name></type> <name>marked</name></decl>;</decl_stmt>
}</block></struct></type><name>GCheader</name>;</typedef>
<typedef>typedef <type><union>union<block>{
<decl_stmt><decl><type><name>GCObject</name><modifier>*</modifier></type><name>gc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name><modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>lua_Number</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>b</name></decl>;</decl_stmt>
}</block></union></type><name>Value</name>;</typedef>
<typedef>typedef <type><struct>struct <name>lua_TValue</name><block>{
<decl_stmt><decl><type><name>Value</name></type> <name>value</name></decl>;</decl_stmt><decl_stmt><decl><type><name>int</name></type> <name>tt</name></decl>;</decl_stmt>
}</block></struct></type><name>TValue</name>;</typedef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ttisnil</name><parameter_list>(<parameter><type><name>o</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(ttype(o)==0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ttisnumber</name><parameter_list>(<parameter><type><name>o</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(ttype(o)==3)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ttisstring</name><parameter_list>(<parameter><type><name>o</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(ttype(o)==4)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ttistable</name><parameter_list>(<parameter><type><name>o</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(ttype(o)==5)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ttisfunction</name><parameter_list>(<parameter><type><name>o</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(ttype(o)==6)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ttisboolean</name><parameter_list>(<parameter><type><name>o</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(ttype(o)==1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ttisuserdata</name><parameter_list>(<parameter><type><name>o</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(ttype(o)==7)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ttisthread</name><parameter_list>(<parameter><type><name>o</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(ttype(o)==8)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ttislightuserdata</name><parameter_list>(<parameter><type><name>o</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(ttype(o)==2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ttype</name><parameter_list>(<parameter><type><name>o</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((o)-&gt;tt)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>gcvalue</name><parameter_list>(<parameter><type><name>o</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>check_exp(iscollectable(o),(o)-&gt;value.gc)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pvalue</name><parameter_list>(<parameter><type><name>o</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>check_exp(ttislightuserdata(o),(o)-&gt;value.p)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>nvalue</name><parameter_list>(<parameter><type><name>o</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>check_exp(ttisnumber(o),(o)-&gt;value.n)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rawtsvalue</name><parameter_list>(<parameter><type><name>o</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>check_exp(ttisstring(o),&amp;(o)-&gt;value.gc-&gt;ts)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>tsvalue</name><parameter_list>(<parameter><type><name>o</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(&amp;rawtsvalue(o)-&gt;tsv)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rawuvalue</name><parameter_list>(<parameter><type><name>o</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>check_exp(ttisuserdata(o),&amp;(o)-&gt;value.gc-&gt;u)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>uvalue</name><parameter_list>(<parameter><type><name>o</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(&amp;rawuvalue(o)-&gt;uv)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>clvalue</name><parameter_list>(<parameter><type><name>o</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>check_exp(ttisfunction(o),&amp;(o)-&gt;value.gc-&gt;cl)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>hvalue</name><parameter_list>(<parameter><type><name>o</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>check_exp(ttistable(o),&amp;(o)-&gt;value.gc-&gt;h)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>bvalue</name><parameter_list>(<parameter><type><name>o</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>check_exp(ttisboolean(o),(o)-&gt;value.b)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>thvalue</name><parameter_list>(<parameter><type><name>o</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>check_exp(ttisthread(o),&amp;(o)-&gt;value.gc-&gt;th)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>l_isfalse</name><parameter_list>(<parameter><type><name>o</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(ttisnil(o)||(ttisboolean(o)&amp;&amp;bvalue(o)==0))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>checkconsistency</name><parameter_list>(<parameter><type><name>obj</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>checkliveness</name><parameter_list>(<parameter><type><name>g</name></type></parameter>,<parameter><type><name>obj</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>setnilvalue</name><parameter_list>(<parameter><type><name>obj</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((obj)-&gt;tt=0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>setnvalue</name><parameter_list>(<parameter><type><name>obj</name></type></parameter>,<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>{TValue*i_o=(obj);i_o-&gt;value.n=(x);i_o-&gt;tt=3;}</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>setbvalue</name><parameter_list>(<parameter><type><name>obj</name></type></parameter>,<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>{TValue*i_o=(obj);i_o-&gt;value.b=(x);i_o-&gt;tt=1;}</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>setsvalue</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>obj</name></type></parameter>,<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>{TValue*i_o=(obj);i_o-&gt;value.gc=cast(GCObject*,(x));i_o-&gt;tt=4;checkliveness(G(L),i_o);}</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>setuvalue</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>obj</name></type></parameter>,<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>{TValue*i_o=(obj);i_o-&gt;value.gc=cast(GCObject*,(x));i_o-&gt;tt=7;checkliveness(G(L),i_o);}</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>setthvalue</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>obj</name></type></parameter>,<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>{TValue*i_o=(obj);i_o-&gt;value.gc=cast(GCObject*,(x));i_o-&gt;tt=8;checkliveness(G(L),i_o);}</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>setclvalue</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>obj</name></type></parameter>,<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>{TValue*i_o=(obj);i_o-&gt;value.gc=cast(GCObject*,(x));i_o-&gt;tt=6;checkliveness(G(L),i_o);}</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>sethvalue</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>obj</name></type></parameter>,<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>{TValue*i_o=(obj);i_o-&gt;value.gc=cast(GCObject*,(x));i_o-&gt;tt=5;checkliveness(G(L),i_o);}</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>setptvalue</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>obj</name></type></parameter>,<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>{TValue*i_o=(obj);i_o-&gt;value.gc=cast(GCObject*,(x));i_o-&gt;tt=(8+1);checkliveness(G(L),i_o);}</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>setobj</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>obj1</name></type></parameter>,<parameter><type><name>obj2</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>{const TValue*o2=(obj2);TValue*o1=(obj1);o1-&gt;value=o2-&gt;value;o1-&gt;tt=o2-&gt;tt;checkliveness(G(L),o1);}</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>setttype</name><parameter_list>(<parameter><type><name>obj</name></type></parameter>,<parameter><type><name>tt</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(ttype(obj)=(tt))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>iscollectable</name><parameter_list>(<parameter><type><name>o</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(ttype(o)&gt;=4)</cpp:value></cpp:define>
<typedef>typedef <type><name>TValue</name><modifier>*</modifier></type><name>StkId</name>;</typedef>
<typedef>typedef <type><union>union <name>TString</name><block>{
<decl_stmt><decl><type><name>L_Umaxalign</name></type> <name>dummy</name></decl>;</decl_stmt>
<struct>struct<block>{
<decl_stmt><decl><type><name>GCObject</name><modifier>*</modifier></type><name>next</name></decl>;</decl_stmt><decl_stmt><decl><type><name>lu_byte</name></type> <name>tt</name></decl>;</decl_stmt><decl_stmt><decl><type><name>lu_byte</name></type> <name>marked</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>lu_byte</name></type> <name>reserved</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>hash</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
}</block><decl><name>tsv</name></decl>;</struct>
}</block></union></type><name>TString</name>;</typedef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>getstr</name><parameter_list>(<parameter><type><name>ts</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>cast(const char*,(ts)+1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>svalue</name><parameter_list>(<parameter><type><name>o</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>getstr(rawtsvalue(o))</cpp:value></cpp:define>
<typedef>typedef <type><union>union <name>Udata</name><block>{
<decl_stmt><decl><type><name>L_Umaxalign</name></type> <name>dummy</name></decl>;</decl_stmt>
<struct>struct<block>{
<decl_stmt><decl><type><name>GCObject</name><modifier>*</modifier></type><name>next</name></decl>;</decl_stmt><decl_stmt><decl><type><name>lu_byte</name></type> <name>tt</name></decl>;</decl_stmt><decl_stmt><decl><type><name>lu_byte</name></type> <name>marked</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>Table</name></name><modifier>*</modifier></type><name>metatable</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>Table</name></name><modifier>*</modifier></type><name>env</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
}</block><decl><name>uv</name></decl>;</struct>
}</block></union></type><name>Udata</name>;</typedef>
<typedef>typedef <type><struct>struct <name>Proto</name><block>{
<decl_stmt><decl><type><name>GCObject</name><modifier>*</modifier></type><name>next</name></decl>;</decl_stmt><decl_stmt><decl><type><name>lu_byte</name></type> <name>tt</name></decl>;</decl_stmt><decl_stmt><decl><type><name>lu_byte</name></type> <name>marked</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TValue</name><modifier>*</modifier></type><name>k</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Instruction</name><modifier>*</modifier></type><name>code</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>Proto</name></name><modifier>*</modifier><modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name><modifier>*</modifier></type><name>lineinfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>LocVar</name></name><modifier>*</modifier></type><name>locvars</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TString</name><modifier>*</modifier><modifier>*</modifier></type><name>upvalues</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TString</name><modifier>*</modifier></type><name>source</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sizeupvalues</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sizek</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sizecode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sizelineinfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sizep</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sizelocvars</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>linedefined</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>lastlinedefined</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GCObject</name><modifier>*</modifier></type><name>gclist</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>lu_byte</name></type> <name>nups</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>lu_byte</name></type> <name>numparams</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>lu_byte</name></type> <name>is_vararg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>lu_byte</name></type> <name>maxstacksize</name></decl>;</decl_stmt>
}</block></struct></type><name>Proto</name>;</typedef>
<typedef>typedef <type><struct>struct <name>LocVar</name><block>{
<decl_stmt><decl><type><name>TString</name><modifier>*</modifier></type><name>varname</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>startpc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>endpc</name></decl>;</decl_stmt>
}</block></struct></type><name>LocVar</name>;</typedef>
<typedef>typedef <type><struct>struct <name>UpVal</name><block>{
<decl_stmt><decl><type><name>GCObject</name><modifier>*</modifier></type><name>next</name></decl>;</decl_stmt><decl_stmt><decl><type><name>lu_byte</name></type> <name>tt</name></decl>;</decl_stmt><decl_stmt><decl><type><name>lu_byte</name></type> <name>marked</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TValue</name><modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
<union>union<block>{
<decl_stmt><decl><type><name>TValue</name></type> <name>value</name></decl>;</decl_stmt>
<struct>struct<block>{
<decl_stmt><decl><type><name><name>struct</name> <name>UpVal</name></name><modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>UpVal</name></name><modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
}</block><decl><name>l</name></decl>;</struct>
}</block><decl><name>u</name></decl>;</union>
}</block></struct></type><name>UpVal</name>;</typedef>
<typedef>typedef <type><struct>struct <name>CClosure</name><block>{
<decl_stmt><decl><type><name>GCObject</name><modifier>*</modifier></type><name>next</name></decl>;</decl_stmt><decl_stmt><decl><type><name>lu_byte</name></type> <name>tt</name></decl>;</decl_stmt><decl_stmt><decl><type><name>lu_byte</name></type> <name>marked</name></decl>;</decl_stmt><decl_stmt><decl><type><name>lu_byte</name></type> <name>isC</name></decl>;</decl_stmt><decl_stmt><decl><type><name>lu_byte</name></type> <name>nupvalues</name></decl>;</decl_stmt><decl_stmt><decl><type><name>GCObject</name><modifier>*</modifier></type><name>gclist</name></decl>;</decl_stmt><decl_stmt><decl><type><name><name>struct</name> <name>Table</name></name><modifier>*</modifier></type><name>env</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>lua_CFunction</name></type> <name>f</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TValue</name></type> <name><name>upvalue</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type><name>CClosure</name>;</typedef>
<typedef>typedef <type><struct>struct <name>LClosure</name><block>{
<decl_stmt><decl><type><name>GCObject</name><modifier>*</modifier></type><name>next</name></decl>;</decl_stmt><decl_stmt><decl><type><name>lu_byte</name></type> <name>tt</name></decl>;</decl_stmt><decl_stmt><decl><type><name>lu_byte</name></type> <name>marked</name></decl>;</decl_stmt><decl_stmt><decl><type><name>lu_byte</name></type> <name>isC</name></decl>;</decl_stmt><decl_stmt><decl><type><name>lu_byte</name></type> <name>nupvalues</name></decl>;</decl_stmt><decl_stmt><decl><type><name>GCObject</name><modifier>*</modifier></type><name>gclist</name></decl>;</decl_stmt><decl_stmt><decl><type><name><name>struct</name> <name>Table</name></name><modifier>*</modifier></type><name>env</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>Proto</name></name><modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UpVal</name><modifier>*</modifier></type><name><name>upvals</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type><name>LClosure</name>;</typedef>
<typedef>typedef <type><union>union <name>Closure</name><block>{
<decl_stmt><decl><type><name>CClosure</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LClosure</name></type> <name>l</name></decl>;</decl_stmt>
}</block></union></type><name>Closure</name>;</typedef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>iscfunction</name><parameter_list>(<parameter><type><name>o</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(ttype(o)==6&amp;&amp;clvalue(o)-&gt;c.isC)</cpp:value></cpp:define>
<typedef>typedef <type><union>union <name>TKey</name><block>{
<struct>struct<block>{
<decl_stmt><decl><type><name>Value</name></type> <name>value</name></decl>;</decl_stmt><decl_stmt><decl><type><name>int</name></type> <name>tt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>Node</name></name><modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
}</block><decl><name>nk</name></decl>;</struct>
<decl_stmt><decl><type><name>TValue</name></type> <name>tvk</name></decl>;</decl_stmt>
}</block></union></type><name>TKey</name>;</typedef>
<typedef>typedef <type><struct>struct <name>Node</name><block>{
<decl_stmt><decl><type><name>TValue</name></type> <name>i_val</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TKey</name></type> <name>i_key</name></decl>;</decl_stmt>
}</block></struct></type><name>Node</name>;</typedef>
<typedef>typedef <type><struct>struct <name>Table</name><block>{
<decl_stmt><decl><type><name>GCObject</name><modifier>*</modifier></type><name>next</name></decl>;</decl_stmt><decl_stmt><decl><type><name>lu_byte</name></type> <name>tt</name></decl>;</decl_stmt><decl_stmt><decl><type><name>lu_byte</name></type> <name>marked</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>lu_byte</name></type> <name>flags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>lu_byte</name></type> <name>lsizenode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>Table</name></name><modifier>*</modifier></type><name>metatable</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TValue</name><modifier>*</modifier></type><name>array</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type><name>lastfree</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GCObject</name><modifier>*</modifier></type><name>gclist</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sizearray</name></decl>;</decl_stmt>
}</block></struct></type><name>Table</name>;</typedef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lmod</name><parameter_list>(<parameter><type><name>s</name></type></parameter>,<parameter><type><name>size</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(check_exp((size&amp;(size-1))==0,(cast(int,(s)&amp;((size)-1)))))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>twoto</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((size_t)1&lt;&lt;(x))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>sizenode</name><parameter_list>(<parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(twoto((t)-&gt;lsizenode))</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>TValue</name></type> <name>luaO_nilobject_</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ceillog2</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(luaO_log2((x)-1)+1)</cpp:value></cpp:define>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>luaO_log2</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>x</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>gfasttm</name><parameter_list>(<parameter><type><name>g</name></type></parameter>,<parameter><type><name>et</name></type></parameter>,<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((et)==NULL?NULL:((et)-&gt;flags&amp;(1u&lt;&lt;(e)))?NULL:luaT_gettm(et,e,(g)-&gt;tmname[e]))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>fasttm</name><parameter_list>(<parameter><type><name>l</name></type></parameter>,<parameter><type><name>et</name></type></parameter>,<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>gfasttm(G(l),et,e)</cpp:value></cpp:define>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>luaT_gettm</name><parameter_list>(<parameter><decl><type><name>Table</name><modifier>*</modifier></type><name>events</name></decl></parameter>,<parameter><decl><type><name>TMS</name></type> <name>event</name></decl></parameter>,<parameter><decl><type><name>TString</name><modifier>*</modifier></type><name>ename</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>luaM_reallocv</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>on</name></type></parameter>,<parameter><type><name>n</name></type></parameter>,<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((cast(size_t,(n)+1)&lt;=((size_t)(~(size_t)0)-2)/(e))?luaM_realloc_(L,(b),(on)*(e),(n)*(e)):luaM_toobig(L))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>luaM_freemem</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>luaM_realloc_(L,(b),(s),0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>luaM_free</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>luaM_realloc_(L,(b),sizeof(*(b)),0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>luaM_freearray</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>n</name></type></parameter>,<parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>luaM_reallocv(L,(b),n,0,sizeof(t))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>luaM_malloc</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>luaM_realloc_(L,NULL,0,(t))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>luaM_new</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>cast(t*,luaM_malloc(L,sizeof(t)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>luaM_newvector</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>n</name></type></parameter>,<parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>cast(t*,luaM_reallocv(L,NULL,0,n,sizeof(t)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>luaM_growvector</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>v</name></type></parameter>,<parameter><type><name>nelems</name></type></parameter>,<parameter><type><name>size</name></type></parameter>,<parameter><type><name>t</name></type></parameter>,<parameter><type><name>limit</name></type></parameter>,<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>if((nelems)+1&gt;(size))((v)=cast(t*,luaM_growaux_(L,v,&amp;(size),sizeof(t),limit,e)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>luaM_reallocvector</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>v</name></type></parameter>,<parameter><type><name>oldn</name></type></parameter>,<parameter><type><name>n</name></type></parameter>,<parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((v)=cast(t*,luaM_reallocv(L,v,oldn,n,sizeof(t))))</cpp:value></cpp:define>
<function_decl><type><specifier>static</specifier> <name>void</name><modifier>*</modifier></type><name>luaM_realloc_</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>void</name><modifier>*</modifier></type><name>block</name></decl></parameter>,<parameter><decl><type><name>size_t</name></type> <name>oldsize</name></decl></parameter>,
<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name><modifier>*</modifier></type><name>luaM_toobig</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name><modifier>*</modifier></type><name>luaM_growaux_</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>void</name><modifier>*</modifier></type><name>block</name></decl></parameter>,<parameter><decl><type><name>int</name><modifier>*</modifier></type><name>size</name></decl></parameter>,
<parameter><decl><type><name>size_t</name></type> <name>size_elem</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>limit</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>errormsg</name></decl></parameter>)</parameter_list>;</function_decl>
<typedef>typedef <type><name><name>struct</name> <name>Zio</name></name></type> <name>ZIO</name>;</typedef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>char2int</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>cast(int,cast(unsigned char,(c)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>zgetc</name><parameter_list>(<parameter><type><name>z</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(((z)-&gt;n--)&gt;0?char2int(*(z)-&gt;p++):luaZ_fill(z))</cpp:value></cpp:define>
<typedef>typedef <type><struct>struct <name>Mbuffer</name><block>{
<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type><name>buffer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>buffsize</name></decl>;</decl_stmt>
}</block></struct></type><name>Mbuffer</name>;</typedef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>luaZ_initbuffer</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>buff</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((buff)-&gt;buffer=NULL,(buff)-&gt;buffsize=0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>luaZ_buffer</name><parameter_list>(<parameter><type><name>buff</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((buff)-&gt;buffer)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>luaZ_sizebuffer</name><parameter_list>(<parameter><type><name>buff</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((buff)-&gt;buffsize)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>luaZ_bufflen</name><parameter_list>(<parameter><type><name>buff</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((buff)-&gt;n)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>luaZ_resetbuffer</name><parameter_list>(<parameter><type><name>buff</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((buff)-&gt;n=0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>luaZ_resizebuffer</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>buff</name></type></parameter>,<parameter><type><name>size</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(luaM_reallocvector(L,(buff)-&gt;buffer,(buff)-&gt;buffsize,size,char),(buff)-&gt;buffsize=size)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>luaZ_freebuffer</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>buff</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>luaZ_resizebuffer(L,buff,0)</cpp:value></cpp:define>
<struct>struct <name>Zio</name><block>{
<decl_stmt><decl><type><name>size_t</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>lua_Reader</name></type> <name>reader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name><modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl>;</decl_stmt>
}</block>;</struct>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>luaZ_fill</name><parameter_list>(<parameter><decl><type><name>ZIO</name><modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list>;</function_decl>
<struct_decl>struct <name>lua_longjmp</name>;</struct_decl>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>gt</name><parameter_list>(<parameter><type><name>L</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(&amp;L-&gt;l_gt)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>registry</name><parameter_list>(<parameter><type><name>L</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(&amp;G(L)-&gt;l_registry)</cpp:value></cpp:define>
<typedef>typedef <type><struct>struct <name>stringtable</name><block>{
<decl_stmt><decl><type><name>GCObject</name><modifier>*</modifier><modifier>*</modifier></type><name>hash</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>lu_int32</name></type> <name>nuse</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>size</name></decl>;</decl_stmt>
}</block></struct></type><name>stringtable</name>;</typedef>
<typedef>typedef <type><struct>struct <name>CallInfo</name><block>{
<decl_stmt><decl><type><name>StkId</name></type> <name>base</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>StkId</name></type> <name>func</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>StkId</name></type> <name>top</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Instruction</name><modifier>*</modifier></type><name>savedpc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nresults</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tailcalls</name></decl>;</decl_stmt>
}</block></struct></type><name>CallInfo</name>;</typedef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>curr_func</name><parameter_list>(<parameter><type><name>L</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(clvalue(L-&gt;ci-&gt;func))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ci_func</name><parameter_list>(<parameter><type><name>ci</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(clvalue((ci)-&gt;func))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>f_isLua</name><parameter_list>(<parameter><type><name>ci</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(!ci_func(ci)-&gt;c.isC)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>isLua</name><parameter_list>(<parameter><type><name>ci</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(ttisfunction((ci)-&gt;func)&amp;&amp;f_isLua(ci))</cpp:value></cpp:define>
<typedef>typedef <type><struct>struct <name>global_State</name><block>{
<decl_stmt><decl><type><name>stringtable</name></type> <name>strt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>lua_Alloc</name></type> <name>frealloc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name><modifier>*</modifier></type><name>ud</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>lu_byte</name></type> <name>currentwhite</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>lu_byte</name></type> <name>gcstate</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sweepstrgc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GCObject</name><modifier>*</modifier></type><name>rootgc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GCObject</name><modifier>*</modifier><modifier>*</modifier></type><name>sweepgc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GCObject</name><modifier>*</modifier></type><name>gray</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GCObject</name><modifier>*</modifier></type><name>grayagain</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GCObject</name><modifier>*</modifier></type><name>weak</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GCObject</name><modifier>*</modifier></type><name>tmudata</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Mbuffer</name></type> <name>buff</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>lu_mem</name></type> <name>GCthreshold</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>lu_mem</name></type> <name>totalbytes</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>lu_mem</name></type> <name>estimate</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>lu_mem</name></type> <name>gcdept</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>gcpause</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>gcstepmul</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>lua_CFunction</name></type> <name>panic</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TValue</name></type> <name>l_registry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>lua_State</name></name><modifier>*</modifier></type><name>mainthread</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UpVal</name></type> <name>uvhead</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>Table</name></name><modifier>*</modifier></type><name><name>mt</name><index>[<expr><operator>(</operator><literal type="number">8</literal><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TString</name><modifier>*</modifier></type><name><name>tmname</name><index>[<expr><name>TM_N</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type><name>global_State</name>;</typedef>
<struct>struct <name>lua_State</name><block>{
<decl_stmt><decl><type><name>GCObject</name><modifier>*</modifier></type><name>next</name></decl>;</decl_stmt><decl_stmt><decl><type><name>lu_byte</name></type> <name>tt</name></decl>;</decl_stmt><decl_stmt><decl><type><name>lu_byte</name></type> <name>marked</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>lu_byte</name></type> <name>status</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>StkId</name></type> <name>top</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>StkId</name></type> <name>base</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>global_State</name><modifier>*</modifier></type><name>l_G</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CallInfo</name><modifier>*</modifier></type><name>ci</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Instruction</name><modifier>*</modifier></type><name>savedpc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>StkId</name></type> <name>stack_last</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>StkId</name></type> <name>stack</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CallInfo</name><modifier>*</modifier></type><name>end_ci</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CallInfo</name><modifier>*</modifier></type><name>base_ci</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>stacksize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>size_ci</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>nCcalls</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>baseCcalls</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>lu_byte</name></type> <name>hookmask</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>lu_byte</name></type> <name>allowhook</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>basehookcount</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>hookcount</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>lua_Hook</name></type> <name>hook</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TValue</name></type> <name>l_gt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TValue</name></type> <name>env</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GCObject</name><modifier>*</modifier></type><name>openupval</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GCObject</name><modifier>*</modifier></type><name>gclist</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>lua_longjmp</name></name><modifier>*</modifier></type><name>errorJmp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>errfunc</name></decl>;</decl_stmt>
}</block>;</struct>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>G</name><parameter_list>(<parameter><type><name>L</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(L-&gt;l_G)</cpp:value></cpp:define>
<union>union <name>GCObject</name><block>{
<decl_stmt><decl><type><name>GCheader</name></type> <name>gch</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>union</name> <name>TString</name></name></type> <name>ts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>union</name> <name>Udata</name></name></type> <name>u</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>union</name> <name>Closure</name></name></type> <name>cl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>Table</name></name></type> <name>h</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>Proto</name></name></type> <name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>UpVal</name></name></type> <name>uv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>lua_State</name></name></type> <name>th</name></decl>;</decl_stmt>
}</block>;</union>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rawgco2ts</name><parameter_list>(<parameter><type><name>o</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>check_exp((o)-&gt;gch.tt==4,&amp;((o)-&gt;ts))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>gco2ts</name><parameter_list>(<parameter><type><name>o</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(&amp;rawgco2ts(o)-&gt;tsv)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rawgco2u</name><parameter_list>(<parameter><type><name>o</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>check_exp((o)-&gt;gch.tt==7,&amp;((o)-&gt;u))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>gco2u</name><parameter_list>(<parameter><type><name>o</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(&amp;rawgco2u(o)-&gt;uv)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>gco2cl</name><parameter_list>(<parameter><type><name>o</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>check_exp((o)-&gt;gch.tt==6,&amp;((o)-&gt;cl))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>gco2h</name><parameter_list>(<parameter><type><name>o</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>check_exp((o)-&gt;gch.tt==5,&amp;((o)-&gt;h))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>gco2p</name><parameter_list>(<parameter><type><name>o</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>check_exp((o)-&gt;gch.tt==(8+1),&amp;((o)-&gt;p))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>gco2uv</name><parameter_list>(<parameter><type><name>o</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>check_exp((o)-&gt;gch.tt==(8+2),&amp;((o)-&gt;uv))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ngcotouv</name><parameter_list>(<parameter><type><name>o</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>check_exp((o)==NULL||(o)-&gt;gch.tt==(8+2),&amp;((o)-&gt;uv))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>gco2th</name><parameter_list>(<parameter><type><name>o</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>check_exp((o)-&gt;gch.tt==8,&amp;((o)-&gt;th))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>obj2gco</name><parameter_list>(<parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(cast(GCObject*,(v)))</cpp:value></cpp:define>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>luaE_freethread</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L1</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pcRel</name><parameter_list>(<parameter><type><name>pc</name></type></parameter>,<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(cast(int,(pc)-(p)-&gt;code)-1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>getline_</name><parameter_list>(<parameter><type><name>f</name></type></parameter>,<parameter><type><name>pc</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(((f)-&gt;lineinfo)?(f)-&gt;lineinfo[pc]:0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>resethookcount</name><parameter_list>(<parameter><type><name>L</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(L-&gt;hookcount=L-&gt;basehookcount)</cpp:value></cpp:define>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>luaG_typeerror</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>o</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>opname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>luaG_runerror</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>luaD_checkstack</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>if((char*)L-&gt;stack_last-(char*)L-&gt;top&lt;=(n)*(int)sizeof(TValue))luaD_growstack(L,n);else condhardstacktests(luaD_reallocstack(L,L-&gt;stacksize-5-1));</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>incr_top</name><parameter_list>(<parameter><type><name>L</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>{luaD_checkstack(L,1);L-&gt;top++;}</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>savestack</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((char*)(p)-(char*)L-&gt;stack)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>restorestack</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((TValue*)((char*)L-&gt;stack+(n)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>saveci</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((char*)(p)-(char*)L-&gt;base_ci)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>restoreci</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((CallInfo*)((char*)L-&gt;base_ci+(n)))</cpp:value></cpp:define>
<typedef>typedef <function_decl><type><name>void</name></type>(<modifier>*</modifier><name>Pfunc</name>)<parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>void</name><modifier>*</modifier></type><name>ud</name></decl></parameter>)</parameter_list>;</function_decl></typedef>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>luaD_poscall</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>StkId</name></type> <name>firstResult</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>luaD_reallocCI</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>newsize</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>luaD_reallocstack</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>newsize</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>luaD_growstack</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>luaD_throw</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>errcode</name></decl></parameter>)</parameter_list>;</function_decl>
<function><type><specifier>static</specifier> <name>void</name><modifier>*</modifier></type><name>luaM_growaux_</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>void</name><modifier>*</modifier></type><name>block</name></decl></parameter>,<parameter><decl><type><name>int</name><modifier>*</modifier></type><name>size</name></decl></parameter>,<parameter><decl><type><name>size_t</name></type> <name>size_elems</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>limit</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>errormsg</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>void</name><modifier>*</modifier></type><name>newblock</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>newsize</name></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><operator>*</operator><name>size</name><operator>&gt;=</operator><name>limit</name><operator>/</operator><literal type="number">2</literal></expr>)</condition><block>{<block_content>
<if_stmt><if>if<condition>(<expr><operator>*</operator><name>size</name><operator>&gt;=</operator><name>limit</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaG_runerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>errormsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>newsize</name><operator>=</operator><name>limit</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block>{<block_content>
<expr_stmt><expr><name>newsize</name><operator>=</operator><operator>(</operator><operator>*</operator><name>size</name><operator>)</operator><operator>*</operator><literal type="number">2</literal></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>newsize</name><operator>&lt;</operator><literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>newsize</name><operator>=</operator><literal type="number">4</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>newblock</name><operator>=</operator><call><name>luaM_reallocv</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>block</name></expr></argument>,<argument><expr><operator>*</operator><name>size</name></expr></argument>,<argument><expr><name>newsize</name></expr></argument>,<argument><expr><name>size_elems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>size</name><operator>=</operator><name>newsize</name></expr>;</expr_stmt>
<return>return <expr><name>newblock</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name><modifier>*</modifier></type><name>luaM_toobig</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>luaG_runerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"memory allocation error: block too big"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name><modifier>*</modifier></type><name>luaM_realloc_</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>void</name><modifier>*</modifier></type><name>block</name></decl></parameter>,<parameter><decl><type><name>size_t</name></type> <name>osize</name></decl></parameter>,<parameter><decl><type><name>size_t</name></type> <name>nsize</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>global_State</name><modifier>*</modifier></type><name>g</name><init>=<expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>block</name><operator>=</operator><call>(<modifier>*</modifier><name><name>g</name><operator>-&gt;</operator><name>frealloc</name></name>)<argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>ud</name></name></expr></argument>,<argument><expr><name>block</name></expr></argument>,<argument><expr><name>osize</name></expr></argument>,<argument><expr><name>nsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>block</name><operator>==</operator><name>NULL</name><operator>&amp;&amp;</operator><name>nsize</name><operator>&gt;</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaD_throw</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>totalbytes</name></name><operator>=</operator><operator>(</operator><name><name>g</name><operator>-&gt;</operator><name>totalbytes</name></name><operator>-</operator><name>osize</name><operator>)</operator><operator>+</operator><name>nsize</name></expr>;</expr_stmt>
<return>return <expr><name>block</name></expr>;</return>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>resetbits</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>m</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((x)&amp;=cast(lu_byte,~(m)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>setbits</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>m</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((x)|=(m))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>testbits</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>m</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((x)&amp;(m))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>bitmask</name><parameter_list>(<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(1&lt;&lt;(b))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>bit2mask</name><parameter_list>(<parameter><type><name>b1</name></type></parameter>,<parameter><type><name>b2</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(bitmask(b1)|bitmask(b2))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>l_setbit</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>setbits(x,bitmask(b))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>resetbit</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>resetbits(x,bitmask(b))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>testbit</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>testbits(x,bitmask(b))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>set2bits</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>b1</name></type></parameter>,<parameter><type><name>b2</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>setbits(x,(bit2mask(b1,b2)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>reset2bits</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>b1</name></type></parameter>,<parameter><type><name>b2</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>resetbits(x,(bit2mask(b1,b2)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>test2bits</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>b1</name></type></parameter>,<parameter><type><name>b2</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>testbits(x,(bit2mask(b1,b2)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>iswhite</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>test2bits((x)-&gt;gch.marked,0,1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>isblack</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>testbit((x)-&gt;gch.marked,2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>isgray</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(!isblack(x)&amp;&amp;!iswhite(x))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>otherwhite</name><parameter_list>(<parameter><type><name>g</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(g-&gt;currentwhite^bit2mask(0,1))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>isdead</name><parameter_list>(<parameter><type><name>g</name></type></parameter>,<parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((v)-&gt;gch.marked&amp;otherwhite(g)&amp;bit2mask(0,1))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>changewhite</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((x)-&gt;gch.marked^=bit2mask(0,1))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>gray2black</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>l_setbit((x)-&gt;gch.marked,2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>valiswhite</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(iscollectable(x)&amp;&amp;iswhite(gcvalue(x)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>luaC_white</name><parameter_list>(<parameter><type><name>g</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>cast(lu_byte,(g)-&gt;currentwhite&amp;bit2mask(0,1))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>luaC_checkGC</name><parameter_list>(<parameter><type><name>L</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>{condhardstacktests(luaD_reallocstack(L,L-&gt;stacksize-5-1));if(G(L)-&gt;totalbytes&gt;=G(L)-&gt;GCthreshold)luaC_step(L);}</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>luaC_barrier</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>p</name></type></parameter>,<parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>{if(valiswhite(v)&amp;&amp;isblack(obj2gco(p)))luaC_barrierf(L,obj2gco(p),gcvalue(v));}</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>luaC_barriert</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>t</name></type></parameter>,<parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>{if(valiswhite(v)&amp;&amp;isblack(obj2gco(t)))luaC_barrierback(L,t);}</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>luaC_objbarrier</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>p</name></type></parameter>,<parameter><type><name>o</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>{if(iswhite(obj2gco(o))&amp;&amp;isblack(obj2gco(p)))luaC_barrierf(L,obj2gco(p),obj2gco(o));}</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>luaC_objbarriert</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>t</name></type></parameter>,<parameter><type><name>o</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>{if(iswhite(obj2gco(o))&amp;&amp;isblack(obj2gco(t)))luaC_barrierback(L,t);}</cpp:value></cpp:define>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>luaC_step</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>luaC_link</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>GCObject</name><modifier>*</modifier></type><name>o</name></decl></parameter>,<parameter><decl><type><name>lu_byte</name></type> <name>tt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>luaC_linkupval</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>UpVal</name><modifier>*</modifier></type><name>uv</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>luaC_barrierf</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>GCObject</name><modifier>*</modifier></type><name>o</name></decl></parameter>,<parameter><decl><type><name>GCObject</name><modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>luaC_barrierback</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>Table</name><modifier>*</modifier></type><name>t</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>sizestring</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(sizeof(union TString)+((s)-&gt;len+1)*sizeof(char))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>sizeudata</name><parameter_list>(<parameter><type><name>u</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(sizeof(union Udata)+(u)-&gt;len)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>luaS_new</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(luaS_newlstr(L,s,strlen(s)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>luaS_newliteral</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(luaS_newlstr(L,""s,(sizeof(s)/sizeof(char))-1))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>luaS_fix</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>l_setbit((s)-&gt;tsv.marked,5)</cpp:value></cpp:define>
<function_decl><type><specifier>static</specifier> <name>TString</name><modifier>*</modifier></type><name>luaS_newlstr</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>str</name></decl></parameter>,<parameter><decl><type><name>size_t</name></type> <name>l</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>tostring</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>o</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((ttype(o)==4)||(luaV_tostring(L,o)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>tonumber</name><parameter_list>(<parameter><type><name>o</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(ttype(o)==3||(((o)=luaV_tonumber(o,n))!=NULL))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>equalobj</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>o1</name></type></parameter>,<parameter><type><name>o2</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(ttype(o1)==ttype(o2)&amp;&amp;luaV_equalval(L,o1,o2))</cpp:value></cpp:define>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>luaV_equalval</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>t1</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>t2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>luaV_tonumber</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>obj</name></decl></parameter>,<parameter><decl><type><name>TValue</name><modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>luaV_tostring</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>StkId</name></type> <name>obj</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>luaV_execute</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>nexeccalls</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>luaV_concat</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>total</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>last</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>TValue</name></type> <name>luaO_nilobject_</name><init>=<expr><block>{<expr><block>{<expr><name>NULL</name></expr>}</block></expr>,<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>int</name></type> <name>luaO_int2fb</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>x</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>e</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<while>while<condition>(<expr><name>x</name><operator>&gt;=</operator><literal type="number">16</literal></expr>)</condition><block>{<block_content>
<expr_stmt><expr><name>x</name><operator>=</operator><operator>(</operator><name>x</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>&gt;&gt;</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>e</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if<condition>(<expr><name>x</name><operator>&lt;</operator><literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content><return>return <expr><name>x</name></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content> <return>return<expr><operator>(</operator><operator>(</operator><name>e</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">3</literal><operator>)</operator><operator>|</operator><operator>(</operator><call><name>cast_int</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">8</literal><operator>)</operator></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>luaO_fb2int</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>e</name><init>=<expr><operator>(</operator><name>x</name><operator>&gt;&gt;</operator><literal type="number">3</literal><operator>)</operator><operator>&amp;</operator><literal type="number">31</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>e</name><operator>==</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content><return>return <expr><name>x</name></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content> <return>return<expr><operator>(</operator><operator>(</operator><name>x</name><operator>&amp;</operator><literal type="number">7</literal><operator>)</operator><operator>+</operator><literal type="number">8</literal><operator>)</operator><operator>&lt;&lt;</operator><operator>(</operator><name>e</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>luaO_log2</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>x</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>lu_byte</name></type> <name><name>log_2</name><index>[<expr><literal type="number">256</literal></expr>]</index></name><init>=<expr><block>{
<expr><literal type="number">0</literal></expr>,<expr><literal type="number">1</literal></expr>,<expr><literal type="number">2</literal></expr>,<expr><literal type="number">2</literal></expr>,<expr><literal type="number">3</literal></expr>,<expr><literal type="number">3</literal></expr>,<expr><literal type="number">3</literal></expr>,<expr><literal type="number">3</literal></expr>,<expr><literal type="number">4</literal></expr>,<expr><literal type="number">4</literal></expr>,<expr><literal type="number">4</literal></expr>,<expr><literal type="number">4</literal></expr>,<expr><literal type="number">4</literal></expr>,<expr><literal type="number">4</literal></expr>,<expr><literal type="number">4</literal></expr>,<expr><literal type="number">4</literal></expr>,<expr><literal type="number">5</literal></expr>,<expr><literal type="number">5</literal></expr>,<expr><literal type="number">5</literal></expr>,<expr><literal type="number">5</literal></expr>,<expr><literal type="number">5</literal></expr>,<expr><literal type="number">5</literal></expr>,<expr><literal type="number">5</literal></expr>,<expr><literal type="number">5</literal></expr>,<expr><literal type="number">5</literal></expr>,<expr><literal type="number">5</literal></expr>,<expr><literal type="number">5</literal></expr>,<expr><literal type="number">5</literal></expr>,<expr><literal type="number">5</literal></expr>,<expr><literal type="number">5</literal></expr>,<expr><literal type="number">5</literal></expr>,<expr><literal type="number">5</literal></expr>,
<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,
<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,
<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,
<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,
<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,
<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,
<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>l</name><init>=<expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<while>while<condition>(<expr><name>x</name><operator>&gt;=</operator><literal type="number">256</literal></expr>)</condition><block>{<block_content><expr_stmt><expr><name>l</name><operator>+=</operator><literal type="number">8</literal></expr>;</expr_stmt><expr_stmt><expr><name>x</name><operator>&gt;&gt;=</operator><literal type="number">8</literal></expr>;</expr_stmt></block_content>}</block></while>
<return>return <expr><name>l</name><operator>+</operator><name><name>log_2</name><index>[<expr><name>x</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>luaO_rawequalObj</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>t1</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>t2</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><call><name>ttype</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call><operator>!=</operator><call><name>ttype</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content><return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content> <switch>switch<condition>(<expr><call><name>ttype</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case>
<return>return <expr><literal type="number">1</literal></expr>;</return>
<case>case <expr><literal type="number">3</literal></expr>:</case>
<return>return <expr><call><name>luai_numeq</name><argument_list>(<argument><expr><call><name>nvalue</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>nvalue</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><literal type="number">1</literal></expr>:</case>
<return>return <expr><call><name>bvalue</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call><operator>==</operator><call><name>bvalue</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><literal type="number">2</literal></expr>:</case>
<return>return <expr><call><name>pvalue</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call><operator>==</operator><call><name>pvalue</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</return>
<default>default:</default>
<return>return <expr><call><name>gcvalue</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call><operator>==</operator><call><name>gcvalue</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></switch></block_content></block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>luaO_str2d</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>s</name></decl></parameter>,<parameter><decl><type><name>lua_Number</name><modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>result</name><operator>=</operator><call><name>lua_str2number</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>endptr</name><operator>==</operator><name>s</name></expr>)</condition><block type="pseudo"><block_content><return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><operator>*</operator><name>endptr</name><operator>==</operator><literal type="char">'x'</literal><operator>||</operator><operator>*</operator><name>endptr</name><operator>==</operator><literal type="char">'X'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>result</name><operator>=</operator><call><name>cast_num</name><argument_list>(<argument><expr><call><name>strtoul</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>,<argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><operator>*</operator><name>endptr</name><operator>==</operator><literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content><return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<while>while<condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><macro><name>cast</name><argument_list>(<argument>unsigned char</argument>,<argument>*endptr</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><name>endptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
<if_stmt><if>if<condition>(<expr><operator>*</operator><name>endptr</name><operator>!=</operator><literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content><return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>pushstr</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>setsvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>,<argument><expr><call><name>luaS_new</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>incr_top</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>luaO_pushvfstring</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><name>va_list</name></type> <name>argp</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>n</name><init>=<expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>pushstr</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>e</name><init>=<expr><call><name>strchr</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>,<argument><expr><literal type="char">'%'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>e</name><operator>==</operator><name>NULL</name></expr>)</condition><block type="pseudo"><block_content><break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>setsvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>,<argument><expr><call><name>luaS_newlstr</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>fmt</name></expr></argument>,<argument><expr><name>e</name><operator>-</operator><name>fmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>incr_top</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch<condition>(<expr><operator>*</operator><operator>(</operator><name>e</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition><block>{<block_content>
<case>case<expr><literal type="char">'s'</literal></expr>:</case><block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>s</name><init>=<expr><call><name>va_arg</name><argument_list>(<argument><expr><name>argp</name></expr></argument>,<argument><expr><name>char</name><operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>s</name><operator>==</operator><name>NULL</name></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><name>s</name><operator>=</operator><literal type="string">"(null)"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>pushstr</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case<expr><literal type="char">'c'</literal></expr>:</case><block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>buff</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>buff</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>=</operator><call><name>cast</name><argument_list>(<argument><expr><name>char</name></expr></argument>,<argument><expr><call><name>va_arg</name><argument_list>(<argument><expr><name>argp</name></expr></argument>,<argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buff</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>=</operator><literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pushstr</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case<expr><literal type="char">'d'</literal></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>setnvalue</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>,<argument><expr><call><name>cast_num</name><argument_list>(<argument><expr><call><name>va_arg</name><argument_list>(<argument><expr><name>argp</name></expr></argument>,<argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>incr_top</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case<expr><literal type="char">'f'</literal></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>setnvalue</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>,<argument><expr><call><name>cast_num</name><argument_list>(<argument><expr><call><name>va_arg</name><argument_list>(<argument><expr><name>argp</name></expr></argument>,<argument><expr><name>l_uacNumber</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>incr_top</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case<expr><literal type="char">'p'</literal></expr>:</case><block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>buff</name><index>[<expr><literal type="number">4</literal><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>+</operator><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buff</name></expr></argument>,<argument><expr><literal type="string">"%p"</literal></expr></argument>,<argument><expr><call><name>va_arg</name><argument_list>(<argument><expr><name>argp</name></expr></argument>,<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pushstr</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case<expr><literal type="char">'%'</literal></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>pushstr</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"%"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<default>default:</default><block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>buff</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>buff</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>=</operator><literal type="char">'%'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buff</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>=</operator><operator>*</operator><operator>(</operator><name>e</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buff</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>=</operator><literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pushstr</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
</block_content>}</block></switch>
<expr_stmt><expr><name>n</name><operator>+=</operator><literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>fmt</name><operator>=</operator><name>e</name><operator>+</operator><literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>pushstr</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaV_concat</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>n</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><call><name>cast_int</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><name><name>L</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-=</operator><name>n</name></expr>;</expr_stmt>
<return>return <expr><call><name>svalue</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>luaO_pushfstring</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>msg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>va_list</name></type> <name>argp</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>argp</name></expr></argument>,<argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>msg</name><operator>=</operator><call><name>luaO_pushvfstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>fmt</name></expr></argument>,<argument><expr><name>argp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>argp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>msg</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaO_chunkid</name><parameter_list>(<parameter><decl><type><name>char</name><modifier>*</modifier></type><name>out</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>source</name></decl></parameter>,<parameter><decl><type><name>size_t</name></type> <name>bufflen</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><operator>*</operator><name>source</name><operator>==</operator><literal type="char">'='</literal></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><name>source</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>bufflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>out</name><index>[<expr><name>bufflen</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>=</operator><literal type="char">'\0'</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block>{<block_content>
<if_stmt><if>if<condition>(<expr><operator>*</operator><name>source</name><operator>==</operator><literal type="char">'@'</literal></expr>)</condition><block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>l</name></decl>;</decl_stmt>
<expr_stmt><expr><name>source</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>bufflen</name><operator>-=</operator><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">" '...' "</literal></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name>l</name><operator>=</operator><call><name>strlen</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>l</name><operator>&gt;</operator><name>bufflen</name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><name>source</name><operator>+=</operator><operator>(</operator><name>l</name><operator>-</operator><name>bufflen</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name><init>=<expr><call><name>strcspn</name><argument_list>(<argument><expr><name>source</name></expr></argument>,<argument><expr><literal type="string">"\n\r"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>bufflen</name><operator>-=</operator><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">" [string \"...\"] "</literal></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>len</name><operator>&gt;</operator><name>bufflen</name></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><name>len</name><operator>=</operator><name>bufflen</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"[string \""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name><name>source</name><index>[<expr><name>len</name></expr>]</index></name><operator>!=</operator><literal type="char">'\0'</literal></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>strncat</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><name>source</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr><literal type="string">"\"]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>gnode</name><parameter_list>(<parameter><type><name>t</name></type></parameter>,<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(&amp;(t)-&gt;node[i])</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>gkey</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(&amp;(n)-&gt;i_key.nk)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>gval</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(&amp;(n)-&gt;i_val)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>gnext</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((n)-&gt;i_key.nk.next)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>key2tval</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(&amp;(n)-&gt;i_key.tvk)</cpp:value></cpp:define>
<function_decl><type><specifier>static</specifier> <name>TValue</name><modifier>*</modifier></type><name>luaH_setnum</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>Table</name><modifier>*</modifier></type><name>t</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>key</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>luaH_getstr</name><parameter_list>(<parameter><decl><type><name>Table</name><modifier>*</modifier></type><name>t</name></decl></parameter>,<parameter><decl><type><name>TString</name><modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TValue</name><modifier>*</modifier></type><name>luaH_set</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>Table</name><modifier>*</modifier></type><name>t</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name><modifier>*</modifier><specifier>const</specifier></type> <name><name>luaT_typenames</name><index>[]</index></name><init>=<expr><block>{
<expr><literal type="string">"nil"</literal></expr>,<expr><literal type="string">"boolean"</literal></expr>,<expr><literal type="string">"userdata"</literal></expr>,<expr><literal type="string">"number"</literal></expr>,
<expr><literal type="string">"string"</literal></expr>,<expr><literal type="string">"table"</literal></expr>,<expr><literal type="string">"function"</literal></expr>,<expr><literal type="string">"userdata"</literal></expr>,<expr><literal type="string">"thread"</literal></expr>,
<expr><literal type="string">"proto"</literal></expr>,<expr><literal type="string">"upval"</literal></expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaT_init</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name><modifier>*</modifier><specifier>const</specifier></type> <name><name>luaT_eventname</name><index>[]</index></name><init>=<expr><block>{
<expr><literal type="string">"__index"</literal></expr>,<expr><literal type="string">"__newindex"</literal></expr>,
<expr><literal type="string">"__gc"</literal></expr>,<expr><literal type="string">"__mode"</literal></expr>,<expr><literal type="string">"__eq"</literal></expr>,
<expr><literal type="string">"__add"</literal></expr>,<expr><literal type="string">"__sub"</literal></expr>,<expr><literal type="string">"__mul"</literal></expr>,<expr><literal type="string">"__div"</literal></expr>,<expr><literal type="string">"__mod"</literal></expr>,
<expr><literal type="string">"__pow"</literal></expr>,<expr><literal type="string">"__unm"</literal></expr>,<expr><literal type="string">"__len"</literal></expr>,<expr><literal type="string">"__lt"</literal></expr>,<expr><literal type="string">"__le"</literal></expr>,
<expr><literal type="string">"__concat"</literal></expr>,<expr><literal type="string">"__call"</literal></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init><condition><expr><name>i</name><operator>&lt;</operator><name>TM_N</name></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
<expr_stmt><expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>tmname</name><index>[<expr><name>i</name></expr>]</index></name><operator>=</operator><call><name>luaS_new</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>luaT_eventname</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaS_fix</name><argument_list>(<argument><expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>tmname</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>luaT_gettm</name><parameter_list>(<parameter><decl><type><name>Table</name><modifier>*</modifier></type><name>events</name></decl></parameter>,<parameter><decl><type><name>TMS</name></type> <name>event</name></decl></parameter>,<parameter><decl><type><name>TString</name><modifier>*</modifier></type><name>ename</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>tm</name><init>=<expr><call><name>luaH_getstr</name><argument_list>(<argument><expr><name>events</name></expr></argument>,<argument><expr><name>ename</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><call><name>ttisnil</name><argument_list>(<argument><expr><name>tm</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<expr_stmt><expr><name><name>events</name><operator>-&gt;</operator><name>flags</name></name><operator>|=</operator><call><name>cast_byte</name><argument_list>(<argument><expr><literal type="number">1u</literal><operator>&lt;&lt;</operator><name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content> <return>return <expr><name>tm</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>luaT_gettmbyobj</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>o</name></decl></parameter>,<parameter><decl><type><name>TMS</name></type> <name>event</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>Table</name><modifier>*</modifier></type><name>mt</name></decl>;</decl_stmt>
<switch>switch<condition>(<expr><call><name>ttype</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<case>case <expr><literal type="number">5</literal></expr>:</case>
<expr_stmt><expr><name>mt</name><operator>=</operator><call><name>hvalue</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>metatable</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">7</literal></expr>:</case>
<expr_stmt><expr><name>mt</name><operator>=</operator><call><name>uvalue</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>metatable</name></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><name>mt</name><operator>=</operator><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>mt</name><index>[<expr><call><name>ttype</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></switch>
<return>return<expr><operator>(</operator><ternary><condition><expr><name>mt</name></expr>?</condition><then><expr><call><name>luaH_getstr</name><argument_list>(<argument><expr><name>mt</name></expr></argument>,<argument><expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>tmname</name><index>[<expr><name>event</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></then><else>:<expr><operator>(</operator><operator>&amp;</operator><name>luaO_nilobject_</name><operator>)</operator></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>sizeCclosure</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(cast(int,sizeof(CClosure))+cast(int,sizeof(TValue)*((n)-1)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>sizeLclosure</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(cast(int,sizeof(LClosure))+cast(int,sizeof(TValue*)*((n)-1)))</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>Closure</name><modifier>*</modifier></type><name>luaF_newCclosure</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>nelems</name></decl></parameter>,<parameter><decl><type><name>Table</name><modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>Closure</name><modifier>*</modifier></type><name>c</name><init>=<expr><call><name>cast</name><argument_list>(<argument><expr><name>Closure</name><operator>*</operator></expr></argument>,<argument><expr><call><name>luaM_malloc</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>sizeCclosure</name><argument_list>(<argument><expr><name>nelems</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaC_link</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>obj2gco</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>isC</name></name><operator>=</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>env</name></name><operator>=</operator><name>e</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>nupvalues</name></name><operator>=</operator><call><name>cast_byte</name><argument_list>(<argument><expr><name>nelems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>c</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>Closure</name><modifier>*</modifier></type><name>luaF_newLclosure</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>nelems</name></decl></parameter>,<parameter><decl><type><name>Table</name><modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>Closure</name><modifier>*</modifier></type><name>c</name><init>=<expr><call><name>cast</name><argument_list>(<argument><expr><name>Closure</name><operator>*</operator></expr></argument>,<argument><expr><call><name>luaM_malloc</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>sizeLclosure</name><argument_list>(<argument><expr><name>nelems</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaC_link</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>obj2gco</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>isC</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>env</name></name><operator>=</operator><name>e</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>nupvalues</name></name><operator>=</operator><call><name>cast_byte</name><argument_list>(<argument><expr><name>nelems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while<condition>(<expr><name>nelems</name><operator>--</operator></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>upvals</name><index>[<expr><name>nelems</name></expr>]</index></name><operator>=</operator><name>NULL</name></expr>;</expr_stmt></block_content></block></while>
<return>return <expr><name>c</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>UpVal</name><modifier>*</modifier></type><name>luaF_newupval</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>UpVal</name><modifier>*</modifier></type><name>uv</name><init>=<expr><call><name>luaM_new</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>UpVal</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaC_link</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>obj2gco</name><argument_list>(<argument><expr><name>uv</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><operator>(</operator><literal type="number">8</literal><operator>+</operator><literal type="number">2</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>uv</name><operator>-&gt;</operator><name>v</name></name><operator>=</operator><operator>&amp;</operator><name><name>uv</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>value</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setnilvalue</name><argument_list>(<argument><expr><name><name>uv</name><operator>-&gt;</operator><name>v</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>uv</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>UpVal</name><modifier>*</modifier></type><name>luaF_findupval</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>StkId</name></type> <name>level</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>global_State</name><modifier>*</modifier></type><name>g</name><init>=<expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GCObject</name><modifier>*</modifier><modifier>*</modifier></type><name>pp</name><init>=<expr><operator>&amp;</operator><name><name>L</name><operator>-&gt;</operator><name>openupval</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UpVal</name><modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UpVal</name><modifier>*</modifier></type><name>uv</name></decl>;</decl_stmt>
<while>while<condition>(<expr><operator>*</operator><name>pp</name><operator>!=</operator><name>NULL</name><operator>&amp;&amp;</operator><operator>(</operator><name>p</name><operator>=</operator><call><name>ngcotouv</name><argument_list>(<argument><expr><operator>*</operator><name>pp</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>v</name><operator>&gt;=</operator><name>level</name></expr>)</condition><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>v</name></name><operator>==</operator><name>level</name></expr>)</condition><block>{<block_content>
<if_stmt><if>if<condition>(<expr><call><name>isdead</name><argument_list>(<argument><expr><name>g</name></expr></argument>,<argument><expr><call><name>obj2gco</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>changewhite</name><argument_list>(<argument><expr><call><name>obj2gco</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>pp</name><operator>=</operator><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name>uv</name><operator>=</operator><call><name>luaM_new</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>UpVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>uv</name><operator>-&gt;</operator><name>tt</name></name><operator>=</operator><operator>(</operator><literal type="number">8</literal><operator>+</operator><literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>uv</name><operator>-&gt;</operator><name>marked</name></name><operator>=</operator><call><name>luaC_white</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>uv</name><operator>-&gt;</operator><name>v</name></name><operator>=</operator><name>level</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>uv</name><operator>-&gt;</operator><name>next</name></name><operator>=</operator><operator>*</operator><name>pp</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>pp</name><operator>=</operator><call><name>obj2gco</name><argument_list>(<argument><expr><name>uv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>uv</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>l</name><operator>.</operator><name>prev</name></name><operator>=</operator><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>uvhead</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>uv</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>l</name><operator>.</operator><name>next</name></name><operator>=</operator><name><name>g</name><operator>-&gt;</operator><name>uvhead</name><operator>.</operator><name>u</name><operator>.</operator><name>l</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>uv</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>l</name><operator>.</operator><name>next</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>l</name><operator>.</operator><name>prev</name></name><operator>=</operator><name>uv</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>uvhead</name><operator>.</operator><name>u</name><operator>.</operator><name>l</name><operator>.</operator><name>next</name></name><operator>=</operator><name>uv</name></expr>;</expr_stmt>
<return>return <expr><name>uv</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>unlinkupval</name><parameter_list>(<parameter><decl><type><name>UpVal</name><modifier>*</modifier></type><name>uv</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><name><name>uv</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>l</name><operator>.</operator><name>next</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>l</name><operator>.</operator><name>prev</name></name><operator>=</operator><name><name>uv</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>l</name><operator>.</operator><name>prev</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>uv</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>l</name><operator>.</operator><name>prev</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>l</name><operator>.</operator><name>next</name></name><operator>=</operator><name><name>uv</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>l</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaF_freeupval</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>UpVal</name><modifier>*</modifier></type><name>uv</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name><name>uv</name><operator>-&gt;</operator><name>v</name></name><operator>!=</operator><operator>&amp;</operator><name><name>uv</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>value</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>unlinkupval</name><argument_list>(<argument><expr><name>uv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>luaM_free</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>uv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaF_close</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>StkId</name></type> <name>level</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>UpVal</name><modifier>*</modifier></type><name>uv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>global_State</name><modifier>*</modifier></type><name>g</name><init>=<expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<while>while<condition>(<expr><name><name>L</name><operator>-&gt;</operator><name>openupval</name></name><operator>!=</operator><name>NULL</name><operator>&amp;&amp;</operator><operator>(</operator><name>uv</name><operator>=</operator><call><name>ngcotouv</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>openupval</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>v</name><operator>&gt;=</operator><name>level</name></expr>)</condition><block>{<block_content>
<decl_stmt><decl><type><name>GCObject</name><modifier>*</modifier></type><name>o</name><init>=<expr><call><name>obj2gco</name><argument_list>(<argument><expr><name>uv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>openupval</name></name><operator>=</operator><name><name>uv</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><call><name>isdead</name><argument_list>(<argument><expr><name>g</name></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaF_freeupval</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>uv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block>{<block_content>
<expr_stmt><expr><call><name>unlinkupval</name><argument_list>(<argument><expr><name>uv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>uv</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>value</name></name></expr></argument>,<argument><expr><name><name>uv</name><operator>-&gt;</operator><name>v</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>uv</name><operator>-&gt;</operator><name>v</name></name><operator>=</operator><operator>&amp;</operator><name><name>uv</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>value</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaC_linkupval</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>uv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>Proto</name><modifier>*</modifier></type><name>luaF_newproto</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>Proto</name><modifier>*</modifier></type><name>f</name><init>=<expr><call><name>luaM_new</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>Proto</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaC_link</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>obj2gco</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><operator>(</operator><literal type="number">8</literal><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>k</name></name><operator>=</operator><name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>sizek</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>p</name></name><operator>=</operator><name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>sizep</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>code</name></name><operator>=</operator><name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>sizecode</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>sizelineinfo</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>sizeupvalues</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>nups</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>upvalues</name></name><operator>=</operator><name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>numparams</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>is_vararg</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>maxstacksize</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>lineinfo</name></name><operator>=</operator><name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>sizelocvars</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>locvars</name></name><operator>=</operator><name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>linedefined</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>lastlinedefined</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>source</name></name><operator>=</operator><name>NULL</name></expr>;</expr_stmt>
<return>return <expr><name>f</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaF_freeproto</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>Proto</name><modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>luaM_freearray</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>f</name><operator>-&gt;</operator><name>code</name></name></expr></argument>,<argument><expr><name><name>f</name><operator>-&gt;</operator><name>sizecode</name></name></expr></argument>,<argument><expr><name>Instruction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaM_freearray</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>f</name><operator>-&gt;</operator><name>p</name></name></expr></argument>,<argument><expr><name><name>f</name><operator>-&gt;</operator><name>sizep</name></name></expr></argument>,<argument><expr><name>Proto</name><operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaM_freearray</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>f</name><operator>-&gt;</operator><name>k</name></name></expr></argument>,<argument><expr><name><name>f</name><operator>-&gt;</operator><name>sizek</name></name></expr></argument>,<argument><expr><name>TValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaM_freearray</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>f</name><operator>-&gt;</operator><name>lineinfo</name></name></expr></argument>,<argument><expr><name><name>f</name><operator>-&gt;</operator><name>sizelineinfo</name></name></expr></argument>,<argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaM_freearray</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>f</name><operator>-&gt;</operator><name>locvars</name></name></expr></argument>,<argument><expr><name><name>f</name><operator>-&gt;</operator><name>sizelocvars</name></name></expr></argument>,<argument><expr>struct <name>LocVar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaM_freearray</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>f</name><operator>-&gt;</operator><name>upvalues</name></name></expr></argument>,<argument><expr><name><name>f</name><operator>-&gt;</operator><name>sizeupvalues</name></name></expr></argument>,<argument><expr><name>TString</name><operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaM_free</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaF_freeclosure</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>Closure</name><modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>size</name><init>=<expr><ternary><condition><expr><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>isC</name></name><operator>)</operator></expr>?</condition><then><expr><call><name>sizeCclosure</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>nupvalues</name></name></expr></argument>)</argument_list></call></expr></then><else>:
<expr><call><name>sizeLclosure</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>nupvalues</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaM_freemem</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>c</name></expr></argument>,<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MASK1</name><parameter_list>(<parameter><type><name>n</name></type></parameter>,<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((~((~(Instruction)0)&lt;&lt;n))&lt;&lt;p)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MASK0</name><parameter_list>(<parameter><type><name>n</name></type></parameter>,<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(~MASK1(n,p))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_OPCODE</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(cast(OpCode,((i)&gt;&gt;0)&amp;MASK1(6,0)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_OPCODE</name><parameter_list>(<parameter><type><name>i</name></type></parameter>,<parameter><type><name>o</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((i)=(((i)&amp;MASK0(6,0))|((cast(Instruction,o)&lt;&lt;0)&amp;MASK1(6,0))))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GETARG_A</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(cast(int,((i)&gt;&gt;(0+6))&amp;MASK1(8,0)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SETARG_A</name><parameter_list>(<parameter><type><name>i</name></type></parameter>,<parameter><type><name>u</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((i)=(((i)&amp;MASK0(8,(0+6)))|((cast(Instruction,u)&lt;&lt;(0+6))&amp;MASK1(8,(0+6)))))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GETARG_B</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(cast(int,((i)&gt;&gt;(((0+6)+8)+9))&amp;MASK1(9,0)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SETARG_B</name><parameter_list>(<parameter><type><name>i</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((i)=(((i)&amp;MASK0(9,(((0+6)+8)+9)))|((cast(Instruction,b)&lt;&lt;(((0+6)+8)+9))&amp;MASK1(9,(((0+6)+8)+9)))))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GETARG_C</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(cast(int,((i)&gt;&gt;((0+6)+8))&amp;MASK1(9,0)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SETARG_C</name><parameter_list>(<parameter><type><name>i</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((i)=(((i)&amp;MASK0(9,((0+6)+8)))|((cast(Instruction,b)&lt;&lt;((0+6)+8))&amp;MASK1(9,((0+6)+8)))))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GETARG_Bx</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(cast(int,((i)&gt;&gt;((0+6)+8))&amp;MASK1((9+9),0)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SETARG_Bx</name><parameter_list>(<parameter><type><name>i</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((i)=(((i)&amp;MASK0((9+9),((0+6)+8)))|((cast(Instruction,b)&lt;&lt;((0+6)+8))&amp;MASK1((9+9),((0+6)+8)))))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GETARG_sBx</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(GETARG_Bx(i)-(((1&lt;&lt;(9+9))-1)&gt;&gt;1))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SETARG_sBx</name><parameter_list>(<parameter><type><name>i</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>SETARG_Bx((i),cast(unsigned int,(b)+(((1&lt;&lt;(9+9))-1)&gt;&gt;1)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CREATE_ABC</name><parameter_list>(<parameter><type><name>o</name></type></parameter>,<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((cast(Instruction,o)&lt;&lt;0)|(cast(Instruction,a)&lt;&lt;(0+6))|(cast(Instruction,b)&lt;&lt;(((0+6)+8)+9))|(cast(Instruction,c)&lt;&lt;((0+6)+8)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CREATE_ABx</name><parameter_list>(<parameter><type><name>o</name></type></parameter>,<parameter><type><name>a</name></type></parameter>,<parameter><type><name>bc</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((cast(Instruction,o)&lt;&lt;0)|(cast(Instruction,a)&lt;&lt;(0+6))|(cast(Instruction,bc)&lt;&lt;((0+6)+8)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ISK</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((x)&amp;(1&lt;&lt;(9-1)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INDEXK</name><parameter_list>(<parameter><type><name>r</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((int)(r)&amp;~(1&lt;&lt;(9-1)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RKASK</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((x)|(1&lt;&lt;(9-1)))</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>lu_byte</name></type> <name><name>luaP_opmodes</name><index>[<expr><operator>(</operator><call><name>cast</name><argument_list>(<argument><expr><name>int</name></expr></argument>,<argument><expr><name>OP_VARARG</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>]</index></name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>getBMode</name><parameter_list>(<parameter><type><name>m</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(cast(enum OpArgMask,(luaP_opmodes[m]&gt;&gt;4)&amp;3))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>getCMode</name><parameter_list>(<parameter><type><name>m</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(cast(enum OpArgMask,(luaP_opmodes[m]&gt;&gt;2)&amp;3))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>testTMode</name><parameter_list>(<parameter><type><name>m</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(luaP_opmodes[m]&amp;(1&lt;&lt;7))</cpp:value></cpp:define>
<typedef>typedef <type><struct>struct <name>expdesc</name><block>{
<decl_stmt><decl><type><name>expkind</name></type> <name>k</name></decl>;</decl_stmt>
<union>union<block>{
<struct>struct<block>{<decl_stmt><decl><type><name>int</name></type> <name>info</name></decl>,<name>aux</name>;</decl_stmt>}</block><decl><name>s</name></decl>;</struct>
<decl_stmt><decl><type><name>lua_Number</name></type> <name>nval</name></decl>;</decl_stmt>
}</block><decl><name>u</name></decl>;</union>
<decl_stmt><decl><type><name>int</name></type> <name>t</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>f</name></decl>;</decl_stmt>
}</block></struct></type><name>expdesc</name>;</typedef>
<typedef>typedef <type><struct>struct <name>upvaldesc</name><block>{
<decl_stmt><decl><type><name>lu_byte</name></type> <name>k</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>lu_byte</name></type> <name>info</name></decl>;</decl_stmt>
}</block></struct></type><name>upvaldesc</name>;</typedef>
<struct_decl>struct <name>BlockCnt</name>;</struct_decl>
<typedef>typedef <type><struct>struct <name>FuncState</name><block>{
<decl_stmt><decl><type><name>Proto</name><modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Table</name><modifier>*</modifier></type><name>h</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>FuncState</name></name><modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>LexState</name></name><modifier>*</modifier></type><name>ls</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>lua_State</name></name><modifier>*</modifier></type><name>L</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>BlockCnt</name></name><modifier>*</modifier></type><name>bl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>lasttarget</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>jpc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>freereg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nk</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>np</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>short</name></type> <name>nlocvars</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>lu_byte</name></type> <name>nactvar</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>upvaldesc</name></type> <name><name>upvalues</name><index>[<expr><literal type="number">60</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name><name>actvar</name><index>[<expr><literal type="number">200</literal></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type><name>FuncState</name>;</typedef>
<function_decl><type><specifier>static</specifier> <name>Proto</name><modifier>*</modifier></type><name>luaY_parser</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>ZIO</name><modifier>*</modifier></type><name>z</name></decl></parameter>,<parameter><decl><type><name>Mbuffer</name><modifier>*</modifier></type><name>buff</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>;</function_decl>
<struct>struct <name>lua_longjmp</name><block>{
<decl_stmt><decl><type><name><name>struct</name> <name>lua_longjmp</name></name><modifier>*</modifier></type><name>previous</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>jmp_buf</name></type> <name>b</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>status</name></decl>;</decl_stmt>
}</block>;</struct>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaD_seterrorobj</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>errcode</name></decl></parameter>,<parameter><decl><type><name>StkId</name></type> <name>oldtop</name></decl></parameter>)</parameter_list><block>{<block_content>
<switch>switch<condition>(<expr><name>errcode</name></expr>)</condition><block>{<block_content>
<case>case <expr><literal type="number">4</literal></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>setsvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>oldtop</name></expr></argument>,<argument><expr><call><name>luaS_newliteral</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"not enough memory"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><literal type="number">5</literal></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>setsvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>oldtop</name></expr></argument>,<argument><expr><call><name>luaS_newliteral</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"error in error handling"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><literal type="number">3</literal></expr>:</case>
<case>case <expr><literal type="number">2</literal></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>setobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>oldtop</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
</block_content>}</block></switch>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>=</operator><name>oldtop</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>restore_stack_limit</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name><name>L</name><operator>-&gt;</operator><name>size_ci</name></name><operator>&gt;</operator><literal type="number">20000</literal></expr>)</condition><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>inuse</name><init>=<expr><call><name>cast_int</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>ci</name></name><operator>-</operator><name><name>L</name><operator>-&gt;</operator><name>base_ci</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>inuse</name><operator>+</operator><literal type="number">1</literal><operator>&lt;</operator><literal type="number">20000</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaD_reallocCI</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">20000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>resetstack</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>ci</name></name><operator>=</operator><name><name>L</name><operator>-&gt;</operator><name>base_ci</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>=</operator><name><name>L</name><operator>-&gt;</operator><name>ci</name><operator>-&gt;</operator><name>base</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaF_close</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaD_seterrorobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>status</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>nCcalls</name></name><operator>=</operator><name><name>L</name><operator>-&gt;</operator><name>baseCcalls</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>allowhook</name></name><operator>=</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>restore_stack_limit</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>errfunc</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>errorJmp</name></name><operator>=</operator><name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaD_throw</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>errcode</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name><name>L</name><operator>-&gt;</operator><name>errorJmp</name></name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>errorJmp</name><operator>-&gt;</operator><name>status</name></name><operator>=</operator><name>errcode</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>LUAI_THROW</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>errorJmp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block>{<block_content>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>status</name></name><operator>=</operator><call><name>cast_byte</name><argument_list>(<argument><expr><name>errcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>panic</name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>resetstack</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>errcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>panic</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>luaD_rawrunprotected</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>Pfunc</name></type> <name>f</name></decl></parameter>,<parameter><decl><type><name>void</name><modifier>*</modifier></type><name>ud</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>lua_longjmp</name></name></type> <name>lj</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>lj</name><operator>.</operator><name>status</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lj</name><operator>.</operator><name>previous</name></name><operator>=</operator><name><name>L</name><operator>-&gt;</operator><name>errorJmp</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>errorJmp</name></name><operator>=</operator><operator>&amp;</operator><name>lj</name></expr>;</expr_stmt>
<macro><name>LUAI_TRY</name><argument_list>(<argument>L</argument>,<argument>&amp;lj</argument>,
<argument>(*f)(L,ud);</argument>
)</argument_list></macro><empty_stmt>;</empty_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>errorJmp</name></name><operator>=</operator><name><name>lj</name><operator>.</operator><name>previous</name></name></expr>;</expr_stmt>
<return>return <expr><name><name>lj</name><operator>.</operator><name>status</name></name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>correctstack</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>TValue</name><modifier>*</modifier></type><name>oldstack</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>CallInfo</name><modifier>*</modifier></type><name>ci</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GCObject</name><modifier>*</modifier></type><name>up</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>=</operator><operator>(</operator><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><name>oldstack</name><operator>)</operator><operator>+</operator><name><name>L</name><operator>-&gt;</operator><name>stack</name></name></expr>;</expr_stmt>
<for>for<control>(<init><expr><name>up</name><operator>=</operator><name><name>L</name><operator>-&gt;</operator><name>openupval</name></name></expr>;</init><condition><expr><name>up</name><operator>!=</operator><name>NULL</name></expr>;</condition><incr><expr><name>up</name><operator>=</operator><name><name>up</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>gco2uv</name><argument_list>(<argument><expr><name>up</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>v</name><operator>=</operator><operator>(</operator><call><name>gco2uv</name><argument_list>(<argument><expr><name>up</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>v</name><operator>-</operator><name>oldstack</name><operator>)</operator><operator>+</operator><name><name>L</name><operator>-&gt;</operator><name>stack</name></name></expr>;</expr_stmt></block_content></block></for>
<for>for<control>(<init><expr><name>ci</name><operator>=</operator><name><name>L</name><operator>-&gt;</operator><name>base_ci</name></name></expr>;</init><condition><expr><name>ci</name><operator>&lt;=</operator><name><name>L</name><operator>-&gt;</operator><name>ci</name></name></expr>;</condition><incr><expr><name>ci</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
<expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>top</name></name><operator>=</operator><operator>(</operator><name><name>ci</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><name>oldstack</name><operator>)</operator><operator>+</operator><name><name>L</name><operator>-&gt;</operator><name>stack</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>base</name></name><operator>=</operator><operator>(</operator><name><name>ci</name><operator>-&gt;</operator><name>base</name></name><operator>-</operator><name>oldstack</name><operator>)</operator><operator>+</operator><name><name>L</name><operator>-&gt;</operator><name>stack</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>func</name></name><operator>=</operator><operator>(</operator><name><name>ci</name><operator>-&gt;</operator><name>func</name></name><operator>-</operator><name>oldstack</name><operator>)</operator><operator>+</operator><name><name>L</name><operator>-&gt;</operator><name>stack</name></name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>=</operator><operator>(</operator><name><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>-</operator><name>oldstack</name><operator>)</operator><operator>+</operator><name><name>L</name><operator>-&gt;</operator><name>stack</name></name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaD_reallocstack</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>newsize</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>TValue</name><modifier>*</modifier></type><name>oldstack</name><init>=<expr><name><name>L</name><operator>-&gt;</operator><name>stack</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>realsize</name><init>=<expr><name>newsize</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><literal type="number">5</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaM_reallocvector</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>stacksize</name></name></expr></argument>,<argument><expr><name>realsize</name></expr></argument>,<argument><expr><name>TValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>stacksize</name></name><operator>=</operator><name>realsize</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>stack_last</name></name><operator>=</operator><name><name>L</name><operator>-&gt;</operator><name>stack</name></name><operator>+</operator><name>newsize</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>correctstack</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>oldstack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaD_reallocCI</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>newsize</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>CallInfo</name><modifier>*</modifier></type><name>oldci</name><init>=<expr><name><name>L</name><operator>-&gt;</operator><name>base_ci</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaM_reallocvector</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>base_ci</name></name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>size_ci</name></name></expr></argument>,<argument><expr><name>newsize</name></expr></argument>,<argument><expr><name>CallInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>size_ci</name></name><operator>=</operator><name>newsize</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>ci</name></name><operator>=</operator><operator>(</operator><name><name>L</name><operator>-&gt;</operator><name>ci</name></name><operator>-</operator><name>oldci</name><operator>)</operator><operator>+</operator><name><name>L</name><operator>-&gt;</operator><name>base_ci</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>end_ci</name></name><operator>=</operator><name><name>L</name><operator>-&gt;</operator><name>base_ci</name></name><operator>+</operator><name><name>L</name><operator>-&gt;</operator><name>size_ci</name></name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaD_growstack</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name>n</name><operator>&lt;=</operator><name><name>L</name><operator>-&gt;</operator><name>stacksize</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaD_reallocstack</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">2</literal><operator>*</operator><name><name>L</name><operator>-&gt;</operator><name>stacksize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaD_reallocstack</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>stacksize</name></name><operator>+</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>CallInfo</name><modifier>*</modifier></type><name>growCI</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name><name>L</name><operator>-&gt;</operator><name>size_ci</name></name><operator>&gt;</operator><literal type="number">20000</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaD_throw</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block>{<block_content>
<expr_stmt><expr><call><name>luaD_reallocCI</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">2</literal><operator>*</operator><name><name>L</name><operator>-&gt;</operator><name>size_ci</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name><name>L</name><operator>-&gt;</operator><name>size_ci</name></name><operator>&gt;</operator><literal type="number">20000</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaG_runerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"stack overflow"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<return>return<expr><operator>++</operator><name><name>L</name><operator>-&gt;</operator><name>ci</name></name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>StkId</name></type> <name>adjust_varargs</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>Proto</name><modifier>*</modifier></type><name>p</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>actual</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nfixargs</name><init>=<expr><name><name>p</name><operator>-&gt;</operator><name>numparams</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Table</name><modifier>*</modifier></type><name>htab</name><init>=<expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>StkId</name></type> <name>base</name></decl>,<decl><type ref="prev"/><name>fixed</name></decl>;</decl_stmt>
<for>for<control>(<init>;</init><condition><expr><name>actual</name><operator>&lt;</operator><name>nfixargs</name></expr>;</condition><incr><expr><operator>++</operator><name>actual</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>setnilvalue</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><name>fixed</name><operator>=</operator><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><name>actual</name></expr>;</expr_stmt>
<expr_stmt><expr><name>base</name><operator>=</operator><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr>;</expr_stmt>
<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init><condition><expr><name>i</name><operator>&lt;</operator><name>nfixargs</name></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
<expr_stmt><expr><call><name>setobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>++</operator></expr></argument>,<argument><expr><name>fixed</name><operator>+</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setnilvalue</name><argument_list>(<argument><expr><name>fixed</name><operator>+</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if<condition>(<expr><name>htab</name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>sethvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>++</operator></expr></argument>,<argument><expr><name>htab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>base</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>StkId</name></type> <name>tryfuncTM</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>StkId</name></type> <name>func</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>tm</name><init>=<expr><call><name>luaT_gettmbyobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>func</name></expr></argument>,<argument><expr><name>TM_CALL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>StkId</name></type> <name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>funcr</name><init>=<expr><call><name>savestack</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ttisfunction</name><argument_list>(<argument><expr><name>tm</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaG_typeerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>func</name></expr></argument>,<argument><expr><literal type="string">"call"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<for>for<control>(<init><expr><name>p</name><operator>=</operator><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr>;</init><condition><expr><name>p</name><operator>&gt;</operator><name>func</name></expr>;</condition><incr><expr><name>p</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content><expr_stmt><expr><call><name>setobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>p</name></expr></argument>,<argument><expr><name>p</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>incr_top</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>func</name><operator>=</operator><call><name>restorestack</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>funcr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>func</name></expr></argument>,<argument><expr><name>tm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>func</name></expr>;</return>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>inc_ci</name><parameter_list>(<parameter><type><name>L</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((L-&gt;ci==L-&gt;end_ci)?growCI(L):(condhardstacktests(luaD_reallocCI(L,L-&gt;size_ci)),++L-&gt;ci))</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>int</name></type> <name>luaD_precall</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>StkId</name></type> <name>func</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>nresults</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>LClosure</name><modifier>*</modifier></type><name>cl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>funcr</name></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ttisfunction</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>func</name><operator>=</operator><call><name>tryfuncTM</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>funcr</name><operator>=</operator><call><name>savestack</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cl</name><operator>=</operator><operator>&amp;</operator><call><name>clvalue</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>l</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>ci</name><operator>-&gt;</operator><name>savedpc</name></name><operator>=</operator><name><name>L</name><operator>-&gt;</operator><name>savedpc</name></name></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>cl</name><operator>-&gt;</operator><name>isC</name></name></expr>)</condition><block>{<block_content>
<decl_stmt><decl><type><name>CallInfo</name><modifier>*</modifier></type><name>ci</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>StkId</name></type> <name>st</name></decl>,<decl><type ref="prev"/><name>base</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Proto</name><modifier>*</modifier></type><name>p</name><init>=<expr><name><name>cl</name><operator>-&gt;</operator><name>p</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaD_checkstack</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>p</name><operator>-&gt;</operator><name>maxstacksize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>func</name><operator>=</operator><call><name>restorestack</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>funcr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>is_vararg</name></name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><name>base</name><operator>=</operator><name>func</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>&gt;</operator><name>base</name><operator>+</operator><name><name>p</name><operator>-&gt;</operator><name>numparams</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>=</operator><name>base</name><operator>+</operator><name><name>p</name><operator>-&gt;</operator><name>numparams</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if>
<else>else<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>nargs</name><init>=<expr><call><name>cast_int</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><name>func</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>base</name><operator>=</operator><call><name>adjust_varargs</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>p</name></expr></argument>,<argument><expr><name>nargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>func</name><operator>=</operator><call><name>restorestack</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>funcr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>ci</name><operator>=</operator><call><name>inc_ci</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>func</name></name><operator>=</operator><name>func</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>=</operator><name><name>ci</name><operator>-&gt;</operator><name>base</name></name><operator>=</operator><name>base</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>top</name></name><operator>=</operator><name><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>+</operator><name><name>p</name><operator>-&gt;</operator><name>maxstacksize</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>savedpc</name></name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>code</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>tailcalls</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>nresults</name></name><operator>=</operator><name>nresults</name></expr>;</expr_stmt>
<for>for<control>(<init><expr><name>st</name><operator>=</operator><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr>;</init><condition><expr><name>st</name><operator>&lt;</operator><name><name>ci</name><operator>-&gt;</operator><name>top</name></name></expr>;</condition><incr><expr><name>st</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>setnilvalue</name><argument_list>(<argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>=</operator><name><name>ci</name><operator>-&gt;</operator><name>top</name></name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if>
<else>else<block>{<block_content>
<decl_stmt><decl><type><name>CallInfo</name><modifier>*</modifier></type><name>ci</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaD_checkstack</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">20</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ci</name><operator>=</operator><call><name>inc_ci</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>func</name></name><operator>=</operator><call><name>restorestack</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>funcr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>=</operator><name><name>ci</name><operator>-&gt;</operator><name>base</name></name><operator>=</operator><name><name>ci</name><operator>-&gt;</operator><name>func</name></name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>top</name></name><operator>=</operator><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>+</operator><literal type="number">20</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>nresults</name></name><operator>=</operator><name>nresults</name></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name><operator>=</operator><operator>(</operator><operator>*</operator><call><name>curr_func</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>c</name><operator>.</operator><name>f</name></name><operator>)</operator><operator>(</operator><name>L</name><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>n</name><operator>&lt;</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">2</literal></expr>;</return></block_content></block></if>
<else>else<block>{<block_content>
<expr_stmt><expr><call><name>luaD_poscall</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>luaD_poscall</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>StkId</name></type> <name>firstResult</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>StkId</name></type> <name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>wanted</name></decl>,<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CallInfo</name><modifier>*</modifier></type><name>ci</name></decl>;</decl_stmt>
<expr_stmt><expr><name>ci</name><operator>=</operator><name><name>L</name><operator>-&gt;</operator><name>ci</name></name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>res</name><operator>=</operator><name><name>ci</name><operator>-&gt;</operator><name>func</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>wanted</name><operator>=</operator><name><name>ci</name><operator>-&gt;</operator><name>nresults</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>=</operator><operator>(</operator><name>ci</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>-&gt;</operator><name>base</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>savedpc</name></name><operator>=</operator><operator>(</operator><name>ci</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>-&gt;</operator><name>savedpc</name></expr>;</expr_stmt>
<for>for<control>(<init><expr><name>i</name><operator>=</operator><name>wanted</name></expr>;</init><condition><expr><name>i</name><operator>!=</operator><literal type="number">0</literal><operator>&amp;&amp;</operator><name>firstResult</name><operator>&lt;</operator><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr>;</condition><incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>setobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>res</name><operator>++</operator></expr></argument>,<argument><expr><name>firstResult</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<while>while<condition>(<expr><name>i</name><operator>--</operator><operator>&gt;</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>setnilvalue</name><argument_list>(<argument><expr><name>res</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>=</operator><name>res</name></expr>;</expr_stmt>
<return>return<expr><operator>(</operator><name>wanted</name><operator>-</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaD_call</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>StkId</name></type> <name>func</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>nResults</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><operator>++</operator><name><name>L</name><operator>-&gt;</operator><name>nCcalls</name></name><operator>&gt;=</operator><literal type="number">200</literal></expr>)</condition><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name><name>L</name><operator>-&gt;</operator><name>nCcalls</name></name><operator>==</operator><literal type="number">200</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaG_runerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"C stack overflow"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if<condition>(<expr><name><name>L</name><operator>-&gt;</operator><name>nCcalls</name></name><operator>&gt;=</operator><operator>(</operator><literal type="number">200</literal><operator>+</operator><operator>(</operator><literal type="number">200</literal><operator>&gt;&gt;</operator><literal type="number">3</literal><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaD_throw</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><call><name>luaD_precall</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>func</name></expr></argument>,<argument><expr><name>nResults</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaV_execute</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>nCcalls</name></name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaC_checkGC</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>luaD_pcall</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>Pfunc</name></type> <name>func</name></decl></parameter>,<parameter><decl><type><name>void</name><modifier>*</modifier></type><name>u</name></decl></parameter>,
<parameter><decl><type><name>ptrdiff_t</name></type> <name>old_top</name></decl></parameter>,<parameter><decl><type><name>ptrdiff_t</name></type> <name>ef</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>oldnCcalls</name><init>=<expr><name><name>L</name><operator>-&gt;</operator><name>nCcalls</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>old_ci</name><init>=<expr><call><name>saveci</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>ci</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>lu_byte</name></type> <name>old_allowhooks</name><init>=<expr><name><name>L</name><operator>-&gt;</operator><name>allowhook</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>old_errfunc</name><init>=<expr><name><name>L</name><operator>-&gt;</operator><name>errfunc</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>errfunc</name></name><operator>=</operator><name>ef</name></expr>;</expr_stmt>
<expr_stmt><expr><name>status</name><operator>=</operator><call><name>luaD_rawrunprotected</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>func</name></expr></argument>,<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>status</name><operator>!=</operator><literal type="number">0</literal></expr>)</condition><block>{<block_content>
<decl_stmt><decl><type><name>StkId</name></type> <name>oldtop</name><init>=<expr><call><name>restorestack</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>old_top</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaF_close</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>oldtop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaD_seterrorobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>status</name></expr></argument>,<argument><expr><name>oldtop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>nCcalls</name></name><operator>=</operator><name>oldnCcalls</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>ci</name></name><operator>=</operator><call><name>restoreci</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>old_ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>=</operator><name><name>L</name><operator>-&gt;</operator><name>ci</name><operator>-&gt;</operator><name>base</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>savedpc</name></name><operator>=</operator><name><name>L</name><operator>-&gt;</operator><name>ci</name><operator>-&gt;</operator><name>savedpc</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>allowhook</name></name><operator>=</operator><name>old_allowhooks</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>restore_stack_limit</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>errfunc</name></name><operator>=</operator><name>old_errfunc</name></expr>;</expr_stmt>
<return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>
<struct>struct <name>SParser</name><block>{
<decl_stmt><decl><type><name>ZIO</name><modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Mbuffer</name></type> <name>buff</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
}</block>;</struct>
<function><type><specifier>static</specifier> <name>void</name></type> <name>f_parser</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>void</name><modifier>*</modifier></type><name>ud</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Proto</name><modifier>*</modifier></type><name>tf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Closure</name><modifier>*</modifier></type><name>cl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>SParser</name></name><modifier>*</modifier></type><name>p</name><init>=<expr><call><name>cast</name><argument_list>(<argument><expr>struct <name>SParser</name><operator>*</operator></expr></argument>,<argument><expr><name>ud</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaC_checkGC</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tf</name><operator>=</operator><call><name>luaY_parser</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>p</name><operator>-&gt;</operator><name>z</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>buff</name></name></expr></argument>,<argument><expr><name><name>p</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cl</name><operator>=</operator><call><name>luaF_newLclosure</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>tf</name><operator>-&gt;</operator><name>nups</name></name></expr></argument>,<argument><expr><call><name>hvalue</name><argument_list>(<argument><expr><call><name>gt</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cl</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>p</name></name><operator>=</operator><name>tf</name></expr>;</expr_stmt>
<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init><condition><expr><name>i</name><operator>&lt;</operator><name><name>tf</name><operator>-&gt;</operator><name>nups</name></name></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>cl</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>upvals</name><index>[<expr><name>i</name></expr>]</index></name><operator>=</operator><call><name>luaF_newupval</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>setclvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>,<argument><expr><name>cl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>incr_top</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>luaD_protectedparser</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>ZIO</name><modifier>*</modifier></type><name>z</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>SParser</name></name></type> <name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>p</name><operator>.</operator><name>z</name></name><operator>=</operator><name>z</name></expr>;</expr_stmt><expr_stmt><expr><name><name>p</name><operator>.</operator><name>name</name></name><operator>=</operator><name>name</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaZ_initbuffer</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>p</name><operator>.</operator><name>buff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>status</name><operator>=</operator><call><name>luaD_pcall</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>f_parser</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>,<argument><expr><call><name>savestack</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>errfunc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaZ_freebuffer</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>p</name><operator>.</operator><name>buff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaS_resize</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>newsize</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>GCObject</name><modifier>*</modifier><modifier>*</modifier></type><name>newhash</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>stringtable</name><modifier>*</modifier></type><name>tb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>gcstate</name><operator>==</operator><literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>newhash</name><operator>=</operator><call><name>luaM_newvector</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>newsize</name></expr></argument>,<argument><expr><name>GCObject</name><operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tb</name><operator>=</operator><operator>&amp;</operator><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>strt</name></expr>;</expr_stmt>
<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init><condition><expr><name>i</name><operator>&lt;</operator><name>newsize</name></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content><expr_stmt><expr><name><name>newhash</name><index>[<expr><name>i</name></expr>]</index></name><operator>=</operator><name>NULL</name></expr>;</expr_stmt></block_content></block></for>
<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init><condition><expr><name>i</name><operator>&lt;</operator><name><name>tb</name><operator>-&gt;</operator><name>size</name></name></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
<decl_stmt><decl><type><name>GCObject</name><modifier>*</modifier></type><name>p</name><init>=<expr><name><name>tb</name><operator>-&gt;</operator><name>hash</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<while>while<condition>(<expr><name>p</name></expr>)</condition><block>{<block_content>
<decl_stmt><decl><type><name>GCObject</name><modifier>*</modifier></type><name>next</name><init>=<expr><name><name>p</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>next</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>h</name><init>=<expr><call><name>gco2ts</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>hash</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>h1</name><init>=<expr><call><name>lmod</name><argument_list>(<argument><expr><name>h</name></expr></argument>,<argument><expr><name>newsize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>next</name></name><operator>=</operator><name><name>newhash</name><index>[<expr><name>h1</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newhash</name><index>[<expr><name>h1</name></expr>]</index></name><operator>=</operator><name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name><operator>=</operator><name>next</name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></for>
<expr_stmt><expr><call><name>luaM_freearray</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>tb</name><operator>-&gt;</operator><name>hash</name></name></expr></argument>,<argument><expr><name><name>tb</name><operator>-&gt;</operator><name>size</name></name></expr></argument>,<argument><expr><name>TString</name><operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tb</name><operator>-&gt;</operator><name>size</name></name><operator>=</operator><name>newsize</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tb</name><operator>-&gt;</operator><name>hash</name></name><operator>=</operator><name>newhash</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>TString</name><modifier>*</modifier></type><name>newlstr</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>str</name></decl></parameter>,<parameter><decl><type><name>size_t</name></type> <name>l</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>h</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>TString</name><modifier>*</modifier></type><name>ts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>stringtable</name><modifier>*</modifier></type><name>tb</name></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>l</name><operator>+</operator><literal type="number">1</literal><operator>&gt;</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><operator>~</operator><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">0</literal><operator>)</operator><operator>-</operator><literal type="number">2</literal><operator>)</operator><operator>-</operator><sizeof>sizeof<argument_list>(<argument><expr><name>TString</name></expr></argument>)</argument_list></sizeof><operator>)</operator><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaM_toobig</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>ts</name><operator>=</operator><call><name>cast</name><argument_list>(<argument><expr><name>TString</name><operator>*</operator></expr></argument>,<argument><expr><call><name>luaM_malloc</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>(</operator><name>l</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof><operator>+</operator><sizeof>sizeof<argument_list>(<argument><expr><name>TString</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ts</name><operator>-&gt;</operator><name>tsv</name><operator>.</operator><name>len</name></name><operator>=</operator><name>l</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ts</name><operator>-&gt;</operator><name>tsv</name><operator>.</operator><name>hash</name></name><operator>=</operator><name>h</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ts</name><operator>-&gt;</operator><name>tsv</name><operator>.</operator><name>marked</name></name><operator>=</operator><call><name>luaC_white</name><argument_list>(<argument><expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ts</name><operator>-&gt;</operator><name>tsv</name><operator>.</operator><name>tt</name></name><operator>=</operator><literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ts</name><operator>-&gt;</operator><name>tsv</name><operator>.</operator><name>reserved</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ts</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>str</name></expr></argument>,<argument><expr><name>l</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name>ts</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator><index>[<expr><name>l</name></expr>]</index><operator>=</operator><literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>tb</name><operator>=</operator><operator>&amp;</operator><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>strt</name></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name><operator>=</operator><call><name>lmod</name><argument_list>(<argument><expr><name>h</name></expr></argument>,<argument><expr><name><name>tb</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ts</name><operator>-&gt;</operator><name>tsv</name><operator>.</operator><name>next</name></name><operator>=</operator><name><name>tb</name><operator>-&gt;</operator><name>hash</name><index>[<expr><name>h</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tb</name><operator>-&gt;</operator><name>hash</name><index>[<expr><name>h</name></expr>]</index></name><operator>=</operator><call><name>obj2gco</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tb</name><operator>-&gt;</operator><name>nuse</name></name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name><name>tb</name><operator>-&gt;</operator><name>nuse</name></name><operator>&gt;</operator><call><name>cast</name><argument_list>(<argument><expr><name>lu_int32</name></expr></argument>,<argument><expr><name><name>tb</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call><operator>&amp;&amp;</operator><name><name>tb</name><operator>-&gt;</operator><name>size</name></name><operator>&lt;=</operator><operator>(</operator><name>INT_MAX</name><operator>-</operator><literal type="number">2</literal><operator>)</operator><operator>/</operator><literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaS_resize</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>tb</name><operator>-&gt;</operator><name>size</name></name><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>ts</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>TString</name><modifier>*</modifier></type><name>luaS_newlstr</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>str</name></decl></parameter>,<parameter><decl><type><name>size_t</name></type> <name>l</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>GCObject</name><modifier>*</modifier></type><name>o</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>h</name><init>=<macro><name>cast</name><argument_list>(<argument>unsigned int</argument>,<argument>l</argument>)</argument_list></macro></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>step</name><init>=<expr><operator>(</operator><name>l</name><operator>&gt;&gt;</operator><literal type="number">5</literal><operator>)</operator><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>l1</name></decl>;</decl_stmt>
<for>for<control>(<init><expr><name>l1</name><operator>=</operator><name>l</name></expr>;</init><condition><expr><name>l1</name><operator>&gt;=</operator><name>step</name></expr>;</condition><incr><expr><name>l1</name><operator>-=</operator><name>step</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name>h</name><operator>=</operator><name>h</name><operator>^</operator><operator>(</operator><operator>(</operator><name>h</name><operator>&lt;&lt;</operator><literal type="number">5</literal><operator>)</operator><operator>+</operator><operator>(</operator><name>h</name><operator>&gt;&gt;</operator><literal type="number">2</literal><operator>)</operator><operator>+</operator><macro><name>cast</name><argument_list>(<argument>unsigned char</argument>,<argument>str[l1-<literal type="number">1</literal>]</argument>)</argument_list></macro><operator>)</operator></expr>;</expr_stmt></block_content></block></for>
<for>for<control>(<init><expr><name>o</name><operator>=</operator><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>strt</name><operator>.</operator><name>hash</name><index>[<expr><call><name>lmod</name><argument_list>(<argument><expr><name>h</name></expr></argument>,<argument><expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>strt</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</init>
<condition><expr><name>o</name><operator>!=</operator><name>NULL</name></expr>;</condition>
<incr><expr><name>o</name><operator>=</operator><name><name>o</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>next</name></name></expr></incr>)</control><block>{<block_content>
<decl_stmt><decl><type><name>TString</name><modifier>*</modifier></type><name>ts</name><init>=<expr><call><name>rawgco2ts</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name><name>ts</name><operator>-&gt;</operator><name>tsv</name><operator>.</operator><name>len</name></name><operator>==</operator><name>l</name><operator>&amp;&amp;</operator><operator>(</operator><call><name>memcmp</name><argument_list>(<argument><expr><name>str</name></expr></argument>,<argument><expr><call><name>getstr</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>l</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr>)</condition><block>{<block_content>
<if_stmt><if>if<condition>(<expr><call><name>isdead</name><argument_list>(<argument><expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><call><name>changewhite</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>ts</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><call><name>newlstr</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>str</name></expr></argument>,<argument><expr><name>l</name></expr></argument>,<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>Udata</name><modifier>*</modifier></type><name>luaS_newudata</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>size_t</name></type> <name>s</name></decl></parameter>,<parameter><decl><type><name>Table</name><modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>Udata</name><modifier>*</modifier></type><name>u</name></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>s</name><operator>&gt;</operator><operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><operator>~</operator><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">0</literal><operator>)</operator><operator>-</operator><literal type="number">2</literal><operator>)</operator><operator>-</operator><sizeof>sizeof<argument_list>(<argument><expr><name>Udata</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaM_toobig</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>u</name><operator>=</operator><call><name>cast</name><argument_list>(<argument><expr><name>Udata</name><operator>*</operator></expr></argument>,<argument><expr><call><name>luaM_malloc</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>s</name><operator>+</operator><sizeof>sizeof<argument_list>(<argument><expr><name>Udata</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>u</name><operator>-&gt;</operator><name>uv</name><operator>.</operator><name>marked</name></name><operator>=</operator><call><name>luaC_white</name><argument_list>(<argument><expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>u</name><operator>-&gt;</operator><name>uv</name><operator>.</operator><name>tt</name></name><operator>=</operator><literal type="number">7</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>u</name><operator>-&gt;</operator><name>uv</name><operator>.</operator><name>len</name></name><operator>=</operator><name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>u</name><operator>-&gt;</operator><name>uv</name><operator>.</operator><name>metatable</name></name><operator>=</operator><name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>u</name><operator>-&gt;</operator><name>uv</name><operator>.</operator><name>env</name></name><operator>=</operator><name>e</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>u</name><operator>-&gt;</operator><name>uv</name><operator>.</operator><name>next</name></name><operator>=</operator><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>mainthread</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>mainthread</name><operator>-&gt;</operator><name>next</name></name><operator>=</operator><call><name>obj2gco</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>u</name></expr>;</return>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>hashpow2</name><parameter_list>(<parameter><type><name>t</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(gnode(t,lmod((n),sizenode(t))))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>hashstr</name><parameter_list>(<parameter><type><name>t</name></type></parameter>,<parameter><type><name>str</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>hashpow2(t,(str)-&gt;tsv.hash)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>hashboolean</name><parameter_list>(<parameter><type><name>t</name></type></parameter>,<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>hashpow2(t,p)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>hashmod</name><parameter_list>(<parameter><type><name>t</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(gnode(t,((n)%((sizenode(t)-1)|1))))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>hashpointer</name><parameter_list>(<parameter><type><name>t</name></type></parameter>,<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>hashmod(t,IntPoint(p))</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>Node</name></type> <name>dummynode_</name><init>=<expr><block>{
<expr><block>{<expr><block>{<expr><name>NULL</name></expr>}</block></expr>,<expr><literal type="number">0</literal></expr>}</block></expr>,
<expr><block>{<expr><block>{<expr><block>{<expr><name>NULL</name></expr>}</block></expr>,<expr><literal type="number">0</literal></expr>,<expr><name>NULL</name></expr>}</block></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>Node</name><modifier>*</modifier></type><name>hashnum</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Table</name><modifier>*</modifier></type><name>t</name></decl></parameter>,<parameter><decl><type><name>lua_Number</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name><name>a</name><index>[<expr><call><name>cast_int</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>lua_Number</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><call><name>luai_numeq</name><argument_list>(<argument><expr><name>n</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>gnode</name><argument_list>(<argument><expr><name>t</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>a</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>n</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init><condition><expr><name>i</name><operator>&lt;</operator><call><name>cast_int</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>lua_Number</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content><expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>+=</operator><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
<return>return <expr><call><name>hashmod</name><argument_list>(<argument><expr><name>t</name></expr></argument>,<argument><expr><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>Node</name><modifier>*</modifier></type><name>mainposition</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Table</name><modifier>*</modifier></type><name>t</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list><block>{<block_content>
<switch>switch<condition>(<expr><call><name>ttype</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<case>case <expr><literal type="number">3</literal></expr>:</case>
<return>return <expr><call><name>hashnum</name><argument_list>(<argument><expr><name>t</name></expr></argument>,<argument><expr><call><name>nvalue</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><literal type="number">4</literal></expr>:</case>
<return>return <expr><call><name>hashstr</name><argument_list>(<argument><expr><name>t</name></expr></argument>,<argument><expr><call><name>rawtsvalue</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><literal type="number">1</literal></expr>:</case>
<return>return <expr><call><name>hashboolean</name><argument_list>(<argument><expr><name>t</name></expr></argument>,<argument><expr><call><name>bvalue</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><literal type="number">2</literal></expr>:</case>
<return>return <expr><call><name>hashpointer</name><argument_list>(<argument><expr><name>t</name></expr></argument>,<argument><expr><call><name>pvalue</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<default>default:</default>
<return>return <expr><call><name>hashpointer</name><argument_list>(<argument><expr><name>t</name></expr></argument>,<argument><expr><call><name>gcvalue</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>arrayindex</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><call><name>ttisnumber</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<decl_stmt><decl><type><name>lua_Number</name></type> <name>n</name><init>=<expr><call><name>nvalue</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>lua_number2int</name><argument_list>(<argument><expr><name>k</name></expr></argument>,<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><call><name>luai_numeq</name><argument_list>(<argument><expr><call><name>cast_num</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>k</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return<expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>findindex</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>Table</name><modifier>*</modifier></type><name>t</name></decl></parameter>,<parameter><decl><type><name>StkId</name></type> <name>key</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><call><name>ttisnil</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content><return>return<expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>i</name><operator>=</operator><call><name>arrayindex</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><literal type="number">0</literal><operator>&lt;</operator><name>i</name><operator>&amp;&amp;</operator><name>i</name><operator>&lt;=</operator><name><name>t</name><operator>-&gt;</operator><name>sizearray</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
<else>else<block>{<block_content>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type><name>n</name><init>=<expr><call><name>mainposition</name><argument_list>(<argument><expr><name>t</name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<do>do<block>{<block_content>
<if_stmt><if>if<condition>(<expr><call><name>luaO_rawequalObj</name><argument_list>(<argument><expr><call><name>key2tval</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call><operator>||</operator>
<operator>(</operator><call><name>ttype</name><argument_list>(<argument><expr><call><name>gkey</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>==</operator><operator>(</operator><literal type="number">8</literal><operator>+</operator><literal type="number">3</literal><operator>)</operator><operator>&amp;&amp;</operator><call><name>iscollectable</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call><operator>&amp;&amp;</operator>
<call><name>gcvalue</name><argument_list>(<argument><expr><call><name>gkey</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>==</operator><call><name>gcvalue</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block>{<block_content>
<expr_stmt><expr><name>i</name><operator>=</operator><call><name>cast_int</name><argument_list>(<argument><expr><name>n</name><operator>-</operator><call><name>gnode</name><argument_list>(<argument><expr><name>t</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>i</name><operator>+</operator><name><name>t</name><operator>-&gt;</operator><name>sizearray</name></name></expr>;</return>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>n</name><operator>=</operator><call><name>gnext</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block>while<condition>(<expr><name>n</name></expr>)</condition>;</do>
<expr_stmt><expr><call><name>luaG_runerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"invalid key to "</literal><call><name>LUA_QL</name><argument_list>(<argument><expr><literal type="string">"next"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>luaH_next</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>Table</name><modifier>*</modifier></type><name>t</name></decl></parameter>,<parameter><decl><type><name>StkId</name></type> <name>key</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name><init>=<expr><call><name>findindex</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>t</name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<for>for<control>(<init><expr><name>i</name><operator>++</operator></expr>;</init><condition><expr><name>i</name><operator>&lt;</operator><name><name>t</name><operator>-&gt;</operator><name>sizearray</name></name></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ttisnil</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>t</name><operator>-&gt;</operator><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>setnvalue</name><argument_list>(<argument><expr><name>key</name></expr></argument>,<argument><expr><call><name>cast_num</name><argument_list>(<argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>key</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>t</name><operator>-&gt;</operator><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<for>for<control>(<init><expr><name>i</name><operator>-=</operator><name><name>t</name><operator>-&gt;</operator><name>sizearray</name></name></expr>;</init><condition><expr><name>i</name><operator>&lt;</operator><operator>(</operator><name>int</name><operator>)</operator><call><name>sizenode</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ttisnil</name><argument_list>(<argument><expr><call><name>gval</name><argument_list>(<argument><expr><call><name>gnode</name><argument_list>(<argument><expr><name>t</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>setobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><call><name>key2tval</name><argument_list>(<argument><expr><call><name>gnode</name><argument_list>(<argument><expr><name>t</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>key</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><call><name>gval</name><argument_list>(<argument><expr><call><name>gnode</name><argument_list>(<argument><expr><name>t</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>computesizes</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name><name>nums</name><index>[]</index></name></decl></parameter>,<parameter><decl><type><name>int</name><modifier>*</modifier></type><name>narray</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>twotoi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>a</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>na</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator><expr><name>twotoi</name><operator>=</operator><literal type="number">1</literal></expr>;</init><condition><expr><name>twotoi</name><operator>/</operator><literal type="number">2</literal><operator>&lt;</operator><operator>*</operator><name>narray</name></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator><expr><name>twotoi</name><operator>*=</operator><literal type="number">2</literal></expr></incr>)</control><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name><name>nums</name><index>[<expr><name>i</name></expr>]</index></name><operator>&gt;</operator><literal type="number">0</literal></expr>)</condition><block>{<block_content>
<expr_stmt><expr><name>a</name><operator>+=</operator><name><name>nums</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>a</name><operator>&gt;</operator><name>twotoi</name><operator>/</operator><literal type="number">2</literal></expr>)</condition><block>{<block_content>
<expr_stmt><expr><name>n</name><operator>=</operator><name>twotoi</name></expr>;</expr_stmt>
<expr_stmt><expr><name>na</name><operator>=</operator><name>a</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><name>a</name><operator>==</operator><operator>*</operator><name>narray</name></expr>)</condition><block type="pseudo"><block_content><break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><operator>*</operator><name>narray</name><operator>=</operator><name>n</name></expr>;</expr_stmt>
<return>return <expr><name>na</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>countint</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>key</name></decl></parameter>,<parameter><decl><type><name>int</name><modifier>*</modifier></type><name>nums</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>k</name><init>=<expr><call><name>arrayindex</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><literal type="number">0</literal><operator>&lt;</operator><name>k</name><operator>&amp;&amp;</operator><name>k</name><operator>&lt;=</operator><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><operator>(</operator><literal type="number">32</literal><operator>-</operator><literal type="number">2</literal><operator>)</operator><operator>)</operator></expr>)</condition><block>{<block_content>
<expr_stmt><expr><name><name>nums</name><index>[<expr><call><name>ceillog2</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>numusearray</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Table</name><modifier>*</modifier></type><name>t</name></decl></parameter>,<parameter><decl><type><name>int</name><modifier>*</modifier></type><name>nums</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>lg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ttlg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ause</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name><init>=<expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<for>for<control>(<init><expr><name>lg</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator><expr><name>ttlg</name><operator>=</operator><literal type="number">1</literal></expr>;</init><condition><expr><name>lg</name><operator>&lt;=</operator><operator>(</operator><literal type="number">32</literal><operator>-</operator><literal type="number">2</literal><operator>)</operator></expr>;</condition><incr><expr><name>lg</name><operator>++</operator></expr><operator>,</operator><expr><name>ttlg</name><operator>*=</operator><literal type="number">2</literal></expr></incr>)</control><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>lc</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>lim</name><init>=<expr><name>ttlg</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>lim</name><operator>&gt;</operator><name><name>t</name><operator>-&gt;</operator><name>sizearray</name></name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><name>lim</name><operator>=</operator><name><name>t</name><operator>-&gt;</operator><name>sizearray</name></name></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>i</name><operator>&gt;</operator><name>lim</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<for>for<control>(<init>;</init><condition><expr><name>i</name><operator>&lt;=</operator><name>lim</name></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ttisnil</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>t</name><operator>-&gt;</operator><name>array</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>lc</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>nums</name><index>[<expr><name>lg</name></expr>]</index></name><operator>+=</operator><name>lc</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ause</name><operator>+=</operator><name>lc</name></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><name>ause</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>numusehash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Table</name><modifier>*</modifier></type><name>t</name></decl></parameter>,<parameter><decl><type><name>int</name><modifier>*</modifier></type><name>nums</name></decl></parameter>,<parameter><decl><type><name>int</name><modifier>*</modifier></type><name>pnasize</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>totaluse</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ause</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name><init>=<expr><call><name>sizenode</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<while>while<condition>(<expr><name>i</name><operator>--</operator></expr>)</condition><block>{<block_content>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type><name>n</name><init>=<expr><operator>&amp;</operator><name><name>t</name><operator>-&gt;</operator><name>node</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ttisnil</name><argument_list>(<argument><expr><call><name>gval</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<expr_stmt><expr><name>ause</name><operator>+=</operator><call><name>countint</name><argument_list>(<argument><expr><call><name>key2tval</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>nums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>totaluse</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><operator>*</operator><name>pnasize</name><operator>+=</operator><name>ause</name></expr>;</expr_stmt>
<return>return <expr><name>totaluse</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>setarrayvector</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>Table</name><modifier>*</modifier></type><name>t</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaM_reallocvector</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>t</name><operator>-&gt;</operator><name>array</name></name></expr></argument>,<argument><expr><name><name>t</name><operator>-&gt;</operator><name>sizearray</name></name></expr></argument>,<argument><expr><name>size</name></expr></argument>,<argument><expr><name>TValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for<control>(<init><expr><name>i</name><operator>=</operator><name><name>t</name><operator>-&gt;</operator><name>sizearray</name></name></expr>;</init><condition><expr><name>i</name><operator>&lt;</operator><name>size</name></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>setnilvalue</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>t</name><operator>-&gt;</operator><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>sizearray</name></name><operator>=</operator><name>size</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>setnodevector</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>Table</name><modifier>*</modifier></type><name>t</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>lsize</name></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>size</name><operator>==</operator><literal type="number">0</literal></expr>)</condition><block>{<block_content>
<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>node</name></name><operator>=</operator><call><name>cast</name><argument_list>(<argument><expr><name>Node</name><operator>*</operator></expr></argument>,<argument><expr><operator>(</operator><operator>&amp;</operator><name>dummynode_</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lsize</name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><name>lsize</name><operator>=</operator><call><name>ceillog2</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>lsize</name><operator>&gt;</operator><operator>(</operator><literal type="number">32</literal><operator>-</operator><literal type="number">2</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaG_runerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"table overflow"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>size</name><operator>=</operator><call><name>twoto</name><argument_list>(<argument><expr><name>lsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>node</name></name><operator>=</operator><call><name>luaM_newvector</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>size</name></expr></argument>,<argument><expr><name>Node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init><condition><expr><name>i</name><operator>&lt;</operator><name>size</name></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type><name>n</name><init>=<expr><call><name>gnode</name><argument_list>(<argument><expr><name>t</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>gnext</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>=</operator><name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setnilvalue</name><argument_list>(<argument><expr><call><name>gkey</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setnilvalue</name><argument_list>(<argument><expr><call><name>gval</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>lsizenode</name></name><operator>=</operator><call><name>cast_byte</name><argument_list>(<argument><expr><name>lsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>lastfree</name></name><operator>=</operator><call><name>gnode</name><argument_list>(<argument><expr><name>t</name></expr></argument>,<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>resize</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>Table</name><modifier>*</modifier></type><name>t</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>nasize</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>nhsize</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>oldasize</name><init>=<expr><name><name>t</name><operator>-&gt;</operator><name>sizearray</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>oldhsize</name><init>=<expr><name><name>t</name><operator>-&gt;</operator><name>lsizenode</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type><name>nold</name><init>=<expr><name><name>t</name><operator>-&gt;</operator><name>node</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>nasize</name><operator>&gt;</operator><name>oldasize</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>setarrayvector</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>t</name></expr></argument>,<argument><expr><name>nasize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>setnodevector</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>t</name></expr></argument>,<argument><expr><name>nhsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>nasize</name><operator>&lt;</operator><name>oldasize</name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>sizearray</name></name><operator>=</operator><name>nasize</name></expr>;</expr_stmt>
<for>for<control>(<init><expr><name>i</name><operator>=</operator><name>nasize</name></expr>;</init><condition><expr><name>i</name><operator>&lt;</operator><name>oldasize</name></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ttisnil</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>t</name><operator>-&gt;</operator><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>setobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>luaH_setnum</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>t</name></expr></argument>,<argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>t</name><operator>-&gt;</operator><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>luaM_reallocvector</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>t</name><operator>-&gt;</operator><name>array</name></name></expr></argument>,<argument><expr><name>oldasize</name></expr></argument>,<argument><expr><name>nasize</name></expr></argument>,<argument><expr><name>TValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<for>for<control>(<init><expr><name>i</name><operator>=</operator><call><name>twoto</name><argument_list>(<argument><expr><name>oldhsize</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr>;</init><condition><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition><incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type><name>old</name><init>=<expr><name>nold</name><operator>+</operator><name>i</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ttisnil</name><argument_list>(<argument><expr><call><name>gval</name><argument_list>(<argument><expr><name>old</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>setobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>luaH_set</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>t</name></expr></argument>,<argument><expr><call><name>key2tval</name><argument_list>(<argument><expr><name>old</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>gval</name><argument_list>(<argument><expr><name>old</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if<condition>(<expr><name>nold</name><operator>!=</operator><operator>(</operator><operator>&amp;</operator><name>dummynode_</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaM_freearray</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>nold</name></expr></argument>,<argument><expr><call><name>twoto</name><argument_list>(<argument><expr><name>oldhsize</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>Node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaH_resizearray</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>Table</name><modifier>*</modifier></type><name>t</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>nasize</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>nsize</name><init>=<expr><ternary><condition><expr><operator>(</operator><name><name>t</name><operator>-&gt;</operator><name>node</name></name><operator>==</operator><operator>(</operator><operator>&amp;</operator><name>dummynode_</name><operator>)</operator><operator>)</operator></expr>?</condition><then><expr><literal type="number">0</literal></expr></then><else>:<expr><call><name>sizenode</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>resize</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>t</name></expr></argument>,<argument><expr><name>nasize</name></expr></argument>,<argument><expr><name>nsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>rehash</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>Table</name><modifier>*</modifier></type><name>t</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>ek</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>nasize</name></decl>,<decl><type ref="prev"/><name>na</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>nums</name><index>[<expr><operator>(</operator><literal type="number">32</literal><operator>-</operator><literal type="number">2</literal><operator>)</operator><operator>+</operator><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>totaluse</name></decl>;</decl_stmt>
<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init><condition><expr><name>i</name><operator>&lt;=</operator><operator>(</operator><literal type="number">32</literal><operator>-</operator><literal type="number">2</literal><operator>)</operator></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content><expr_stmt><expr><name><name>nums</name><index>[<expr><name>i</name></expr>]</index></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><name>nasize</name><operator>=</operator><call><name>numusearray</name><argument_list>(<argument><expr><name>t</name></expr></argument>,<argument><expr><name>nums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>totaluse</name><operator>=</operator><name>nasize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>totaluse</name><operator>+=</operator><call><name>numusehash</name><argument_list>(<argument><expr><name>t</name></expr></argument>,<argument><expr><name>nums</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>nasize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>nasize</name><operator>+=</operator><call><name>countint</name><argument_list>(<argument><expr><name>ek</name></expr></argument>,<argument><expr><name>nums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>totaluse</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>na</name><operator>=</operator><call><name>computesizes</name><argument_list>(<argument><expr><name>nums</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>nasize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>resize</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>t</name></expr></argument>,<argument><expr><name>nasize</name></expr></argument>,<argument><expr><name>totaluse</name><operator>-</operator><name>na</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>Table</name><modifier>*</modifier></type><name>luaH_new</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>narray</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>nhash</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>Table</name><modifier>*</modifier></type><name>t</name><init>=<expr><call><name>luaM_new</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>Table</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaC_link</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>obj2gco</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>metatable</name></name><operator>=</operator><name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>flags</name></name><operator>=</operator><call><name>cast_byte</name><argument_list>(<argument><expr><operator>~</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>array</name></name><operator>=</operator><name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>sizearray</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>lsizenode</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>node</name></name><operator>=</operator><call><name>cast</name><argument_list>(<argument><expr><name>Node</name><operator>*</operator></expr></argument>,<argument><expr><operator>(</operator><operator>&amp;</operator><name>dummynode_</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setarrayvector</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>t</name></expr></argument>,<argument><expr><name>narray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setnodevector</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>t</name></expr></argument>,<argument><expr><name>nhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>t</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaH_free</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>Table</name><modifier>*</modifier></type><name>t</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>node</name></name><operator>!=</operator><operator>(</operator><operator>&amp;</operator><name>dummynode_</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaM_freearray</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>t</name><operator>-&gt;</operator><name>node</name></name></expr></argument>,<argument><expr><call><name>sizenode</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>Node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>luaM_freearray</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>t</name><operator>-&gt;</operator><name>array</name></name></expr></argument>,<argument><expr><name><name>t</name><operator>-&gt;</operator><name>sizearray</name></name></expr></argument>,<argument><expr><name>TValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaM_free</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>Node</name><modifier>*</modifier></type><name>getfreepos</name><parameter_list>(<parameter><decl><type><name>Table</name><modifier>*</modifier></type><name>t</name></decl></parameter>)</parameter_list><block>{<block_content>
<while>while<condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>lastfree</name></name><operator>--</operator><operator>&gt;</operator><name><name>t</name><operator>-&gt;</operator><name>node</name></name></expr>)</condition><block>{<block_content>
<if_stmt><if>if<condition>(<expr><call><name>ttisnil</name><argument_list>(<argument><expr><call><name>gkey</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>lastfree</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>t</name><operator>-&gt;</operator><name>lastfree</name></name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></while>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>TValue</name><modifier>*</modifier></type><name>newkey</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>Table</name><modifier>*</modifier></type><name>t</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type><name>mp</name><init>=<expr><call><name>mainposition</name><argument_list>(<argument><expr><name>t</name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ttisnil</name><argument_list>(<argument><expr><call><name>gval</name><argument_list>(<argument><expr><name>mp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>||</operator><name>mp</name><operator>==</operator><operator>(</operator><operator>&amp;</operator><name>dummynode_</name><operator>)</operator></expr>)</condition><block>{<block_content>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type><name>othern</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type><name>n</name><init>=<expr><call><name>getfreepos</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>n</name><operator>==</operator><name>NULL</name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>rehash</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>t</name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>luaH_set</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>t</name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>othern</name><operator>=</operator><call><name>mainposition</name><argument_list>(<argument><expr><name>t</name></expr></argument>,<argument><expr><call><name>key2tval</name><argument_list>(<argument><expr><name>mp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>othern</name><operator>!=</operator><name>mp</name></expr>)</condition><block>{<block_content>
<while>while<condition>(<expr><call><name>gnext</name><argument_list>(<argument><expr><name>othern</name></expr></argument>)</argument_list></call><operator>!=</operator><name>mp</name></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><name>othern</name><operator>=</operator><call><name>gnext</name><argument_list>(<argument><expr><name>othern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
<expr_stmt><expr><call><name>gnext</name><argument_list>(<argument><expr><name>othern</name></expr></argument>)</argument_list></call><operator>=</operator><name>n</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>n</name><operator>=</operator><operator>*</operator><name>mp</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gnext</name><argument_list>(<argument><expr><name>mp</name></expr></argument>)</argument_list></call><operator>=</operator><name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setnilvalue</name><argument_list>(<argument><expr><call><name>gval</name><argument_list>(<argument><expr><name>mp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block>{<block_content>
<expr_stmt><expr><call><name>gnext</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>=</operator><call><name>gnext</name><argument_list>(<argument><expr><name>mp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gnext</name><argument_list>(<argument><expr><name>mp</name></expr></argument>)</argument_list></call><operator>=</operator><name>n</name></expr>;</expr_stmt>
<expr_stmt><expr><name>mp</name><operator>=</operator><name>n</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>gkey</name><argument_list>(<argument><expr><name>mp</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>value</name><operator>=</operator><name><name>key</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt><expr_stmt><expr><call><name>gkey</name><argument_list>(<argument><expr><name>mp</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>tt</name><operator>=</operator><name><name>key</name><operator>-&gt;</operator><name>tt</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaC_barriert</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>t</name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>gval</name><argument_list>(<argument><expr><name>mp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>luaH_getnum</name><parameter_list>(<parameter><decl><type><name>Table</name><modifier>*</modifier></type><name>t</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>key</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><macro><name>cast</name><argument_list>(<argument>unsigned int</argument>,<argument>key</argument>)</argument_list></macro><operator>-</operator><literal type="number">1</literal><operator>&lt;</operator><macro><name>cast</name><argument_list>(<argument>unsigned int</argument>,<argument>t-&gt;sizearray</argument>)</argument_list></macro></expr>)</condition><block type="pseudo"><block_content>
<return>return<expr><operator>&amp;</operator><name><name>t</name><operator>-&gt;</operator><name>array</name><index>[<expr><name>key</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</return></block_content></block></if>
<else>else<block>{<block_content>
<decl_stmt><decl><type><name>lua_Number</name></type> <name>nk</name><init>=<expr><call><name>cast_num</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type><name>n</name><init>=<expr><call><name>hashnum</name><argument_list>(<argument><expr><name>t</name></expr></argument>,<argument><expr><name>nk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<do>do<block>{<block_content>
<if_stmt><if>if<condition>(<expr><call><name>ttisnumber</name><argument_list>(<argument><expr><call><name>gkey</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>&amp;&amp;</operator><call><name>luai_numeq</name><argument_list>(<argument><expr><call><name>nvalue</name><argument_list>(<argument><expr><call><name>gkey</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>nk</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>gval</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>n</name><operator>=</operator><call><name>gnext</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block>while<condition>(<expr><name>n</name></expr>)</condition>;</do>
<return>return<expr><operator>(</operator><operator>&amp;</operator><name>luaO_nilobject_</name><operator>)</operator></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>luaH_getstr</name><parameter_list>(<parameter><decl><type><name>Table</name><modifier>*</modifier></type><name>t</name></decl></parameter>,<parameter><decl><type><name>TString</name><modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type><name>n</name><init>=<expr><call><name>hashstr</name><argument_list>(<argument><expr><name>t</name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<do>do<block>{<block_content>
<if_stmt><if>if<condition>(<expr><call><name>ttisstring</name><argument_list>(<argument><expr><call><name>gkey</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>&amp;&amp;</operator><call><name>rawtsvalue</name><argument_list>(<argument><expr><call><name>gkey</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>==</operator><name>key</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>gval</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>n</name><operator>=</operator><call><name>gnext</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block>while<condition>(<expr><name>n</name></expr>)</condition>;</do>
<return>return<expr><operator>(</operator><operator>&amp;</operator><name>luaO_nilobject_</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>luaH_get</name><parameter_list>(<parameter><decl><type><name>Table</name><modifier>*</modifier></type><name>t</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list><block>{<block_content>
<switch>switch<condition>(<expr><call><name>ttype</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case><return>return<expr><operator>(</operator><operator>&amp;</operator><name>luaO_nilobject_</name><operator>)</operator></expr>;</return>
<case>case <expr><literal type="number">4</literal></expr>:</case><return>return <expr><call><name>luaH_getstr</name><argument_list>(<argument><expr><name>t</name></expr></argument>,<argument><expr><call><name>rawtsvalue</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><literal type="number">3</literal></expr>:</case><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>lua_Number</name></type> <name>n</name><init>=<expr><call><name>nvalue</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>lua_number2int</name><argument_list>(<argument><expr><name>k</name></expr></argument>,<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><call><name>luai_numeq</name><argument_list>(<argument><expr><call><name>cast_num</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>nvalue</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>luaH_getnum</name><argument_list>(<argument><expr><name>t</name></expr></argument>,<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block>
<default>default:</default><block>{<block_content>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type><name>n</name><init>=<expr><call><name>mainposition</name><argument_list>(<argument><expr><name>t</name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<do>do<block>{<block_content>
<if_stmt><if>if<condition>(<expr><call><name>luaO_rawequalObj</name><argument_list>(<argument><expr><call><name>key2tval</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>gval</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>n</name><operator>=</operator><call><name>gnext</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block>while<condition>(<expr><name>n</name></expr>)</condition>;</do>
<return>return<expr><operator>(</operator><operator>&amp;</operator><name>luaO_nilobject_</name><operator>)</operator></expr>;</return>
</block_content>}</block>
</block_content>}</block></switch>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>TValue</name><modifier>*</modifier></type><name>luaH_set</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>Table</name><modifier>*</modifier></type><name>t</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>p</name><init>=<expr><call><name>luaH_get</name><argument_list>(<argument><expr><name>t</name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>flags</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>p</name><operator>!=</operator><operator>(</operator><operator>&amp;</operator><name>luaO_nilobject_</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>cast</name><argument_list>(<argument><expr><name>TValue</name><operator>*</operator></expr></argument>,<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block>{<block_content>
<if_stmt><if>if<condition>(<expr><call><name>ttisnil</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><call><name>luaG_runerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"table index is nil"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if<condition>(<expr><call><name>ttisnumber</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call><operator>&amp;&amp;</operator><call><name>luai_numisnan</name><argument_list>(<argument><expr><call><name>nvalue</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaG_runerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"table index is NaN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><call><name>newkey</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>t</name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>TValue</name><modifier>*</modifier></type><name>luaH_setnum</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>Table</name><modifier>*</modifier></type><name>t</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>key</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>p</name><init>=<expr><call><name>luaH_getnum</name><argument_list>(<argument><expr><name>t</name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>p</name><operator>!=</operator><operator>(</operator><operator>&amp;</operator><name>luaO_nilobject_</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>cast</name><argument_list>(<argument><expr><name>TValue</name><operator>*</operator></expr></argument>,<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block>{<block_content>
<decl_stmt><decl><type><name>TValue</name></type> <name>k</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>setnvalue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>k</name></expr></argument>,<argument><expr><call><name>cast_num</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>newkey</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>t</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>k</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>TValue</name><modifier>*</modifier></type><name>luaH_setstr</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>Table</name><modifier>*</modifier></type><name>t</name></decl></parameter>,<parameter><decl><type><name>TString</name><modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>p</name><init>=<expr><call><name>luaH_getstr</name><argument_list>(<argument><expr><name>t</name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>p</name><operator>!=</operator><operator>(</operator><operator>&amp;</operator><name>luaO_nilobject_</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>cast</name><argument_list>(<argument><expr><name>TValue</name><operator>*</operator></expr></argument>,<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block>{<block_content>
<decl_stmt><decl><type><name>TValue</name></type> <name>k</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>setsvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>k</name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>newkey</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>t</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>k</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unbound_search</name><parameter_list>(<parameter><decl><type><name>Table</name><modifier>*</modifier></type><name>t</name></decl></parameter>,<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>j</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name><init>=<expr><name>j</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
<while>while<condition>(<expr><operator>!</operator><call><name>ttisnil</name><argument_list>(<argument><expr><call><name>luaH_getnum</name><argument_list>(<argument><expr><name>t</name></expr></argument>,<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<expr_stmt><expr><name>i</name><operator>=</operator><name>j</name></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name><operator>*=</operator><literal type="number">2</literal></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>j</name><operator>&gt;</operator><macro><name>cast</name><argument_list>(<argument>unsigned int</argument>,<argument>(INT_MAX-<literal type="number">2</literal>)</argument>)</argument_list></macro></expr>)</condition><block>{<block_content>
<expr_stmt><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</expr_stmt>
<while>while<condition>(<expr><operator>!</operator><call><name>ttisnil</name><argument_list>(<argument><expr><call><name>luaH_getnum</name><argument_list>(<argument><expr><name>t</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
<return>return <expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
<while>while<condition>(<expr><name>j</name><operator>-</operator><name>i</name><operator>&gt;</operator><literal type="number">1</literal></expr>)</condition><block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>m</name><init>=<expr><operator>(</operator><name>i</name><operator>+</operator><name>j</name><operator>)</operator><operator>/</operator><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><call><name>ttisnil</name><argument_list>(<argument><expr><call><name>luaH_getnum</name><argument_list>(<argument><expr><name>t</name></expr></argument>,<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><name>j</name><operator>=</operator><name>m</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>i</name><operator>=</operator><name>m</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></while>
<return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>luaH_getn</name><parameter_list>(<parameter><decl><type><name>Table</name><modifier>*</modifier></type><name>t</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>j</name><init>=<expr><name><name>t</name><operator>-&gt;</operator><name>sizearray</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>j</name><operator>&gt;</operator><literal type="number">0</literal><operator>&amp;&amp;</operator><call><name>ttisnil</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>t</name><operator>-&gt;</operator><name>array</name><index>[<expr><name>j</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<while>while<condition>(<expr><name>j</name><operator>-</operator><name>i</name><operator>&gt;</operator><literal type="number">1</literal></expr>)</condition><block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>m</name><init>=<expr><operator>(</operator><name>i</name><operator>+</operator><name>j</name><operator>)</operator><operator>/</operator><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><call><name>ttisnil</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>t</name><operator>-&gt;</operator><name>array</name><index>[<expr><name>m</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><name>j</name><operator>=</operator><name>m</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>i</name><operator>=</operator><name>m</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></while>
<return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></if>
<if type="elseif">else if<condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>node</name></name><operator>==</operator><operator>(</operator><operator>&amp;</operator><name>dummynode_</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>j</name></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content> <return>return <expr><call><name>unbound_search</name><argument_list>(<argument><expr><name>t</name></expr></argument>,<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>makewhite</name><parameter_list>(<parameter><type><name>g</name></type></parameter>,<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((x)-&gt;gch.marked=cast_byte(((x)-&gt;gch.marked&amp;cast_byte(~(bitmask(2)|bit2mask(0,1))))|luaC_white(g)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>white2gray</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>reset2bits((x)-&gt;gch.marked,0,1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>black2gray</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>resetbit((x)-&gt;gch.marked,2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>stringmark</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>reset2bits((s)-&gt;tsv.marked,0,1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>isfinalized</name><parameter_list>(<parameter><type><name>u</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>testbit((u)-&gt;marked,3)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>markfinalized</name><parameter_list>(<parameter><type><name>u</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>l_setbit((u)-&gt;marked,3)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>markvalue</name><parameter_list>(<parameter><type><name>g</name></type></parameter>,<parameter><type><name>o</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>{checkconsistency(o);if(iscollectable(o)&amp;&amp;iswhite(gcvalue(o)))reallymarkobject(g,gcvalue(o));}</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>markobject</name><parameter_list>(<parameter><type><name>g</name></type></parameter>,<parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>{if(iswhite(obj2gco(t)))reallymarkobject(g,obj2gco(t));}</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>setthreshold</name><parameter_list>(<parameter><type><name>g</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(g-&gt;GCthreshold=(g-&gt;estimate/100)*g-&gt;gcpause)</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>void</name></type> <name>removeentry</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><call><name>iscollectable</name><argument_list>(<argument><expr><call><name>gkey</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>setttype</name><argument_list>(<argument><expr><call><name>gkey</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><operator>(</operator><literal type="number">8</literal><operator>+</operator><literal type="number">3</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>reallymarkobject</name><parameter_list>(<parameter><decl><type><name>global_State</name><modifier>*</modifier></type><name>g</name></decl></parameter>,<parameter><decl><type><name>GCObject</name><modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>white2gray</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch<condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>tt</name></name></expr>)</condition><block>{<block_content>
<case>case <expr><literal type="number">4</literal></expr>:</case><block>{<block_content>
<return>return;</return>
</block_content>}</block>
<case>case <expr><literal type="number">7</literal></expr>:</case><block>{<block_content>
<decl_stmt><decl><type><name>Table</name><modifier>*</modifier></type><name>mt</name><init>=<expr><call><name>gco2u</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>metatable</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>gray2black</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>mt</name></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><call><name>markobject</name><argument_list>(<argument><expr><name>g</name></expr></argument>,<argument><expr><name>mt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>markobject</name><argument_list>(<argument><expr><name>g</name></expr></argument>,<argument><expr><call><name>gco2u</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block>
<case>case<expr><operator>(</operator><literal type="number">8</literal><operator>+</operator><literal type="number">2</literal><operator>)</operator></expr>:</case><block>{<block_content>
<decl_stmt><decl><type><name>UpVal</name><modifier>*</modifier></type><name>uv</name><init>=<expr><call><name>gco2uv</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>markvalue</name><argument_list>(<argument><expr><name>g</name></expr></argument>,<argument><expr><name><name>uv</name><operator>-&gt;</operator><name>v</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name><name>uv</name><operator>-&gt;</operator><name>v</name></name><operator>==</operator><operator>&amp;</operator><name><name>uv</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>value</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>gray2black</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return;</return>
</block_content>}</block>
<case>case <expr><literal type="number">6</literal></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>gco2cl</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>c</name><operator>.</operator><name>gclist</name></name><operator>=</operator><name><name>g</name><operator>-&gt;</operator><name>gray</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gray</name></name><operator>=</operator><name>o</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><literal type="number">5</literal></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>gco2h</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>gclist</name><operator>=</operator><name><name>g</name><operator>-&gt;</operator><name>gray</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gray</name></name><operator>=</operator><name>o</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><literal type="number">8</literal></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>gco2th</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>gclist</name><operator>=</operator><name><name>g</name><operator>-&gt;</operator><name>gray</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gray</name></name><operator>=</operator><name>o</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case<expr><operator>(</operator><literal type="number">8</literal><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>gco2p</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>gclist</name><operator>=</operator><name><name>g</name><operator>-&gt;</operator><name>gray</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gray</name></name><operator>=</operator><name>o</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<default>default:</default><empty_stmt>;</empty_stmt>
</block_content>}</block></switch>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>marktmu</name><parameter_list>(<parameter><decl><type><name>global_State</name><modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>GCObject</name><modifier>*</modifier></type><name>u</name><init>=<expr><name><name>g</name><operator>-&gt;</operator><name>tmudata</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>u</name></expr>)</condition><block>{<block_content>
<do>do<block>{<block_content>
<expr_stmt><expr><name>u</name><operator>=</operator><name><name>u</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>makewhite</name><argument_list>(<argument><expr><name>g</name></expr></argument>,<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>reallymarkobject</name><argument_list>(<argument><expr><name>g</name></expr></argument>,<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>while<condition>(<expr><name>u</name><operator>!=</operator><name><name>g</name><operator>-&gt;</operator><name>tmudata</name></name></expr>)</condition>;</do>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>luaC_separateudata</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>all</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>global_State</name><modifier>*</modifier></type><name>g</name><init>=<expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>deadmem</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GCObject</name><modifier>*</modifier><modifier>*</modifier></type><name>p</name><init>=<expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>mainthread</name><operator>-&gt;</operator><name>next</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GCObject</name><modifier>*</modifier></type><name>curr</name></decl>;</decl_stmt>
<while>while<condition>(<expr><operator>(</operator><name>curr</name><operator>=</operator><operator>*</operator><name>p</name><operator>)</operator><operator>!=</operator><name>NULL</name></expr>)</condition><block>{<block_content>
<if_stmt><if>if<condition>(<expr><operator>!</operator><operator>(</operator><call><name>iswhite</name><argument_list>(<argument><expr><name>curr</name></expr></argument>)</argument_list></call><operator>||</operator><name>all</name><operator>)</operator><operator>||</operator><call><name>isfinalized</name><argument_list>(<argument><expr><call><name>gco2u</name><argument_list>(<argument><expr><name>curr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>p</name><operator>=</operator><operator>&amp;</operator><name><name>curr</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if<condition>(<expr><call><name>fasttm</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>gco2u</name><argument_list>(<argument><expr><name>curr</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>metatable</name></expr></argument>,<argument><expr><name>TM_GC</name></expr></argument>)</argument_list></call><operator>==</operator><name>NULL</name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>markfinalized</name><argument_list>(<argument><expr><call><name>gco2u</name><argument_list>(<argument><expr><name>curr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name><operator>=</operator><operator>&amp;</operator><name><name>curr</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block>{<block_content>
<expr_stmt><expr><name>deadmem</name><operator>+=</operator><call><name>sizeudata</name><argument_list>(<argument><expr><call><name>gco2u</name><argument_list>(<argument><expr><name>curr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>markfinalized</name><argument_list>(<argument><expr><call><name>gco2u</name><argument_list>(<argument><expr><name>curr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>p</name><operator>=</operator><name><name>curr</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>tmudata</name></name><operator>==</operator><name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>tmudata</name></name><operator>=</operator><name><name>curr</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>next</name></name><operator>=</operator><name>curr</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block>{<block_content>
<expr_stmt><expr><name><name>curr</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>next</name></name><operator>=</operator><name><name>g</name><operator>-&gt;</operator><name>tmudata</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>tmudata</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>next</name></name><operator>=</operator><name>curr</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>tmudata</name></name><operator>=</operator><name>curr</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
<return>return <expr><name>deadmem</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>traversetable</name><parameter_list>(<parameter><decl><type><name>global_State</name><modifier>*</modifier></type><name>g</name></decl></parameter>,<parameter><decl><type><name>Table</name><modifier>*</modifier></type><name>h</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>weakkey</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>weakvalue</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>mode</name></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>metatable</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>markobject</name><argument_list>(<argument><expr><name>g</name></expr></argument>,<argument><expr><name><name>h</name><operator>-&gt;</operator><name>metatable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>mode</name><operator>=</operator><call><name>gfasttm</name><argument_list>(<argument><expr><name>g</name></expr></argument>,<argument><expr><name><name>h</name><operator>-&gt;</operator><name>metatable</name></name></expr></argument>,<argument><expr><name>TM_MODE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>mode</name><operator>&amp;&amp;</operator><call><name>ttisstring</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<expr_stmt><expr><name>weakkey</name><operator>=</operator><operator>(</operator><call><name>strchr</name><argument_list>(<argument><expr><call><name>svalue</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><literal type="char">'k'</literal></expr></argument>)</argument_list></call><operator>!=</operator><name>NULL</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>weakvalue</name><operator>=</operator><operator>(</operator><call><name>strchr</name><argument_list>(<argument><expr><call><name>svalue</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><literal type="char">'v'</literal></expr></argument>)</argument_list></call><operator>!=</operator><name>NULL</name><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>weakkey</name><operator>||</operator><name>weakvalue</name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>marked</name></name><operator>&amp;=</operator><operator>~</operator><operator>(</operator><call><name>bitmask</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call><operator>|</operator><call><name>bitmask</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>marked</name></name><operator>|=</operator><call><name>cast_byte</name><argument_list>(<argument><expr><operator>(</operator><name>weakkey</name><operator>&lt;&lt;</operator><literal type="number">3</literal><operator>)</operator><operator>|</operator>
<operator>(</operator><name>weakvalue</name><operator>&lt;&lt;</operator><literal type="number">4</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>gclist</name></name><operator>=</operator><name><name>g</name><operator>-&gt;</operator><name>weak</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>weak</name></name><operator>=</operator><call><name>obj2gco</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><name>weakkey</name><operator>&amp;&amp;</operator><name>weakvalue</name></expr>)</condition><block type="pseudo"><block_content><return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><operator>!</operator><name>weakvalue</name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><name>i</name><operator>=</operator><name><name>h</name><operator>-&gt;</operator><name>sizearray</name></name></expr>;</expr_stmt>
<while>while<condition>(<expr><name>i</name><operator>--</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>markvalue</name><argument_list>(<argument><expr><name>g</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>i</name><operator>=</operator><call><name>sizenode</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while<condition>(<expr><name>i</name><operator>--</operator></expr>)</condition><block>{<block_content>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type><name>n</name><init>=<expr><call><name>gnode</name><argument_list>(<argument><expr><name>h</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><call><name>ttisnil</name><argument_list>(<argument><expr><call><name>gval</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>removeentry</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block>{<block_content>
<if_stmt><if>if<condition>(<expr><operator>!</operator><name>weakkey</name></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><call><name>markvalue</name><argument_list>(<argument><expr><name>g</name></expr></argument>,<argument><expr><call><name>gkey</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><operator>!</operator><name>weakvalue</name></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><call><name>markvalue</name><argument_list>(<argument><expr><name>g</name></expr></argument>,<argument><expr><call><name>gval</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
<return>return <expr><name>weakkey</name><operator>||</operator><name>weakvalue</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>traverseproto</name><parameter_list>(<parameter><decl><type><name>global_State</name><modifier>*</modifier></type><name>g</name></decl></parameter>,<parameter><decl><type><name>Proto</name><modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>source</name></name></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><call><name>stringmark</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>source</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init><condition><expr><name>i</name><operator>&lt;</operator><name><name>f</name><operator>-&gt;</operator><name>sizek</name></name></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>markvalue</name><argument_list>(<argument><expr><name>g</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>f</name><operator>-&gt;</operator><name>k</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init><condition><expr><name>i</name><operator>&lt;</operator><name><name>f</name><operator>-&gt;</operator><name>sizeupvalues</name></name></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>upvalues</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>stringmark</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>upvalues</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init><condition><expr><name>i</name><operator>&lt;</operator><name><name>f</name><operator>-&gt;</operator><name>sizep</name></name></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>markobject</name><argument_list>(<argument><expr><name>g</name></expr></argument>,<argument><expr><name><name>f</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init><condition><expr><name>i</name><operator>&lt;</operator><name><name>f</name><operator>-&gt;</operator><name>sizelocvars</name></name></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>locvars</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>varname</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>stringmark</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>locvars</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>varname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>traverseclosure</name><parameter_list>(<parameter><decl><type><name>global_State</name><modifier>*</modifier></type><name>g</name></decl></parameter>,<parameter><decl><type><name>Closure</name><modifier>*</modifier></type><name>cl</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>markobject</name><argument_list>(<argument><expr><name>g</name></expr></argument>,<argument><expr><name><name>cl</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>env</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name><name>cl</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>isC</name></name></expr>)</condition><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init><condition><expr><name>i</name><operator>&lt;</operator><name><name>cl</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>nupvalues</name></name></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>markvalue</name><argument_list>(<argument><expr><name>g</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>cl</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>upvalue</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></if>
<else>else<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>markobject</name><argument_list>(<argument><expr><name>g</name></expr></argument>,<argument><expr><name><name>cl</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init><condition><expr><name>i</name><operator>&lt;</operator><name><name>cl</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>nupvalues</name></name></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>markobject</name><argument_list>(<argument><expr><name>g</name></expr></argument>,<argument><expr><name><name>cl</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>upvals</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>checkstacksizes</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>StkId</name></type> <name>max</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ci_used</name><init>=<expr><call><name>cast_int</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>ci</name></name><operator>-</operator><name><name>L</name><operator>-&gt;</operator><name>base_ci</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>s_used</name><init>=<expr><call><name>cast_int</name><argument_list>(<argument><expr><name>max</name><operator>-</operator><name><name>L</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name><name>L</name><operator>-&gt;</operator><name>size_ci</name></name><operator>&gt;</operator><literal type="number">20000</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><literal type="number">4</literal><operator>*</operator><name>ci_used</name><operator>&lt;</operator><name><name>L</name><operator>-&gt;</operator><name>size_ci</name></name><operator>&amp;&amp;</operator><literal type="number">2</literal><operator>*</operator><literal type="number">8</literal><operator>&lt;</operator><name><name>L</name><operator>-&gt;</operator><name>size_ci</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaD_reallocCI</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>size_ci</name></name><operator>/</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>condhardstacktests</name><argument_list>(<argument><expr><call><name>luaD_reallocCI</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>ci_used</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><literal type="number">4</literal><operator>*</operator><name>s_used</name><operator>&lt;</operator><name><name>L</name><operator>-&gt;</operator><name>stacksize</name></name><operator>&amp;&amp;</operator>
<literal type="number">2</literal><operator>*</operator><operator>(</operator><operator>(</operator><literal type="number">2</literal><operator>*</operator><literal type="number">20</literal><operator>)</operator><operator>+</operator><literal type="number">5</literal><operator>)</operator><operator>&lt;</operator><name><name>L</name><operator>-&gt;</operator><name>stacksize</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaD_reallocstack</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>stacksize</name></name><operator>/</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>condhardstacktests</name><argument_list>(<argument><expr><call><name>luaD_reallocstack</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>s_used</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>traversestack</name><parameter_list>(<parameter><decl><type><name>global_State</name><modifier>*</modifier></type><name>g</name></decl></parameter>,<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>l</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>StkId</name></type> <name>o</name></decl>,<decl><type ref="prev"/><name>lim</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CallInfo</name><modifier>*</modifier></type><name>ci</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>markvalue</name><argument_list>(<argument><expr><name>g</name></expr></argument>,<argument><expr><call><name>gt</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lim</name><operator>=</operator><name><name>l</name><operator>-&gt;</operator><name>top</name></name></expr>;</expr_stmt>
<for>for<control>(<init><expr><name>ci</name><operator>=</operator><name><name>l</name><operator>-&gt;</operator><name>base_ci</name></name></expr>;</init><condition><expr><name>ci</name><operator>&lt;=</operator><name><name>l</name><operator>-&gt;</operator><name>ci</name></name></expr>;</condition><incr><expr><name>ci</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name>lim</name><operator>&lt;</operator><name><name>ci</name><operator>-&gt;</operator><name>top</name></name></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><name>lim</name><operator>=</operator><name><name>ci</name><operator>-&gt;</operator><name>top</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<for>for<control>(<init><expr><name>o</name><operator>=</operator><name><name>l</name><operator>-&gt;</operator><name>stack</name></name></expr>;</init><condition><expr><name>o</name><operator>&lt;</operator><name><name>l</name><operator>-&gt;</operator><name>top</name></name></expr>;</condition><incr><expr><name>o</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>markvalue</name><argument_list>(<argument><expr><name>g</name></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<for>for<control>(<init>;</init><condition><expr><name>o</name><operator>&lt;=</operator><name>lim</name></expr>;</condition><incr><expr><name>o</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>setnilvalue</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>checkstacksizes</name><argument_list>(<argument><expr><name>l</name></expr></argument>,<argument><expr><name>lim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>l_mem</name></type> <name>propagatemark</name><parameter_list>(<parameter><decl><type><name>global_State</name><modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>GCObject</name><modifier>*</modifier></type><name>o</name><init>=<expr><name><name>g</name><operator>-&gt;</operator><name>gray</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>gray2black</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch<condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>tt</name></name></expr>)</condition><block>{<block_content>
<case>case <expr><literal type="number">5</literal></expr>:</case><block>{<block_content>
<decl_stmt><decl><type><name>Table</name><modifier>*</modifier></type><name>h</name><init>=<expr><call><name>gco2h</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gray</name></name><operator>=</operator><name><name>h</name><operator>-&gt;</operator><name>gclist</name></name></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><call><name>traversetable</name><argument_list>(<argument><expr><name>g</name></expr></argument>,<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>black2gray</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><sizeof>sizeof<argument_list>(<argument><expr><name>Table</name></expr></argument>)</argument_list></sizeof><operator>+</operator><sizeof>sizeof<argument_list>(<argument><expr><name>TValue</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name><name>h</name><operator>-&gt;</operator><name>sizearray</name></name><operator>+</operator>
<sizeof>sizeof<argument_list>(<argument><expr><name>Node</name></expr></argument>)</argument_list></sizeof><operator>*</operator><call><name>sizenode</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>
<case>case <expr><literal type="number">6</literal></expr>:</case><block>{<block_content>
<decl_stmt><decl><type><name>Closure</name><modifier>*</modifier></type><name>cl</name><init>=<expr><call><name>gco2cl</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gray</name></name><operator>=</operator><name><name>cl</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>gclist</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>traverseclosure</name><argument_list>(<argument><expr><name>g</name></expr></argument>,<argument><expr><name>cl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return<expr><ternary><condition><expr><operator>(</operator><name><name>cl</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>isC</name></name><operator>)</operator></expr>?</condition><then><expr><call><name>sizeCclosure</name><argument_list>(<argument><expr><name><name>cl</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>nupvalues</name></name></expr></argument>)</argument_list></call></expr></then><else>:
<expr><call><name>sizeLclosure</name><argument_list>(<argument><expr><name><name>cl</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>nupvalues</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
</block_content>}</block>
<case>case <expr><literal type="number">8</literal></expr>:</case><block>{<block_content>
<decl_stmt><decl><type><name>lua_State</name><modifier>*</modifier></type><name>th</name><init>=<expr><call><name>gco2th</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gray</name></name><operator>=</operator><name><name>th</name><operator>-&gt;</operator><name>gclist</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>gclist</name></name><operator>=</operator><name><name>g</name><operator>-&gt;</operator><name>grayagain</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>grayagain</name></name><operator>=</operator><name>o</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>black2gray</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>traversestack</name><argument_list>(<argument><expr><name>g</name></expr></argument>,<argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><sizeof>sizeof<argument_list>(<argument><expr><name>lua_State</name></expr></argument>)</argument_list></sizeof><operator>+</operator><sizeof>sizeof<argument_list>(<argument><expr><name>TValue</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name><name>th</name><operator>-&gt;</operator><name>stacksize</name></name><operator>+</operator>
<sizeof>sizeof<argument_list>(<argument><expr><name>CallInfo</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name><name>th</name><operator>-&gt;</operator><name>size_ci</name></name></expr>;</return>
</block_content>}</block>
<case>case<expr><operator>(</operator><literal type="number">8</literal><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>:</case><block>{<block_content>
<decl_stmt><decl><type><name>Proto</name><modifier>*</modifier></type><name>p</name><init>=<expr><call><name>gco2p</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gray</name></name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>gclist</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>traverseproto</name><argument_list>(<argument><expr><name>g</name></expr></argument>,<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><sizeof>sizeof<argument_list>(<argument><expr><name>Proto</name></expr></argument>)</argument_list></sizeof><operator>+</operator><sizeof>sizeof<argument_list>(<argument><expr><name>Instruction</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name><name>p</name><operator>-&gt;</operator><name>sizecode</name></name><operator>+</operator>
<sizeof>sizeof<argument_list>(<argument><expr><name>Proto</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><name><name>p</name><operator>-&gt;</operator><name>sizep</name></name><operator>+</operator>
<sizeof>sizeof<argument_list>(<argument><expr><name>TValue</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name><name>p</name><operator>-&gt;</operator><name>sizek</name></name><operator>+</operator>
<sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name><name>p</name><operator>-&gt;</operator><name>sizelineinfo</name></name><operator>+</operator>
<sizeof>sizeof<argument_list>(<argument><expr><name>LocVar</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name><name>p</name><operator>-&gt;</operator><name>sizelocvars</name></name><operator>+</operator>
<sizeof>sizeof<argument_list>(<argument><expr><name>TString</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><name><name>p</name><operator>-&gt;</operator><name>sizeupvalues</name></name></expr>;</return>
</block_content>}</block>
<default>default:</default><return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>propagateall</name><parameter_list>(<parameter><decl><type><name>global_State</name><modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>m</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<while>while<condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>gray</name></name></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><name>m</name><operator>+=</operator><call><name>propagatemark</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
<return>return <expr><name>m</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>iscleared</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>o</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>iskey</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>iscollectable</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content><return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><call><name>ttisstring</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>stringmark</name><argument_list>(<argument><expr><call><name>rawtsvalue</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>iswhite</name><argument_list>(<argument><expr><call><name>gcvalue</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>||</operator>
<operator>(</operator><call><name>ttisuserdata</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call><operator>&amp;&amp;</operator><operator>(</operator><operator>!</operator><name>iskey</name><operator>&amp;&amp;</operator><call><name>isfinalized</name><argument_list>(<argument><expr><call><name>uvalue</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>cleartable</name><parameter_list>(<parameter><decl><type><name>GCObject</name><modifier>*</modifier></type><name>l</name></decl></parameter>)</parameter_list><block>{<block_content>
<while>while<condition>(<expr><name>l</name></expr>)</condition><block>{<block_content>
<decl_stmt><decl><type><name>Table</name><modifier>*</modifier></type><name>h</name><init>=<expr><call><name>gco2h</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name><init>=<expr><name><name>h</name><operator>-&gt;</operator><name>sizearray</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><call><name>testbit</name><argument_list>(<argument><expr><name><name>h</name><operator>-&gt;</operator><name>marked</name></name></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<while>while<condition>(<expr><name>i</name><operator>--</operator></expr>)</condition><block>{<block_content>
<decl_stmt><decl><type><name>TValue</name><modifier>*</modifier></type><name>o</name><init>=<expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><call><name>iscleared</name><argument_list>(<argument><expr><name>o</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>setnilvalue</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></while>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>i</name><operator>=</operator><call><name>sizenode</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while<condition>(<expr><name>i</name><operator>--</operator></expr>)</condition><block>{<block_content>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type><name>n</name><init>=<expr><call><name>gnode</name><argument_list>(<argument><expr><name>h</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ttisnil</name><argument_list>(<argument><expr><call><name>gval</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>&amp;&amp;</operator>
<operator>(</operator><call><name>iscleared</name><argument_list>(<argument><expr><call><name>key2tval</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>||</operator><call><name>iscleared</name><argument_list>(<argument><expr><call><name>gval</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>setnilvalue</name><argument_list>(<argument><expr><call><name>gval</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>removeentry</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name>l</name><operator>=</operator><name><name>h</name><operator>-&gt;</operator><name>gclist</name></name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>freeobj</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>GCObject</name><modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list><block>{<block_content>
<switch>switch<condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>tt</name></name></expr>)</condition><block>{<block_content>
<case>case<expr><operator>(</operator><literal type="number">8</literal><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>:</case><expr_stmt><expr><call><name>luaF_freeproto</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>gco2p</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt><break>break;</break>
<case>case <expr><literal type="number">6</literal></expr>:</case><expr_stmt><expr><call><name>luaF_freeclosure</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>gco2cl</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt><break>break;</break>
<case>case<expr><operator>(</operator><literal type="number">8</literal><operator>+</operator><literal type="number">2</literal><operator>)</operator></expr>:</case><expr_stmt><expr><call><name>luaF_freeupval</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>gco2uv</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt><break>break;</break>
<case>case <expr><literal type="number">5</literal></expr>:</case><expr_stmt><expr><call><name>luaH_free</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>gco2h</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt><break>break;</break>
<case>case <expr><literal type="number">8</literal></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>luaE_freethread</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>gco2th</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><literal type="number">4</literal></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>strt</name><operator>.</operator><name>nuse</name></name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaM_freemem</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>o</name></expr></argument>,<argument><expr><call><name>sizestring</name><argument_list>(<argument><expr><call><name>gco2ts</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><literal type="number">7</literal></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>luaM_freemem</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>o</name></expr></argument>,<argument><expr><call><name>sizeudata</name><argument_list>(<argument><expr><call><name>gco2u</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<default>default:</default><empty_stmt>;</empty_stmt>
</block_content>}</block></switch>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>sweepwholelist</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>sweeplist(L,p,((lu_mem)(~(lu_mem)0)-2))</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>GCObject</name><modifier>*</modifier><modifier>*</modifier></type><name>sweeplist</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>GCObject</name><modifier>*</modifier><modifier>*</modifier></type><name>p</name></decl></parameter>,<parameter><decl><type><name>lu_mem</name></type> <name>count</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>GCObject</name><modifier>*</modifier></type><name>curr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>global_State</name><modifier>*</modifier></type><name>g</name><init>=<expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>deadmask</name><init>=<expr><call><name>otherwhite</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<while>while<condition>(<expr><operator>(</operator><name>curr</name><operator>=</operator><operator>*</operator><name>p</name><operator>)</operator><operator>!=</operator><name>NULL</name><operator>&amp;&amp;</operator><name>count</name><operator>--</operator><operator>&gt;</operator><literal type="number">0</literal></expr>)</condition><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name><name>curr</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>tt</name></name><operator>==</operator><literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>sweepwholelist</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>&amp;</operator><call><name>gco2th</name><argument_list>(<argument><expr><name>curr</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>openupval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><operator>(</operator><name><name>curr</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>marked</name></name><operator>^</operator><call><name>bit2mask</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>&amp;</operator><name>deadmask</name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>makewhite</name><argument_list>(<argument><expr><name>g</name></expr></argument>,<argument><expr><name>curr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name><operator>=</operator><operator>&amp;</operator><name><name>curr</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>p</name><operator>=</operator><name><name>curr</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>curr</name><operator>==</operator><name><name>g</name><operator>-&gt;</operator><name>rootgc</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>rootgc</name></name><operator>=</operator><name><name>curr</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>freeobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>curr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>checkSizes</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>global_State</name><modifier>*</modifier></type><name>g</name><init>=<expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>strt</name><operator>.</operator><name>nuse</name></name><operator>&lt;</operator><call><name>cast</name><argument_list>(<argument><expr><name>lu_int32</name></expr></argument>,<argument><expr><name><name>g</name><operator>-&gt;</operator><name>strt</name><operator>.</operator><name>size</name></name><operator>/</operator><literal type="number">4</literal></expr></argument>)</argument_list></call><operator>&amp;&amp;</operator>
<name><name>g</name><operator>-&gt;</operator><name>strt</name><operator>.</operator><name>size</name></name><operator>&gt;</operator><literal type="number">32</literal><operator>*</operator><literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaS_resize</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>g</name><operator>-&gt;</operator><name>strt</name><operator>.</operator><name>size</name></name><operator>/</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><call><name>luaZ_sizebuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>buff</name></name></expr></argument>)</argument_list></call><operator>&gt;</operator><literal type="number">32</literal><operator>*</operator><literal type="number">2</literal></expr>)</condition><block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>newsize</name><init>=<expr><call><name>luaZ_sizebuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>buff</name></name></expr></argument>)</argument_list></call><operator>/</operator><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaZ_resizebuffer</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>buff</name></name></expr></argument>,<argument><expr><name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>GCTM</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>global_State</name><modifier>*</modifier></type><name>g</name><init>=<expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GCObject</name><modifier>*</modifier></type><name>o</name><init>=<expr><name><name>g</name><operator>-&gt;</operator><name>tmudata</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>next</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Udata</name><modifier>*</modifier></type><name>udata</name><init>=<expr><call><name>rawgco2u</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>tm</name></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>o</name><operator>==</operator><name><name>g</name><operator>-&gt;</operator><name>tmudata</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>tmudata</name></name><operator>=</operator><name>NULL</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>tmudata</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>next</name></name><operator>=</operator><name><name>udata</name><operator>-&gt;</operator><name>uv</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name><name>udata</name><operator>-&gt;</operator><name>uv</name><operator>.</operator><name>next</name></name><operator>=</operator><name><name>g</name><operator>-&gt;</operator><name>mainthread</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>mainthread</name><operator>-&gt;</operator><name>next</name></name><operator>=</operator><name>o</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>makewhite</name><argument_list>(<argument><expr><name>g</name></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tm</name><operator>=</operator><call><name>fasttm</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>udata</name><operator>-&gt;</operator><name>uv</name><operator>.</operator><name>metatable</name></name></expr></argument>,<argument><expr><name>TM_GC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>tm</name><operator>!=</operator><name>NULL</name></expr>)</condition><block>{<block_content>
<decl_stmt><decl><type><name>lu_byte</name></type> <name>oldah</name><init>=<expr><name><name>L</name><operator>-&gt;</operator><name>allowhook</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>lu_mem</name></type> <name>oldt</name><init>=<expr><name><name>g</name><operator>-&gt;</operator><name>GCthreshold</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>allowhook</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>GCthreshold</name></name><operator>=</operator><literal type="number">2</literal><operator>*</operator><name><name>g</name><operator>-&gt;</operator><name>totalbytes</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>,<argument><expr><name>tm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setuvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>udata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>+=</operator><literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaD_call</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">2</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>allowhook</name></name><operator>=</operator><name>oldah</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>GCthreshold</name></name><operator>=</operator><name>oldt</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaC_callGCTM</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<while>while<condition>(<expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>tmudata</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>GCTM</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaC_freeall</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>global_State</name><modifier>*</modifier></type><name>g</name><init>=<expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>currentwhite</name></name><operator>=</operator><call><name>bit2mask</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>|</operator><call><name>bitmask</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sweepwholelist</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>rootgc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init><condition><expr><name>i</name><operator>&lt;</operator><name><name>g</name><operator>-&gt;</operator><name>strt</name><operator>.</operator><name>size</name></name></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>sweepwholelist</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>strt</name><operator>.</operator><name>hash</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>markmt</name><parameter_list>(<parameter><decl><type><name>global_State</name><modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init><condition><expr><name>i</name><operator>&lt;</operator><operator>(</operator><literal type="number">8</literal><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if<condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>mt</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><call><name>markobject</name><argument_list>(<argument><expr><name>g</name></expr></argument>,<argument><expr><name><name>g</name><operator>-&gt;</operator><name>mt</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>markroot</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>global_State</name><modifier>*</modifier></type><name>g</name><init>=<expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gray</name></name><operator>=</operator><name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>grayagain</name></name><operator>=</operator><name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>weak</name></name><operator>=</operator><name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>markobject</name><argument_list>(<argument><expr><name>g</name></expr></argument>,<argument><expr><name><name>g</name><operator>-&gt;</operator><name>mainthread</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>markvalue</name><argument_list>(<argument><expr><name>g</name></expr></argument>,<argument><expr><call><name>gt</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>mainthread</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>markvalue</name><argument_list>(<argument><expr><name>g</name></expr></argument>,<argument><expr><call><name>registry</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>markmt</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gcstate</name></name><operator>=</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>remarkupvals</name><parameter_list>(<parameter><decl><type><name>global_State</name><modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>UpVal</name><modifier>*</modifier></type><name>uv</name></decl>;</decl_stmt>
<for>for<control>(<init><expr><name>uv</name><operator>=</operator><name><name>g</name><operator>-&gt;</operator><name>uvhead</name><operator>.</operator><name>u</name><operator>.</operator><name>l</name><operator>.</operator><name>next</name></name></expr>;</init><condition><expr><name>uv</name><operator>!=</operator><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>uvhead</name></name></expr>;</condition><incr><expr><name>uv</name><operator>=</operator><name><name>uv</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>l</name><operator>.</operator><name>next</name></name></expr></incr>)</control><block>{<block_content>
<if_stmt><if>if<condition>(<expr><call><name>isgray</name><argument_list>(<argument><expr><call><name>obj2gco</name><argument_list>(<argument><expr><name>uv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>markvalue</name><argument_list>(<argument><expr><name>g</name></expr></argument>,<argument><expr><name><name>uv</name><operator>-&gt;</operator><name>v</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>atomic</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>global_State</name><modifier>*</modifier></type><name>g</name><init>=<expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>udsize</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>remarkupvals</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>propagateall</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gray</name></name><operator>=</operator><name><name>g</name><operator>-&gt;</operator><name>weak</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>weak</name></name><operator>=</operator><name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>markobject</name><argument_list>(<argument><expr><name>g</name></expr></argument>,<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>markmt</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>propagateall</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gray</name></name><operator>=</operator><name><name>g</name><operator>-&gt;</operator><name>grayagain</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>grayagain</name></name><operator>=</operator><name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>propagateall</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>udsize</name><operator>=</operator><call><name>luaC_separateudata</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>marktmu</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>udsize</name><operator>+=</operator><call><name>propagateall</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>cleartable</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>weak</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>currentwhite</name></name><operator>=</operator><call><name>cast_byte</name><argument_list>(<argument><expr><call><name>otherwhite</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>sweepstrgc</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>sweepgc</name></name><operator>=</operator><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>rootgc</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gcstate</name></name><operator>=</operator><literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>estimate</name></name><operator>=</operator><name><name>g</name><operator>-&gt;</operator><name>totalbytes</name></name><operator>-</operator><name>udsize</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>l_mem</name></type> <name>singlestep</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>global_State</name><modifier>*</modifier></type><name>g</name><init>=<expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<switch>switch<condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>gcstate</name></name></expr>)</condition><block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>markroot</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block>
<case>case <expr><literal type="number">1</literal></expr>:</case><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>gray</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>propagatemark</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block>{<block_content>
<expr_stmt><expr><call><name>atomic</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block>
<case>case <expr><literal type="number">2</literal></expr>:</case><block>{<block_content>
<decl_stmt><decl><type><name>lu_mem</name></type> <name>old</name><init>=<expr><name><name>g</name><operator>-&gt;</operator><name>totalbytes</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>sweepwholelist</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>strt</name><operator>.</operator><name>hash</name><index>[<expr><name><name>g</name><operator>-&gt;</operator><name>sweepstrgc</name></name><operator>++</operator></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>sweepstrgc</name></name><operator>&gt;=</operator><name><name>g</name><operator>-&gt;</operator><name>strt</name><operator>.</operator><name>size</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gcstate</name></name><operator>=</operator><literal type="number">3</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>estimate</name></name><operator>-=</operator><name>old</name><operator>-</operator><name><name>g</name><operator>-&gt;</operator><name>totalbytes</name></name></expr>;</expr_stmt>
<return>return <expr><literal type="number">10</literal></expr>;</return>
</block_content>}</block>
<case>case <expr><literal type="number">3</literal></expr>:</case><block>{<block_content>
<decl_stmt><decl><type><name>lu_mem</name></type> <name>old</name><init>=<expr><name><name>g</name><operator>-&gt;</operator><name>totalbytes</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>sweepgc</name></name><operator>=</operator><call><name>sweeplist</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>g</name><operator>-&gt;</operator><name>sweepgc</name></name></expr></argument>,<argument><expr><literal type="number">40</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><operator>*</operator><name><name>g</name><operator>-&gt;</operator><name>sweepgc</name></name><operator>==</operator><name>NULL</name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>checkSizes</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gcstate</name></name><operator>=</operator><literal type="number">4</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>estimate</name></name><operator>-=</operator><name>old</name><operator>-</operator><name><name>g</name><operator>-&gt;</operator><name>totalbytes</name></name></expr>;</expr_stmt>
<return>return <expr><literal type="number">40</literal><operator>*</operator><literal type="number">10</literal></expr>;</return>
</block_content>}</block>
<case>case <expr><literal type="number">4</literal></expr>:</case><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>tmudata</name></name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>GCTM</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>estimate</name></name><operator>&gt;</operator><literal type="number">100</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>estimate</name></name><operator>-=</operator><literal type="number">100</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">100</literal></expr>;</return>
</block_content>}</block></if>
<else>else<block>{<block_content>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gcstate</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gcdept</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block>
<default>default:</default><return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaC_step</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>global_State</name><modifier>*</modifier></type><name>g</name><init>=<expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>l_mem</name></type> <name>lim</name><init>=<expr><operator>(</operator><literal type="number">1024u</literal><operator>/</operator><literal type="number">100</literal><operator>)</operator><operator>*</operator><name><name>g</name><operator>-&gt;</operator><name>gcstepmul</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>lim</name><operator>==</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>lim</name><operator>=</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>lu_mem</name><operator>)</operator><operator>(</operator><operator>~</operator><operator>(</operator><name>lu_mem</name><operator>)</operator><literal type="number">0</literal><operator>)</operator><operator>-</operator><literal type="number">2</literal><operator>)</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>/</operator><literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gcdept</name></name><operator>+=</operator><name><name>g</name><operator>-&gt;</operator><name>totalbytes</name></name><operator>-</operator><name><name>g</name><operator>-&gt;</operator><name>GCthreshold</name></name></expr>;</expr_stmt>
<do>do<block>{<block_content>
<expr_stmt><expr><name>lim</name><operator>-=</operator><call><name>singlestep</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>gcstate</name></name><operator>==</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block>while<condition>(<expr><name>lim</name><operator>&gt;</operator><literal type="number">0</literal></expr>)</condition>;</do>
<if_stmt><if>if<condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>gcstate</name></name><operator>!=</operator><literal type="number">0</literal></expr>)</condition><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>gcdept</name></name><operator>&lt;</operator><literal type="number">1024u</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>GCthreshold</name></name><operator>=</operator><name><name>g</name><operator>-&gt;</operator><name>totalbytes</name></name><operator>+</operator><literal type="number">1024u</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block>{<block_content>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gcdept</name></name><operator>-=</operator><literal type="number">1024u</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>GCthreshold</name></name><operator>=</operator><name><name>g</name><operator>-&gt;</operator><name>totalbytes</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<else>else<block>{<block_content>
<expr_stmt><expr><call><name>setthreshold</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaC_barrierf</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>GCObject</name><modifier>*</modifier></type><name>o</name></decl></parameter>,<parameter><decl><type><name>GCObject</name><modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>global_State</name><modifier>*</modifier></type><name>g</name><init>=<expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>gcstate</name></name><operator>==</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>reallymarkobject</name><argument_list>(<argument><expr><name>g</name></expr></argument>,<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>makewhite</name><argument_list>(<argument><expr><name>g</name></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaC_barrierback</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>Table</name><modifier>*</modifier></type><name>t</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>global_State</name><modifier>*</modifier></type><name>g</name><init>=<expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GCObject</name><modifier>*</modifier></type><name>o</name><init>=<expr><call><name>obj2gco</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>black2gray</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>gclist</name></name><operator>=</operator><name><name>g</name><operator>-&gt;</operator><name>grayagain</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>grayagain</name></name><operator>=</operator><name>o</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaC_link</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>GCObject</name><modifier>*</modifier></type><name>o</name></decl></parameter>,<parameter><decl><type><name>lu_byte</name></type> <name>tt</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>global_State</name><modifier>*</modifier></type><name>g</name><init>=<expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>next</name></name><operator>=</operator><name><name>g</name><operator>-&gt;</operator><name>rootgc</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>rootgc</name></name><operator>=</operator><name>o</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>marked</name></name><operator>=</operator><call><name>luaC_white</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>tt</name></name><operator>=</operator><name>tt</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaC_linkupval</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>UpVal</name><modifier>*</modifier></type><name>uv</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>global_State</name><modifier>*</modifier></type><name>g</name><init>=<expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GCObject</name><modifier>*</modifier></type><name>o</name><init>=<expr><call><name>obj2gco</name><argument_list>(<argument><expr><name>uv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>next</name></name><operator>=</operator><name><name>g</name><operator>-&gt;</operator><name>rootgc</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>rootgc</name></name><operator>=</operator><name>o</name></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><call><name>isgray</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>gcstate</name></name><operator>==</operator><literal type="number">1</literal></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>gray2black</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaC_barrier</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>uv</name></expr></argument>,<argument><expr><name><name>uv</name><operator>-&gt;</operator><name>v</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block>{<block_content>
<expr_stmt><expr><call><name>makewhite</name><argument_list>(<argument><expr><name>g</name></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<typedef>typedef <type><union>union<block>{
<decl_stmt><decl><type><name>lua_Number</name></type> <name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TString</name><modifier>*</modifier></type><name>ts</name></decl>;</decl_stmt>
}</block></union></type><name>SemInfo</name>;</typedef>
<typedef>typedef <type><struct>struct <name>Token</name><block>{
<decl_stmt><decl><type><name>int</name></type> <name>token</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SemInfo</name></type> <name>seminfo</name></decl>;</decl_stmt>
}</block></struct></type><name>Token</name>;</typedef>
<typedef>typedef <type><struct>struct <name>LexState</name><block>{
<decl_stmt><decl><type><name>int</name></type> <name>current</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>linenumber</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>lastline</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Token</name></type> <name>t</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Token</name></type> <name>lookahead</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>FuncState</name></name><modifier>*</modifier></type><name>fs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>lua_State</name></name><modifier>*</modifier></type><name>L</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ZIO</name><modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Mbuffer</name><modifier>*</modifier></type><name>buff</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TString</name><modifier>*</modifier></type><name>source</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>decpoint</name></decl>;</decl_stmt>
}</block></struct></type><name>LexState</name>;</typedef>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>luaX_init</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>luaX_lexerror</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>msg</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>token</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>state_size</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(sizeof(x)+0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>fromstate</name><parameter_list>(<parameter><type><name>l</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(cast(lu_byte*,(l))-0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>tostate</name><parameter_list>(<parameter><type><name>l</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(cast(lua_State*,cast(lu_byte*,l)+0))</cpp:value></cpp:define>
<typedef>typedef <type><struct>struct <name>LG</name><block>{
<decl_stmt><decl><type><name>lua_State</name></type> <name>l</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>global_State</name></type> <name>g</name></decl>;</decl_stmt>
}</block></struct></type><name>LG</name>;</typedef>
<function><type><specifier>static</specifier> <name>void</name></type> <name>stack_init</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L1</name></decl></parameter>,<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><name><name>L1</name><operator>-&gt;</operator><name>base_ci</name></name><operator>=</operator><call><name>luaM_newvector</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">8</literal></expr></argument>,<argument><expr><name>CallInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L1</name><operator>-&gt;</operator><name>ci</name></name><operator>=</operator><name><name>L1</name><operator>-&gt;</operator><name>base_ci</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L1</name><operator>-&gt;</operator><name>size_ci</name></name><operator>=</operator><literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L1</name><operator>-&gt;</operator><name>end_ci</name></name><operator>=</operator><name><name>L1</name><operator>-&gt;</operator><name>base_ci</name></name><operator>+</operator><name><name>L1</name><operator>-&gt;</operator><name>size_ci</name></name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L1</name><operator>-&gt;</operator><name>stack</name></name><operator>=</operator><call><name>luaM_newvector</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>(</operator><literal type="number">2</literal><operator>*</operator><literal type="number">20</literal><operator>)</operator><operator>+</operator><literal type="number">5</literal></expr></argument>,<argument><expr><name>TValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L1</name><operator>-&gt;</operator><name>stacksize</name></name><operator>=</operator><operator>(</operator><literal type="number">2</literal><operator>*</operator><literal type="number">20</literal><operator>)</operator><operator>+</operator><literal type="number">5</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L1</name><operator>-&gt;</operator><name>top</name></name><operator>=</operator><name><name>L1</name><operator>-&gt;</operator><name>stack</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L1</name><operator>-&gt;</operator><name>stack_last</name></name><operator>=</operator><name><name>L1</name><operator>-&gt;</operator><name>stack</name></name><operator>+</operator><operator>(</operator><name><name>L1</name><operator>-&gt;</operator><name>stacksize</name></name><operator>-</operator><literal type="number">5</literal><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L1</name><operator>-&gt;</operator><name>ci</name><operator>-&gt;</operator><name>func</name></name><operator>=</operator><name><name>L1</name><operator>-&gt;</operator><name>top</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setnilvalue</name><argument_list>(<argument><expr><name><name>L1</name><operator>-&gt;</operator><name>top</name></name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L1</name><operator>-&gt;</operator><name>base</name></name><operator>=</operator><name><name>L1</name><operator>-&gt;</operator><name>ci</name><operator>-&gt;</operator><name>base</name></name><operator>=</operator><name><name>L1</name><operator>-&gt;</operator><name>top</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L1</name><operator>-&gt;</operator><name>ci</name><operator>-&gt;</operator><name>top</name></name><operator>=</operator><name><name>L1</name><operator>-&gt;</operator><name>top</name></name><operator>+</operator><literal type="number">20</literal></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>freestack</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L1</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>luaM_freearray</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>L1</name><operator>-&gt;</operator><name>base_ci</name></name></expr></argument>,<argument><expr><name><name>L1</name><operator>-&gt;</operator><name>size_ci</name></name></expr></argument>,<argument><expr><name>CallInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaM_freearray</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>L1</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>,<argument><expr><name><name>L1</name><operator>-&gt;</operator><name>stacksize</name></name></expr></argument>,<argument><expr><name>TValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>f_luaopen</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>void</name><modifier>*</modifier></type><name>ud</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>global_State</name><modifier>*</modifier></type><name>g</name><init>=<expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>ud</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>stack_init</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sethvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>gt</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>luaH_new</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sethvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>registry</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>luaH_new</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaS_resize</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaT_init</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaX_init</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaS_fix</name><argument_list>(<argument><expr><call><name>luaS_newliteral</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"not enough memory"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>GCthreshold</name></name><operator>=</operator><literal type="number">4</literal><operator>*</operator><name><name>g</name><operator>-&gt;</operator><name>totalbytes</name></name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>preinit_state</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>global_State</name><modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>=</operator><name>g</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>stack</name></name><operator>=</operator><name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>stacksize</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>errorJmp</name></name><operator>=</operator><name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>hook</name></name><operator>=</operator><name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>hookmask</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>basehookcount</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>allowhook</name></name><operator>=</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>resethookcount</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>openupval</name></name><operator>=</operator><name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>size_ci</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>nCcalls</name></name><operator>=</operator><name><name>L</name><operator>-&gt;</operator><name>baseCcalls</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>status</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>base_ci</name></name><operator>=</operator><name><name>L</name><operator>-&gt;</operator><name>ci</name></name><operator>=</operator><name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>savedpc</name></name><operator>=</operator><name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>errfunc</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setnilvalue</name><argument_list>(<argument><expr><call><name>gt</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>close_state</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>global_State</name><modifier>*</modifier></type><name>g</name><init>=<expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaF_close</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaC_freeall</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaM_freearray</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>strt</name><operator>.</operator><name>hash</name></name></expr></argument>,<argument><expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>strt</name><operator>.</operator><name>size</name></name></expr></argument>,<argument><expr><name>TString</name><operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaZ_freebuffer</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>buff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>freestack</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call>(<modifier>*</modifier><name><name>g</name><operator>-&gt;</operator><name>frealloc</name></name>)<argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>ud</name></name></expr></argument>,<argument><expr><call><name>fromstate</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>state_size</name><argument_list>(<argument><expr><name>LG</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaE_freethread</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L1</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>luaF_close</name><argument_list>(<argument><expr><name>L1</name></expr></argument>,<argument><expr><name><name>L1</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>freestack</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>L1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaM_freemem</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>fromstate</name><argument_list>(<argument><expr><name>L1</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>state_size</name><argument_list>(<argument><expr><name>lua_State</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>lua_State</name><modifier>*</modifier></type><name>lua_newstate</name><parameter_list>(<parameter><decl><type><name>lua_Alloc</name></type> <name>f</name></decl></parameter>,<parameter><decl><type><name>void</name><modifier>*</modifier></type><name>ud</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>global_State</name><modifier>*</modifier></type><name>g</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name><modifier>*</modifier></type><name>l</name><init>=<expr><call>(<modifier>*</modifier><name>f</name>)<argument_list>(<argument><expr><name>ud</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><call><name>state_size</name><argument_list>(<argument><expr><name>LG</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>l</name><operator>==</operator><name>NULL</name></expr>)</condition><block type="pseudo"><block_content><return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>L</name><operator>=</operator><call><name>tostate</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>g</name><operator>=</operator><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>LG</name><operator>*</operator><operator>)</operator><name>L</name><operator>)</operator><operator>-&gt;</operator><name>g</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>next</name></name><operator>=</operator><name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>tt</name></name><operator>=</operator><literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>currentwhite</name></name><operator>=</operator><call><name>bit2mask</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>marked</name></name><operator>=</operator><call><name>luaC_white</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>set2bits</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>marked</name></name></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>,<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>preinit_state</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>frealloc</name></name><operator>=</operator><name>f</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>ud</name></name><operator>=</operator><name>ud</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>mainthread</name></name><operator>=</operator><name>L</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>uvhead</name><operator>.</operator><name>u</name><operator>.</operator><name>l</name><operator>.</operator><name>prev</name></name><operator>=</operator><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>uvhead</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>uvhead</name><operator>.</operator><name>u</name><operator>.</operator><name>l</name><operator>.</operator><name>next</name></name><operator>=</operator><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>uvhead</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>GCthreshold</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>strt</name><operator>.</operator><name>size</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>strt</name><operator>.</operator><name>nuse</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>strt</name><operator>.</operator><name>hash</name></name><operator>=</operator><name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setnilvalue</name><argument_list>(<argument><expr><call><name>registry</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaZ_initbuffer</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>buff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>panic</name></name><operator>=</operator><name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gcstate</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>rootgc</name></name><operator>=</operator><call><name>obj2gco</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>sweepstrgc</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>sweepgc</name></name><operator>=</operator><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>rootgc</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gray</name></name><operator>=</operator><name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>grayagain</name></name><operator>=</operator><name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>weak</name></name><operator>=</operator><name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>tmudata</name></name><operator>=</operator><name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>totalbytes</name></name><operator>=</operator><sizeof>sizeof<argument_list>(<argument><expr><name>LG</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gcpause</name></name><operator>=</operator><literal type="number">200</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gcstepmul</name></name><operator>=</operator><literal type="number">200</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gcdept</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init><condition><expr><name>i</name><operator>&lt;</operator><operator>(</operator><literal type="number">8</literal><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content><expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>mt</name><index>[<expr><name>i</name></expr>]</index></name><operator>=</operator><name>NULL</name></expr>;</expr_stmt></block_content></block></for>
<if_stmt><if>if<condition>(<expr><call><name>luaD_rawrunprotected</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>f_luaopen</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>close_state</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>L</name><operator>=</operator><name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content/>}</block></else></if_stmt>
<return>return <expr><name>L</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>callallgcTM</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>void</name><modifier>*</modifier></type><name>ud</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>ud</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaC_callGCTM</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>lua_close</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><name>L</name><operator>=</operator><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>mainthread</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaF_close</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaC_separateudata</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>errfunc</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<do>do<block>{<block_content>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>ci</name></name><operator>=</operator><name><name>L</name><operator>-&gt;</operator><name>base_ci</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>=</operator><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>=</operator><name><name>L</name><operator>-&gt;</operator><name>ci</name><operator>-&gt;</operator><name>base</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>nCcalls</name></name><operator>=</operator><name><name>L</name><operator>-&gt;</operator><name>baseCcalls</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block>while<condition>(<expr><call><name>luaD_rawrunprotected</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>callallgcTM</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr>)</condition>;</do>
<expr_stmt><expr><call><name>close_state</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>getcode</name><parameter_list>(<parameter><type><name>fs</name></type></parameter>,<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((fs)-&gt;f-&gt;code[(e)-&gt;u.s.info])</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>luaK_codeAsBx</name><parameter_list>(<parameter><type><name>fs</name></type></parameter>,<parameter><type><name>o</name></type></parameter>,<parameter><type><name>A</name></type></parameter>,<parameter><type><name>sBx</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>luaK_codeABx(fs,o,A,(sBx)+(((1&lt;&lt;(9+9))-1)&gt;&gt;1))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>luaK_setmultret</name><parameter_list>(<parameter><type><name>fs</name></type></parameter>,<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>luaK_setreturns(fs,e,(-1))</cpp:value></cpp:define>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>luaK_codeABx</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name>OpCode</name></type> <name>o</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>A</name></decl></parameter>,<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>Bx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>luaK_codeABC</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name>OpCode</name></type> <name>o</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>A</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>B</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>C</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>luaK_setreturns</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name>expdesc</name><modifier>*</modifier></type><name>e</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>nresults</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>luaK_patchtohere</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>list</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>luaK_concat</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name>int</name><modifier>*</modifier></type><name>l1</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>l2</name></decl></parameter>)</parameter_list>;</function_decl>
<function><type><specifier>static</specifier> <name>int</name></type> <name>currentpc</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>CallInfo</name><modifier>*</modifier></type><name>ci</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>isLua</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content><return>return<expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><name>ci</name><operator>==</operator><name><name>L</name><operator>-&gt;</operator><name>ci</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>savedpc</name></name><operator>=</operator><name><name>L</name><operator>-&gt;</operator><name>savedpc</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><call><name>pcRel</name><argument_list>(<argument><expr><name><name>ci</name><operator>-&gt;</operator><name>savedpc</name></name></expr></argument>,<argument><expr><call><name>ci_func</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>l</name><operator>.</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>currentline</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>CallInfo</name><modifier>*</modifier></type><name>ci</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>pc</name><init>=<expr><call><name>currentpc</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>pc</name><operator>&lt;</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return<expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><call><name>getline_</name><argument_list>(<argument><expr><call><name>ci_func</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>l</name><operator>.</operator><name>p</name></name></expr></argument>,<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lua_getstack</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>,<parameter><decl><type><name>lua_Debug</name><modifier>*</modifier></type><name>ar</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CallInfo</name><modifier>*</modifier></type><name>ci</name></decl>;</decl_stmt>
<for>for<control>(<init><expr><name>ci</name><operator>=</operator><name><name>L</name><operator>-&gt;</operator><name>ci</name></name></expr>;</init><condition><expr><name>level</name><operator>&gt;</operator><literal type="number">0</literal><operator>&amp;&amp;</operator><name>ci</name><operator>&gt;</operator><name><name>L</name><operator>-&gt;</operator><name>base_ci</name></name></expr>;</condition><incr><expr><name>ci</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
<expr_stmt><expr><name>level</name><operator>--</operator></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><call><name>f_isLua</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>level</name><operator>-=</operator><name><name>ci</name><operator>-&gt;</operator><name>tailcalls</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if<condition>(<expr><name>level</name><operator>==</operator><literal type="number">0</literal><operator>&amp;&amp;</operator><name>ci</name><operator>&gt;</operator><name><name>L</name><operator>-&gt;</operator><name>base_ci</name></name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><name>status</name><operator>=</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ar</name><operator>-&gt;</operator><name>i_ci</name></name><operator>=</operator><call><name>cast_int</name><argument_list>(<argument><expr><name>ci</name><operator>-</operator><name><name>L</name><operator>-&gt;</operator><name>base_ci</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if<condition>(<expr><name>level</name><operator>&lt;</operator><literal type="number">0</literal></expr>)</condition><block>{<block_content>
<expr_stmt><expr><name>status</name><operator>=</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ar</name><operator>-&gt;</operator><name>i_ci</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>status</name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
<return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>Proto</name><modifier>*</modifier></type><name>getluaproto</name><parameter_list>(<parameter><decl><type><name>CallInfo</name><modifier>*</modifier></type><name>ci</name></decl></parameter>)</parameter_list><block>{<block_content>
<return>return<expr><operator>(</operator><ternary><condition><expr><call><name>isLua</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>?</condition><then><expr><call><name>ci_func</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>l</name><operator>.</operator><name>p</name></name></expr></then><else>:<expr><name>NULL</name></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>funcinfo</name><parameter_list>(<parameter><decl><type><name>lua_Debug</name><modifier>*</modifier></type><name>ar</name></decl></parameter>,<parameter><decl><type><name>Closure</name><modifier>*</modifier></type><name>cl</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name><name>cl</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>isC</name></name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><name><name>ar</name><operator>-&gt;</operator><name>source</name></name><operator>=</operator><literal type="string">"=[C]"</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ar</name><operator>-&gt;</operator><name>linedefined</name></name><operator>=</operator><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ar</name><operator>-&gt;</operator><name>lastlinedefined</name></name><operator>=</operator><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ar</name><operator>-&gt;</operator><name>what</name></name><operator>=</operator><literal type="string">"C"</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block>{<block_content>
<expr_stmt><expr><name><name>ar</name><operator>-&gt;</operator><name>source</name></name><operator>=</operator><call><name>getstr</name><argument_list>(<argument><expr><name><name>cl</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>p</name><operator>-&gt;</operator><name>source</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ar</name><operator>-&gt;</operator><name>linedefined</name></name><operator>=</operator><name><name>cl</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>p</name><operator>-&gt;</operator><name>linedefined</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ar</name><operator>-&gt;</operator><name>lastlinedefined</name></name><operator>=</operator><name><name>cl</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>p</name><operator>-&gt;</operator><name>lastlinedefined</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ar</name><operator>-&gt;</operator><name>what</name></name><operator>=</operator><ternary><condition><expr><operator>(</operator><name><name>ar</name><operator>-&gt;</operator><name>linedefined</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr>?</condition><then><expr><literal type="string">"main"</literal></expr></then><else>:<expr><literal type="string">"Lua"</literal></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>luaO_chunkid</name><argument_list>(<argument><expr><name><name>ar</name><operator>-&gt;</operator><name>short_src</name></name></expr></argument>,<argument><expr><name><name>ar</name><operator>-&gt;</operator><name>source</name></name></expr></argument>,<argument><expr><literal type="number">60</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>info_tailcall</name><parameter_list>(<parameter><decl><type><name>lua_Debug</name><modifier>*</modifier></type><name>ar</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><name><name>ar</name><operator>-&gt;</operator><name>name</name></name><operator>=</operator><name><name>ar</name><operator>-&gt;</operator><name>namewhat</name></name><operator>=</operator><literal type="string">""</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ar</name><operator>-&gt;</operator><name>what</name></name><operator>=</operator><literal type="string">"tail"</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ar</name><operator>-&gt;</operator><name>lastlinedefined</name></name><operator>=</operator><name><name>ar</name><operator>-&gt;</operator><name>linedefined</name></name><operator>=</operator><name><name>ar</name><operator>-&gt;</operator><name>currentline</name></name><operator>=</operator><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ar</name><operator>-&gt;</operator><name>source</name></name><operator>=</operator><literal type="string">"=(tail call)"</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaO_chunkid</name><argument_list>(<argument><expr><name><name>ar</name><operator>-&gt;</operator><name>short_src</name></name></expr></argument>,<argument><expr><name><name>ar</name><operator>-&gt;</operator><name>source</name></name></expr></argument>,<argument><expr><literal type="number">60</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ar</name><operator>-&gt;</operator><name>nups</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>collectvalidlines</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>Closure</name><modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name>f</name><operator>==</operator><name>NULL</name><operator>||</operator><name><name>f</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>isC</name></name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>setnilvalue</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block>{<block_content>
<decl_stmt><decl><type><name>Table</name><modifier>*</modifier></type><name>t</name><init>=<expr><call><name>luaH_new</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name><modifier>*</modifier></type><name>lineinfo</name><init>=<expr><name><name>f</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>p</name><operator>-&gt;</operator><name>lineinfo</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init><condition><expr><name>i</name><operator>&lt;</operator><name><name>f</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>p</name><operator>-&gt;</operator><name>sizelineinfo</name></name></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>setbvalue</name><argument_list>(<argument><expr><call><name>luaH_setnum</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>t</name></expr></argument>,<argument><expr><name><name>lineinfo</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>sethvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>,<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>incr_top</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>auxgetinfo</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>what</name></decl></parameter>,<parameter><decl><type><name>lua_Debug</name><modifier>*</modifier></type><name>ar</name></decl></parameter>,
<parameter><decl><type><name>Closure</name><modifier>*</modifier></type><name>f</name></decl></parameter>,<parameter><decl><type><name>CallInfo</name><modifier>*</modifier></type><name>ci</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>status</name><init>=<expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>f</name><operator>==</operator><name>NULL</name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>info_tailcall</name><argument_list>(<argument><expr><name>ar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<for>for<control>(<init>;</init><condition><expr><operator>*</operator><name>what</name></expr>;</condition><incr><expr><name>what</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
<switch>switch<condition>(<expr><operator>*</operator><name>what</name></expr>)</condition><block>{<block_content>
<case>case<expr><literal type="char">'S'</literal></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>funcinfo</name><argument_list>(<argument><expr><name>ar</name></expr></argument>,<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case<expr><literal type="char">'l'</literal></expr>:</case><block>{<block_content>
<expr_stmt><expr><name><name>ar</name><operator>-&gt;</operator><name>currentline</name></name><operator>=</operator><ternary><condition><expr><operator>(</operator><name>ci</name><operator>)</operator></expr>?</condition><then><expr><call><name>currentline</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr></then><else>:<expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case<expr><literal type="char">'u'</literal></expr>:</case><block>{<block_content>
<expr_stmt><expr><name><name>ar</name><operator>-&gt;</operator><name>nups</name></name><operator>=</operator><name><name>f</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>nupvalues</name></name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case<expr><literal type="char">'n'</literal></expr>:</case><block>{<block_content>
<expr_stmt><expr><name><name>ar</name><operator>-&gt;</operator><name>namewhat</name></name><operator>=</operator><ternary><condition><expr><operator>(</operator><name>ci</name><operator>)</operator></expr>?</condition><then><expr><name>NULL</name></expr></then><else>:<expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name><name>ar</name><operator>-&gt;</operator><name>namewhat</name></name><operator>==</operator><name>NULL</name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><name><name>ar</name><operator>-&gt;</operator><name>namewhat</name></name><operator>=</operator><literal type="string">""</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ar</name><operator>-&gt;</operator><name>name</name></name><operator>=</operator><name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block>
<case>case<expr><literal type="char">'L'</literal></expr>:</case>
<case>case<expr><literal type="char">'f'</literal></expr>:</case>
<break>break;</break>
<default>default:</default><expr_stmt><expr><name>status</name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></switch>
</block_content>}</block></for>
<return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lua_getinfo</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>what</name></decl></parameter>,<parameter><decl><type><name>lua_Debug</name><modifier>*</modifier></type><name>ar</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Closure</name><modifier>*</modifier></type><name>f</name><init>=<expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CallInfo</name><modifier>*</modifier></type><name>ci</name><init>=<expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><operator>*</operator><name>what</name><operator>==</operator><literal type="char">'&gt;'</literal></expr>)</condition><block>{<block_content>
<decl_stmt><decl><type><name>StkId</name></type> <name>func</name><init>=<expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luai_apicheck</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>ttisfunction</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>what</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>f</name><operator>=</operator><call><name>clvalue</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if<condition>(<expr><name><name>ar</name><operator>-&gt;</operator><name>i_ci</name></name><operator>!=</operator><literal type="number">0</literal></expr>)</condition><block>{<block_content>
<expr_stmt><expr><name>ci</name><operator>=</operator><name><name>L</name><operator>-&gt;</operator><name>base_ci</name></name><operator>+</operator><name><name>ar</name><operator>-&gt;</operator><name>i_ci</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>f</name><operator>=</operator><call><name>clvalue</name><argument_list>(<argument><expr><name><name>ci</name><operator>-&gt;</operator><name>func</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>status</name><operator>=</operator><call><name>auxgetinfo</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>what</name></expr></argument>,<argument><expr><name>ar</name></expr></argument>,<argument><expr><name>f</name></expr></argument>,<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>what</name></expr></argument>,<argument><expr><literal type="char">'f'</literal></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name>f</name><operator>==</operator><name>NULL</name></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><call><name>setnilvalue</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>setclvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>,<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>incr_top</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>what</name></expr></argument>,<argument><expr><literal type="char">'L'</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>collectvalidlines</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>isinstack</name><parameter_list>(<parameter><decl><type><name>CallInfo</name><modifier>*</modifier></type><name>ci</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>StkId</name></type> <name>p</name></decl>;</decl_stmt>
<for>for<control>(<init><expr><name>p</name><operator>=</operator><name><name>ci</name><operator>-&gt;</operator><name>base</name></name></expr>;</init><condition><expr><name>p</name><operator>&lt;</operator><name><name>ci</name><operator>-&gt;</operator><name>top</name></name></expr>;</condition><incr><expr><name>p</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if<condition>(<expr><name>o</name><operator>==</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content><return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaG_typeerror</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>o</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>op</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>name</name><init>=<expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>t</name><init>=<expr><name><name>luaT_typenames</name><index>[<expr><call><name>ttype</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>kind</name><init>=<expr><ternary><condition><expr><operator>(</operator><call><name>isinstack</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>ci</name></name></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call><operator>)</operator></expr>?</condition><then>
<expr><name>NULL</name></expr></then><else>:
<expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>kind</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaG_runerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"attempt to %s %s "</literal><call><name>LUA_QL</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>)</argument_list></call><literal type="string">" (a %s value)"</literal></expr></argument>,
<argument><expr><name>op</name></expr></argument>,<argument><expr><name>kind</name></expr></argument>,<argument><expr><name>name</name></expr></argument>,<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaG_runerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"attempt to %s a %s value"</literal></expr></argument>,<argument><expr><name>op</name></expr></argument>,<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaG_concaterror</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>StkId</name></type> <name>p1</name></decl></parameter>,<parameter><decl><type><name>StkId</name></type> <name>p2</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><call><name>ttisstring</name><argument_list>(<argument><expr><name>p1</name></expr></argument>)</argument_list></call><operator>||</operator><call><name>ttisnumber</name><argument_list>(<argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><name>p1</name><operator>=</operator><name>p2</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>luaG_typeerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>p1</name></expr></argument>,<argument><expr><literal type="string">"concatenate"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaG_aritherror</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>p1</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>p2</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>TValue</name></type> <name>temp</name></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><call><name>luaV_tonumber</name><argument_list>(<argument><expr><name>p1</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>temp</name></expr></argument>)</argument_list></call><operator>==</operator><name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>p2</name><operator>=</operator><name>p1</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>luaG_typeerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>p2</name></expr></argument>,<argument><expr><literal type="string">"perform arithmetic on"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>luaG_ordererror</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>p1</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>p2</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>t1</name><init>=<expr><name><name>luaT_typenames</name><index>[<expr><call><name>ttype</name><argument_list>(<argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>t2</name><init>=<expr><name><name>luaT_typenames</name><index>[<expr><call><name>ttype</name><argument_list>(<argument><expr><name>p2</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name><name>t1</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>==</operator><name><name>t2</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaG_runerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"attempt to compare two %s values"</literal></expr></argument>,<argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaG_runerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"attempt to compare %s with %s"</literal></expr></argument>,<argument><expr><name>t1</name></expr></argument>,<argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>addinfo</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>CallInfo</name><modifier>*</modifier></type><name>ci</name><init>=<expr><name><name>L</name><operator>-&gt;</operator><name>ci</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><call><name>isLua</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>buff</name><index>[<expr><literal type="number">60</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>line</name><init>=<expr><call><name>currentline</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaO_chunkid</name><argument_list>(<argument><expr><name>buff</name></expr></argument>,<argument><expr><call><name>getstr</name><argument_list>(<argument><expr><call><name>getluaproto</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>source</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><literal type="number">60</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaO_pushfstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"%s:%d: %s"</literal></expr></argument>,<argument><expr><name>buff</name></expr></argument>,<argument><expr><name>line</name></expr></argument>,<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaG_errormsg</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name><name>L</name><operator>-&gt;</operator><name>errfunc</name></name><operator>!=</operator><literal type="number">0</literal></expr>)</condition><block>{<block_content>
<decl_stmt><decl><type><name>StkId</name></type> <name>errfunc</name><init>=<expr><call><name>restorestack</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>errfunc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ttisfunction</name><argument_list>(<argument><expr><name>errfunc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><call><name>luaD_throw</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>setobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>errfunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>incr_top</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaD_call</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">2</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>luaD_throw</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaG_runerror</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>va_list</name></type> <name>argp</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>argp</name></expr></argument>,<argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addinfo</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>luaO_pushvfstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>fmt</name></expr></argument>,<argument><expr><name>argp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>argp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaG_errormsg</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>luaZ_fill</name><parameter_list>(<parameter><decl><type><name>ZIO</name><modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name><init>=<expr><name><name>z</name><operator>-&gt;</operator><name>L</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>buff</name></decl>;</decl_stmt>
<expr_stmt><expr><name>buff</name><operator>=</operator><call><name><name>z</name><operator>-&gt;</operator><name>reader</name></name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>z</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>buff</name><operator>==</operator><name>NULL</name><operator>||</operator><name>size</name><operator>==</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content><return>return<expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>n</name></name><operator>=</operator><name>size</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>p</name></name><operator>=</operator><name>buff</name></expr>;</expr_stmt>
<return>return <expr><call><name>char2int</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name><name>z</name><operator>-&gt;</operator><name>p</name></name><operator>++</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaZ_init</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>ZIO</name><modifier>*</modifier></type><name>z</name></decl></parameter>,<parameter><decl><type><name>lua_Reader</name></type> <name>reader</name></decl></parameter>,<parameter><decl><type><name>void</name><modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>L</name></name><operator>=</operator><name>L</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>reader</name></name><operator>=</operator><name>reader</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>data</name></name><operator>=</operator><name>data</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>n</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>p</name></name><operator>=</operator><name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>char</name><modifier>*</modifier></type><name>luaZ_openspace</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>Mbuffer</name><modifier>*</modifier></type><name>buff</name></decl></parameter>,<parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name>n</name><operator>&gt;</operator><name><name>buff</name><operator>-&gt;</operator><name>buffsize</name></name></expr>)</condition><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name>n</name><operator>&lt;</operator><literal type="number">32</literal></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><name>n</name><operator>=</operator><literal type="number">32</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>luaZ_resizebuffer</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>buff</name></expr></argument>,<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name><name>buff</name><operator>-&gt;</operator><name>buffer</name></name></expr>;</return>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>opmode</name><parameter_list>(<parameter><type><name>t</name></type></parameter>,<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>m</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(((t)&lt;&lt;7)|((a)&lt;&lt;6)|((b)&lt;&lt;4)|((c)&lt;&lt;2)|(m))</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>lu_byte</name></type> <name><name>luaP_opmodes</name><index>[<expr><operator>(</operator><call><name>cast</name><argument_list>(<argument><expr><name>int</name></expr></argument>,<argument><expr><name>OP_VARARG</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>]</index></name><init>=<expr><block>{
<expr><call><name>opmode</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>OpArgR</name></expr></argument>,<argument><expr><name>OpArgN</name></expr></argument>,<argument><expr><name>iABC</name></expr></argument>)</argument_list></call></expr>
,<expr><call><name>opmode</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>OpArgK</name></expr></argument>,<argument><expr><name>OpArgN</name></expr></argument>,<argument><expr><name>iABx</name></expr></argument>)</argument_list></call></expr>
,<expr><call><name>opmode</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>OpArgU</name></expr></argument>,<argument><expr><name>OpArgU</name></expr></argument>,<argument><expr><name>iABC</name></expr></argument>)</argument_list></call></expr>
,<expr><call><name>opmode</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>OpArgR</name></expr></argument>,<argument><expr><name>OpArgN</name></expr></argument>,<argument><expr><name>iABC</name></expr></argument>)</argument_list></call></expr>
,<expr><call><name>opmode</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>OpArgU</name></expr></argument>,<argument><expr><name>OpArgN</name></expr></argument>,<argument><expr><name>iABC</name></expr></argument>)</argument_list></call></expr>
,<expr><call><name>opmode</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>OpArgK</name></expr></argument>,<argument><expr><name>OpArgN</name></expr></argument>,<argument><expr><name>iABx</name></expr></argument>)</argument_list></call></expr>
,<expr><call><name>opmode</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>OpArgR</name></expr></argument>,<argument><expr><name>OpArgK</name></expr></argument>,<argument><expr><name>iABC</name></expr></argument>)</argument_list></call></expr>
,<expr><call><name>opmode</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>OpArgK</name></expr></argument>,<argument><expr><name>OpArgN</name></expr></argument>,<argument><expr><name>iABx</name></expr></argument>)</argument_list></call></expr>
,<expr><call><name>opmode</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>OpArgU</name></expr></argument>,<argument><expr><name>OpArgN</name></expr></argument>,<argument><expr><name>iABC</name></expr></argument>)</argument_list></call></expr>
,<expr><call><name>opmode</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>OpArgK</name></expr></argument>,<argument><expr><name>OpArgK</name></expr></argument>,<argument><expr><name>iABC</name></expr></argument>)</argument_list></call></expr>
,<expr><call><name>opmode</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>OpArgU</name></expr></argument>,<argument><expr><name>OpArgU</name></expr></argument>,<argument><expr><name>iABC</name></expr></argument>)</argument_list></call></expr>
,<expr><call><name>opmode</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>OpArgR</name></expr></argument>,<argument><expr><name>OpArgK</name></expr></argument>,<argument><expr><name>iABC</name></expr></argument>)</argument_list></call></expr>
,<expr><call><name>opmode</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>OpArgK</name></expr></argument>,<argument><expr><name>OpArgK</name></expr></argument>,<argument><expr><name>iABC</name></expr></argument>)</argument_list></call></expr>
,<expr><call><name>opmode</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>OpArgK</name></expr></argument>,<argument><expr><name>OpArgK</name></expr></argument>,<argument><expr><name>iABC</name></expr></argument>)</argument_list></call></expr>
,<expr><call><name>opmode</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>OpArgK</name></expr></argument>,<argument><expr><name>OpArgK</name></expr></argument>,<argument><expr><name>iABC</name></expr></argument>)</argument_list></call></expr>
,<expr><call><name>opmode</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>OpArgK</name></expr></argument>,<argument><expr><name>OpArgK</name></expr></argument>,<argument><expr><name>iABC</name></expr></argument>)</argument_list></call></expr>
,<expr><call><name>opmode</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>OpArgK</name></expr></argument>,<argument><expr><name>OpArgK</name></expr></argument>,<argument><expr><name>iABC</name></expr></argument>)</argument_list></call></expr>
,<expr><call><name>opmode</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>OpArgK</name></expr></argument>,<argument><expr><name>OpArgK</name></expr></argument>,<argument><expr><name>iABC</name></expr></argument>)</argument_list></call></expr>
,<expr><call><name>opmode</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>OpArgR</name></expr></argument>,<argument><expr><name>OpArgN</name></expr></argument>,<argument><expr><name>iABC</name></expr></argument>)</argument_list></call></expr>
,<expr><call><name>opmode</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>OpArgR</name></expr></argument>,<argument><expr><name>OpArgN</name></expr></argument>,<argument><expr><name>iABC</name></expr></argument>)</argument_list></call></expr>
,<expr><call><name>opmode</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>OpArgR</name></expr></argument>,<argument><expr><name>OpArgN</name></expr></argument>,<argument><expr><name>iABC</name></expr></argument>)</argument_list></call></expr>
,<expr><call><name>opmode</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>OpArgR</name></expr></argument>,<argument><expr><name>OpArgR</name></expr></argument>,<argument><expr><name>iABC</name></expr></argument>)</argument_list></call></expr>
,<expr><call><name>opmode</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>OpArgR</name></expr></argument>,<argument><expr><name>OpArgN</name></expr></argument>,<argument><expr><name>iAsBx</name></expr></argument>)</argument_list></call></expr>
,<expr><call><name>opmode</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>OpArgK</name></expr></argument>,<argument><expr><name>OpArgK</name></expr></argument>,<argument><expr><name>iABC</name></expr></argument>)</argument_list></call></expr>
,<expr><call><name>opmode</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>OpArgK</name></expr></argument>,<argument><expr><name>OpArgK</name></expr></argument>,<argument><expr><name>iABC</name></expr></argument>)</argument_list></call></expr>
,<expr><call><name>opmode</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>OpArgK</name></expr></argument>,<argument><expr><name>OpArgK</name></expr></argument>,<argument><expr><name>iABC</name></expr></argument>)</argument_list></call></expr>
,<expr><call><name>opmode</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>OpArgR</name></expr></argument>,<argument><expr><name>OpArgU</name></expr></argument>,<argument><expr><name>iABC</name></expr></argument>)</argument_list></call></expr>
,<expr><call><name>opmode</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>OpArgR</name></expr></argument>,<argument><expr><name>OpArgU</name></expr></argument>,<argument><expr><name>iABC</name></expr></argument>)</argument_list></call></expr>
,<expr><call><name>opmode</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>OpArgU</name></expr></argument>,<argument><expr><name>OpArgU</name></expr></argument>,<argument><expr><name>iABC</name></expr></argument>)</argument_list></call></expr>
,<expr><call><name>opmode</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>OpArgU</name></expr></argument>,<argument><expr><name>OpArgU</name></expr></argument>,<argument><expr><name>iABC</name></expr></argument>)</argument_list></call></expr>
,<expr><call><name>opmode</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>OpArgU</name></expr></argument>,<argument><expr><name>OpArgN</name></expr></argument>,<argument><expr><name>iABC</name></expr></argument>)</argument_list></call></expr>
,<expr><call><name>opmode</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>OpArgR</name></expr></argument>,<argument><expr><name>OpArgN</name></expr></argument>,<argument><expr><name>iAsBx</name></expr></argument>)</argument_list></call></expr>
,<expr><call><name>opmode</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>OpArgR</name></expr></argument>,<argument><expr><name>OpArgN</name></expr></argument>,<argument><expr><name>iAsBx</name></expr></argument>)</argument_list></call></expr>
,<expr><call><name>opmode</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>OpArgN</name></expr></argument>,<argument><expr><name>OpArgU</name></expr></argument>,<argument><expr><name>iABC</name></expr></argument>)</argument_list></call></expr>
,<expr><call><name>opmode</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>OpArgU</name></expr></argument>,<argument><expr><name>OpArgU</name></expr></argument>,<argument><expr><name>iABC</name></expr></argument>)</argument_list></call></expr>
,<expr><call><name>opmode</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>OpArgN</name></expr></argument>,<argument><expr><name>OpArgN</name></expr></argument>,<argument><expr><name>iABC</name></expr></argument>)</argument_list></call></expr>
,<expr><call><name>opmode</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>OpArgU</name></expr></argument>,<argument><expr><name>OpArgN</name></expr></argument>,<argument><expr><name>iABx</name></expr></argument>)</argument_list></call></expr>
,<macro><name>opmode</name><argument_list>(<argument><literal type="number">0</literal></argument>,<argument><literal type="number">1</literal></argument>,<argument>OpArgU</argument>,<argument>OpArgN</argument>,<argument>iABC</argument>)</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>next</name><parameter_list>(<parameter><type><name>ls</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(ls-&gt;current=zgetc(ls-&gt;z))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>currIsNewline</name><parameter_list>(<parameter><type><name>ls</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(ls-&gt;current=='\n'||ls-&gt;current=='\r')</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name><modifier>*</modifier><specifier>const</specifier></type> <name><name>luaX_tokens</name><index>[]</index></name><init>=<expr><block>{
<expr><literal type="string">"and"</literal></expr>,<expr><literal type="string">"break"</literal></expr>,<expr><literal type="string">"do"</literal></expr>,<expr><literal type="string">"else"</literal></expr>,<expr><literal type="string">"elseif"</literal></expr>,
<expr><literal type="string">"end"</literal></expr>,<expr><literal type="string">"false"</literal></expr>,<expr><literal type="string">"for"</literal></expr>,<expr><literal type="string">"function"</literal></expr>,<expr><literal type="string">"if"</literal></expr>,
<expr><literal type="string">"in"</literal></expr>,<expr><literal type="string">"local"</literal></expr>,<expr><literal type="string">"nil"</literal></expr>,<expr><literal type="string">"not"</literal></expr>,<expr><literal type="string">"or"</literal></expr>,<expr><literal type="string">"repeat"</literal></expr>,
<expr><literal type="string">"return"</literal></expr>,<expr><literal type="string">"then"</literal></expr>,<expr><literal type="string">"true"</literal></expr>,<expr><literal type="string">"until"</literal></expr>,<expr><literal type="string">"while"</literal></expr>,
<expr><literal type="string">".."</literal></expr>,<expr><literal type="string">"..."</literal></expr>,<expr><literal type="string">"=="</literal></expr>,<expr><literal type="string">"&gt;="</literal></expr>,<expr><literal type="string">"&lt;="</literal></expr>,<expr><literal type="string">"~="</literal></expr>,
<expr><literal type="string">"&lt;number&gt;"</literal></expr>,<expr><literal type="string">"&lt;name&gt;"</literal></expr>,<expr><literal type="string">"&lt;string&gt;"</literal></expr>,<expr><literal type="string">"&lt;eof&gt;"</literal></expr>,
<expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>save_and_next</name><parameter_list>(<parameter><type><name>ls</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(save(ls,ls-&gt;current),next(ls))</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>void</name></type> <name>save</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>Mbuffer</name><modifier>*</modifier></type><name>b</name><init>=<expr><name><name>ls</name><operator>-&gt;</operator><name>buff</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>n</name></name><operator>+</operator><literal type="number">1</literal><operator>&gt;</operator><name><name>b</name><operator>-&gt;</operator><name>buffsize</name></name></expr>)</condition><block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>newsize</name></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>buffsize</name></name><operator>&gt;=</operator><operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><operator>~</operator><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">0</literal><operator>)</operator><operator>-</operator><literal type="number">2</literal><operator>)</operator><operator>/</operator><literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaX_lexerror</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><literal type="string">"lexical element too long"</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>newsize</name><operator>=</operator><name><name>b</name><operator>-&gt;</operator><name>buffsize</name></name><operator>*</operator><literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaZ_resizebuffer</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>,<argument><expr><name>b</name></expr></argument>,<argument><expr><name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>buffer</name><index>[<expr><name><name>b</name><operator>-&gt;</operator><name>n</name></name><operator>++</operator></expr>]</index></name><operator>=</operator><call><name>cast</name><argument_list>(<argument><expr><name>char</name></expr></argument>,<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaX_init</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init><condition><expr><name>i</name><operator>&lt;</operator><operator>(</operator><call><name>cast</name><argument_list>(<argument><expr><name>int</name></expr></argument>,<argument><expr><name>TK_WHILE</name><operator>-</operator><literal type="number">257</literal><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
<decl_stmt><decl><type><name>TString</name><modifier>*</modifier></type><name>ts</name><init>=<expr><call><name>luaS_new</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>luaX_tokens</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaS_fix</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ts</name><operator>-&gt;</operator><name>tsv</name><operator>.</operator><name>reserved</name></name><operator>=</operator><call><name>cast_byte</name><argument_list>(<argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>luaX_token2str</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>token</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name>token</name><operator>&lt;</operator><literal type="number">257</literal></expr>)</condition><block>{<block_content>
<return>return<expr><ternary><condition><expr><operator>(</operator><call><name>iscntrl</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call><operator>)</operator></expr>?</condition><then><expr><call><name>luaO_pushfstring</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>,<argument><expr><literal type="string">"char(%d)"</literal></expr></argument>,<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr></then><else>:
<expr><call><name>luaO_pushfstring</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>,<argument><expr><literal type="string">"%c"</literal></expr></argument>,<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><name><name>luaX_tokens</name><index>[<expr><name>token</name><operator>-</operator><literal type="number">257</literal></expr>]</index></name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>txtToken</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>token</name></decl></parameter>)</parameter_list><block>{<block_content>
<switch>switch<condition>(<expr><name>token</name></expr>)</condition><block>{<block_content>
<case>case <expr><name>TK_NAME</name></expr>:</case>
<case>case <expr><name>TK_STRING</name></expr>:</case>
<case>case <expr><name>TK_NUMBER</name></expr>:</case>
<expr_stmt><expr><call><name>save</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>luaZ_buffer</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>buff</name></name></expr></argument>)</argument_list></call></expr>;</return>
<default>default:</default>
<return>return <expr><call><name>luaX_token2str</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaX_lexerror</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>msg</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>token</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>buff</name><index>[<expr><literal type="number">80</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaO_chunkid</name><argument_list>(<argument><expr><name>buff</name></expr></argument>,<argument><expr><call><name>getstr</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>source</name></name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><literal type="number">80</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>msg</name><operator>=</operator><call><name>luaO_pushfstring</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>,<argument><expr><literal type="string">"%s:%d: %s"</literal></expr></argument>,<argument><expr><name>buff</name></expr></argument>,<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>linenumber</name></name></expr></argument>,<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>token</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaO_pushfstring</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>,<argument><expr><literal type="string">"%s near "</literal><call><name>LUA_QL</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>msg</name></expr></argument>,<argument><expr><call><name>txtToken</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>luaD_throw</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaX_syntaxerror</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>luaX_lexerror</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>msg</name></expr></argument>,<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>TString</name><modifier>*</modifier></type><name>luaX_newstring</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>str</name></decl></parameter>,<parameter><decl><type><name>size_t</name></type> <name>l</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name><init>=<expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TString</name><modifier>*</modifier></type><name>ts</name><init>=<expr><call><name>luaS_newlstr</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>str</name></expr></argument>,<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TValue</name><modifier>*</modifier></type><name>o</name><init>=<expr><call><name>luaH_setstr</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name><operator>-&gt;</operator><name>h</name></name></expr></argument>,<argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><call><name>ttisnil</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>setbvalue</name><argument_list>(<argument><expr><name>o</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaC_checkGC</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ts</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>inclinenumber</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>old</name><init>=<expr><name><name>ls</name><operator>-&gt;</operator><name>current</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><call><name>currIsNewline</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call><operator>&amp;&amp;</operator><name><name>ls</name><operator>-&gt;</operator><name>current</name></name><operator>!=</operator><name>old</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><operator>++</operator><name><name>ls</name><operator>-&gt;</operator><name>linenumber</name></name><operator>&gt;=</operator><operator>(</operator><name>INT_MAX</name><operator>-</operator><literal type="number">2</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaX_syntaxerror</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><literal type="string">"chunk has too many lines"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaX_setinput</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>,<parameter><decl><type><name>ZIO</name><modifier>*</modifier></type><name>z</name></decl></parameter>,<parameter><decl><type><name>TString</name><modifier>*</modifier></type><name>source</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>decpoint</name></name><operator>=</operator><literal type="char">'.'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name><operator>=</operator><name>L</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>lookahead</name><operator>.</operator><name>token</name></name><operator>=</operator><name>TK_EOS</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>z</name></name><operator>=</operator><name>z</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name><operator>=</operator><name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>linenumber</name></name><operator>=</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>lastline</name></name><operator>=</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>source</name></name><operator>=</operator><name>source</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaZ_resizebuffer</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>,<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>buff</name></name></expr></argument>,<argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>check_next</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>set</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>strchr</name><argument_list>(<argument><expr><name>set</name></expr></argument>,<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>current</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>save_and_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>buffreplace</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>,<parameter><decl><type><name>char</name></type> <name>from</name></decl></parameter>,<parameter><decl><type><name>char</name></type> <name>to</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>n</name><init>=<expr><call><name>luaZ_bufflen</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>buff</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type><name>p</name><init>=<expr><call><name>luaZ_buffer</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>buff</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<while>while<condition>(<expr><name>n</name><operator>--</operator></expr>)</condition><block type="pseudo"><block_content>
<if_stmt><if>if<condition>(<expr><name><name>p</name><index>[<expr><name>n</name></expr>]</index></name><operator>==</operator><name>from</name></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><name><name>p</name><index>[<expr><name>n</name></expr>]</index></name><operator>=</operator><name>to</name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></while>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>read_numeral</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>,<parameter><decl><type><name>SemInfo</name><modifier>*</modifier></type><name>seminfo</name></decl></parameter>)</parameter_list><block>{<block_content>
<do>do<block>{<block_content>
<expr_stmt><expr><call><name>save_and_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>while<condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>current</name></name></expr></argument>)</argument_list></call><operator>||</operator><name><name>ls</name><operator>-&gt;</operator><name>current</name></name><operator>==</operator><literal type="char">'.'</literal></expr>)</condition>;</do>
<if_stmt><if>if<condition>(<expr><call><name>check_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><literal type="string">"Ee"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>check_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><literal type="string">"+-"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<while>while<condition>(<expr><call><name>isalnum</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>current</name></name></expr></argument>)</argument_list></call><operator>||</operator><name><name>ls</name><operator>-&gt;</operator><name>current</name></name><operator>==</operator><literal type="char">'_'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>save_and_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
<expr_stmt><expr><call><name>save</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>buffreplace</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><literal type="char">'.'</literal></expr></argument>,<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>decpoint</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>luaO_str2d</name><argument_list>(<argument><expr><call><name>luaZ_buffer</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>buff</name></name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>seminfo</name><operator>-&gt;</operator><name>r</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaX_lexerror</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><literal type="string">"malformed number"</literal></expr></argument>,<argument><expr><name>TK_NUMBER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>skip_sep</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>count</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>s</name><init>=<expr><name><name>ls</name><operator>-&gt;</operator><name>current</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>save_and_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while<condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>current</name></name><operator>==</operator><literal type="char">'='</literal></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>save_and_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return<expr><ternary><condition><expr><operator>(</operator><name><name>ls</name><operator>-&gt;</operator><name>current</name></name><operator>==</operator><name>s</name><operator>)</operator></expr>?</condition><then><expr><name>count</name></expr></then><else>:<expr><operator>(</operator><operator>-</operator><name>count</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>read_long_string</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>,<parameter><decl><type><name>SemInfo</name><modifier>*</modifier></type><name>seminfo</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>sep</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>cont</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><operator>(</operator><name>cont</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>save_and_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><call><name>currIsNewline</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>inclinenumber</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
<switch>switch<condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>current</name></name></expr>)</condition><block>{<block_content>
<case>case<expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>:</case>
<expr_stmt><expr><call><name>luaX_lexerror</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><ternary><condition><expr><operator>(</operator><name>seminfo</name><operator>)</operator></expr>?</condition><then><expr><literal type="string">"unfinished long string"</literal></expr></then><else>:
<expr><literal type="string">"unfinished long comment"</literal></expr></else></ternary></expr></argument>,<argument><expr><name>TK_EOS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case<expr><literal type="char">']'</literal></expr>:</case><block>{<block_content>
<if_stmt><if>if<condition>(<expr><call><name>skip_sep</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call><operator>==</operator><name>sep</name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>save_and_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>endloop</name>;</goto>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block>
<case>case<expr><literal type="char">'\n'</literal></expr>:</case>
<case>case<expr><literal type="char">'\r'</literal></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>save</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>inclinenumber</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><operator>!</operator><name>seminfo</name></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><call><name>luaZ_resetbuffer</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>buff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
</block_content>}</block>
<default>default:</default><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name>seminfo</name></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><call><name>save_and_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block>
</block_content>}</block></switch>
</block_content>}</block></for><label><name>endloop</name>:</label>
<if_stmt><if>if<condition>(<expr><name>seminfo</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>seminfo</name><operator>-&gt;</operator><name>ts</name></name><operator>=</operator><call><name>luaX_newstring</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><call><name>luaZ_buffer</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>buff</name></name></expr></argument>)</argument_list></call><operator>+</operator><operator>(</operator><literal type="number">2</literal><operator>+</operator><name>sep</name><operator>)</operator></expr></argument>,
<argument><expr><call><name>luaZ_bufflen</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>buff</name></name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">2</literal><operator>*</operator><operator>(</operator><literal type="number">2</literal><operator>+</operator><name>sep</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>read_string</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>del</name></decl></parameter>,<parameter><decl><type><name>SemInfo</name><modifier>*</modifier></type><name>seminfo</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>save_and_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while<condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>current</name></name><operator>!=</operator><name>del</name></expr>)</condition><block>{<block_content>
<switch>switch<condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>current</name></name></expr>)</condition><block>{<block_content>
<case>case<expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>:</case>
<expr_stmt><expr><call><name>luaX_lexerror</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><literal type="string">"unfinished string"</literal></expr></argument>,<argument><expr><name>TK_EOS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
<case>case<expr><literal type="char">'\n'</literal></expr>:</case>
<case>case<expr><literal type="char">'\r'</literal></expr>:</case>
<expr_stmt><expr><call><name>luaX_lexerror</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><literal type="string">"unfinished string"</literal></expr></argument>,<argument><expr><name>TK_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
<case>case<expr><literal type="char">'\\'</literal></expr>:</case><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch<condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>current</name></name></expr>)</condition><block>{<block_content>
<case>case<expr><literal type="char">'a'</literal></expr>:</case><expr_stmt><expr><name>c</name><operator>=</operator><literal type="char">'\a'</literal></expr>;</expr_stmt><break>break;</break>
<case>case<expr><literal type="char">'b'</literal></expr>:</case><expr_stmt><expr><name>c</name><operator>=</operator><literal type="char">'\b'</literal></expr>;</expr_stmt><break>break;</break>
<case>case<expr><literal type="char">'f'</literal></expr>:</case><expr_stmt><expr><name>c</name><operator>=</operator><literal type="char">'\f'</literal></expr>;</expr_stmt><break>break;</break>
<case>case<expr><literal type="char">'n'</literal></expr>:</case><expr_stmt><expr><name>c</name><operator>=</operator><literal type="char">'\n'</literal></expr>;</expr_stmt><break>break;</break>
<case>case<expr><literal type="char">'r'</literal></expr>:</case><expr_stmt><expr><name>c</name><operator>=</operator><literal type="char">'\r'</literal></expr>;</expr_stmt><break>break;</break>
<case>case<expr><literal type="char">'t'</literal></expr>:</case><expr_stmt><expr><name>c</name><operator>=</operator><literal type="char">'\t'</literal></expr>;</expr_stmt><break>break;</break>
<case>case<expr><literal type="char">'v'</literal></expr>:</case><expr_stmt><expr><name>c</name><operator>=</operator><literal type="char">'\v'</literal></expr>;</expr_stmt><break>break;</break>
<case>case<expr><literal type="char">'\n'</literal></expr>:</case>
<case>case<expr><literal type="char">'\r'</literal></expr>:</case><expr_stmt><expr><call><name>save</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt><expr_stmt><expr><call><name>inclinenumber</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt><continue>continue;</continue>
<case>case<expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>:</case><continue>continue;</continue>
<default>default:</default><block>{<block_content>
<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>isdigit</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>current</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>save_and_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>c</name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<do>do<block>{<block_content>
<expr_stmt><expr><name>c</name><operator>=</operator><literal type="number">10</literal><operator>*</operator><name>c</name><operator>+</operator><operator>(</operator><name><name>ls</name><operator>-&gt;</operator><name>current</name></name><operator>-</operator><literal type="char">'0'</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>while<condition>(<expr><operator>++</operator><name>i</name><operator>&lt;</operator><literal type="number">3</literal><operator>&amp;&amp;</operator><call><name>isdigit</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>current</name></name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
<if_stmt><if>if<condition>(<expr><name>c</name><operator>&gt;</operator><name>UCHAR_MAX</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaX_lexerror</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><literal type="string">"escape sequence too large"</literal></expr></argument>,<argument><expr><name>TK_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>save</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<continue>continue;</continue>
</block_content>}</block>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>save</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block>
<default>default:</default>
<expr_stmt><expr><call><name>save_and_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
</block_content>}</block></while>
<expr_stmt><expr><call><name>save_and_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>seminfo</name><operator>-&gt;</operator><name>ts</name></name><operator>=</operator><call><name>luaX_newstring</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><call><name>luaZ_buffer</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>buff</name></name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></argument>,
<argument><expr><call><name>luaZ_bufflen</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>buff</name></name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>llex</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>,<parameter><decl><type><name>SemInfo</name><modifier>*</modifier></type><name>seminfo</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>luaZ_resetbuffer</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>buff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
<switch>switch<condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>current</name></name></expr>)</condition><block>{<block_content>
<case>case<expr><literal type="char">'\n'</literal></expr>:</case>
<case>case<expr><literal type="char">'\r'</literal></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>inclinenumber</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block>
<case>case<expr><literal type="char">'-'</literal></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>current</name></name><operator>!=</operator><literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content><return>return<expr><literal type="char">'-'</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>current</name></name><operator>==</operator><literal type="char">'['</literal></expr>)</condition><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>sep</name><init>=<expr><call><name>skip_sep</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaZ_resetbuffer</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>buff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>sep</name><operator>&gt;=</operator><literal type="number">0</literal></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>read_long_string</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaZ_resetbuffer</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>buff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<while>while<condition>(<expr><operator>!</operator><call><name>currIsNewline</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call><operator>&amp;&amp;</operator><name><name>ls</name><operator>-&gt;</operator><name>current</name></name><operator>!=</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
<continue>continue;</continue>
</block_content>}</block>
<case>case<expr><literal type="char">'['</literal></expr>:</case><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>sep</name><init>=<expr><call><name>skip_sep</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>sep</name><operator>&gt;=</operator><literal type="number">0</literal></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>read_long_string</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>seminfo</name></expr></argument>,<argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>TK_STRING</name></expr>;</return>
</block_content>}</block></if>
<if type="elseif">else if<condition>(<expr><name>sep</name><operator>==</operator><operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content><return>return<expr><literal type="char">'['</literal></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>luaX_lexerror</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><literal type="string">"invalid long string delimiter"</literal></expr></argument>,<argument><expr><name>TK_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block>
<case>case<expr><literal type="char">'='</literal></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>current</name></name><operator>!=</operator><literal type="char">'='</literal></expr>)</condition><block type="pseudo"><block_content><return>return<expr><literal type="char">'='</literal></expr>;</return></block_content></block></if>
<else>else<block>{<block_content><expr_stmt><expr><call><name>next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt><return>return <expr><name>TK_EQ</name></expr>;</return></block_content>}</block></else></if_stmt>
</block_content>}</block>
<case>case<expr><literal type="char">'&lt;'</literal></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>current</name></name><operator>!=</operator><literal type="char">'='</literal></expr>)</condition><block type="pseudo"><block_content><return>return<expr><literal type="char">'&lt;'</literal></expr>;</return></block_content></block></if>
<else>else<block>{<block_content><expr_stmt><expr><call><name>next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt><return>return <expr><name>TK_LE</name></expr>;</return></block_content>}</block></else></if_stmt>
</block_content>}</block>
<case>case<expr><literal type="char">'&gt;'</literal></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>current</name></name><operator>!=</operator><literal type="char">'='</literal></expr>)</condition><block type="pseudo"><block_content><return>return<expr><literal type="char">'&gt;'</literal></expr>;</return></block_content></block></if>
<else>else<block>{<block_content><expr_stmt><expr><call><name>next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt><return>return <expr><name>TK_GE</name></expr>;</return></block_content>}</block></else></if_stmt>
</block_content>}</block>
<case>case<expr><literal type="char">'~'</literal></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>current</name></name><operator>!=</operator><literal type="char">'='</literal></expr>)</condition><block type="pseudo"><block_content><return>return<expr><literal type="char">'~'</literal></expr>;</return></block_content></block></if>
<else>else<block>{<block_content><expr_stmt><expr><call><name>next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt><return>return <expr><name>TK_NE</name></expr>;</return></block_content>}</block></else></if_stmt>
</block_content>}</block>
<case>case<expr><literal type="char">'"'</literal></expr>:</case>
<case>case<expr><literal type="char">'\''</literal></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>read_string</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>current</name></name></expr></argument>,<argument><expr><name>seminfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>TK_STRING</name></expr>;</return>
</block_content>}</block>
<case>case<expr><literal type="char">'.'</literal></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>save_and_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><call><name>check_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<if_stmt><if>if<condition>(<expr><call><name>check_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>TK_DOTS</name></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content> <return>return <expr><name>TK_CONCAT</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if<condition>(<expr><operator>!</operator><call><name>isdigit</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>current</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content><return>return<expr><literal type="char">'.'</literal></expr>;</return></block_content></block></if>
<else>else<block>{<block_content>
<expr_stmt><expr><call><name>read_numeral</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>seminfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>TK_NUMBER</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block>
<case>case<expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>:</case><block>{<block_content>
<return>return <expr><name>TK_EOS</name></expr>;</return>
</block_content>}</block>
<default>default:</default><block>{<block_content>
<if_stmt><if>if<condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>current</name></name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if>
<if type="elseif">else if<condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>current</name></name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>read_numeral</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>seminfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>TK_NUMBER</name></expr>;</return>
</block_content>}</block></if>
<if type="elseif">else if<condition>(<expr><call><name>isalpha</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>current</name></name></expr></argument>)</argument_list></call><operator>||</operator><name><name>ls</name><operator>-&gt;</operator><name>current</name></name><operator>==</operator><literal type="char">'_'</literal></expr>)</condition><block>{<block_content>
<decl_stmt><decl><type><name>TString</name><modifier>*</modifier></type><name>ts</name></decl>;</decl_stmt>
<do>do<block>{<block_content>
<expr_stmt><expr><call><name>save_and_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>while<condition>(<expr><call><name>isalnum</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>current</name></name></expr></argument>)</argument_list></call><operator>||</operator><name><name>ls</name><operator>-&gt;</operator><name>current</name></name><operator>==</operator><literal type="char">'_'</literal></expr>)</condition>;</do>
<expr_stmt><expr><name>ts</name><operator>=</operator><call><name>luaX_newstring</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><call><name>luaZ_buffer</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>buff</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>luaZ_bufflen</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>buff</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name><name>ts</name><operator>-&gt;</operator><name>tsv</name><operator>.</operator><name>reserved</name></name><operator>&gt;</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>ts</name><operator>-&gt;</operator><name>tsv</name><operator>.</operator><name>reserved</name></name><operator>-</operator><literal type="number">1</literal><operator>+</operator><literal type="number">257</literal></expr>;</return></block_content></block></if>
<else>else<block>{<block_content>
<expr_stmt><expr><name><name>seminfo</name><operator>-&gt;</operator><name>ts</name></name><operator>=</operator><name>ts</name></expr>;</expr_stmt>
<return>return <expr><name>TK_NAME</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<else>else<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>c</name><init>=<expr><name><name>ls</name><operator>-&gt;</operator><name>current</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>c</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block>
</block_content>}</block></switch>
</block_content>}</block></for>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaX_next</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>lastline</name></name><operator>=</operator><name><name>ls</name><operator>-&gt;</operator><name>linenumber</name></name></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>lookahead</name><operator>.</operator><name>token</name></name><operator>!=</operator><name>TK_EOS</name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>t</name></name><operator>=</operator><name><name>ls</name><operator>-&gt;</operator><name>lookahead</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>lookahead</name><operator>.</operator><name>token</name></name><operator>=</operator><name>TK_EOS</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name><operator>=</operator><call><name>llex</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>seminfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaX_lookahead</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>lookahead</name><operator>.</operator><name>token</name></name><operator>=</operator><call><name>llex</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>ls</name><operator>-&gt;</operator><name>lookahead</name><operator>.</operator><name>seminfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>hasjumps</name><parameter_list>(<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((e)-&gt;t!=(e)-&gt;f)</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>int</name></type> <name>isnumeral</name><parameter_list>(<parameter><decl><type><name>expdesc</name><modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list><block>{<block_content>
<return>return<expr><operator>(</operator><name><name>e</name><operator>-&gt;</operator><name>k</name></name><operator>==</operator><name>VKNUM</name><operator>&amp;&amp;</operator><name><name>e</name><operator>-&gt;</operator><name>t</name></name><operator>==</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>&amp;&amp;</operator><name><name>e</name><operator>-&gt;</operator><name>f</name></name><operator>==</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaK_nil</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>from</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>Instruction</name><modifier>*</modifier></type><name>previous</name></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name><name>fs</name><operator>-&gt;</operator><name>pc</name></name><operator>&gt;</operator><name><name>fs</name><operator>-&gt;</operator><name>lasttarget</name></name></expr>)</condition><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name><name>fs</name><operator>-&gt;</operator><name>pc</name></name><operator>==</operator><literal type="number">0</literal></expr>)</condition><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name>from</name><operator>&gt;=</operator><name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
</block_content>}</block></if>
<else>else<block>{<block_content>
<expr_stmt><expr><name>previous</name><operator>=</operator><operator>&amp;</operator><name><name>fs</name><operator>-&gt;</operator><name>f</name><operator>-&gt;</operator><name>code</name><index>[<expr><name><name>fs</name><operator>-&gt;</operator><name>pc</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><call><name>GET_OPCODE</name><argument_list>(<argument><expr><operator>*</operator><name>previous</name></expr></argument>)</argument_list></call><operator>==</operator><name>OP_LOADNIL</name></expr>)</condition><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>pfrom</name><init>=<expr><call><name>GETARG_A</name><argument_list>(<argument><expr><operator>*</operator><name>previous</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pto</name><init>=<expr><call><name>GETARG_B</name><argument_list>(<argument><expr><operator>*</operator><name>previous</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>pfrom</name><operator>&lt;=</operator><name>from</name><operator>&amp;&amp;</operator><name>from</name><operator>&lt;=</operator><name>pto</name><operator>+</operator><literal type="number">1</literal></expr>)</condition><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name>from</name><operator>+</operator><name>n</name><operator>-</operator><literal type="number">1</literal><operator>&gt;</operator><name>pto</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>SETARG_B</name><argument_list>(<argument><expr><operator>*</operator><name>previous</name></expr></argument>,<argument><expr><name>from</name><operator>+</operator><name>n</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>luaK_codeABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>OP_LOADNIL</name></expr></argument>,<argument><expr><name>from</name></expr></argument>,<argument><expr><name>from</name><operator>+</operator><name>n</name><operator>-</operator><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>luaK_jump</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>jpc</name><init>=<expr><name><name>fs</name><operator>-&gt;</operator><name>jpc</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>jpc</name></name><operator>=</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name><operator>=</operator><call><name>luaK_codeAsBx</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>OP_JMP</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaK_concat</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>j</name></expr></argument>,<argument><expr><name>jpc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>j</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaK_ret</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>first</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>nret</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>luaK_codeABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>OP_RETURN</name></expr></argument>,<argument><expr><name>first</name></expr></argument>,<argument><expr><name>nret</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>condjump</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name>OpCode</name></type> <name>op</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>A</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>B</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>C</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>luaK_codeABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>op</name></expr></argument>,<argument><expr><name>A</name></expr></argument>,<argument><expr><name>B</name></expr></argument>,<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>luaK_jump</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fixjump</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>pc</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>dest</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>Instruction</name><modifier>*</modifier></type><name>jmp</name><init>=<expr><operator>&amp;</operator><name><name>fs</name><operator>-&gt;</operator><name>f</name><operator>-&gt;</operator><name>code</name><index>[<expr><name>pc</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>offset</name><init>=<expr><name>dest</name><operator>-</operator><operator>(</operator><name>pc</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><call><name>abs</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call><operator>&gt;</operator><operator>(</operator><operator>(</operator><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><operator>(</operator><literal type="number">9</literal><operator>+</operator><literal type="number">9</literal><operator>)</operator><operator>)</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>&gt;&gt;</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaX_syntaxerror</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>ls</name></name></expr></argument>,<argument><expr><literal type="string">"control structure too long"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>SETARG_sBx</name><argument_list>(<argument><expr><operator>*</operator><name>jmp</name></expr></argument>,<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>luaK_getlabel</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>lasttarget</name></name><operator>=</operator><name><name>fs</name><operator>-&gt;</operator><name>pc</name></name></expr>;</expr_stmt>
<return>return <expr><name><name>fs</name><operator>-&gt;</operator><name>pc</name></name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>getjump</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>pc</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>offset</name><init>=<expr><call><name>GETARG_sBx</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>f</name><operator>-&gt;</operator><name>code</name><index>[<expr><name>pc</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>offset</name><operator>==</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return<expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return<expr><operator>(</operator><name>pc</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>+</operator><name>offset</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>Instruction</name><modifier>*</modifier></type><name>getjumpcontrol</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>pc</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>Instruction</name><modifier>*</modifier></type><name>pi</name><init>=<expr><operator>&amp;</operator><name><name>fs</name><operator>-&gt;</operator><name>f</name><operator>-&gt;</operator><name>code</name><index>[<expr><name>pc</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>pc</name><operator>&gt;=</operator><literal type="number">1</literal><operator>&amp;&amp;</operator><call><name>testTMode</name><argument_list>(<argument><expr><call><name>GET_OPCODE</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>pi</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>pi</name><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><name>pi</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>need_value</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>list</name></decl></parameter>)</parameter_list><block>{<block_content>
<for>for<control>(<init>;</init><condition><expr><name>list</name><operator>!=</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</condition><incr><expr><name>list</name><operator>=</operator><call><name>getjump</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr></incr>)</control><block>{<block_content>
<decl_stmt><decl><type><name>Instruction</name></type> <name>i</name><init>=<expr><operator>*</operator><call><name>getjumpcontrol</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><call><name>GET_OPCODE</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>!=</operator><name>OP_TESTSET</name></expr>)</condition><block type="pseudo"><block_content><return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>patchtestreg</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>node</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>reg</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>Instruction</name><modifier>*</modifier></type><name>i</name><init>=<expr><call><name>getjumpcontrol</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><call><name>GET_OPCODE</name><argument_list>(<argument><expr><operator>*</operator><name>i</name></expr></argument>)</argument_list></call><operator>!=</operator><name>OP_TESTSET</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><name>reg</name><operator>!=</operator><operator>(</operator><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>&amp;&amp;</operator><name>reg</name><operator>!=</operator><call><name>GETARG_B</name><argument_list>(<argument><expr><operator>*</operator><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>SETARG_A</name><argument_list>(<argument><expr><operator>*</operator><name>i</name></expr></argument>,<argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>i</name><operator>=</operator><call><name>CREATE_ABC</name><argument_list>(<argument><expr><name>OP_TEST</name></expr></argument>,<argument><expr><call><name>GETARG_B</name><argument_list>(<argument><expr><operator>*</operator><name>i</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><call><name>GETARG_C</name><argument_list>(<argument><expr><operator>*</operator><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>removevalues</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>list</name></decl></parameter>)</parameter_list><block>{<block_content>
<for>for<control>(<init>;</init><condition><expr><name>list</name><operator>!=</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</condition><incr><expr><name>list</name><operator>=</operator><call><name>getjump</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>patchtestreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>list</name></expr></argument>,<argument><expr><operator>(</operator><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>patchlistaux</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>list</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>vtarget</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>reg</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>dtarget</name></decl></parameter>)</parameter_list><block>{<block_content>
<while>while<condition>(<expr><name>list</name><operator>!=</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>next</name><init>=<expr><call><name>getjump</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><call><name>patchtestreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>list</name></expr></argument>,<argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fixjump</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>list</name></expr></argument>,<argument><expr><name>vtarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fixjump</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>list</name></expr></argument>,<argument><expr><name>dtarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name>list</name><operator>=</operator><name>next</name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>dischargejpc</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>patchlistaux</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>jpc</name></name></expr></argument>,<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>pc</name></name></expr></argument>,<argument><expr><operator>(</operator><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>,<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>pc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>jpc</name></name><operator>=</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaK_patchlist</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>list</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>target</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name>target</name><operator>==</operator><name><name>fs</name><operator>-&gt;</operator><name>pc</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaK_patchtohere</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block>{<block_content>
<expr_stmt><expr><call><name>patchlistaux</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>list</name></expr></argument>,<argument><expr><name>target</name></expr></argument>,<argument><expr><operator>(</operator><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>,<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaK_patchtohere</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>list</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>luaK_getlabel</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaK_concat</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>fs</name><operator>-&gt;</operator><name>jpc</name></name></expr></argument>,<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaK_concat</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name>int</name><modifier>*</modifier></type><name>l1</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>l2</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name>l2</name><operator>==</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content><return>return;</return></block_content></block></if>
<if type="elseif">else if<condition>(<expr><operator>*</operator><name>l1</name><operator>==</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>l1</name><operator>=</operator><name>l2</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>list</name><init>=<expr><operator>*</operator><name>l1</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>next</name></decl>;</decl_stmt>
<while>while<condition>(<expr><operator>(</operator><name>next</name><operator>=</operator><call><name>getjump</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>list</name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>list</name><operator>=</operator><name>next</name></expr>;</expr_stmt></block_content></block></while>
<expr_stmt><expr><call><name>fixjump</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>list</name></expr></argument>,<argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaK_checkstack</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>newstack</name><init>=<expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name><operator>+</operator><name>n</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>newstack</name><operator>&gt;</operator><name><name>fs</name><operator>-&gt;</operator><name>f</name><operator>-&gt;</operator><name>maxstacksize</name></name></expr>)</condition><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name>newstack</name><operator>&gt;=</operator><literal type="number">250</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaX_syntaxerror</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>ls</name></name></expr></argument>,<argument><expr><literal type="string">"function or expression too complex"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>f</name><operator>-&gt;</operator><name>maxstacksize</name></name><operator>=</operator><call><name>cast_byte</name><argument_list>(<argument><expr><name>newstack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaK_reserveregs</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>luaK_checkstack</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name><operator>+=</operator><name>n</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>freereg</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>reg</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ISK</name><argument_list>(<argument><expr><name>reg</name></expr></argument>)</argument_list></call><operator>&amp;&amp;</operator><name>reg</name><operator>&gt;=</operator><name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>freeexp</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name>expdesc</name><modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name><operator>==</operator><name>VNONRELOC</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>freereg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>addk</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name>TValue</name><modifier>*</modifier></type><name>k</name></decl></parameter>,<parameter><decl><type><name>TValue</name><modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name><init>=<expr><name><name>fs</name><operator>-&gt;</operator><name>L</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TValue</name><modifier>*</modifier></type><name>idx</name><init>=<expr><call><name>luaH_set</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>h</name></name></expr></argument>,<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Proto</name><modifier>*</modifier></type><name>f</name><init>=<expr><name><name>fs</name><operator>-&gt;</operator><name>f</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>oldsize</name><init>=<expr><name><name>f</name><operator>-&gt;</operator><name>sizek</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><call><name>ttisnumber</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<return>return <expr><call><name>cast_int</name><argument_list>(<argument><expr><call><name>nvalue</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if>
<else>else<block>{<block_content>
<expr_stmt><expr><call><name>setnvalue</name><argument_list>(<argument><expr><name>idx</name></expr></argument>,<argument><expr><call><name>cast_num</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>nk</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaM_growvector</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>f</name><operator>-&gt;</operator><name>k</name></name></expr></argument>,<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>nk</name></name></expr></argument>,<argument><expr><name><name>f</name><operator>-&gt;</operator><name>sizek</name></name></expr></argument>,<argument><expr><name>TValue</name></expr></argument>,
<argument><expr><operator>(</operator><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><operator>(</operator><literal type="number">9</literal><operator>+</operator><literal type="number">9</literal><operator>)</operator><operator>)</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>,<argument><expr><literal type="string">"constant table overflow"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while<condition>(<expr><name>oldsize</name><operator>&lt;</operator><name><name>f</name><operator>-&gt;</operator><name>sizek</name></name></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><call><name>setnilvalue</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>f</name><operator>-&gt;</operator><name>k</name><index>[<expr><name>oldsize</name><operator>++</operator></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
<expr_stmt><expr><call><name>setobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>f</name><operator>-&gt;</operator><name>k</name><index>[<expr><name><name>fs</name><operator>-&gt;</operator><name>nk</name></name></expr>]</index></name></expr></argument>,<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaC_barrier</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>f</name></expr></argument>,<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>fs</name><operator>-&gt;</operator><name>nk</name></name><operator>++</operator></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>luaK_stringK</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name>TString</name><modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>TValue</name></type> <name>o</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>setsvalue</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>L</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>o</name></expr></argument>,<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>addk</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>o</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>o</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>luaK_numberK</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name>lua_Number</name></type> <name>r</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>TValue</name></type> <name>o</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>setnvalue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>o</name></expr></argument>,<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>addk</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>o</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>o</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>boolK</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>b</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>TValue</name></type> <name>o</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>setbvalue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>o</name></expr></argument>,<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>addk</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>o</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>o</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>nilK</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>TValue</name></type> <name>k</name></decl>,<decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>setnilvalue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sethvalue</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>L</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>k</name></expr></argument>,<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>h</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>addk</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>k</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaK_setreturns</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name>expdesc</name><modifier>*</modifier></type><name>e</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>nresults</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name><operator>==</operator><name>VCALL</name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>SETARG_C</name><argument_list>(<argument><expr><call><name>getcode</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>nresults</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if<condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name><operator>==</operator><name>VVARARG</name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>SETARG_B</name><argument_list>(<argument><expr><call><name>getcode</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>nresults</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SETARG_A</name><argument_list>(<argument><expr><call><name>getcode</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaK_reserveregs</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaK_setoneret</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name>expdesc</name><modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name><operator>==</operator><name>VCALL</name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name><operator>=</operator><name>VNONRELOC</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name><operator>=</operator><call><name>GETARG_A</name><argument_list>(<argument><expr><call><name>getcode</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if<condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name><operator>==</operator><name>VVARARG</name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>SETARG_B</name><argument_list>(<argument><expr><call><name>getcode</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name><operator>=</operator><name>VRELOCABLE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaK_dischargevars</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name>expdesc</name><modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list><block>{<block_content>
<switch>switch<condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name></expr>)</condition><block>{<block_content>
<case>case <expr><name>VLOCAL</name></expr>:</case><block>{<block_content>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name><operator>=</operator><name>VNONRELOC</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>VUPVAL</name></expr>:</case><block>{<block_content>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name><operator>=</operator><call><name>luaK_codeABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>OP_GETUPVAL</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name><operator>=</operator><name>VRELOCABLE</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>VGLOBAL</name></expr>:</case><block>{<block_content>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name><operator>=</operator><call><name>luaK_codeABx</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>OP_GETGLOBAL</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name><operator>=</operator><name>VRELOCABLE</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>VINDEXED</name></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>freereg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>aux</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>freereg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name><operator>=</operator><call><name>luaK_codeABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>OP_GETTABLE</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr></argument>,<argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>aux</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name><operator>=</operator><name>VRELOCABLE</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>VVARARG</name></expr>:</case>
<case>case <expr><name>VCALL</name></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>luaK_setoneret</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<default>default:</default><break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>code_label</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>A</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>b</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>jump</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>luaK_getlabel</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>luaK_codeABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>OP_LOADBOOL</name></expr></argument>,<argument><expr><name>A</name></expr></argument>,<argument><expr><name>b</name></expr></argument>,<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>discharge2reg</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name>expdesc</name><modifier>*</modifier></type><name>e</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>reg</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>luaK_dischargevars</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch<condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name></expr>)</condition><block>{<block_content>
<case>case <expr><name>VNIL</name></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>luaK_nil</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>reg</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>VFALSE</name></expr>:</case><case>case <expr><name>VTRUE</name></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>luaK_codeABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>OP_LOADBOOL</name></expr></argument>,<argument><expr><name>reg</name></expr></argument>,<argument><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name><operator>==</operator><name>VTRUE</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>VK</name></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>luaK_codeABx</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>OP_LOADK</name></expr></argument>,<argument><expr><name>reg</name></expr></argument>,<argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>VKNUM</name></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>luaK_codeABx</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>OP_LOADK</name></expr></argument>,<argument><expr><name>reg</name></expr></argument>,<argument><expr><call><name>luaK_numberK</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>nval</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>VRELOCABLE</name></expr>:</case><block>{<block_content>
<decl_stmt><decl><type><name>Instruction</name><modifier>*</modifier></type><name>pc</name><init>=<expr><operator>&amp;</operator><call><name>getcode</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SETARG_A</name><argument_list>(<argument><expr><operator>*</operator><name>pc</name></expr></argument>,<argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>VNONRELOC</name></expr>:</case><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name>reg</name><operator>!=</operator><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaK_codeABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>OP_MOVE</name></expr></argument>,<argument><expr><name>reg</name></expr></argument>,<argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
</block_content>}</block>
<default>default:</default><block>{<block_content>
<return>return;</return>
</block_content>}</block>
</block_content>}</block></switch>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name><operator>=</operator><name>reg</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name><operator>=</operator><name>VNONRELOC</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>discharge2anyreg</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name>expdesc</name><modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name><operator>!=</operator><name>VNONRELOC</name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>luaK_reserveregs</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>discharge2reg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>e</name></expr></argument>,<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>exp2reg</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name>expdesc</name><modifier>*</modifier></type><name>e</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>reg</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>discharge2reg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>e</name></expr></argument>,<argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name><operator>==</operator><name>VJMP</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaK_concat</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>e</name><operator>-&gt;</operator><name>t</name></name></expr></argument>,<argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><call><name>hasjumps</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>final</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>p_f</name><init>=<expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>p_t</name><init>=<expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><call><name>need_value</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name><name>e</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call><operator>||</operator><call><name>need_value</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name><name>e</name><operator>-&gt;</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>fj</name><init>=<expr><ternary><condition><expr><operator>(</operator><name><name>e</name><operator>-&gt;</operator><name>k</name></name><operator>==</operator><name>VJMP</name><operator>)</operator></expr>?</condition><then><expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></then><else>:<expr><call><name>luaK_jump</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>p_f</name><operator>=</operator><call><name>code_label</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>reg</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p_t</name><operator>=</operator><call><name>code_label</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>reg</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaK_patchtohere</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>fj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>final</name><operator>=</operator><call><name>luaK_getlabel</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>patchlistaux</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name><name>e</name><operator>-&gt;</operator><name>f</name></name></expr></argument>,<argument><expr><name>final</name></expr></argument>,<argument><expr><name>reg</name></expr></argument>,<argument><expr><name>p_f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>patchlistaux</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name><name>e</name><operator>-&gt;</operator><name>t</name></name></expr></argument>,<argument><expr><name>final</name></expr></argument>,<argument><expr><name>reg</name></expr></argument>,<argument><expr><name>p_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>f</name></name><operator>=</operator><name><name>e</name><operator>-&gt;</operator><name>t</name></name><operator>=</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name><operator>=</operator><name>reg</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name><operator>=</operator><name>VNONRELOC</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaK_exp2nextreg</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name>expdesc</name><modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>luaK_dischargevars</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>freeexp</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaK_reserveregs</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exp2reg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>e</name></expr></argument>,<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>luaK_exp2anyreg</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name>expdesc</name><modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>luaK_dischargevars</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name><operator>==</operator><name>VNONRELOC</name></expr>)</condition><block>{<block_content>
<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>hasjumps</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content><return>return <expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name><operator>&gt;=</operator><name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>exp2reg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>e</name></expr></argument>,<argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>luaK_exp2nextreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaK_exp2val</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name>expdesc</name><modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><call><name>hasjumps</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaK_exp2anyreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaK_dischargevars</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>luaK_exp2RK</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name>expdesc</name><modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>luaK_exp2val</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch<condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name></expr>)</condition><block>{<block_content>
<case>case <expr><name>VKNUM</name></expr>:</case>
<case>case <expr><name>VTRUE</name></expr>:</case>
<case>case <expr><name>VFALSE</name></expr>:</case>
<case>case <expr><name>VNIL</name></expr>:</case><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name><name>fs</name><operator>-&gt;</operator><name>nk</name></name><operator>&lt;=</operator><operator>(</operator><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><operator>(</operator><literal type="number">9</literal><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition><block>{<block_content>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name><operator>=</operator><ternary><condition><expr><operator>(</operator><name><name>e</name><operator>-&gt;</operator><name>k</name></name><operator>==</operator><name>VNIL</name><operator>)</operator></expr>?</condition><then><expr><call><name>nilK</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr></then><else>:
<expr><ternary><condition><expr><operator>(</operator><name><name>e</name><operator>-&gt;</operator><name>k</name></name><operator>==</operator><name>VKNUM</name><operator>)</operator></expr>?</condition><then><expr><call><name>luaK_numberK</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>nval</name></name></expr></argument>)</argument_list></call></expr></then><else>:
<expr><call><name>boolK</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><operator>(</operator><name><name>e</name><operator>-&gt;</operator><name>k</name></name><operator>==</operator><name>VTRUE</name><operator>)</operator></expr></argument>)</argument_list></call></expr></else></ternary></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name><operator>=</operator><name>VK</name></expr>;</expr_stmt>
<return>return <expr><call><name>RKASK</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content> <break>break;</break></block_content></block></else></if_stmt>
</block_content>}</block>
<case>case <expr><name>VK</name></expr>:</case><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name><operator>&lt;=</operator><operator>(</operator><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><operator>(</operator><literal type="number">9</literal><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>RKASK</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content> <break>break;</break></block_content></block></else></if_stmt>
</block_content>}</block>
<default>default:</default><break>break;</break>
</block_content>}</block></switch>
<return>return <expr><call><name>luaK_exp2anyreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaK_storevar</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name>expdesc</name><modifier>*</modifier></type><name>var</name></decl></parameter>,<parameter><decl><type><name>expdesc</name><modifier>*</modifier></type><name>ex</name></decl></parameter>)</parameter_list><block>{<block_content>
<switch>switch<condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>k</name></name></expr>)</condition><block>{<block_content>
<case>case <expr><name>VLOCAL</name></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>freeexp</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>ex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exp2reg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>ex</name></expr></argument>,<argument><expr><name><name>var</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block>
<case>case <expr><name>VUPVAL</name></expr>:</case><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>e</name><init>=<expr><call><name>luaK_exp2anyreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>ex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaK_codeABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>OP_SETUPVAL</name></expr></argument>,<argument><expr><name>e</name></expr></argument>,<argument><expr><name><name>var</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>VGLOBAL</name></expr>:</case><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>e</name><init>=<expr><call><name>luaK_exp2anyreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>ex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaK_codeABx</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>OP_SETGLOBAL</name></expr></argument>,<argument><expr><name>e</name></expr></argument>,<argument><expr><name><name>var</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>VINDEXED</name></expr>:</case><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>e</name><init>=<expr><call><name>luaK_exp2RK</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>ex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaK_codeABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>OP_SETTABLE</name></expr></argument>,<argument><expr><name><name>var</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr></argument>,<argument><expr><name><name>var</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>aux</name></name></expr></argument>,<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<default>default:</default><block>{<block_content>
<break>break;</break>
</block_content>}</block>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>freeexp</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>ex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaK_self</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name>expdesc</name><modifier>*</modifier></type><name>e</name></decl></parameter>,<parameter><decl><type><name>expdesc</name><modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>func</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaK_exp2anyreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>freeexp</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>func</name><operator>=</operator><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaK_reserveregs</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaK_codeABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>OP_SELF</name></expr></argument>,<argument><expr><name>func</name></expr></argument>,<argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr></argument>,<argument><expr><call><name>luaK_exp2RK</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>freeexp</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name><operator>=</operator><name>func</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name><operator>=</operator><name>VNONRELOC</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>invertjump</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name>expdesc</name><modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>Instruction</name><modifier>*</modifier></type><name>pc</name><init>=<expr><call><name>getjumpcontrol</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SETARG_A</name><argument_list>(<argument><expr><operator>*</operator><name>pc</name></expr></argument>,<argument><expr><operator>!</operator><operator>(</operator><call><name>GETARG_A</name><argument_list>(<argument><expr><operator>*</operator><name>pc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jumponcond</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name>expdesc</name><modifier>*</modifier></type><name>e</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>cond</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name><operator>==</operator><name>VRELOCABLE</name></expr>)</condition><block>{<block_content>
<decl_stmt><decl><type><name>Instruction</name></type> <name>ie</name><init>=<expr><call><name>getcode</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><call><name>GET_OPCODE</name><argument_list>(<argument><expr><name>ie</name></expr></argument>)</argument_list></call><operator>==</operator><name>OP_NOT</name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>pc</name></name><operator>--</operator></expr>;</expr_stmt>
<return>return <expr><call><name>condjump</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>OP_TEST</name></expr></argument>,<argument><expr><call><name>GETARG_B</name><argument_list>(<argument><expr><name>ie</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><operator>!</operator><name>cond</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>discharge2anyreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>freeexp</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>condjump</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>OP_TESTSET</name></expr></argument>,<argument><expr><operator>(</operator><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>,<argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr></argument>,<argument><expr><name>cond</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaK_goiftrue</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name>expdesc</name><modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>pc</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaK_dischargevars</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch<condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name></expr>)</condition><block>{<block_content>
<case>case <expr><name>VK</name></expr>:</case><case>case <expr><name>VKNUM</name></expr>:</case><case>case <expr><name>VTRUE</name></expr>:</case><block>{<block_content>
<expr_stmt><expr><name>pc</name><operator>=</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>VJMP</name></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>invertjump</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pc</name><operator>=</operator><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<default>default:</default><block>{<block_content>
<expr_stmt><expr><name>pc</name><operator>=</operator><call><name>jumponcond</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>e</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>luaK_concat</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>e</name><operator>-&gt;</operator><name>f</name></name></expr></argument>,<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaK_patchtohere</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name><name>e</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>t</name></name><operator>=</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaK_goiffalse</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name>expdesc</name><modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>pc</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaK_dischargevars</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch<condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name></expr>)</condition><block>{<block_content>
<case>case <expr><name>VNIL</name></expr>:</case><case>case <expr><name>VFALSE</name></expr>:</case><block>{<block_content>
<expr_stmt><expr><name>pc</name><operator>=</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>VJMP</name></expr>:</case><block>{<block_content>
<expr_stmt><expr><name>pc</name><operator>=</operator><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<default>default:</default><block>{<block_content>
<expr_stmt><expr><name>pc</name><operator>=</operator><call><name>jumponcond</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>e</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>luaK_concat</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>e</name><operator>-&gt;</operator><name>t</name></name></expr></argument>,<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaK_patchtohere</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name><name>e</name><operator>-&gt;</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>f</name></name><operator>=</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>codenot</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name>expdesc</name><modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>luaK_dischargevars</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch<condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name></expr>)</condition><block>{<block_content>
<case>case <expr><name>VNIL</name></expr>:</case><case>case <expr><name>VFALSE</name></expr>:</case><block>{<block_content>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name><operator>=</operator><name>VTRUE</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>VK</name></expr>:</case><case>case <expr><name>VKNUM</name></expr>:</case><case>case <expr><name>VTRUE</name></expr>:</case><block>{<block_content>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name><operator>=</operator><name>VFALSE</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>VJMP</name></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>invertjump</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>VRELOCABLE</name></expr>:</case>
<case>case <expr><name>VNONRELOC</name></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>discharge2anyreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>freeexp</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name><operator>=</operator><call><name>luaK_codeABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>OP_NOT</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name><operator>=</operator><name>VRELOCABLE</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<default>default:</default><block>{<block_content>
<break>break;</break>
</block_content>}</block>
</block_content>}</block></switch>
<block>{<block_content><decl_stmt><decl><type><name>int</name></type> <name>temp</name><init>=<expr><name><name>e</name><operator>-&gt;</operator><name>f</name></name></expr></init></decl>;</decl_stmt><expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>f</name></name><operator>=</operator><name><name>e</name><operator>-&gt;</operator><name>t</name></name></expr>;</expr_stmt><expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>t</name></name><operator>=</operator><name>temp</name></expr>;</expr_stmt></block_content>}</block>
<expr_stmt><expr><call><name>removevalues</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name><name>e</name><operator>-&gt;</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>removevalues</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name><name>e</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaK_indexed</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name>expdesc</name><modifier>*</modifier></type><name>t</name></decl></parameter>,<parameter><decl><type><name>expdesc</name><modifier>*</modifier></type><name>k</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>aux</name></name><operator>=</operator><call><name>luaK_exp2RK</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>k</name></name><operator>=</operator><name>VINDEXED</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>constfolding</name><parameter_list>(<parameter><decl><type><name>OpCode</name></type> <name>op</name></decl></parameter>,<parameter><decl><type><name>expdesc</name><modifier>*</modifier></type><name>e1</name></decl></parameter>,<parameter><decl><type><name>expdesc</name><modifier>*</modifier></type><name>e2</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>lua_Number</name></type> <name>v1</name></decl>,<decl><type ref="prev"/><name>v2</name></decl>,<decl><type ref="prev"/><name>r</name></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>isnumeral</name><argument_list>(<argument><expr><name>e1</name></expr></argument>)</argument_list></call><operator>||</operator><operator>!</operator><call><name>isnumeral</name><argument_list>(<argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content><return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>v1</name><operator>=</operator><name><name>e1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>nval</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>v2</name><operator>=</operator><name><name>e2</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>nval</name></name></expr>;</expr_stmt>
<switch>switch<condition>(<expr><name>op</name></expr>)</condition><block>{<block_content>
<case>case <expr><name>OP_ADD</name></expr>:</case><expr_stmt><expr><name>r</name><operator>=</operator><call><name>luai_numadd</name><argument_list>(<argument><expr><name>v1</name></expr></argument>,<argument><expr><name>v2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt><break>break;</break>
<case>case <expr><name>OP_SUB</name></expr>:</case><expr_stmt><expr><name>r</name><operator>=</operator><call><name>luai_numsub</name><argument_list>(<argument><expr><name>v1</name></expr></argument>,<argument><expr><name>v2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt><break>break;</break>
<case>case <expr><name>OP_MUL</name></expr>:</case><expr_stmt><expr><name>r</name><operator>=</operator><call><name>luai_nummul</name><argument_list>(<argument><expr><name>v1</name></expr></argument>,<argument><expr><name>v2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt><break>break;</break>
<case>case <expr><name>OP_DIV</name></expr>:</case>
<if_stmt><if>if<condition>(<expr><name>v2</name><operator>==</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content><return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name><operator>=</operator><call><name>luai_numdiv</name><argument_list>(<argument><expr><name>v1</name></expr></argument>,<argument><expr><name>v2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt><break>break;</break>
<case>case <expr><name>OP_MOD</name></expr>:</case>
<if_stmt><if>if<condition>(<expr><name>v2</name><operator>==</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content><return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name><operator>=</operator><call><name>luai_nummod</name><argument_list>(<argument><expr><name>v1</name></expr></argument>,<argument><expr><name>v2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt><break>break;</break>
<case>case <expr><name>OP_POW</name></expr>:</case><expr_stmt><expr><name>r</name><operator>=</operator><call><name>luai_numpow</name><argument_list>(<argument><expr><name>v1</name></expr></argument>,<argument><expr><name>v2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt><break>break;</break>
<case>case <expr><name>OP_UNM</name></expr>:</case><expr_stmt><expr><name>r</name><operator>=</operator><call><name>luai_numunm</name><argument_list>(<argument><expr><name>v1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt><break>break;</break>
<case>case <expr><name>OP_LEN</name></expr>:</case><return>return <expr><literal type="number">0</literal></expr>;</return>
<default>default:</default><expr_stmt><expr><name>r</name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt><break>break;</break>
</block_content>}</block></switch>
<if_stmt><if>if<condition>(<expr><call><name>luai_numisnan</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content><return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>e1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>nval</name></name><operator>=</operator><name>r</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>codearith</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name>OpCode</name></type> <name>op</name></decl></parameter>,<parameter><decl><type><name>expdesc</name><modifier>*</modifier></type><name>e1</name></decl></parameter>,<parameter><decl><type><name>expdesc</name><modifier>*</modifier></type><name>e2</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><call><name>constfolding</name><argument_list>(<argument><expr><name>op</name></expr></argument>,<argument><expr><name>e1</name></expr></argument>,<argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if>
<else>else<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>o2</name><init>=<expr><ternary><condition><expr><operator>(</operator><name>op</name><operator>!=</operator><name>OP_UNM</name><operator>&amp;&amp;</operator><name>op</name><operator>!=</operator><name>OP_LEN</name><operator>)</operator></expr>?</condition><then><expr><call><name>luaK_exp2RK</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>o1</name><init>=<expr><call><name>luaK_exp2RK</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>e1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>o1</name><operator>&gt;</operator><name>o2</name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>freeexp</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>e1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>freeexp</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block>{<block_content>
<expr_stmt><expr><call><name>freeexp</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>freeexp</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>e1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>e1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name><operator>=</operator><call><name>luaK_codeABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>op</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>o1</name></expr></argument>,<argument><expr><name>o2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e1</name><operator>-&gt;</operator><name>k</name></name><operator>=</operator><name>VRELOCABLE</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>codecomp</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name>OpCode</name></type> <name>op</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>cond</name></decl></parameter>,<parameter><decl><type><name>expdesc</name><modifier>*</modifier></type><name>e1</name></decl></parameter>,
<parameter><decl><type><name>expdesc</name><modifier>*</modifier></type><name>e2</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>o1</name><init>=<expr><call><name>luaK_exp2RK</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>e1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>o2</name><init>=<expr><call><name>luaK_exp2RK</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>freeexp</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>freeexp</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>e1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>cond</name><operator>==</operator><literal type="number">0</literal><operator>&amp;&amp;</operator><name>op</name><operator>!=</operator><name>OP_EQ</name></expr>)</condition><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>temp</name></decl>;</decl_stmt>
<expr_stmt><expr><name>temp</name><operator>=</operator><name>o1</name></expr>;</expr_stmt><expr_stmt><expr><name>o1</name><operator>=</operator><name>o2</name></expr>;</expr_stmt><expr_stmt><expr><name>o2</name><operator>=</operator><name>temp</name></expr>;</expr_stmt>
<expr_stmt><expr><name>cond</name><operator>=</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>e1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name><operator>=</operator><call><name>condjump</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>op</name></expr></argument>,<argument><expr><name>cond</name></expr></argument>,<argument><expr><name>o1</name></expr></argument>,<argument><expr><name>o2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e1</name><operator>-&gt;</operator><name>k</name></name><operator>=</operator><name>VJMP</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaK_prefix</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name>UnOpr</name></type> <name>op</name></decl></parameter>,<parameter><decl><type><name>expdesc</name><modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>expdesc</name></type> <name>e2</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>e2</name><operator>.</operator><name>t</name></name><operator>=</operator><name><name>e2</name><operator>.</operator><name>f</name></name><operator>=</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt><expr_stmt><expr><name><name>e2</name><operator>.</operator><name>k</name></name><operator>=</operator><name>VKNUM</name></expr>;</expr_stmt><expr_stmt><expr><name><name>e2</name><operator>.</operator><name>u</name><operator>.</operator><name>nval</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<switch>switch<condition>(<expr><name>op</name></expr>)</condition><block>{<block_content>
<case>case <expr><name>OPR_MINUS</name></expr>:</case><block>{<block_content>
<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>isnumeral</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaK_exp2anyreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>codearith</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>OP_UNM</name></expr></argument>,<argument><expr><name>e</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>OPR_NOT</name></expr>:</case><expr_stmt><expr><call><name>codenot</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt><break>break;</break>
<case>case <expr><name>OPR_LEN</name></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>luaK_exp2anyreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>codearith</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>OP_LEN</name></expr></argument>,<argument><expr><name>e</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<default>default:</default><empty_stmt>;</empty_stmt>
</block_content>}</block></switch>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaK_infix</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name>BinOpr</name></type> <name>op</name></decl></parameter>,<parameter><decl><type><name>expdesc</name><modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
<switch>switch<condition>(<expr><name>op</name></expr>)</condition><block>{<block_content>
<case>case <expr><name>OPR_AND</name></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>luaK_goiftrue</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>OPR_OR</name></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>luaK_goiffalse</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>OPR_CONCAT</name></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>luaK_exp2nextreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>OPR_ADD</name></expr>:</case><case>case <expr><name>OPR_SUB</name></expr>:</case><case>case <expr><name>OPR_MUL</name></expr>:</case><case>case <expr><name>OPR_DIV</name></expr>:</case>
<case>case <expr><name>OPR_MOD</name></expr>:</case><case>case <expr><name>OPR_POW</name></expr>:</case><block>{<block_content>
<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>isnumeral</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><call><name>luaK_exp2RK</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
</block_content>}</block>
<default>default:</default><block>{<block_content>
<expr_stmt><expr><call><name>luaK_exp2RK</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
</block_content>}</block></switch>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaK_posfix</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name>BinOpr</name></type> <name>op</name></decl></parameter>,<parameter><decl><type><name>expdesc</name><modifier>*</modifier></type><name>e1</name></decl></parameter>,<parameter><decl><type><name>expdesc</name><modifier>*</modifier></type><name>e2</name></decl></parameter>)</parameter_list><block>{<block_content>
<switch>switch<condition>(<expr><name>op</name></expr>)</condition><block>{<block_content>
<case>case <expr><name>OPR_AND</name></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>luaK_dischargevars</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaK_concat</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>e2</name><operator>-&gt;</operator><name>f</name></name></expr></argument>,<argument><expr><name><name>e1</name><operator>-&gt;</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>e1</name><operator>=</operator><operator>*</operator><name>e2</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>OPR_OR</name></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>luaK_dischargevars</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaK_concat</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>e2</name><operator>-&gt;</operator><name>t</name></name></expr></argument>,<argument><expr><name><name>e1</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>e1</name><operator>=</operator><operator>*</operator><name>e2</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>OPR_CONCAT</name></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>luaK_exp2val</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name><name>e2</name><operator>-&gt;</operator><name>k</name></name><operator>==</operator><name>VRELOCABLE</name><operator>&amp;&amp;</operator><call><name>GET_OPCODE</name><argument_list>(<argument><expr><call><name>getcode</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>==</operator><name>OP_CONCAT</name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>freeexp</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>e1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SETARG_B</name><argument_list>(<argument><expr><call><name>getcode</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name><name>e1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e1</name><operator>-&gt;</operator><name>k</name></name><operator>=</operator><name>VRELOCABLE</name></expr>;</expr_stmt><expr_stmt><expr><name><name>e1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name><operator>=</operator><name><name>e2</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block>{<block_content>
<expr_stmt><expr><call><name>luaK_exp2nextreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>codearith</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>OP_CONCAT</name></expr></argument>,<argument><expr><name>e1</name></expr></argument>,<argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>OPR_ADD</name></expr>:</case><expr_stmt><expr><call><name>codearith</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>OP_ADD</name></expr></argument>,<argument><expr><name>e1</name></expr></argument>,<argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt><break>break;</break>
<case>case <expr><name>OPR_SUB</name></expr>:</case><expr_stmt><expr><call><name>codearith</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>OP_SUB</name></expr></argument>,<argument><expr><name>e1</name></expr></argument>,<argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt><break>break;</break>
<case>case <expr><name>OPR_MUL</name></expr>:</case><expr_stmt><expr><call><name>codearith</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>OP_MUL</name></expr></argument>,<argument><expr><name>e1</name></expr></argument>,<argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt><break>break;</break>
<case>case <expr><name>OPR_DIV</name></expr>:</case><expr_stmt><expr><call><name>codearith</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>OP_DIV</name></expr></argument>,<argument><expr><name>e1</name></expr></argument>,<argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt><break>break;</break>
<case>case <expr><name>OPR_MOD</name></expr>:</case><expr_stmt><expr><call><name>codearith</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>OP_MOD</name></expr></argument>,<argument><expr><name>e1</name></expr></argument>,<argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt><break>break;</break>
<case>case <expr><name>OPR_POW</name></expr>:</case><expr_stmt><expr><call><name>codearith</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>OP_POW</name></expr></argument>,<argument><expr><name>e1</name></expr></argument>,<argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt><break>break;</break>
<case>case <expr><name>OPR_EQ</name></expr>:</case><expr_stmt><expr><call><name>codecomp</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>OP_EQ</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>e1</name></expr></argument>,<argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt><break>break;</break>
<case>case <expr><name>OPR_NE</name></expr>:</case><expr_stmt><expr><call><name>codecomp</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>OP_EQ</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>e1</name></expr></argument>,<argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt><break>break;</break>
<case>case <expr><name>OPR_LT</name></expr>:</case><expr_stmt><expr><call><name>codecomp</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>OP_LT</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>e1</name></expr></argument>,<argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt><break>break;</break>
<case>case <expr><name>OPR_LE</name></expr>:</case><expr_stmt><expr><call><name>codecomp</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>OP_LE</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>e1</name></expr></argument>,<argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt><break>break;</break>
<case>case <expr><name>OPR_GT</name></expr>:</case><expr_stmt><expr><call><name>codecomp</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>OP_LT</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>e1</name></expr></argument>,<argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt><break>break;</break>
<case>case <expr><name>OPR_GE</name></expr>:</case><expr_stmt><expr><call><name>codecomp</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>OP_LE</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>e1</name></expr></argument>,<argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt><break>break;</break>
<default>default:</default><empty_stmt>;</empty_stmt>
</block_content>}</block></switch>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaK_fixline</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>f</name><operator>-&gt;</operator><name>lineinfo</name><index>[<expr><name><name>fs</name><operator>-&gt;</operator><name>pc</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>=</operator><name>line</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>luaK_code</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name>Instruction</name></type> <name>i</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>Proto</name><modifier>*</modifier></type><name>f</name><init>=<expr><name><name>fs</name><operator>-&gt;</operator><name>f</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>dischargejpc</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaM_growvector</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>L</name></name></expr></argument>,<argument><expr><name><name>f</name><operator>-&gt;</operator><name>code</name></name></expr></argument>,<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>pc</name></name></expr></argument>,<argument><expr><name><name>f</name><operator>-&gt;</operator><name>sizecode</name></name></expr></argument>,<argument><expr><name>Instruction</name></expr></argument>,
<argument><expr><operator>(</operator><name>INT_MAX</name><operator>-</operator><literal type="number">2</literal><operator>)</operator></expr></argument>,<argument><expr><literal type="string">"code size overflow"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>code</name><index>[<expr><name><name>fs</name><operator>-&gt;</operator><name>pc</name></name></expr>]</index></name><operator>=</operator><name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaM_growvector</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>L</name></name></expr></argument>,<argument><expr><name><name>f</name><operator>-&gt;</operator><name>lineinfo</name></name></expr></argument>,<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>pc</name></name></expr></argument>,<argument><expr><name><name>f</name><operator>-&gt;</operator><name>sizelineinfo</name></name></expr></argument>,<argument><expr><name>int</name></expr></argument>,
<argument><expr><operator>(</operator><name>INT_MAX</name><operator>-</operator><literal type="number">2</literal><operator>)</operator></expr></argument>,<argument><expr><literal type="string">"code size overflow"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>lineinfo</name><index>[<expr><name><name>fs</name><operator>-&gt;</operator><name>pc</name></name></expr>]</index></name><operator>=</operator><name>line</name></expr>;</expr_stmt>
<return>return <expr><name><name>fs</name><operator>-&gt;</operator><name>pc</name></name><operator>++</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>luaK_codeABC</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name>OpCode</name></type> <name>o</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>a</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>b</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list><block>{<block_content>
<return>return <expr><call><name>luaK_code</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><call><name>CREATE_ABC</name><argument_list>(<argument><expr><name>o</name></expr></argument>,<argument><expr><name>a</name></expr></argument>,<argument><expr><name>b</name></expr></argument>,<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>ls</name><operator>-&gt;</operator><name>lastline</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>luaK_codeABx</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name>OpCode</name></type> <name>o</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>a</name></decl></parameter>,<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>bc</name></decl></parameter>)</parameter_list><block>{<block_content>
<return>return <expr><call><name>luaK_code</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><call><name>CREATE_ABx</name><argument_list>(<argument><expr><name>o</name></expr></argument>,<argument><expr><name>a</name></expr></argument>,<argument><expr><name>bc</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>ls</name><operator>-&gt;</operator><name>lastline</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaK_setlist</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>base</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>nelems</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>tostore</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>c</name><init>=<expr><operator>(</operator><name>nelems</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>/</operator><literal type="number">50</literal><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>b</name><init>=<expr><ternary><condition><expr><operator>(</operator><name>tostore</name><operator>==</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>?</condition><then><expr><literal type="number">0</literal></expr></then><else>:<expr><name>tostore</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>c</name><operator>&lt;=</operator><operator>(</operator><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">9</literal><operator>)</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaK_codeABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>OP_SETLIST</name></expr></argument>,<argument><expr><name>base</name></expr></argument>,<argument><expr><name>b</name></expr></argument>,<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block>{<block_content>
<expr_stmt><expr><call><name>luaK_codeABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>OP_SETLIST</name></expr></argument>,<argument><expr><name>base</name></expr></argument>,<argument><expr><name>b</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaK_code</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><call><name>cast</name><argument_list>(<argument><expr><name>Instruction</name></expr></argument>,<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>ls</name><operator>-&gt;</operator><name>lastline</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name><operator>=</operator><name>base</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>hasmultret</name><parameter_list>(<parameter><type><name>k</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((k)==VCALL||(k)==VVARARG)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>getlocvar</name><parameter_list>(<parameter><type><name>fs</name></type></parameter>,<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((fs)-&gt;f-&gt;locvars[(fs)-&gt;actvar[i]])</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>luaY_checklimit</name><parameter_list>(<parameter><type><name>fs</name></type></parameter>,<parameter><type><name>v</name></type></parameter>,<parameter><type><name>l</name></type></parameter>,<parameter><type><name>m</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>if((v)&gt;(l))errorlimit(fs,l,m)</cpp:value></cpp:define>
<typedef>typedef <type><struct>struct <name>BlockCnt</name><block>{
<decl_stmt><decl><type><name><name>struct</name> <name>BlockCnt</name></name><modifier>*</modifier></type><name>previous</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>breaklist</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>lu_byte</name></type> <name>nactvar</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>lu_byte</name></type> <name>upval</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>lu_byte</name></type> <name>isbreakable</name></decl>;</decl_stmt>
}</block></struct></type><name>BlockCnt</name>;</typedef>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>chunk</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>expr</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>,<parameter><decl><type><name>expdesc</name><modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list>;</function_decl>
<function><type><specifier>static</specifier> <name>void</name></type> <name>anchor_token</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name><operator>==</operator><name>TK_NAME</name><operator>||</operator><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name><operator>==</operator><name>TK_STRING</name></expr>)</condition><block>{<block_content>
<decl_stmt><decl><type><name>TString</name><modifier>*</modifier></type><name>ts</name><init>=<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>seminfo</name><operator>.</operator><name>ts</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaX_newstring</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><call><name>getstr</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name><name>ts</name><operator>-&gt;</operator><name>tsv</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>error_expected</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>token</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>luaX_syntaxerror</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,
<argument><expr><call><name>luaO_pushfstring</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>,<argument><expr><call><name>LUA_QL</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>)</argument_list></call><literal type="string">" expected"</literal></expr></argument>,<argument><expr><call><name>luaX_token2str</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>errorlimit</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>limit</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>what</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>msg</name><init>=<expr><ternary><condition><expr><operator>(</operator><name><name>fs</name><operator>-&gt;</operator><name>f</name><operator>-&gt;</operator><name>linedefined</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr>?</condition><then>
<expr><call><name>luaO_pushfstring</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>L</name></name></expr></argument>,<argument><expr><literal type="string">"main function has more than %d %s"</literal></expr></argument>,<argument><expr><name>limit</name></expr></argument>,<argument><expr><name>what</name></expr></argument>)</argument_list></call></expr></then><else>:
<expr><call><name>luaO_pushfstring</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>L</name></name></expr></argument>,<argument><expr><literal type="string">"function at line %d has more than %d %s"</literal></expr></argument>,
<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>f</name><operator>-&gt;</operator><name>linedefined</name></name></expr></argument>,<argument><expr><name>limit</name></expr></argument>,<argument><expr><name>what</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaX_lexerror</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>ls</name></name></expr></argument>,<argument><expr><name>msg</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>testnext</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name><operator>==</operator><name>c</name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>check</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name><operator>!=</operator><name>c</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>error_expected</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>checknext</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>check</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>check_condition</name><parameter_list>(<parameter><type><name>ls</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>msg</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>{if(!(c))luaX_syntaxerror(ls,msg);}</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>void</name></type> <name>check_match</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>what</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>who</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>where</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>testnext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>what</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name>where</name><operator>==</operator><name><name>ls</name><operator>-&gt;</operator><name>linenumber</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>error_expected</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>what</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block>{<block_content>
<expr_stmt><expr><call><name>luaX_syntaxerror</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><call><name>luaO_pushfstring</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>,
<argument><expr><call><name>LUA_QL</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>)</argument_list></call><literal type="string">" expected (to close "</literal><call><name>LUA_QL</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>)</argument_list></call><literal type="string">" at line %d)"</literal></expr></argument>,
<argument><expr><call><name>luaX_token2str</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>what</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>luaX_token2str</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>who</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>where</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>TString</name><modifier>*</modifier></type><name>str_checkname</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>TString</name><modifier>*</modifier></type><name>ts</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>check</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>TK_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ts</name><operator>=</operator><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>seminfo</name><operator>.</operator><name>ts</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ts</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>init_exp</name><parameter_list>(<parameter><decl><type><name>expdesc</name><modifier>*</modifier></type><name>e</name></decl></parameter>,<parameter><decl><type><name>expkind</name></type> <name>k</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>f</name></name><operator>=</operator><name><name>e</name><operator>-&gt;</operator><name>t</name></name><operator>=</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name><operator>=</operator><name>k</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name><operator>=</operator><name>i</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>codestring</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>,<parameter><decl><type><name>expdesc</name><modifier>*</modifier></type><name>e</name></decl></parameter>,<parameter><decl><type><name>TString</name><modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>init_exp</name><argument_list>(<argument><expr><name>e</name></expr></argument>,<argument><expr><name>VK</name></expr></argument>,<argument><expr><call><name>luaK_stringK</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>,<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>checkname</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>,<parameter><decl><type><name>expdesc</name><modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>codestring</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>e</name></expr></argument>,<argument><expr><call><name>str_checkname</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>registerlocalvar</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>,<parameter><decl><type><name>TString</name><modifier>*</modifier></type><name>varname</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name><init>=<expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Proto</name><modifier>*</modifier></type><name>f</name><init>=<expr><name><name>fs</name><operator>-&gt;</operator><name>f</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>oldsize</name><init>=<expr><name><name>f</name><operator>-&gt;</operator><name>sizelocvars</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaM_growvector</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>,<argument><expr><name><name>f</name><operator>-&gt;</operator><name>locvars</name></name></expr></argument>,<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>nlocvars</name></name></expr></argument>,<argument><expr><name><name>f</name><operator>-&gt;</operator><name>sizelocvars</name></name></expr></argument>,
<argument><expr><name>LocVar</name></expr></argument>,<argument><expr><name>SHRT_MAX</name></expr></argument>,<argument><expr><literal type="string">"too many local variables"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while<condition>(<expr><name>oldsize</name><operator>&lt;</operator><name><name>f</name><operator>-&gt;</operator><name>sizelocvars</name></name></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>locvars</name><index>[<expr><name>oldsize</name><operator>++</operator></expr>]</index></name><operator>.</operator><name>varname</name><operator>=</operator><name>NULL</name></expr>;</expr_stmt></block_content></block></while>
<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>locvars</name><index>[<expr><name><name>fs</name><operator>-&gt;</operator><name>nlocvars</name></name></expr>]</index></name><operator>.</operator><name>varname</name><operator>=</operator><name>varname</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaC_objbarrier</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>,<argument><expr><name>f</name></expr></argument>,<argument><expr><name>varname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>fs</name><operator>-&gt;</operator><name>nlocvars</name></name><operator>++</operator></expr>;</return>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>new_localvarliteral</name><parameter_list>(<parameter><type><name>ls</name></type></parameter>,<parameter><type><name>v</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>new_localvar(ls,luaX_newstring(ls,""v,(sizeof(v)/sizeof(char))-1),n)</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>void</name></type> <name>new_localvar</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>,<parameter><decl><type><name>TString</name><modifier>*</modifier></type><name>name</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name><init>=<expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaY_checklimit</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name><operator>+</operator><name>n</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">200</literal></expr></argument>,<argument><expr><literal type="string">"local variables"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>actvar</name><index>[<expr><name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name><operator>+</operator><name>n</name></expr>]</index></name><operator>=</operator><macro><name>cast</name><argument_list>(<argument>unsigned short</argument>,<argument>registerlocalvar(ls,name)</argument>)</argument_list></macro></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>adjustlocalvars</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>nvars</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name><init>=<expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name><operator>=</operator><call><name>cast_byte</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name><operator>+</operator><name>nvars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for<control>(<init>;</init><condition><expr><name>nvars</name></expr>;</condition><incr><expr><name>nvars</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
<expr_stmt><expr><call><name>getlocvar</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name><operator>-</operator><name>nvars</name></expr></argument>)</argument_list></call><operator>.</operator><name>startpc</name><operator>=</operator><name><name>fs</name><operator>-&gt;</operator><name>pc</name></name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>removevars</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>tolevel</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name><init>=<expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
<while>while<condition>(<expr><name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name><operator>&gt;</operator><name>tolevel</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>getlocvar</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><operator>--</operator><name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name></expr></argument>)</argument_list></call><operator>.</operator><name>endpc</name><operator>=</operator><name><name>fs</name><operator>-&gt;</operator><name>pc</name></name></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>indexupvalue</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name>TString</name><modifier>*</modifier></type><name>name</name></decl></parameter>,<parameter><decl><type><name>expdesc</name><modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Proto</name><modifier>*</modifier></type><name>f</name><init>=<expr><name><name>fs</name><operator>-&gt;</operator><name>f</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>oldsize</name><init>=<expr><name><name>f</name><operator>-&gt;</operator><name>sizeupvalues</name></name></expr></init></decl>;</decl_stmt>
<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init><condition><expr><name>i</name><operator>&lt;</operator><name><name>f</name><operator>-&gt;</operator><name>nups</name></name></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name><name>fs</name><operator>-&gt;</operator><name>upvalues</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>k</name><operator>==</operator><name><name>v</name><operator>-&gt;</operator><name>k</name></name><operator>&amp;&amp;</operator><name><name>fs</name><operator>-&gt;</operator><name>upvalues</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>info</name><operator>==</operator><name><name>v</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr>)</condition><block>{<block_content>
<return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>luaY_checklimit</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name><name>f</name><operator>-&gt;</operator><name>nups</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">60</literal></expr></argument>,<argument><expr><literal type="string">"upvalues"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaM_growvector</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>L</name></name></expr></argument>,<argument><expr><name><name>f</name><operator>-&gt;</operator><name>upvalues</name></name></expr></argument>,<argument><expr><name><name>f</name><operator>-&gt;</operator><name>nups</name></name></expr></argument>,<argument><expr><name><name>f</name><operator>-&gt;</operator><name>sizeupvalues</name></name></expr></argument>,
<argument><expr><name>TString</name><operator>*</operator></expr></argument>,<argument><expr><operator>(</operator><name>INT_MAX</name><operator>-</operator><literal type="number">2</literal><operator>)</operator></expr></argument>,<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while<condition>(<expr><name>oldsize</name><operator>&lt;</operator><name><name>f</name><operator>-&gt;</operator><name>sizeupvalues</name></name></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>upvalues</name><index>[<expr><name>oldsize</name><operator>++</operator></expr>]</index></name><operator>=</operator><name>NULL</name></expr>;</expr_stmt></block_content></block></while>
<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>upvalues</name><index>[<expr><name><name>f</name><operator>-&gt;</operator><name>nups</name></name></expr>]</index></name><operator>=</operator><name>name</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaC_objbarrier</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>L</name></name></expr></argument>,<argument><expr><name>f</name></expr></argument>,<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>upvalues</name><index>[<expr><name><name>f</name><operator>-&gt;</operator><name>nups</name></name></expr>]</index></name><operator>.</operator><name>k</name><operator>=</operator><call><name>cast_byte</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>k</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>upvalues</name><index>[<expr><name><name>f</name><operator>-&gt;</operator><name>nups</name></name></expr>]</index></name><operator>.</operator><name>info</name><operator>=</operator><call><name>cast_byte</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>f</name><operator>-&gt;</operator><name>nups</name></name><operator>++</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>searchvar</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name>TString</name><modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for<control>(<init><expr><name>i</name><operator>=</operator><name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init><condition><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition><incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name>n</name><operator>==</operator><call><name>getlocvar</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>.</operator><name>varname</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>i</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return<expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>markupval</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>BlockCnt</name><modifier>*</modifier></type><name>bl</name><init>=<expr><name><name>fs</name><operator>-&gt;</operator><name>bl</name></name></expr></init></decl>;</decl_stmt>
<while>while<condition>(<expr><name>bl</name><operator>&amp;&amp;</operator><name><name>bl</name><operator>-&gt;</operator><name>nactvar</name></name><operator>&gt;</operator><name>level</name></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><name>bl</name><operator>=</operator><name><name>bl</name><operator>-&gt;</operator><name>previous</name></name></expr>;</expr_stmt></block_content></block></while>
<if_stmt><if>if<condition>(<expr><name>bl</name></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><name><name>bl</name><operator>-&gt;</operator><name>upval</name></name><operator>=</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>singlevaraux</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name>TString</name><modifier>*</modifier></type><name>n</name></decl></parameter>,<parameter><decl><type><name>expdesc</name><modifier>*</modifier></type><name>var</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>base</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name>fs</name><operator>==</operator><name>NULL</name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>init_exp</name><argument_list>(<argument><expr><name>var</name></expr></argument>,<argument><expr><name>VGLOBAL</name></expr></argument>,<argument><expr><operator>(</operator><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>VGLOBAL</name></expr>;</return>
</block_content>}</block></if>
<else>else<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>v</name><init>=<expr><call><name>searchvar</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>v</name><operator>&gt;=</operator><literal type="number">0</literal></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>init_exp</name><argument_list>(<argument><expr><name>var</name></expr></argument>,<argument><expr><name>VLOCAL</name></expr></argument>,<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><operator>!</operator><name>base</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>markupval</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>VLOCAL</name></expr>;</return>
</block_content>}</block></if>
<else>else<block>{<block_content>
<if_stmt><if>if<condition>(<expr><call><name>singlevaraux</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>prev</name></name></expr></argument>,<argument><expr><name>n</name></expr></argument>,<argument><expr><name>var</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>==</operator><name>VGLOBAL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>VGLOBAL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name><operator>=</operator><call><name>indexupvalue</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>n</name></expr></argument>,<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>k</name></name><operator>=</operator><name>VUPVAL</name></expr>;</expr_stmt>
<return>return <expr><name>VUPVAL</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>singlevar</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>,<parameter><decl><type><name>expdesc</name><modifier>*</modifier></type><name>var</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>TString</name><modifier>*</modifier></type><name>varname</name><init>=<expr><call><name>str_checkname</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name><init>=<expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><call><name>singlevaraux</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>varname</name></expr></argument>,<argument><expr><name>var</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>==</operator><name>VGLOBAL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name><operator>=</operator><call><name>luaK_stringK</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>varname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>adjust_assign</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>nvars</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>nexps</name></decl></parameter>,<parameter><decl><type><name>expdesc</name><modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name><init>=<expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>extra</name><init>=<expr><name>nvars</name><operator>-</operator><name>nexps</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><call><name>hasmultret</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<expr_stmt><expr><name>extra</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>extra</name><operator>&lt;</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><name>extra</name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>luaK_setreturns</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>e</name></expr></argument>,<argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>extra</name><operator>&gt;</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><call><name>luaK_reserveregs</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>extra</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if>
<else>else<block>{<block_content>
<if_stmt><if>if<condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name><operator>!=</operator><name>VVOID</name></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><call><name>luaK_exp2nextreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><name>extra</name><operator>&gt;</operator><literal type="number">0</literal></expr>)</condition><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>reg</name><init>=<expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaK_reserveregs</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaK_nil</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>reg</name></expr></argument>,<argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>enterlevel</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><operator>++</operator><name><name>ls</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>nCcalls</name></name><operator>&gt;</operator><literal type="number">200</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaX_lexerror</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><literal type="string">"chunk has too many syntax levels"</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>leavelevel</name><parameter_list>(<parameter><type><name>ls</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((ls)-&gt;L-&gt;nCcalls--)</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>void</name></type> <name>enterblock</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name>BlockCnt</name><modifier>*</modifier></type><name>bl</name></decl></parameter>,<parameter><decl><type><name>lu_byte</name></type> <name>isbreakable</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><name><name>bl</name><operator>-&gt;</operator><name>breaklist</name></name><operator>=</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bl</name><operator>-&gt;</operator><name>isbreakable</name></name><operator>=</operator><name>isbreakable</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bl</name><operator>-&gt;</operator><name>nactvar</name></name><operator>=</operator><name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bl</name><operator>-&gt;</operator><name>upval</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bl</name><operator>-&gt;</operator><name>previous</name></name><operator>=</operator><name><name>fs</name><operator>-&gt;</operator><name>bl</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>bl</name></name><operator>=</operator><name>bl</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>leaveblock</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>BlockCnt</name><modifier>*</modifier></type><name>bl</name><init>=<expr><name><name>fs</name><operator>-&gt;</operator><name>bl</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>bl</name></name><operator>=</operator><name><name>bl</name><operator>-&gt;</operator><name>previous</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>removevars</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>ls</name></name></expr></argument>,<argument><expr><name><name>bl</name><operator>-&gt;</operator><name>nactvar</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name><name>bl</name><operator>-&gt;</operator><name>upval</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaK_codeABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>OP_CLOSE</name></expr></argument>,<argument><expr><name><name>bl</name><operator>-&gt;</operator><name>nactvar</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name><operator>=</operator><name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaK_patchtohere</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name><name>bl</name><operator>-&gt;</operator><name>breaklist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>pushclosure</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>,<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>func</name></decl></parameter>,<parameter><decl><type><name>expdesc</name><modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name><init>=<expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Proto</name><modifier>*</modifier></type><name>f</name><init>=<expr><name><name>fs</name><operator>-&gt;</operator><name>f</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>oldsize</name><init>=<expr><name><name>f</name><operator>-&gt;</operator><name>sizep</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaM_growvector</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>,<argument><expr><name><name>f</name><operator>-&gt;</operator><name>p</name></name></expr></argument>,<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>np</name></name></expr></argument>,<argument><expr><name><name>f</name><operator>-&gt;</operator><name>sizep</name></name></expr></argument>,<argument><expr><name>Proto</name><operator>*</operator></expr></argument>,
<argument><expr><operator>(</operator><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><operator>(</operator><literal type="number">9</literal><operator>+</operator><literal type="number">9</literal><operator>)</operator><operator>)</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>,<argument><expr><literal type="string">"constant table overflow"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while<condition>(<expr><name>oldsize</name><operator>&lt;</operator><name><name>f</name><operator>-&gt;</operator><name>sizep</name></name></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>oldsize</name><operator>++</operator></expr>]</index></name><operator>=</operator><name>NULL</name></expr>;</expr_stmt></block_content></block></while>
<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>p</name><index>[<expr><name><name>fs</name><operator>-&gt;</operator><name>np</name></name><operator>++</operator></expr>]</index></name><operator>=</operator><name><name>func</name><operator>-&gt;</operator><name>f</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaC_objbarrier</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>,<argument><expr><name>f</name></expr></argument>,<argument><expr><name><name>func</name><operator>-&gt;</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>init_exp</name><argument_list>(<argument><expr><name>v</name></expr></argument>,<argument><expr><name>VRELOCABLE</name></expr></argument>,<argument><expr><call><name>luaK_codeABx</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>OP_CLOSURE</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>np</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init><condition><expr><name>i</name><operator>&lt;</operator><name><name>func</name><operator>-&gt;</operator><name>f</name><operator>-&gt;</operator><name>nups</name></name></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
<decl_stmt><decl><type><name>OpCode</name></type> <name>o</name><init>=<expr><ternary><condition><expr><operator>(</operator><name><name>func</name><operator>-&gt;</operator><name>upvalues</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>k</name><operator>==</operator><name>VLOCAL</name><operator>)</operator></expr>?</condition><then><expr><name>OP_MOVE</name></expr></then><else>:<expr><name>OP_GETUPVAL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaK_codeABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>o</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name><name>func</name><operator>-&gt;</operator><name>upvalues</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>info</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>open_func</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>,<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name><init>=<expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Proto</name><modifier>*</modifier></type><name>f</name><init>=<expr><call><name>luaF_newproto</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>f</name></name><operator>=</operator><name>f</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>prev</name></name><operator>=</operator><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>ls</name></name><operator>=</operator><name>ls</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>L</name></name><operator>=</operator><name>L</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name><operator>=</operator><name>fs</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>pc</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>lasttarget</name></name><operator>=</operator><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>jpc</name></name><operator>=</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>nk</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>np</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>nlocvars</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>bl</name></name><operator>=</operator><name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>source</name></name><operator>=</operator><name><name>ls</name><operator>-&gt;</operator><name>source</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>maxstacksize</name></name><operator>=</operator><literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>h</name></name><operator>=</operator><call><name>luaH_new</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sethvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>,<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>h</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>incr_top</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setptvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>,<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>incr_top</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>close_func</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name><init>=<expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name><init>=<expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Proto</name><modifier>*</modifier></type><name>f</name><init>=<expr><name><name>fs</name><operator>-&gt;</operator><name>f</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>removevars</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaK_ret</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaM_reallocvector</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>f</name><operator>-&gt;</operator><name>code</name></name></expr></argument>,<argument><expr><name><name>f</name><operator>-&gt;</operator><name>sizecode</name></name></expr></argument>,<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>pc</name></name></expr></argument>,<argument><expr><name>Instruction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>sizecode</name></name><operator>=</operator><name><name>fs</name><operator>-&gt;</operator><name>pc</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaM_reallocvector</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>f</name><operator>-&gt;</operator><name>lineinfo</name></name></expr></argument>,<argument><expr><name><name>f</name><operator>-&gt;</operator><name>sizelineinfo</name></name></expr></argument>,<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>pc</name></name></expr></argument>,<argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>sizelineinfo</name></name><operator>=</operator><name><name>fs</name><operator>-&gt;</operator><name>pc</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaM_reallocvector</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>f</name><operator>-&gt;</operator><name>k</name></name></expr></argument>,<argument><expr><name><name>f</name><operator>-&gt;</operator><name>sizek</name></name></expr></argument>,<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>nk</name></name></expr></argument>,<argument><expr><name>TValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>sizek</name></name><operator>=</operator><name><name>fs</name><operator>-&gt;</operator><name>nk</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaM_reallocvector</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>f</name><operator>-&gt;</operator><name>p</name></name></expr></argument>,<argument><expr><name><name>f</name><operator>-&gt;</operator><name>sizep</name></name></expr></argument>,<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>np</name></name></expr></argument>,<argument><expr><name>Proto</name><operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>sizep</name></name><operator>=</operator><name><name>fs</name><operator>-&gt;</operator><name>np</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaM_reallocvector</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>f</name><operator>-&gt;</operator><name>locvars</name></name></expr></argument>,<argument><expr><name><name>f</name><operator>-&gt;</operator><name>sizelocvars</name></name></expr></argument>,<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>nlocvars</name></name></expr></argument>,<argument><expr><name>LocVar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>sizelocvars</name></name><operator>=</operator><name><name>fs</name><operator>-&gt;</operator><name>nlocvars</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaM_reallocvector</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>f</name><operator>-&gt;</operator><name>upvalues</name></name></expr></argument>,<argument><expr><name><name>f</name><operator>-&gt;</operator><name>sizeupvalues</name></name></expr></argument>,<argument><expr><name><name>f</name><operator>-&gt;</operator><name>nups</name></name></expr></argument>,<argument><expr><name>TString</name><operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>sizeupvalues</name></name><operator>=</operator><name><name>f</name><operator>-&gt;</operator><name>nups</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name><operator>=</operator><name><name>fs</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>fs</name></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><call><name>anchor_token</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-=</operator><literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>Proto</name><modifier>*</modifier></type><name>luaY_parser</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>ZIO</name><modifier>*</modifier></type><name>z</name></decl></parameter>,<parameter><decl><type><name>Mbuffer</name><modifier>*</modifier></type><name>buff</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>LexState</name></name></type> <name>lexstate</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>FuncState</name></name></type> <name>funcstate</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>lexstate</name><operator>.</operator><name>buff</name></name><operator>=</operator><name>buff</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaX_setinput</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>lexstate</name></expr></argument>,<argument><expr><name>z</name></expr></argument>,<argument><expr><call><name>luaS_new</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>open_func</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lexstate</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>funcstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>funcstate</name><operator>.</operator><name>f</name><operator>-&gt;</operator><name>is_vararg</name></name><operator>=</operator><literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lexstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lexstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>check</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lexstate</name></expr></argument>,<argument><expr><name>TK_EOS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>close_func</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lexstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>funcstate</name><operator>.</operator><name>f</name></name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>field</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>,<parameter><decl><type><name>expdesc</name><modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name><init>=<expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>expdesc</name></type> <name>key</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaK_exp2anyreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>checkname</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaK_indexed</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>v</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>yindex</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>,<parameter><decl><type><name>expdesc</name><modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>expr</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaK_exp2val</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>,<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>checknext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><literal type="char">']'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<struct>struct <name>ConsControl</name><block>{
<decl_stmt><decl><type><name>expdesc</name></type> <name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>expdesc</name><modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nh</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>na</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tostore</name></decl>;</decl_stmt>
}</block>;</struct>
<function><type><specifier>static</specifier> <name>void</name></type> <name>recfield</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>,<parameter><decl><type><name><name>struct</name> <name>ConsControl</name></name><modifier>*</modifier></type><name>cc</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name><init>=<expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>reg</name><init>=<expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name><operator>-&gt;</operator><name>freereg</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>expdesc</name></type> <name>key</name></decl>,<decl><type ref="prev"/><name>val</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rkkey</name></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name><operator>==</operator><name>TK_NAME</name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>luaY_checklimit</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>nh</name></name></expr></argument>,<argument><expr><operator>(</operator><name>INT_MAX</name><operator>-</operator><literal type="number">2</literal><operator>)</operator></expr></argument>,<argument><expr><literal type="string">"items in a constructor"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>checkname</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>yindex</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>nh</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>checknext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rkkey</name><operator>=</operator><call><name>luaK_exp2RK</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>expr</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaK_codeABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>OP_SETTABLE</name></expr></argument>,<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>t</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr></argument>,<argument><expr><name>rkkey</name></expr></argument>,<argument><expr><call><name>luaK_exp2RK</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name><operator>=</operator><name>reg</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>closelistfield</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name><name>struct</name> <name>ConsControl</name></name><modifier>*</modifier></type><name>cc</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name><name>cc</name><operator>-&gt;</operator><name>v</name><operator>.</operator><name>k</name></name><operator>==</operator><name>VVOID</name></expr>)</condition><block type="pseudo"><block_content><return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>luaK_exp2nextreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>cc</name><operator>-&gt;</operator><name>v</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>v</name><operator>.</operator><name>k</name></name><operator>=</operator><name>VVOID</name></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name><name>cc</name><operator>-&gt;</operator><name>tostore</name></name><operator>==</operator><literal type="number">50</literal></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>luaK_setlist</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>t</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr></argument>,<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>na</name></name></expr></argument>,<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>tostore</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>tostore</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>lastlistfield</name><parameter_list>(<parameter><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name></decl></parameter>,<parameter><decl><type><name><name>struct</name> <name>ConsControl</name></name><modifier>*</modifier></type><name>cc</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name><name>cc</name><operator>-&gt;</operator><name>tostore</name></name><operator>==</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content><return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><call><name>hasmultret</name><argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>v</name><operator>.</operator><name>k</name></name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>luaK_setmultret</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>cc</name><operator>-&gt;</operator><name>v</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaK_setlist</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>t</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr></argument>,<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>na</name></name></expr></argument>,<argument><expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>na</name></name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block>{<block_content>
<if_stmt><if>if<condition>(<expr><name><name>cc</name><operator>-&gt;</operator><name>v</name><operator>.</operator><name>k</name></name><operator>!=</operator><name>VVOID</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaK_exp2nextreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>cc</name><operator>-&gt;</operator><name>v</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>luaK_setlist</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>t</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr></argument>,<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>na</name></name></expr></argument>,<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>tostore</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>listfield</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>,<parameter><decl><type><name><name>struct</name> <name>ConsControl</name></name><modifier>*</modifier></type><name>cc</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>expr</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>cc</name><operator>-&gt;</operator><name>v</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaY_checklimit</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>,<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>na</name></name></expr></argument>,<argument><expr><operator>(</operator><name>INT_MAX</name><operator>-</operator><literal type="number">2</literal><operator>)</operator></expr></argument>,<argument><expr><literal type="string">"items in a constructor"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>na</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>tostore</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>constructor</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>,<parameter><decl><type><name>expdesc</name><modifier>*</modifier></type><name>t</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name><init>=<expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>line</name><init>=<expr><name><name>ls</name><operator>-&gt;</operator><name>linenumber</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pc</name><init>=<expr><call><name>luaK_codeABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>OP_NEWTABLE</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>ConsControl</name></name></type> <name>cc</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>cc</name><operator>.</operator><name>na</name></name><operator>=</operator><name><name>cc</name><operator>.</operator><name>nh</name></name><operator>=</operator><name><name>cc</name><operator>.</operator><name>tostore</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cc</name><operator>.</operator><name>t</name></name><operator>=</operator><name>t</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>init_exp</name><argument_list>(<argument><expr><name>t</name></expr></argument>,<argument><expr><name>VRELOCABLE</name></expr></argument>,<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>init_exp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cc</name><operator>.</operator><name>v</name></name></expr></argument>,<argument><expr><name>VVOID</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaK_exp2nextreg</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>,<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>checknext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><literal type="char">'{'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<do>do<block>{<block_content>
<if_stmt><if>if<condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name><operator>==</operator><literal type="char">'}'</literal></expr>)</condition><block type="pseudo"><block_content><break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>closelistfield</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch<condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name></expr>)</condition><block>{<block_content>
<case>case <expr><name>TK_NAME</name></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>luaX_lookahead</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>lookahead</name><operator>.</operator><name>token</name></name><operator>!=</operator><literal type="char">'='</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>listfield</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>recfield</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<break>break;</break>
</block_content>}</block>
<case>case<expr><literal type="char">'['</literal></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>recfield</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<default>default:</default><block>{<block_content>
<expr_stmt><expr><call><name>listfield</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
</block_content>}</block></switch>
</block_content>}</block>while<condition>(<expr><call><name>testnext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call><operator>||</operator><call><name>testnext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><literal type="char">';'</literal></expr></argument>)</argument_list></call></expr>)</condition>;</do>
<expr_stmt><expr><call><name>check_match</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><literal type="char">'}'</literal></expr></argument>,<argument><expr><literal type="char">'{'</literal></expr></argument>,<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lastlistfield</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SETARG_B</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>f</name><operator>-&gt;</operator><name>code</name><index>[<expr><name>pc</name></expr>]</index></name></expr></argument>,<argument><expr><call><name>luaO_int2fb</name><argument_list>(<argument><expr><name><name>cc</name><operator>.</operator><name>na</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SETARG_C</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>f</name><operator>-&gt;</operator><name>code</name><index>[<expr><name>pc</name></expr>]</index></name></expr></argument>,<argument><expr><call><name>luaO_int2fb</name><argument_list>(<argument><expr><name><name>cc</name><operator>.</operator><name>nh</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>parlist</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name><init>=<expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Proto</name><modifier>*</modifier></type><name>f</name><init>=<expr><name><name>fs</name><operator>-&gt;</operator><name>f</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nparams</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>is_vararg</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name><operator>!=</operator><literal type="char">')'</literal></expr>)</condition><block>{<block_content>
<do>do<block>{<block_content>
<switch>switch<condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name></expr>)</condition><block>{<block_content>
<case>case <expr><name>TK_NAME</name></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>new_localvar</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><call><name>str_checkname</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>nparams</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>TK_DOTS</name></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>is_vararg</name></name><operator>|=</operator><literal type="number">2</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<default>default:</default><expr_stmt><expr><call><name>luaX_syntaxerror</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><literal type="string">"&lt;name&gt; or "</literal><call><name>LUA_QL</name><argument_list>(<argument><expr><literal type="string">"..."</literal></expr></argument>)</argument_list></call><literal type="string">" expected"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
</block_content>}</block>while<condition>(<expr><operator>!</operator><name><name>f</name><operator>-&gt;</operator><name>is_vararg</name></name><operator>&amp;&amp;</operator><call><name>testnext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>)</condition>;</do>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>adjustlocalvars</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>nparams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>numparams</name></name><operator>=</operator><call><name>cast_byte</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name><operator>-</operator><operator>(</operator><name><name>f</name><operator>-&gt;</operator><name>is_vararg</name></name><operator>&amp;</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaK_reserveregs</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>body</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>,<parameter><decl><type><name>expdesc</name><modifier>*</modifier></type><name>e</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>needself</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>FuncState</name></type> <name>new_fs</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>open_func</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>new_fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_fs</name><operator>.</operator><name>f</name><operator>-&gt;</operator><name>linedefined</name></name><operator>=</operator><name>line</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>checknext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>needself</name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>new_localvarliteral</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><literal type="string">"self"</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>adjustlocalvars</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>parlist</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>checknext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>chunk</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_fs</name><operator>.</operator><name>f</name><operator>-&gt;</operator><name>lastlinedefined</name></name><operator>=</operator><name><name>ls</name><operator>-&gt;</operator><name>linenumber</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>check_match</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>TK_END</name></expr></argument>,<argument><expr><name>TK_FUNCTION</name></expr></argument>,<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>close_func</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pushclosure</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>new_fs</name></expr></argument>,<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>explist1</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>,<parameter><decl><type><name>expdesc</name><modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>n</name><init>=<expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>expr</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while<condition>(<expr><call><name>testnext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>luaK_exp2nextreg</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>,<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>expr</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>funcargs</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>,<parameter><decl><type><name>expdesc</name><modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name><init>=<expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>expdesc</name></type> <name>args</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>base</name></decl>,<decl><type ref="prev"/><name>nparams</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>line</name><init>=<expr><name><name>ls</name><operator>-&gt;</operator><name>linenumber</name></name></expr></init></decl>;</decl_stmt>
<switch>switch<condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name></expr>)</condition><block>{<block_content>
<case>case<expr><literal type="char">'('</literal></expr>:</case><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name>line</name><operator>!=</operator><name><name>ls</name><operator>-&gt;</operator><name>lastline</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaX_syntaxerror</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><literal type="string">"ambiguous syntax (function call x new statement)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name><operator>==</operator><literal type="char">')'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>args</name><operator>.</operator><name>k</name></name><operator>=</operator><name>VVOID</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block>{<block_content>
<expr_stmt><expr><call><name>explist1</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaK_setmultret</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>check_match</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><literal type="char">')'</literal></expr></argument>,<argument><expr><literal type="char">'('</literal></expr></argument>,<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case<expr><literal type="char">'{'</literal></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>constructor</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>TK_STRING</name></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>codestring</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>args</name></expr></argument>,<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>seminfo</name><operator>.</operator><name>ts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<default>default:</default><block>{<block_content>
<expr_stmt><expr><call><name>luaX_syntaxerror</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><literal type="string">"function arguments expected"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block>
</block_content>}</block></switch>
<expr_stmt><expr><name>base</name><operator>=</operator><name><name>f</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><call><name>hasmultret</name><argument_list>(<argument><expr><name><name>args</name><operator>.</operator><name>k</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>nparams</name><operator>=</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
<else>else<block>{<block_content>
<if_stmt><if>if<condition>(<expr><name><name>args</name><operator>.</operator><name>k</name></name><operator>!=</operator><name>VVOID</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaK_exp2nextreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>nparams</name><operator>=</operator><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name><operator>-</operator><operator>(</operator><name>base</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>init_exp</name><argument_list>(<argument><expr><name>f</name></expr></argument>,<argument><expr><name>VCALL</name></expr></argument>,<argument><expr><call><name>luaK_codeABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>OP_CALL</name></expr></argument>,<argument><expr><name>base</name></expr></argument>,<argument><expr><name>nparams</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaK_fixline</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name><operator>=</operator><name>base</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>prefixexp</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>,<parameter><decl><type><name>expdesc</name><modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
<switch>switch<condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name></expr>)</condition><block>{<block_content>
<case>case<expr><literal type="char">'('</literal></expr>:</case><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>line</name><init>=<expr><name><name>ls</name><operator>-&gt;</operator><name>linenumber</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>expr</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>check_match</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><literal type="char">')'</literal></expr></argument>,<argument><expr><literal type="char">'('</literal></expr></argument>,<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaK_dischargevars</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>,<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block>
<case>case <expr><name>TK_NAME</name></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>singlevar</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block>
<default>default:</default><block>{<block_content>
<expr_stmt><expr><call><name>luaX_syntaxerror</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><literal type="string">"unexpected symbol"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block>
</block_content>}</block></switch>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>primaryexp</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>,<parameter><decl><type><name>expdesc</name><modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name><init>=<expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>prefixexp</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
<switch>switch<condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name></expr>)</condition><block>{<block_content>
<case>case<expr><literal type="char">'.'</literal></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>field</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case<expr><literal type="char">'['</literal></expr>:</case><block>{<block_content>
<decl_stmt><decl><type><name>expdesc</name></type> <name>key</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaK_exp2anyreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>yindex</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaK_indexed</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>v</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case<expr><literal type="char">':'</literal></expr>:</case><block>{<block_content>
<decl_stmt><decl><type><name>expdesc</name></type> <name>key</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>checkname</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaK_self</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>v</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>funcargs</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case<expr><literal type="char">'('</literal></expr>:</case><case>case <expr><name>TK_STRING</name></expr>:</case><case>case<expr><literal type="char">'{'</literal></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>luaK_exp2nextreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>funcargs</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<default>default:</default><return>return;</return>
</block_content>}</block></switch>
</block_content>}</block></for>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>simpleexp</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>,<parameter><decl><type><name>expdesc</name><modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
<switch>switch<condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name></expr>)</condition><block>{<block_content>
<case>case <expr><name>TK_NUMBER</name></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>init_exp</name><argument_list>(<argument><expr><name>v</name></expr></argument>,<argument><expr><name>VKNUM</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>nval</name></name><operator>=</operator><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>seminfo</name><operator>.</operator><name>r</name></name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>TK_STRING</name></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>codestring</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>v</name></expr></argument>,<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>seminfo</name><operator>.</operator><name>ts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>TK_NIL</name></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>init_exp</name><argument_list>(<argument><expr><name>v</name></expr></argument>,<argument><expr><name>VNIL</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>TK_TRUE</name></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>init_exp</name><argument_list>(<argument><expr><name>v</name></expr></argument>,<argument><expr><name>VTRUE</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>TK_FALSE</name></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>init_exp</name><argument_list>(<argument><expr><name>v</name></expr></argument>,<argument><expr><name>VFALSE</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>TK_DOTS</name></expr>:</case><block>{<block_content>
<decl_stmt><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name><init>=<expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>check_condition</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>f</name><operator>-&gt;</operator><name>is_vararg</name></name></expr></argument>,
<argument><expr><literal type="string">"cannot use "</literal><call><name>LUA_QL</name><argument_list>(<argument><expr><literal type="string">"..."</literal></expr></argument>)</argument_list></call><literal type="string">" outside a vararg function"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>f</name><operator>-&gt;</operator><name>is_vararg</name></name><operator>&amp;=</operator><operator>~</operator><literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>init_exp</name><argument_list>(<argument><expr><name>v</name></expr></argument>,<argument><expr><name>VVARARG</name></expr></argument>,<argument><expr><call><name>luaK_codeABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>OP_VARARG</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case<expr><literal type="char">'{'</literal></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>constructor</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block>
<case>case <expr><name>TK_FUNCTION</name></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>body</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>v</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>linenumber</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block>
<default>default:</default><block>{<block_content>
<expr_stmt><expr><call><name>primaryexp</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>UnOpr</name></type> <name>getunopr</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>)</parameter_list><block>{<block_content>
<switch>switch<condition>(<expr><name>op</name></expr>)</condition><block>{<block_content>
<case>case <expr><name>TK_NOT</name></expr>:</case><return>return <expr><name>OPR_NOT</name></expr>;</return>
<case>case<expr><literal type="char">'-'</literal></expr>:</case><return>return <expr><name>OPR_MINUS</name></expr>;</return>
<case>case<expr><literal type="char">'#'</literal></expr>:</case><return>return <expr><name>OPR_LEN</name></expr>;</return>
<default>default:</default><return>return <expr><name>OPR_NOUNOPR</name></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>BinOpr</name></type> <name>getbinopr</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>)</parameter_list><block>{<block_content>
<switch>switch<condition>(<expr><name>op</name></expr>)</condition><block>{<block_content>
<case>case<expr><literal type="char">'+'</literal></expr>:</case><return>return <expr><name>OPR_ADD</name></expr>;</return>
<case>case<expr><literal type="char">'-'</literal></expr>:</case><return>return <expr><name>OPR_SUB</name></expr>;</return>
<case>case<expr><literal type="char">'*'</literal></expr>:</case><return>return <expr><name>OPR_MUL</name></expr>;</return>
<case>case<expr><literal type="char">'/'</literal></expr>:</case><return>return <expr><name>OPR_DIV</name></expr>;</return>
<case>case<expr><literal type="char">'%'</literal></expr>:</case><return>return <expr><name>OPR_MOD</name></expr>;</return>
<case>case<expr><literal type="char">'^'</literal></expr>:</case><return>return <expr><name>OPR_POW</name></expr>;</return>
<case>case <expr><name>TK_CONCAT</name></expr>:</case><return>return <expr><name>OPR_CONCAT</name></expr>;</return>
<case>case <expr><name>TK_NE</name></expr>:</case><return>return <expr><name>OPR_NE</name></expr>;</return>
<case>case <expr><name>TK_EQ</name></expr>:</case><return>return <expr><name>OPR_EQ</name></expr>;</return>
<case>case<expr><literal type="char">'&lt;'</literal></expr>:</case><return>return <expr><name>OPR_LT</name></expr>;</return>
<case>case <expr><name>TK_LE</name></expr>:</case><return>return <expr><name>OPR_LE</name></expr>;</return>
<case>case<expr><literal type="char">'&gt;'</literal></expr>:</case><return>return <expr><name>OPR_GT</name></expr>;</return>
<case>case <expr><name>TK_GE</name></expr>:</case><return>return <expr><name>OPR_GE</name></expr>;</return>
<case>case <expr><name>TK_AND</name></expr>:</case><return>return <expr><name>OPR_AND</name></expr>;</return>
<case>case <expr><name>TK_OR</name></expr>:</case><return>return <expr><name>OPR_OR</name></expr>;</return>
<default>default:</default><return>return <expr><name>OPR_NOBINOPR</name></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>
<struct><specifier>static</specifier> <specifier>const</specifier> struct<block>{
<decl_stmt><decl><type><name>lu_byte</name></type> <name>left</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>lu_byte</name></type> <name>right</name></decl>;</decl_stmt>
}</block><decl><name><name>priority</name><index>[]</index></name><init>=<expr><block>{
<expr><block>{<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>}</block></expr>,<expr><block>{<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>}</block></expr>,<expr><block>{<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>}</block></expr>,<expr><block>{<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>}</block></expr>,<expr><block>{<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">10</literal></expr>,<expr><literal type="number">9</literal></expr>}</block></expr>,<expr><block>{<expr><literal type="number">5</literal></expr>,<expr><literal type="number">4</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">3</literal></expr>,<expr><literal type="number">3</literal></expr>}</block></expr>,<expr><block>{<expr><literal type="number">3</literal></expr>,<expr><literal type="number">3</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">3</literal></expr>,<expr><literal type="number">3</literal></expr>}</block></expr>,<expr><block>{<expr><literal type="number">3</literal></expr>,<expr><literal type="number">3</literal></expr>}</block></expr>,<expr><block>{<expr><literal type="number">3</literal></expr>,<expr><literal type="number">3</literal></expr>}</block></expr>,<expr><block>{<expr><literal type="number">3</literal></expr>,<expr><literal type="number">3</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">2</literal></expr>,<expr><literal type="number">2</literal></expr>}</block></expr>,<expr><block>{<expr><literal type="number">1</literal></expr>,<expr><literal type="number">1</literal></expr>}</block></expr>
}</block></expr></init></decl>;</struct>
<function><type><specifier>static</specifier> <name>BinOpr</name></type> <name>subexpr</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>,<parameter><decl><type><name>expdesc</name><modifier>*</modifier></type><name>v</name></decl></parameter>,<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>limit</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>BinOpr</name></type> <name>op</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UnOpr</name></type> <name>uop</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>enterlevel</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>uop</name><operator>=</operator><call><name>getunopr</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>uop</name><operator>!=</operator><name>OPR_NOUNOPR</name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>subexpr</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>v</name></expr></argument>,<argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaK_prefix</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>,<argument><expr><name>uop</name></expr></argument>,<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>simpleexp</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name>op</name><operator>=</operator><call><name>getbinopr</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while<condition>(<expr><name>op</name><operator>!=</operator><name>OPR_NOBINOPR</name><operator>&amp;&amp;</operator><name><name>priority</name><index>[<expr><name>op</name></expr>]</index></name><operator>.</operator><name>left</name><operator>&gt;</operator><name>limit</name></expr>)</condition><block>{<block_content>
<decl_stmt><decl><type><name>expdesc</name></type> <name>v2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BinOpr</name></type> <name>nextop</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaK_infix</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>,<argument><expr><name>op</name></expr></argument>,<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>nextop</name><operator>=</operator><call><name>subexpr</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>v2</name></expr></argument>,<argument><expr><name><name>priority</name><index>[<expr><name>op</name></expr>]</index></name><operator>.</operator><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaK_posfix</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>,<argument><expr><name>op</name></expr></argument>,<argument><expr><name>v</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>v2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>op</name><operator>=</operator><name>nextop</name></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>leavelevel</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>op</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>expr</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>,<parameter><decl><type><name>expdesc</name><modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>subexpr</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>v</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>block_follow</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>token</name></decl></parameter>)</parameter_list><block>{<block_content>
<switch>switch<condition>(<expr><name>token</name></expr>)</condition><block>{<block_content>
<case>case <expr><name>TK_ELSE</name></expr>:</case><case>case <expr><name>TK_ELSEIF</name></expr>:</case><case>case <expr><name>TK_END</name></expr>:</case>
<case>case <expr><name>TK_UNTIL</name></expr>:</case><case>case <expr><name>TK_EOS</name></expr>:</case>
<return>return <expr><literal type="number">1</literal></expr>;</return>
<default>default:</default><return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>block</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name><init>=<expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BlockCnt</name></type> <name>bl</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>enterblock</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>bl</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>chunk</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>leaveblock</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<struct>struct <name>LHS_assign</name><block>{
<decl_stmt><decl><type><name><name>struct</name> <name>LHS_assign</name></name><modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>expdesc</name></type> <name>v</name></decl>;</decl_stmt>
}</block>;</struct>
<function><type><specifier>static</specifier> <name>void</name></type> <name>check_conflict</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>,<parameter><decl><type><name><name>struct</name> <name>LHS_assign</name></name><modifier>*</modifier></type><name>lh</name></decl></parameter>,<parameter><decl><type><name>expdesc</name><modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name><init>=<expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>extra</name><init>=<expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>conflict</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<for>for<control>(<init>;</init><condition><expr><name>lh</name></expr>;</condition><incr><expr><name>lh</name><operator>=</operator><name><name>lh</name><operator>-&gt;</operator><name>prev</name></name></expr></incr>)</control><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name><name>lh</name><operator>-&gt;</operator><name>v</name><operator>.</operator><name>k</name></name><operator>==</operator><name>VINDEXED</name></expr>)</condition><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name><name>lh</name><operator>-&gt;</operator><name>v</name><operator>.</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name><operator>==</operator><name><name>v</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><name>conflict</name><operator>=</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lh</name><operator>-&gt;</operator><name>v</name><operator>.</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name><operator>=</operator><name>extra</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><name><name>lh</name><operator>-&gt;</operator><name>v</name><operator>.</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>aux</name></name><operator>==</operator><name><name>v</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><name>conflict</name><operator>=</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lh</name><operator>-&gt;</operator><name>v</name><operator>.</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>aux</name></name><operator>=</operator><name>extra</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if<condition>(<expr><name>conflict</name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>luaK_codeABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>OP_MOVE</name></expr></argument>,<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name></expr></argument>,<argument><expr><name><name>v</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name><operator>.</operator><name>info</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaK_reserveregs</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>assignment</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>,<parameter><decl><type><name><name>struct</name> <name>LHS_assign</name></name><modifier>*</modifier></type><name>lh</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>nvars</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>expdesc</name></type> <name>e</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>check_condition</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>VLOCAL</name><operator>&lt;=</operator><name><name>lh</name><operator>-&gt;</operator><name>v</name><operator>.</operator><name>k</name></name><operator>&amp;&amp;</operator><name><name>lh</name><operator>-&gt;</operator><name>v</name><operator>.</operator><name>k</name></name><operator>&lt;=</operator><name>VINDEXED</name></expr></argument>,
<argument><expr><literal type="string">"syntax error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><call><name>testnext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>LHS_assign</name></name></type> <name>nv</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>nv</name><operator>.</operator><name>prev</name></name><operator>=</operator><name>lh</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>primaryexp</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>nv</name><operator>.</operator><name>v</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name><name>nv</name><operator>.</operator><name>v</name><operator>.</operator><name>k</name></name><operator>==</operator><name>VLOCAL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>check_conflict</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>lh</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>nv</name><operator>.</operator><name>v</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>luaY_checklimit</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>,<argument><expr><name>nvars</name></expr></argument>,<argument><expr><literal type="number">200</literal><operator>-</operator><name><name>ls</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>nCcalls</name></name></expr></argument>,
<argument><expr><literal type="string">"variables in assignment"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assignment</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>nv</name></expr></argument>,<argument><expr><name>nvars</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>nexps</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>checknext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>nexps</name><operator>=</operator><call><name>explist1</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>nexps</name><operator>!=</operator><name>nvars</name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>adjust_assign</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>nvars</name></expr></argument>,<argument><expr><name>nexps</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>nexps</name><operator>&gt;</operator><name>nvars</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name><operator>-&gt;</operator><name>freereg</name></name><operator>-=</operator><name>nexps</name><operator>-</operator><name>nvars</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if>
<else>else<block>{<block_content>
<expr_stmt><expr><call><name>luaK_setoneret</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaK_storevar</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>lh</name><operator>-&gt;</operator><name>v</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>init_exp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>e</name></expr></argument>,<argument><expr><name>VNONRELOC</name></expr></argument>,<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name><operator>-&gt;</operator><name>freereg</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaK_storevar</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>lh</name><operator>-&gt;</operator><name>v</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>cond</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>expdesc</name></type> <name>v</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>expr</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name><name>v</name><operator>.</operator><name>k</name></name><operator>==</operator><name>VNIL</name></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><name><name>v</name><operator>.</operator><name>k</name></name><operator>=</operator><name>VFALSE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>luaK_goiftrue</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>v</name><operator>.</operator><name>f</name></name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>breakstat</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name><init>=<expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BlockCnt</name><modifier>*</modifier></type><name>bl</name><init>=<expr><name><name>fs</name><operator>-&gt;</operator><name>bl</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>upval</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<while>while<condition>(<expr><name>bl</name><operator>&amp;&amp;</operator><operator>!</operator><name><name>bl</name><operator>-&gt;</operator><name>isbreakable</name></name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><name>upval</name><operator>|=</operator><name><name>bl</name><operator>-&gt;</operator><name>upval</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>bl</name><operator>=</operator><name><name>bl</name><operator>-&gt;</operator><name>previous</name></name></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if<condition>(<expr><operator>!</operator><name>bl</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaX_syntaxerror</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><literal type="string">"no loop to break"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><name>upval</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaK_codeABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>OP_CLOSE</name></expr></argument>,<argument><expr><name><name>bl</name><operator>-&gt;</operator><name>nactvar</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>luaK_concat</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>bl</name><operator>-&gt;</operator><name>breaklist</name></name></expr></argument>,<argument><expr><call><name>luaK_jump</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>whilestat</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name><init>=<expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>whileinit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>condexit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BlockCnt</name></type> <name>bl</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>whileinit</name><operator>=</operator><call><name>luaK_getlabel</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>condexit</name><operator>=</operator><call><name>cond</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>enterblock</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>bl</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>checknext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>TK_DO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>block</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaK_patchlist</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><call><name>luaK_jump</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>whileinit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>check_match</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>TK_END</name></expr></argument>,<argument><expr><name>TK_WHILE</name></expr></argument>,<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>leaveblock</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaK_patchtohere</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>condexit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>repeatstat</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>condexit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name><init>=<expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>repeat_init</name><init>=<expr><call><name>luaK_getlabel</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BlockCnt</name></type> <name>bl1</name></decl>,<decl><type ref="prev"/><name>bl2</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>enterblock</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>bl1</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>enterblock</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>bl2</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>chunk</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>check_match</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>TK_UNTIL</name></expr></argument>,<argument><expr><name>TK_REPEAT</name></expr></argument>,<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>condexit</name><operator>=</operator><call><name>cond</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>bl2</name><operator>.</operator><name>upval</name></name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>leaveblock</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaK_patchlist</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>,<argument><expr><name>condexit</name></expr></argument>,<argument><expr><name>repeat_init</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block>{<block_content>
<expr_stmt><expr><call><name>breakstat</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaK_patchtohere</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>,<argument><expr><name>condexit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>leaveblock</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaK_patchlist</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>,<argument><expr><call><name>luaK_jump</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>repeat_init</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>leaveblock</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>exp1</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>expdesc</name></type> <name>e</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>expr</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>k</name><operator>=</operator><name><name>e</name><operator>.</operator><name>k</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaK_exp2nextreg</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>k</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>forbody</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>base</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>nvars</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>isnum</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>BlockCnt</name></type> <name>bl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name><init>=<expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>prep</name></decl>,<decl><type ref="prev"/><name>endfor</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>adjustlocalvars</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>checknext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>TK_DO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>prep</name><operator>=</operator><ternary><condition><expr><name>isnum</name></expr>?</condition><then><expr><call><name>luaK_codeAsBx</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>OP_FORPREP</name></expr></argument>,<argument><expr><name>base</name></expr></argument>,<argument><expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></then><else>:<expr><call><name>luaK_jump</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><call><name>enterblock</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>bl</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>adjustlocalvars</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>nvars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaK_reserveregs</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>nvars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>block</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>leaveblock</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaK_patchtohere</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>prep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>endfor</name><operator>=</operator><ternary><condition><expr><operator>(</operator><name>isnum</name><operator>)</operator></expr>?</condition><then><expr><call><name>luaK_codeAsBx</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>OP_FORLOOP</name></expr></argument>,<argument><expr><name>base</name></expr></argument>,<argument><expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></then><else>:
<expr><call><name>luaK_codeABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>OP_TFORLOOP</name></expr></argument>,<argument><expr><name>base</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>nvars</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaK_fixline</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaK_patchlist</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><operator>(</operator><ternary><condition><expr><name>isnum</name></expr>?</condition><then><expr><name>endfor</name></expr></then><else>:<expr><call><name>luaK_jump</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></argument>,<argument><expr><name>prep</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fornum</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>,<parameter><decl><type><name>TString</name><modifier>*</modifier></type><name>varname</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name><init>=<expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>base</name><init>=<expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>new_localvarliteral</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><literal type="string">"(for index)"</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>new_localvarliteral</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><literal type="string">"(for limit)"</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>new_localvarliteral</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><literal type="string">"(for step)"</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>new_localvar</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>varname</name></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>checknext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exp1</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>checknext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exp1</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><call><name>testnext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>exp1</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block>{<block_content>
<expr_stmt><expr><call><name>luaK_codeABx</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>OP_LOADK</name></expr></argument>,<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name></expr></argument>,<argument><expr><call><name>luaK_numberK</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaK_reserveregs</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>forbody</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>base</name></expr></argument>,<argument><expr><name>line</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>forlist</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>,<parameter><decl><type><name>TString</name><modifier>*</modifier></type><name>indexname</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name><init>=<expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>expdesc</name></type> <name>e</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nvars</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>line</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>base</name><init>=<expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>new_localvarliteral</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><literal type="string">"(for generator)"</literal></expr></argument>,<argument><expr><name>nvars</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>new_localvarliteral</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><literal type="string">"(for state)"</literal></expr></argument>,<argument><expr><name>nvars</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>new_localvarliteral</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><literal type="string">"(for control)"</literal></expr></argument>,<argument><expr><name>nvars</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>new_localvar</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>indexname</name></expr></argument>,<argument><expr><name>nvars</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while<condition>(<expr><call><name>testnext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>new_localvar</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><call><name>str_checkname</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>nvars</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
<expr_stmt><expr><call><name>checknext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>TK_IN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>line</name><operator>=</operator><name><name>ls</name><operator>-&gt;</operator><name>linenumber</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>adjust_assign</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>,<argument><expr><call><name>explist1</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaK_checkstack</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>forbody</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>base</name></expr></argument>,<argument><expr><name>line</name></expr></argument>,<argument><expr><name>nvars</name><operator>-</operator><literal type="number">3</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>forstat</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name><init>=<expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TString</name><modifier>*</modifier></type><name>varname</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BlockCnt</name></type> <name>bl</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>enterblock</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>bl</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>varname</name><operator>=</operator><call><name>str_checkname</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch<condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name></expr>)</condition><block>{<block_content>
<case>case<expr><literal type="char">'='</literal></expr>:</case><expr_stmt><expr><call><name>fornum</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>varname</name></expr></argument>,<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt><break>break;</break>
<case>case<expr><literal type="char">','</literal></expr>:</case><case>case <expr><name>TK_IN</name></expr>:</case><expr_stmt><expr><call><name>forlist</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>varname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt><break>break;</break>
<default>default:</default><expr_stmt><expr><call><name>luaX_syntaxerror</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><call><name>LUA_QL</name><argument_list>(<argument><expr><literal type="string">"="</literal></expr></argument>)</argument_list></call><literal type="string">" or "</literal><call><name>LUA_QL</name><argument_list>(<argument><expr><literal type="string">"in"</literal></expr></argument>)</argument_list></call><literal type="string">" expected"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>check_match</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>TK_END</name></expr></argument>,<argument><expr><name>TK_FOR</name></expr></argument>,<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>leaveblock</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>test_then_block</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>condexit</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>condexit</name><operator>=</operator><call><name>cond</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>checknext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>TK_THEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>block</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>condexit</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ifstat</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name><init>=<expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>flist</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>escapelist</name><init>=<expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>flist</name><operator>=</operator><call><name>test_then_block</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while<condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name><operator>==</operator><name>TK_ELSEIF</name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>luaK_concat</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>escapelist</name></expr></argument>,<argument><expr><call><name>luaK_jump</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaK_patchtohere</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>flist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>flist</name><operator>=</operator><call><name>test_then_block</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if<condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name><operator>==</operator><name>TK_ELSE</name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>luaK_concat</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>escapelist</name></expr></argument>,<argument><expr><call><name>luaK_jump</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaK_patchtohere</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>flist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>block</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaK_concat</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>escapelist</name></expr></argument>,<argument><expr><name>flist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>luaK_patchtohere</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>escapelist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>check_match</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>TK_END</name></expr></argument>,<argument><expr><name>TK_IF</name></expr></argument>,<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>localfunc</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>expdesc</name></type> <name>v</name></decl>,<decl><type ref="prev"/><name>b</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name><init>=<expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>new_localvar</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><call><name>str_checkname</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>init_exp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>,<argument><expr><name>VLOCAL</name></expr></argument>,<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaK_reserveregs</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>adjustlocalvars</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>body</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>linenumber</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaK_storevar</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>getlocvar</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>.</operator><name>startpc</name><operator>=</operator><name><name>fs</name><operator>-&gt;</operator><name>pc</name></name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>localstat</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>nvars</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nexps</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>expdesc</name></type> <name>e</name></decl>;</decl_stmt>
<do>do<block>{<block_content>
<expr_stmt><expr><call><name>new_localvar</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><call><name>str_checkname</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>nvars</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>while<condition>(<expr><call><name>testnext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>)</condition>;</do>
<if_stmt><if>if<condition>(<expr><call><name>testnext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>nexps</name><operator>=</operator><call><name>explist1</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block>{<block_content>
<expr_stmt><expr><name><name>e</name><operator>.</operator><name>k</name></name><operator>=</operator><name>VVOID</name></expr>;</expr_stmt>
<expr_stmt><expr><name>nexps</name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>adjust_assign</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>nvars</name></expr></argument>,<argument><expr><name>nexps</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>adjustlocalvars</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>nvars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>funcname</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>,<parameter><decl><type><name>expdesc</name><modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>needself</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>singlevar</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while<condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name><operator>==</operator><literal type="char">'.'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>field</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
<if_stmt><if>if<condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name><operator>==</operator><literal type="char">':'</literal></expr>)</condition><block>{<block_content>
<expr_stmt><expr><name>needself</name><operator>=</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>field</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>needself</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>funcstat</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>needself</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>expdesc</name></type> <name>v</name></decl>,<decl><type ref="prev"/><name>b</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>needself</name><operator>=</operator><call><name>funcname</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>body</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>,<argument><expr><name>needself</name></expr></argument>,<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaK_storevar</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaK_fixline</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>,<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>exprstat</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name><init>=<expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>LHS_assign</name></name></type> <name>v</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>primaryexp</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>v</name><operator>.</operator><name>v</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name><name>v</name><operator>.</operator><name>v</name><operator>.</operator><name>k</name></name><operator>==</operator><name>VCALL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>SETARG_C</name><argument_list>(<argument><expr><call><name>getcode</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>v</name><operator>.</operator><name>v</name></name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block>{<block_content>
<expr_stmt><expr><name><name>v</name><operator>.</operator><name>prev</name></name><operator>=</operator><name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assignment</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>retstat</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>FuncState</name><modifier>*</modifier></type><name>fs</name><init>=<expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>expdesc</name></type> <name>e</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>first</name></decl>,<decl><type ref="prev"/><name>nret</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><call><name>block_follow</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name></expr></argument>)</argument_list></call><operator>||</operator><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name><operator>==</operator><literal type="char">';'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>first</name><operator>=</operator><name>nret</name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block>{<block_content>
<expr_stmt><expr><name>nret</name><operator>=</operator><call><name>explist1</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><call><name>hasmultret</name><argument_list>(<argument><expr><name><name>e</name><operator>.</operator><name>k</name></name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>luaK_setmultret</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name><name>e</name><operator>.</operator><name>k</name></name><operator>==</operator><name>VCALL</name><operator>&amp;&amp;</operator><name>nret</name><operator>==</operator><literal type="number">1</literal></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>SET_OPCODE</name><argument_list>(<argument><expr><call><name>getcode</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>OP_TAILCALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>first</name><operator>=</operator><name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>nret</name><operator>=</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block>{<block_content>
<if_stmt><if>if<condition>(<expr><name>nret</name><operator>==</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>first</name><operator>=</operator><call><name>luaK_exp2anyreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block>{<block_content>
<expr_stmt><expr><call><name>luaK_exp2nextreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>first</name><operator>=</operator><name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>luaK_ret</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><name>first</name></expr></argument>,<argument><expr><name>nret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>statement</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>line</name><init>=<expr><name><name>ls</name><operator>-&gt;</operator><name>linenumber</name></name></expr></init></decl>;</decl_stmt>
<switch>switch<condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name></expr>)</condition><block>{<block_content>
<case>case <expr><name>TK_IF</name></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>ifstat</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block>
<case>case <expr><name>TK_WHILE</name></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>whilestat</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block>
<case>case <expr><name>TK_DO</name></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>block</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>check_match</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>TK_END</name></expr></argument>,<argument><expr><name>TK_DO</name></expr></argument>,<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block>
<case>case <expr><name>TK_FOR</name></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>forstat</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block>
<case>case <expr><name>TK_REPEAT</name></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>repeatstat</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block>
<case>case <expr><name>TK_FUNCTION</name></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>funcstat</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block>
<case>case <expr><name>TK_LOCAL</name></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><call><name>testnext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><name>TK_FUNCTION</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>localfunc</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>localstat</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block>
<case>case <expr><name>TK_RETURN</name></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>retstat</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block>
<case>case <expr><name>TK_BREAK</name></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>breakstat</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block>
<default>default:</default><block>{<block_content>
<expr_stmt><expr><call><name>exprstat</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block>
</block_content>}</block></switch>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>chunk</name><parameter_list>(<parameter><decl><type><name>LexState</name><modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>islast</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>enterlevel</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while<condition>(<expr><operator>!</operator><name>islast</name><operator>&amp;&amp;</operator><operator>!</operator><call><name>block_follow</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<expr_stmt><expr><name>islast</name><operator>=</operator><call><name>statement</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>testnext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,<argument><expr><literal type="char">';'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name><operator>-&gt;</operator><name>freereg</name></name><operator>=</operator><name><name>ls</name><operator>-&gt;</operator><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>leavelevel</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>luaV_tonumber</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>obj</name></decl></parameter>,<parameter><decl><type><name>TValue</name><modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>lua_Number</name></type> <name>num</name></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><call><name>ttisnumber</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content><return>return <expr><name>obj</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><call><name>ttisstring</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>&amp;&amp;</operator><call><name>luaO_str2d</name><argument_list>(<argument><expr><call><name>svalue</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><operator>&amp;</operator><name>num</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>setnvalue</name><argument_list>(<argument><expr><name>n</name></expr></argument>,<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>luaV_tostring</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>StkId</name></type> <name>obj</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ttisnumber</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>
<else>else<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>s</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>lua_Number</name></type> <name>n</name><init>=<expr><call><name>nvalue</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>lua_number2str</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setsvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>obj</name></expr></argument>,<argument><expr><call><name>luaS_new</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>callTMres</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>StkId</name></type> <name>res</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>f</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>p1</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>p2</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>result</name><init>=<expr><call><name>savestack</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>setobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>,<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>+</operator><literal type="number">2</literal></expr></argument>,<argument><expr><name>p2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaD_checkstack</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>+=</operator><literal type="number">3</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaD_call</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">3</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>res</name><operator>=</operator><call><name>restorestack</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>res</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>callTM</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>f</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>p1</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>p2</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>p3</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>setobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>,<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>+</operator><literal type="number">2</literal></expr></argument>,<argument><expr><name>p2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>+</operator><literal type="number">3</literal></expr></argument>,<argument><expr><name>p3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaD_checkstack</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>+=</operator><literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaD_call</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">4</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaV_gettable</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>t</name></decl></parameter>,<parameter><decl><type><name>TValue</name><modifier>*</modifier></type><name>key</name></decl></parameter>,<parameter><decl><type><name>StkId</name></type> <name>val</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>loop</name></decl>;</decl_stmt>
<for>for<control>(<init><expr><name>loop</name><operator>=</operator><literal type="number">0</literal></expr>;</init><condition><expr><name>loop</name><operator>&lt;</operator><literal type="number">100</literal></expr>;</condition><incr><expr><name>loop</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>tm</name></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><call><name>ttistable</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<decl_stmt><decl><type><name>Table</name><modifier>*</modifier></type><name>h</name><init>=<expr><call><name>hvalue</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>res</name><init>=<expr><call><name>luaH_get</name><argument_list>(<argument><expr><name>h</name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ttisnil</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call><operator>||</operator>
<operator>(</operator><name>tm</name><operator>=</operator><call><name>fasttm</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>h</name><operator>-&gt;</operator><name>metatable</name></name></expr></argument>,<argument><expr><name>TM_INDEX</name></expr></argument>)</argument_list></call><operator>)</operator><operator>==</operator><name>NULL</name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>setobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>val</name></expr></argument>,<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if<condition>(<expr><call><name>ttisnil</name><argument_list>(<argument><expr><name>tm</name><operator>=</operator><call><name>luaT_gettmbyobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>t</name></expr></argument>,<argument><expr><name>TM_INDEX</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaG_typeerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>t</name></expr></argument>,<argument><expr><literal type="string">"index"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><call><name>ttisfunction</name><argument_list>(<argument><expr><name>tm</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>callTMres</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>val</name></expr></argument>,<argument><expr><name>tm</name></expr></argument>,<argument><expr><name>t</name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>t</name><operator>=</operator><name>tm</name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>luaG_runerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"loop in gettable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaV_settable</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>t</name></decl></parameter>,<parameter><decl><type><name>TValue</name><modifier>*</modifier></type><name>key</name></decl></parameter>,<parameter><decl><type><name>StkId</name></type> <name>val</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>loop</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TValue</name></type> <name>temp</name></decl>;</decl_stmt>
<for>for<control>(<init><expr><name>loop</name><operator>=</operator><literal type="number">0</literal></expr>;</init><condition><expr><name>loop</name><operator>&lt;</operator><literal type="number">100</literal></expr>;</condition><incr><expr><name>loop</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>tm</name></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><call><name>ttistable</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<decl_stmt><decl><type><name>Table</name><modifier>*</modifier></type><name>h</name><init>=<expr><call><name>hvalue</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TValue</name><modifier>*</modifier></type><name>oldval</name><init>=<expr><call><name>luaH_set</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>h</name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ttisnil</name><argument_list>(<argument><expr><name>oldval</name></expr></argument>)</argument_list></call><operator>||</operator>
<operator>(</operator><name>tm</name><operator>=</operator><call><name>fasttm</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>h</name><operator>-&gt;</operator><name>metatable</name></name></expr></argument>,<argument><expr><name>TM_NEWINDEX</name></expr></argument>)</argument_list></call><operator>)</operator><operator>==</operator><name>NULL</name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>setobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>oldval</name></expr></argument>,<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>flags</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaC_barriert</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>h</name></expr></argument>,<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if<condition>(<expr><call><name>ttisnil</name><argument_list>(<argument><expr><name>tm</name><operator>=</operator><call><name>luaT_gettmbyobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>t</name></expr></argument>,<argument><expr><name>TM_NEWINDEX</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaG_typeerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>t</name></expr></argument>,<argument><expr><literal type="string">"index"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><call><name>ttisfunction</name><argument_list>(<argument><expr><name>tm</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>callTM</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>tm</name></expr></argument>,<argument><expr><name>t</name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>setobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>temp</name></expr></argument>,<argument><expr><name>tm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>t</name><operator>=</operator><operator>&amp;</operator><name>temp</name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>luaG_runerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"loop in settable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>call_binTM</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>p1</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>p2</name></decl></parameter>,
<parameter><decl><type><name>StkId</name></type> <name>res</name></decl></parameter>,<parameter><decl><type><name>TMS</name></type> <name>event</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>tm</name><init>=<expr><call><name>luaT_gettmbyobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>p1</name></expr></argument>,<argument><expr><name>event</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><call><name>ttisnil</name><argument_list>(<argument><expr><name>tm</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>tm</name><operator>=</operator><call><name>luaT_gettmbyobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>p2</name></expr></argument>,<argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><call><name>ttisnil</name><argument_list>(<argument><expr><name>tm</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content><return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>callTMres</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>res</name></expr></argument>,<argument><expr><name>tm</name></expr></argument>,<argument><expr><name>p1</name></expr></argument>,<argument><expr><name>p2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>get_compTM</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>Table</name><modifier>*</modifier></type><name>mt1</name></decl></parameter>,<parameter><decl><type><name>Table</name><modifier>*</modifier></type><name>mt2</name></decl></parameter>,
<parameter><decl><type><name>TMS</name></type> <name>event</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>tm1</name><init>=<expr><call><name>fasttm</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>mt1</name></expr></argument>,<argument><expr><name>event</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>tm2</name></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>tm1</name><operator>==</operator><name>NULL</name></expr>)</condition><block type="pseudo"><block_content><return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><name>mt1</name><operator>==</operator><name>mt2</name></expr>)</condition><block type="pseudo"><block_content><return>return <expr><name>tm1</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>tm2</name><operator>=</operator><call><name>fasttm</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>mt2</name></expr></argument>,<argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>tm2</name><operator>==</operator><name>NULL</name></expr>)</condition><block type="pseudo"><block_content><return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><call><name>luaO_rawequalObj</name><argument_list>(<argument><expr><name>tm1</name></expr></argument>,<argument><expr><name>tm2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>tm1</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>call_orderTM</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>p1</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>p2</name></decl></parameter>,
<parameter><decl><type><name>TMS</name></type> <name>event</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>tm1</name><init>=<expr><call><name>luaT_gettmbyobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>p1</name></expr></argument>,<argument><expr><name>event</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>tm2</name></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><call><name>ttisnil</name><argument_list>(<argument><expr><name>tm1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content><return>return<expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>tm2</name><operator>=</operator><call><name>luaT_gettmbyobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>p2</name></expr></argument>,<argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>luaO_rawequalObj</name><argument_list>(<argument><expr><name>tm1</name></expr></argument>,<argument><expr><name>tm2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return<expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>callTMres</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>,<argument><expr><name>tm1</name></expr></argument>,<argument><expr><name>p1</name></expr></argument>,<argument><expr><name>p2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return<expr><operator>!</operator><call><name>l_isfalse</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>l_strcmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TString</name><modifier>*</modifier></type><name>ls</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>TString</name><modifier>*</modifier></type><name>rs</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>l</name><init>=<expr><call><name>getstr</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>ll</name><init>=<expr><name><name>ls</name><operator>-&gt;</operator><name>tsv</name><operator>.</operator><name>len</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>r</name><init>=<expr><call><name>getstr</name><argument_list>(<argument><expr><name>rs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>lr</name><init>=<expr><name><name>rs</name><operator>-&gt;</operator><name>tsv</name><operator>.</operator><name>len</name></name></expr></init></decl>;</decl_stmt>
<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>temp</name><init>=<expr><call><name>strcoll</name><argument_list>(<argument><expr><name>l</name></expr></argument>,<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>temp</name><operator>!=</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content><return>return <expr><name>temp</name></expr>;</return></block_content></block></if>
<else>else<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name><init>=<expr><call><name>strlen</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>len</name><operator>==</operator><name>lr</name></expr>)</condition><block type="pseudo"><block_content>
<return>return<expr><ternary><condition><expr><operator>(</operator><name>len</name><operator>==</operator><name>ll</name><operator>)</operator></expr>?</condition><then><expr><literal type="number">0</literal></expr></then><else>:<expr><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></if>
<if type="elseif">else if<condition>(<expr><name>len</name><operator>==</operator><name>ll</name></expr>)</condition><block type="pseudo"><block_content>
<return>return<expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>len</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>l</name><operator>+=</operator><name>len</name></expr>;</expr_stmt><expr_stmt><expr><name>ll</name><operator>-=</operator><name>len</name></expr>;</expr_stmt><expr_stmt><expr><name>r</name><operator>+=</operator><name>len</name></expr>;</expr_stmt><expr_stmt><expr><name>lr</name><operator>-=</operator><name>len</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>luaV_lessthan</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>l</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>r</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><call><name>ttype</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call><operator>!=</operator><call><name>ttype</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>luaG_ordererror</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>l</name></expr></argument>,<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<if type="elseif">else if<condition>(<expr><call><name>ttisnumber</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>luai_numlt</name><argument_list>(<argument><expr><call><name>nvalue</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>nvalue</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<if type="elseif">else if<condition>(<expr><call><name>ttisstring</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>l_strcmp</name><argument_list>(<argument><expr><call><name>rawtsvalue</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>rawtsvalue</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>&lt;</operator><literal type="number">0</literal></expr>;</return></block_content></block></if>
<if type="elseif">else if<condition>(<expr><operator>(</operator><name>res</name><operator>=</operator><call><name>call_orderTM</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>l</name></expr></argument>,<argument><expr><name>r</name></expr></argument>,<argument><expr><name>TM_LT</name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>luaG_ordererror</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>l</name></expr></argument>,<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lessequal</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>l</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>r</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><call><name>ttype</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call><operator>!=</operator><call><name>ttype</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>luaG_ordererror</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>l</name></expr></argument>,<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<if type="elseif">else if<condition>(<expr><call><name>ttisnumber</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>luai_numle</name><argument_list>(<argument><expr><call><name>nvalue</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>nvalue</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<if type="elseif">else if<condition>(<expr><call><name>ttisstring</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>l_strcmp</name><argument_list>(<argument><expr><call><name>rawtsvalue</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>rawtsvalue</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>&lt;=</operator><literal type="number">0</literal></expr>;</return></block_content></block></if>
<if type="elseif">else if<condition>(<expr><operator>(</operator><name>res</name><operator>=</operator><call><name>call_orderTM</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>l</name></expr></argument>,<argument><expr><name>r</name></expr></argument>,<argument><expr><name>TM_LE</name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>res</name></expr>;</return></block_content></block></if>
<if type="elseif">else if<condition>(<expr><operator>(</operator><name>res</name><operator>=</operator><call><name>call_orderTM</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>r</name></expr></argument>,<argument><expr><name>l</name></expr></argument>,<argument><expr><name>TM_LT</name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return<expr><operator>!</operator><name>res</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>luaG_ordererror</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>l</name></expr></argument>,<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>luaV_equalval</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>t1</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>t2</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>tm</name></decl>;</decl_stmt>
<switch>switch<condition>(<expr><call><name>ttype</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case><return>return <expr><literal type="number">1</literal></expr>;</return>
<case>case <expr><literal type="number">3</literal></expr>:</case><return>return <expr><call><name>luai_numeq</name><argument_list>(<argument><expr><call><name>nvalue</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>nvalue</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><literal type="number">1</literal></expr>:</case><return>return <expr><call><name>bvalue</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call><operator>==</operator><call><name>bvalue</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><literal type="number">2</literal></expr>:</case><return>return <expr><call><name>pvalue</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call><operator>==</operator><call><name>pvalue</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><literal type="number">7</literal></expr>:</case><block>{<block_content>
<if_stmt><if>if<condition>(<expr><call><name>uvalue</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call><operator>==</operator><call><name>uvalue</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content><return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>tm</name><operator>=</operator><call><name>get_compTM</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>uvalue</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>metatable</name></expr></argument>,<argument><expr><call><name>uvalue</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>metatable</name></expr></argument>,
<argument><expr><name>TM_EQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><literal type="number">5</literal></expr>:</case><block>{<block_content>
<if_stmt><if>if<condition>(<expr><call><name>hvalue</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call><operator>==</operator><call><name>hvalue</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content><return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>tm</name><operator>=</operator><call><name>get_compTM</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>hvalue</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>metatable</name></expr></argument>,<argument><expr><call><name>hvalue</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>metatable</name></expr></argument>,<argument><expr><name>TM_EQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<default>default:</default><return>return <expr><call><name>gcvalue</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call><operator>==</operator><call><name>gcvalue</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></switch>
<if_stmt><if>if<condition>(<expr><name>tm</name><operator>==</operator><name>NULL</name></expr>)</condition><block type="pseudo"><block_content><return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>callTMres</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>,<argument><expr><name>tm</name></expr></argument>,<argument><expr><name>t1</name></expr></argument>,<argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return<expr><operator>!</operator><call><name>l_isfalse</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaV_concat</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>total</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>last</name></decl></parameter>)</parameter_list><block>{<block_content>
<do>do<block>{<block_content>
<decl_stmt><decl><type><name>StkId</name></type> <name>top</name><init>=<expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>+</operator><name>last</name><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name><init>=<expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><operator>!</operator><operator>(</operator><call><name>ttisstring</name><argument_list>(<argument><expr><name>top</name><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call><operator>||</operator><call><name>ttisnumber</name><argument_list>(<argument><expr><name>top</name><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>||</operator><operator>!</operator><call><name>tostring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>top</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>call_binTM</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>top</name><operator>-</operator><literal type="number">2</literal></expr></argument>,<argument><expr><name>top</name><operator>-</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>top</name><operator>-</operator><literal type="number">2</literal></expr></argument>,<argument><expr><name>TM_CONCAT</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaG_concaterror</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>top</name><operator>-</operator><literal type="number">2</literal></expr></argument>,<argument><expr><name>top</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if><if type="elseif">else if<condition>(<expr><call><name>tsvalue</name><argument_list>(<argument><expr><name>top</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>len</name><operator>==</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>tostring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>top</name><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>tl</name><init>=<expr><call><name>tsvalue</name><argument_list>(<argument><expr><name>top</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>len</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type><name>buffer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for<control>(<init><expr><name>n</name><operator>=</operator><literal type="number">1</literal></expr>;</init><condition><expr><name>n</name><operator>&lt;</operator><name>total</name><operator>&amp;&amp;</operator><call><name>tostring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>top</name><operator>-</operator><name>n</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</condition><incr><expr><name>n</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>l</name><init>=<expr><call><name>tsvalue</name><argument_list>(<argument><expr><name>top</name><operator>-</operator><name>n</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>len</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>l</name><operator>&gt;=</operator><operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><operator>~</operator><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">0</literal><operator>)</operator><operator>-</operator><literal type="number">2</literal><operator>)</operator><operator>-</operator><name>tl</name></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><call><name>luaG_runerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"string length overflow"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>tl</name><operator>+=</operator><name>l</name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>buffer</name><operator>=</operator><call><name>luaZ_openspace</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>&amp;</operator><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>buff</name></expr></argument>,<argument><expr><name>tl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tl</name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<for>for<control>(<init><expr><name>i</name><operator>=</operator><name>n</name></expr>;</init><condition><expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal></expr>;</condition><incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>l</name><init>=<expr><call><name>tsvalue</name><argument_list>(<argument><expr><name>top</name><operator>-</operator><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>len</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buffer</name><operator>+</operator><name>tl</name></expr></argument>,<argument><expr><call><name>svalue</name><argument_list>(<argument><expr><name>top</name><operator>-</operator><name>i</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tl</name><operator>+=</operator><name>l</name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>setsvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>top</name><operator>-</operator><name>n</name></expr></argument>,<argument><expr><call><name>luaS_newlstr</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>buffer</name></expr></argument>,<argument><expr><name>tl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>total</name><operator>-=</operator><name>n</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>last</name><operator>-=</operator><name>n</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block>while<condition>(<expr><name>total</name><operator>&gt;</operator><literal type="number">1</literal></expr>)</condition>;</do>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>Arith</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>StkId</name></type> <name>ra</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>rb</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>rc</name></decl></parameter>,<parameter><decl><type><name>TMS</name></type> <name>op</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>TValue</name></type> <name>tempb</name></decl>,<decl><type ref="prev"/><name>tempc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>b</name></decl>,<decl><type ref="prev"><modifier>*</modifier></type><name>c</name></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><operator>(</operator><name>b</name><operator>=</operator><call><name>luaV_tonumber</name><argument_list>(<argument><expr><name>rb</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>tempb</name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><name>NULL</name><operator>&amp;&amp;</operator>
<operator>(</operator><name>c</name><operator>=</operator><call><name>luaV_tonumber</name><argument_list>(<argument><expr><name>rc</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>tempc</name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><name>NULL</name></expr>)</condition><block>{<block_content>
<decl_stmt><decl><type><name>lua_Number</name></type> <name>nb</name><init>=<expr><call><name>nvalue</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>,<decl><type ref="prev"/><name>nc</name><init>=<expr><call><name>nvalue</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<switch>switch<condition>(<expr><name>op</name></expr>)</condition><block>{<block_content>
<case>case <expr><name>TM_ADD</name></expr>:</case><expr_stmt><expr><call><name>setnvalue</name><argument_list>(<argument><expr><name>ra</name></expr></argument>,<argument><expr><call><name>luai_numadd</name><argument_list>(<argument><expr><name>nb</name></expr></argument>,<argument><expr><name>nc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt><break>break;</break>
<case>case <expr><name>TM_SUB</name></expr>:</case><expr_stmt><expr><call><name>setnvalue</name><argument_list>(<argument><expr><name>ra</name></expr></argument>,<argument><expr><call><name>luai_numsub</name><argument_list>(<argument><expr><name>nb</name></expr></argument>,<argument><expr><name>nc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt><break>break;</break>
<case>case <expr><name>TM_MUL</name></expr>:</case><expr_stmt><expr><call><name>setnvalue</name><argument_list>(<argument><expr><name>ra</name></expr></argument>,<argument><expr><call><name>luai_nummul</name><argument_list>(<argument><expr><name>nb</name></expr></argument>,<argument><expr><name>nc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt><break>break;</break>
<case>case <expr><name>TM_DIV</name></expr>:</case><expr_stmt><expr><call><name>setnvalue</name><argument_list>(<argument><expr><name>ra</name></expr></argument>,<argument><expr><call><name>luai_numdiv</name><argument_list>(<argument><expr><name>nb</name></expr></argument>,<argument><expr><name>nc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt><break>break;</break>
<case>case <expr><name>TM_MOD</name></expr>:</case><expr_stmt><expr><call><name>setnvalue</name><argument_list>(<argument><expr><name>ra</name></expr></argument>,<argument><expr><call><name>luai_nummod</name><argument_list>(<argument><expr><name>nb</name></expr></argument>,<argument><expr><name>nc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt><break>break;</break>
<case>case <expr><name>TM_POW</name></expr>:</case><expr_stmt><expr><call><name>setnvalue</name><argument_list>(<argument><expr><name>ra</name></expr></argument>,<argument><expr><call><name>luai_numpow</name><argument_list>(<argument><expr><name>nb</name></expr></argument>,<argument><expr><name>nc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt><break>break;</break>
<case>case <expr><name>TM_UNM</name></expr>:</case><expr_stmt><expr><call><name>setnvalue</name><argument_list>(<argument><expr><name>ra</name></expr></argument>,<argument><expr><call><name>luai_numunm</name><argument_list>(<argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt><break>break;</break>
<default>default:</default><break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></if>
<if type="elseif">else if<condition>(<expr><operator>!</operator><call><name>call_binTM</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>rb</name></expr></argument>,<argument><expr><name>rc</name></expr></argument>,<argument><expr><name>ra</name></expr></argument>,<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaG_aritherror</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>rb</name></expr></argument>,<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>runtime_check</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>{if(!(c))break;}</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RA</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(base+GETARG_A(i))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RB</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>check_exp(getBMode(GET_OPCODE(i))==OpArgR,base+GETARG_B(i))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RKB</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>check_exp(getBMode(GET_OPCODE(i))==OpArgK,ISK(GETARG_B(i))?k+INDEXK(GETARG_B(i)):base+GETARG_B(i))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RKC</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>check_exp(getCMode(GET_OPCODE(i))==OpArgK,ISK(GETARG_C(i))?k+INDEXK(GETARG_C(i)):base+GETARG_C(i))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>KBx</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>check_exp(getBMode(GET_OPCODE(i))==OpArgK,k+GETARG_Bx(i))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dojump</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>pc</name></type></parameter>,<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>{(pc)+=(i);}</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Protect</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>{L-&gt;savedpc=pc;{x;};base=L-&gt;base;}</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>arith_op</name><parameter_list>(<parameter><type><name>op</name></type></parameter>,<parameter><type><name>tm</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>{TValue*rb=RKB(i);TValue*rc=RKC(i);if(ttisnumber(rb)&amp;&amp;ttisnumber(rc)){lua_Number nb=nvalue(rb),nc=nvalue(rc);setnvalue(ra,op(nb,nc));}else Protect(Arith(L,ra,rb,rc,tm));}</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaV_execute</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>nexeccalls</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>LClosure</name><modifier>*</modifier></type><name>cl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>StkId</name></type> <name>base</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TValue</name><modifier>*</modifier></type><name>k</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Instruction</name><modifier>*</modifier></type><name>pc</name></decl>;</decl_stmt>
<label><name>reentry</name>:</label>
<expr_stmt><expr><name>pc</name><operator>=</operator><name><name>L</name><operator>-&gt;</operator><name>savedpc</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>cl</name><operator>=</operator><operator>&amp;</operator><call><name>clvalue</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>ci</name><operator>-&gt;</operator><name>func</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>l</name></expr>;</expr_stmt>
<expr_stmt><expr><name>base</name><operator>=</operator><name><name>L</name><operator>-&gt;</operator><name>base</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>k</name><operator>=</operator><name><name>cl</name><operator>-&gt;</operator><name>p</name><operator>-&gt;</operator><name>k</name></name></expr>;</expr_stmt>
<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>Instruction</name></type> <name>i</name><init>=<expr><operator>*</operator><name>pc</name><operator>++</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>StkId</name></type> <name>ra</name></decl>;</decl_stmt>
<expr_stmt><expr><name>ra</name><operator>=</operator><call><name>RA</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch<condition>(<expr><call><name>GET_OPCODE</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<case>case <expr><name>OP_MOVE</name></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>setobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>ra</name></expr></argument>,<argument><expr><call><name>RB</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block>
<case>case <expr><name>OP_LOADK</name></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>setobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>ra</name></expr></argument>,<argument><expr><call><name>KBx</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block>
<case>case <expr><name>OP_LOADBOOL</name></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>setbvalue</name><argument_list>(<argument><expr><name>ra</name></expr></argument>,<argument><expr><call><name>GETARG_B</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><call><name>GETARG_C</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><name>pc</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<continue>continue;</continue>
</block_content>}</block>
<case>case <expr><name>OP_LOADNIL</name></expr>:</case><block>{<block_content>
<decl_stmt><decl><type><name>TValue</name><modifier>*</modifier></type><name>rb</name><init>=<expr><call><name>RB</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<do>do<block>{<block_content>
<expr_stmt><expr><call><name>setnilvalue</name><argument_list>(<argument><expr><name>rb</name><operator>--</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>while<condition>(<expr><name>rb</name><operator>&gt;=</operator><name>ra</name></expr>)</condition>;</do>
<continue>continue;</continue>
</block_content>}</block>
<case>case <expr><name>OP_GETUPVAL</name></expr>:</case><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>b</name><init>=<expr><call><name>GETARG_B</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>setobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>ra</name></expr></argument>,<argument><expr><name><name>cl</name><operator>-&gt;</operator><name>upvals</name><index>[<expr><name>b</name></expr>]</index></name><operator>-&gt;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block>
<case>case <expr><name>OP_GETGLOBAL</name></expr>:</case><block>{<block_content>
<decl_stmt><decl><type><name>TValue</name></type> <name>g</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TValue</name><modifier>*</modifier></type><name>rb</name><init>=<expr><call><name>KBx</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>sethvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>g</name></expr></argument>,<argument><expr><name><name>cl</name><operator>-&gt;</operator><name>env</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Protect</name><argument_list>(<argument><expr><call><name>luaV_gettable</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>g</name></expr></argument>,<argument><expr><name>rb</name></expr></argument>,<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block>
<case>case <expr><name>OP_GETTABLE</name></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>Protect</name><argument_list>(<argument><expr><call><name>luaV_gettable</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>RB</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>RKC</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block>
<case>case <expr><name>OP_SETGLOBAL</name></expr>:</case><block>{<block_content>
<decl_stmt><decl><type><name>TValue</name></type> <name>g</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>sethvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>g</name></expr></argument>,<argument><expr><name><name>cl</name><operator>-&gt;</operator><name>env</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Protect</name><argument_list>(<argument><expr><call><name>luaV_settable</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>g</name></expr></argument>,<argument><expr><call><name>KBx</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block>
<case>case <expr><name>OP_SETUPVAL</name></expr>:</case><block>{<block_content>
<decl_stmt><decl><type><name>UpVal</name><modifier>*</modifier></type><name>uv</name><init>=<expr><name><name>cl</name><operator>-&gt;</operator><name>upvals</name><index>[<expr><call><name>GETARG_B</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>setobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>uv</name><operator>-&gt;</operator><name>v</name></name></expr></argument>,<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaC_barrier</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>uv</name></expr></argument>,<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block>
<case>case <expr><name>OP_SETTABLE</name></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>Protect</name><argument_list>(<argument><expr><call><name>luaV_settable</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>ra</name></expr></argument>,<argument><expr><call><name>RKB</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>RKC</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block>
<case>case <expr><name>OP_NEWTABLE</name></expr>:</case><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>b</name><init>=<expr><call><name>GETARG_B</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name><init>=<expr><call><name>GETARG_C</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>sethvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>ra</name></expr></argument>,<argument><expr><call><name>luaH_new</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>luaO_fb2int</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>luaO_fb2int</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Protect</name><argument_list>(<argument><expr><call><name>luaC_checkGC</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block>
<case>case <expr><name>OP_SELF</name></expr>:</case><block>{<block_content>
<decl_stmt><decl><type><name>StkId</name></type> <name>rb</name><init>=<expr><call><name>RB</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>setobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>ra</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Protect</name><argument_list>(<argument><expr><call><name>luaV_gettable</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>rb</name></expr></argument>,<argument><expr><call><name>RKC</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block>
<case>case <expr><name>OP_ADD</name></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>arith_op</name><argument_list>(<argument><expr><name>luai_numadd</name></expr></argument>,<argument><expr><name>TM_ADD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block>
<case>case <expr><name>OP_SUB</name></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>arith_op</name><argument_list>(<argument><expr><name>luai_numsub</name></expr></argument>,<argument><expr><name>TM_SUB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block>
<case>case <expr><name>OP_MUL</name></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>arith_op</name><argument_list>(<argument><expr><name>luai_nummul</name></expr></argument>,<argument><expr><name>TM_MUL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block>
<case>case <expr><name>OP_DIV</name></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>arith_op</name><argument_list>(<argument><expr><name>luai_numdiv</name></expr></argument>,<argument><expr><name>TM_DIV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block>
<case>case <expr><name>OP_MOD</name></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>arith_op</name><argument_list>(<argument><expr><name>luai_nummod</name></expr></argument>,<argument><expr><name>TM_MOD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block>
<case>case <expr><name>OP_POW</name></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>arith_op</name><argument_list>(<argument><expr><name>luai_numpow</name></expr></argument>,<argument><expr><name>TM_POW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block>
<case>case <expr><name>OP_UNM</name></expr>:</case><block>{<block_content>
<decl_stmt><decl><type><name>TValue</name><modifier>*</modifier></type><name>rb</name><init>=<expr><call><name>RB</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><call><name>ttisnumber</name><argument_list>(<argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<decl_stmt><decl><type><name>lua_Number</name></type> <name>nb</name><init>=<expr><call><name>nvalue</name><argument_list>(<argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>setnvalue</name><argument_list>(<argument><expr><name>ra</name></expr></argument>,<argument><expr><call><name>luai_numunm</name><argument_list>(<argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block>{<block_content>
<expr_stmt><expr><call><name>Protect</name><argument_list>(<argument><expr><call><name>Arith</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>ra</name></expr></argument>,<argument><expr><name>rb</name></expr></argument>,<argument><expr><name>rb</name></expr></argument>,<argument><expr><name>TM_UNM</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<continue>continue;</continue>
</block_content>}</block>
<case>case <expr><name>OP_NOT</name></expr>:</case><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>res</name><init>=<expr><call><name>l_isfalse</name><argument_list>(<argument><expr><call><name>RB</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>setbvalue</name><argument_list>(<argument><expr><name>ra</name></expr></argument>,<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block>
<case>case <expr><name>OP_LEN</name></expr>:</case><block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>rb</name><init>=<expr><call><name>RB</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<switch>switch<condition>(<expr><call><name>ttype</name><argument_list>(<argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<case>case <expr><literal type="number">5</literal></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>setnvalue</name><argument_list>(<argument><expr><name>ra</name></expr></argument>,<argument><expr><call><name>cast_num</name><argument_list>(<argument><expr><call><name>luaH_getn</name><argument_list>(<argument><expr><call><name>hvalue</name><argument_list>(<argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><literal type="number">4</literal></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>setnvalue</name><argument_list>(<argument><expr><name>ra</name></expr></argument>,<argument><expr><call><name>cast_num</name><argument_list>(<argument><expr><call><name>tsvalue</name><argument_list>(<argument><expr><name>rb</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<default>default:</default><block>{<block_content>
<macro><name>Protect</name><argument_list>(
<argument>if(!call_binTM(L,rb,(&amp;luaO_nilobject_),ra,TM_LEN))
luaG_typeerror(L,rb,<literal type="string">"get length of"</literal>);</argument>
)</argument_list></macro>
</block_content>}</block>
</block_content>}</block></switch>
<continue>continue;</continue>
</block_content>}</block>
<case>case <expr><name>OP_CONCAT</name></expr>:</case><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>b</name><init>=<expr><call><name>GETARG_B</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name><init>=<expr><call><name>GETARG_C</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Protect</name><argument_list>(<argument>luaV_concat(L,c-b+<literal type="number">1</literal>,c);luaC_checkGC(L)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<expr_stmt><expr><call><name>setobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>RA</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>base</name><operator>+</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block>
<case>case <expr><name>OP_JMP</name></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>dojump</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>pc</name></expr></argument>,<argument><expr><call><name>GETARG_sBx</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block>
<case>case <expr><name>OP_EQ</name></expr>:</case><block>{<block_content>
<decl_stmt><decl><type><name>TValue</name><modifier>*</modifier></type><name>rb</name><init>=<expr><call><name>RKB</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TValue</name><modifier>*</modifier></type><name>rc</name><init>=<expr><call><name>RKC</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Protect</name><argument_list>(
<argument>if(equalobj(L,rb,rc)==GETARG_A(i))
dojump(L,pc,GETARG_sBx(*pc));</argument>
)</argument_list></macro>
<expr_stmt><expr><name>pc</name><operator>++</operator></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block>
<case>case <expr><name>OP_LT</name></expr>:</case><block>{<block_content>
<macro><name>Protect</name><argument_list>(
<argument>if(luaV_lessthan(L,RKB(i),RKC(i))==GETARG_A(i))
dojump(L,pc,GETARG_sBx(*pc));</argument>
)</argument_list></macro>
<expr_stmt><expr><name>pc</name><operator>++</operator></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block>
<case>case <expr><name>OP_LE</name></expr>:</case><block>{<block_content>
<macro><name>Protect</name><argument_list>(
<argument>if(lessequal(L,RKB(i),RKC(i))==GETARG_A(i))
dojump(L,pc,GETARG_sBx(*pc));</argument>
)</argument_list></macro>
<expr_stmt><expr><name>pc</name><operator>++</operator></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block>
<case>case <expr><name>OP_TEST</name></expr>:</case><block>{<block_content>
<if_stmt><if>if<condition>(<expr><call><name>l_isfalse</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call><operator>!=</operator><call><name>GETARG_C</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dojump</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>pc</name></expr></argument>,<argument><expr><call><name>GETARG_sBx</name><argument_list>(<argument><expr><operator>*</operator><name>pc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>pc</name><operator>++</operator></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block>
<case>case <expr><name>OP_TESTSET</name></expr>:</case><block>{<block_content>
<decl_stmt><decl><type><name>TValue</name><modifier>*</modifier></type><name>rb</name><init>=<expr><call><name>RB</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><call><name>l_isfalse</name><argument_list>(<argument><expr><name>rb</name></expr></argument>)</argument_list></call><operator>!=</operator><call><name>GETARG_C</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>setobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>ra</name></expr></argument>,<argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dojump</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>pc</name></expr></argument>,<argument><expr><call><name>GETARG_sBx</name><argument_list>(<argument><expr><operator>*</operator><name>pc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>pc</name><operator>++</operator></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block>
<case>case <expr><name>OP_CALL</name></expr>:</case><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>b</name><init>=<expr><call><name>GETARG_B</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nresults</name><init>=<expr><call><name>GETARG_C</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>b</name><operator>!=</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>=</operator><name>ra</name><operator>+</operator><name>b</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>savedpc</name></name><operator>=</operator><name>pc</name></expr>;</expr_stmt>
<switch>switch<condition>(<expr><call><name>luaD_precall</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>ra</name></expr></argument>,<argument><expr><name>nresults</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case><block>{<block_content>
<expr_stmt><expr><name>nexeccalls</name><operator>++</operator></expr>;</expr_stmt>
<goto>goto <name>reentry</name>;</goto>
</block_content>}</block>
<case>case <expr><literal type="number">1</literal></expr>:</case><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name>nresults</name><operator>&gt;=</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>=</operator><name><name>L</name><operator>-&gt;</operator><name>ci</name><operator>-&gt;</operator><name>top</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>base</name><operator>=</operator><name><name>L</name><operator>-&gt;</operator><name>base</name></name></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block>
<default>default:</default><block>{<block_content>
<return>return;</return>
</block_content>}</block>
</block_content>}</block></switch>
</block_content>}</block>
<case>case <expr><name>OP_TAILCALL</name></expr>:</case><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>b</name><init>=<expr><call><name>GETARG_B</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>b</name><operator>!=</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>=</operator><name>ra</name><operator>+</operator><name>b</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>savedpc</name></name><operator>=</operator><name>pc</name></expr>;</expr_stmt>
<switch>switch<condition>(<expr><call><name>luaD_precall</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>ra</name></expr></argument>,<argument><expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case><block>{<block_content>
<decl_stmt><decl><type><name>CallInfo</name><modifier>*</modifier></type><name>ci</name><init>=<expr><name><name>L</name><operator>-&gt;</operator><name>ci</name></name><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>aux</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>StkId</name></type> <name>func</name><init>=<expr><name><name>ci</name><operator>-&gt;</operator><name>func</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>StkId</name></type> <name>pfunc</name><init>=<expr><operator>(</operator><name>ci</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>-&gt;</operator><name>func</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name><name>L</name><operator>-&gt;</operator><name>openupval</name></name></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><call><name>luaF_close</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>ci</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>=</operator><name><name>ci</name><operator>-&gt;</operator><name>base</name></name><operator>=</operator><name><name>ci</name><operator>-&gt;</operator><name>func</name></name><operator>+</operator><operator>(</operator><operator>(</operator><name>ci</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>-&gt;</operator><name>base</name><operator>-</operator><name>pfunc</name><operator>)</operator></expr>;</expr_stmt>
<for>for<control>(<init><expr><name>aux</name><operator>=</operator><literal type="number">0</literal></expr>;</init><condition><expr><name>pfunc</name><operator>+</operator><name>aux</name><operator>&lt;</operator><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr>;</condition><incr><expr><name>aux</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>setobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>func</name><operator>+</operator><name>aux</name></expr></argument>,<argument><expr><name>pfunc</name><operator>+</operator><name>aux</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>top</name></name><operator>=</operator><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>=</operator><name>func</name><operator>+</operator><name>aux</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>savedpc</name></name><operator>=</operator><name><name>L</name><operator>-&gt;</operator><name>savedpc</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>tailcalls</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>ci</name></name><operator>--</operator></expr>;</expr_stmt>
<goto>goto <name>reentry</name>;</goto>
</block_content>}</block>
<case>case <expr><literal type="number">1</literal></expr>:</case><block>{<block_content>
<expr_stmt><expr><name>base</name><operator>=</operator><name><name>L</name><operator>-&gt;</operator><name>base</name></name></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block>
<default>default:</default><block>{<block_content>
<return>return;</return>
</block_content>}</block>
</block_content>}</block></switch>
</block_content>}</block>
<case>case <expr><name>OP_RETURN</name></expr>:</case><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>b</name><init>=<expr><call><name>GETARG_B</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>b</name><operator>!=</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>=</operator><name>ra</name><operator>+</operator><name>b</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><name><name>L</name><operator>-&gt;</operator><name>openupval</name></name></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><call><name>luaF_close</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>savedpc</name></name><operator>=</operator><name>pc</name></expr>;</expr_stmt>
<expr_stmt><expr><name>b</name><operator>=</operator><call><name>luaD_poscall</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><operator>--</operator><name>nexeccalls</name><operator>==</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if>
<else>else<block>{<block_content>
<if_stmt><if>if<condition>(<expr><name>b</name></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>=</operator><name><name>L</name><operator>-&gt;</operator><name>ci</name><operator>-&gt;</operator><name>top</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<goto>goto <name>reentry</name>;</goto>
</block_content>}</block></else></if_stmt>
</block_content>}</block>
<case>case <expr><name>OP_FORLOOP</name></expr>:</case><block>{<block_content>
<decl_stmt><decl><type><name>lua_Number</name></type> <name>step</name><init>=<expr><call><name>nvalue</name><argument_list>(<argument><expr><name>ra</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>lua_Number</name></type> <name>idx</name><init>=<expr><call><name>luai_numadd</name><argument_list>(<argument><expr><call><name>nvalue</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>step</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>lua_Number</name></type> <name>limit</name><init>=<expr><call><name>nvalue</name><argument_list>(<argument><expr><name>ra</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><ternary><condition><expr><call><name>luai_numlt</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>step</name></expr></argument>)</argument_list></call></expr>?</condition><then><expr><call><name>luai_numle</name><argument_list>(<argument><expr><name>idx</name></expr></argument>,<argument><expr><name>limit</name></expr></argument>)</argument_list></call></expr>
</then><else>:<expr><call><name>luai_numle</name><argument_list>(<argument><expr><name>limit</name></expr></argument>,<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>dojump</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>pc</name></expr></argument>,<argument><expr><call><name>GETARG_sBx</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setnvalue</name><argument_list>(<argument><expr><name>ra</name></expr></argument>,<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setnvalue</name><argument_list>(<argument><expr><name>ra</name><operator>+</operator><literal type="number">3</literal></expr></argument>,<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<continue>continue;</continue>
</block_content>}</block>
<case>case <expr><name>OP_FORPREP</name></expr>:</case><block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>init</name><init>=<expr><name>ra</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>plimit</name><init>=<expr><name>ra</name><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>pstep</name><init>=<expr><name>ra</name><operator>+</operator><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>savedpc</name></name><operator>=</operator><name>pc</name></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>tonumber</name><argument_list>(<argument><expr><name>init</name></expr></argument>,<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaG_runerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>LUA_QL</name><argument_list>(<argument><expr><literal type="string">"for"</literal></expr></argument>)</argument_list></call><literal type="string">" initial value must be a number"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if<condition>(<expr><operator>!</operator><call><name>tonumber</name><argument_list>(<argument><expr><name>plimit</name></expr></argument>,<argument><expr><name>ra</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaG_runerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>LUA_QL</name><argument_list>(<argument><expr><literal type="string">"for"</literal></expr></argument>)</argument_list></call><literal type="string">" limit must be a number"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if<condition>(<expr><operator>!</operator><call><name>tonumber</name><argument_list>(<argument><expr><name>pstep</name></expr></argument>,<argument><expr><name>ra</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaG_runerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>LUA_QL</name><argument_list>(<argument><expr><literal type="string">"for"</literal></expr></argument>)</argument_list></call><literal type="string">" step must be a number"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>setnvalue</name><argument_list>(<argument><expr><name>ra</name></expr></argument>,<argument><expr><call><name>luai_numsub</name><argument_list>(<argument><expr><call><name>nvalue</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>nvalue</name><argument_list>(<argument><expr><name>pstep</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dojump</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>pc</name></expr></argument>,<argument><expr><call><name>GETARG_sBx</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block>
<case>case <expr><name>OP_TFORLOOP</name></expr>:</case><block>{<block_content>
<decl_stmt><decl><type><name>StkId</name></type> <name>cb</name><init>=<expr><name>ra</name><operator>+</operator><literal type="number">3</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>setobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>cb</name><operator>+</operator><literal type="number">2</literal></expr></argument>,<argument><expr><name>ra</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>cb</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>ra</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>cb</name></expr></argument>,<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>=</operator><name>cb</name><operator>+</operator><literal type="number">3</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Protect</name><argument_list>(<argument><expr><call><name>luaD_call</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>cb</name></expr></argument>,<argument><expr><call><name>GETARG_C</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>=</operator><name><name>L</name><operator>-&gt;</operator><name>ci</name><operator>-&gt;</operator><name>top</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>cb</name><operator>=</operator><call><name>RA</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">3</literal></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ttisnil</name><argument_list>(<argument><expr><name>cb</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>setobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>cb</name><operator>-</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dojump</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>pc</name></expr></argument>,<argument><expr><call><name>GETARG_sBx</name><argument_list>(<argument><expr><operator>*</operator><name>pc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>pc</name><operator>++</operator></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block>
<case>case <expr><name>OP_SETLIST</name></expr>:</case><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>n</name><init>=<expr><call><name>GETARG_B</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name><init>=<expr><call><name>GETARG_C</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>last</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Table</name><modifier>*</modifier></type><name>h</name></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>n</name><operator>==</operator><literal type="number">0</literal></expr>)</condition><block>{<block_content>
<expr_stmt><expr><name>n</name><operator>=</operator><call><name>cast_int</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><name>ra</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>=</operator><name><name>L</name><operator>-&gt;</operator><name>ci</name><operator>-&gt;</operator><name>top</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><name>c</name><operator>==</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><name>c</name><operator>=</operator><call><name>cast_int</name><argument_list>(<argument><expr><operator>*</operator><name>pc</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>runtime_check</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>ttistable</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name><operator>=</operator><call><name>hvalue</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>last</name><operator>=</operator><operator>(</operator><operator>(</operator><name>c</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><literal type="number">50</literal><operator>)</operator><operator>+</operator><name>n</name></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>last</name><operator>&gt;</operator><name><name>h</name><operator>-&gt;</operator><name>sizearray</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaH_resizearray</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>h</name></expr></argument>,<argument><expr><name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<for>for<control>(<init>;</init><condition><expr><name>n</name><operator>&gt;</operator><literal type="number">0</literal></expr>;</condition><incr><expr><name>n</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
<decl_stmt><decl><type><name>TValue</name><modifier>*</modifier></type><name>val</name><init>=<expr><name>ra</name><operator>+</operator><name>n</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>setobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>luaH_setnum</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>h</name></expr></argument>,<argument><expr><name>last</name><operator>--</operator></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaC_barriert</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>h</name></expr></argument>,<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<continue>continue;</continue>
</block_content>}</block>
<case>case <expr><name>OP_CLOSE</name></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>luaF_close</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block>
<case>case <expr><name>OP_CLOSURE</name></expr>:</case><block>{<block_content>
<decl_stmt><decl><type><name>Proto</name><modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Closure</name><modifier>*</modifier></type><name>ncl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nup</name></decl>,<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<expr_stmt><expr><name>p</name><operator>=</operator><name><name>cl</name><operator>-&gt;</operator><name>p</name><operator>-&gt;</operator><name>p</name><index>[<expr><call><name>GETARG_Bx</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>nup</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>nups</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>ncl</name><operator>=</operator><call><name>luaF_newLclosure</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>nup</name></expr></argument>,<argument><expr><name><name>cl</name><operator>-&gt;</operator><name>env</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ncl</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>p</name></name><operator>=</operator><name>p</name></expr>;</expr_stmt>
<for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init><condition><expr><name>j</name><operator>&lt;</operator><name>nup</name></expr>;</condition><incr><expr><name>j</name><operator>++</operator></expr><operator>,</operator><expr><name>pc</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
<if_stmt><if>if<condition>(<expr><call><name>GET_OPCODE</name><argument_list>(<argument><expr><operator>*</operator><name>pc</name></expr></argument>)</argument_list></call><operator>==</operator><name>OP_GETUPVAL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ncl</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>upvals</name><index>[<expr><name>j</name></expr>]</index></name><operator>=</operator><name><name>cl</name><operator>-&gt;</operator><name>upvals</name><index>[<expr><call><name>GETARG_B</name><argument_list>(<argument><expr><operator>*</operator><name>pc</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block>{<block_content>
<expr_stmt><expr><name><name>ncl</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>upvals</name><index>[<expr><name>j</name></expr>]</index></name><operator>=</operator><call><name>luaF_findupval</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>base</name><operator>+</operator><call><name>GETARG_B</name><argument_list>(<argument><expr><operator>*</operator><name>pc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>setclvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>ra</name></expr></argument>,<argument><expr><name>ncl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Protect</name><argument_list>(<argument><expr><call><name>luaC_checkGC</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block>
<case>case <expr><name>OP_VARARG</name></expr>:</case><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>b</name><init>=<expr><call><name>GETARG_B</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CallInfo</name><modifier>*</modifier></type><name>ci</name><init>=<expr><name><name>L</name><operator>-&gt;</operator><name>ci</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name><init>=<expr><call><name>cast_int</name><argument_list>(<argument><expr><name><name>ci</name><operator>-&gt;</operator><name>base</name></name><operator>-</operator><name><name>ci</name><operator>-&gt;</operator><name>func</name></name></expr></argument>)</argument_list></call><operator>-</operator><name><name>cl</name><operator>-&gt;</operator><name>p</name><operator>-&gt;</operator><name>numparams</name></name><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>b</name><operator>==</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>Protect</name><argument_list>(<argument><expr><call><name>luaD_checkstack</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ra</name><operator>=</operator><call><name>RA</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b</name><operator>=</operator><name>n</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>=</operator><name>ra</name><operator>+</operator><name>n</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init><condition><expr><name>j</name><operator>&lt;</operator><name>b</name></expr>;</condition><incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name>j</name><operator>&lt;</operator><name>n</name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>setobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>ra</name><operator>+</operator><name>j</name></expr></argument>,<argument><expr><name><name>ci</name><operator>-&gt;</operator><name>base</name></name><operator>-</operator><name>n</name><operator>+</operator><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block>{<block_content>
<expr_stmt><expr><call><name>setnilvalue</name><argument_list>(<argument><expr><name>ra</name><operator>+</operator><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
<continue>continue;</continue>
</block_content>}</block>
</block_content>}</block></switch>
</block_content>}</block></for>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>api_checknelems</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>luai_apicheck(L,(n)&lt;=(L-&gt;top-L-&gt;base))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>api_checkvalidindex</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>luai_apicheck(L,(i)!=(&amp;luaO_nilobject_))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>api_incr_top</name><parameter_list>(<parameter><type><name>L</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>{luai_apicheck(L,L-&gt;top&lt;L-&gt;ci-&gt;top);L-&gt;top++;}</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>TValue</name><modifier>*</modifier></type><name>index2adr</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name>idx</name><operator>&gt;</operator><literal type="number">0</literal></expr>)</condition><block>{<block_content>
<decl_stmt><decl><type><name>TValue</name><modifier>*</modifier></type><name>o</name><init>=<expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>+</operator><operator>(</operator><name>idx</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luai_apicheck</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>idx</name><operator>&lt;=</operator><name><name>L</name><operator>-&gt;</operator><name>ci</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><name><name>L</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>o</name><operator>&gt;=</operator><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr>)</condition><block type="pseudo"><block_content><return>return <expr><call><name>cast</name><argument_list>(<argument><expr><name>TValue</name><operator>*</operator></expr></argument>,<argument><expr><operator>(</operator><operator>&amp;</operator><name>luaO_nilobject_</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content> <return>return <expr><name>o</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if<condition>(<expr><name>idx</name><operator>&gt;</operator><operator>(</operator><operator>-</operator><literal type="number">10000</literal><operator>)</operator></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>luai_apicheck</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>idx</name><operator>!=</operator><literal type="number">0</literal><operator>&amp;&amp;</operator><operator>-</operator><name>idx</name><operator>&lt;=</operator><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><name><name>L</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>+</operator><name>idx</name></expr>;</return>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content> <switch>switch<condition>(<expr><name>idx</name></expr>)</condition><block>{<block_content>
<case>case<expr><operator>(</operator><operator>-</operator><literal type="number">10000</literal><operator>)</operator></expr>:</case><return>return <expr><call><name>registry</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</return>
<case>case<expr><operator>(</operator><operator>-</operator><literal type="number">10001</literal><operator>)</operator></expr>:</case><block>{<block_content>
<decl_stmt><decl><type><name>Closure</name><modifier>*</modifier></type><name>func</name><init>=<expr><call><name>curr_func</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>sethvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>L</name><operator>-&gt;</operator><name>env</name></name></expr></argument>,<argument><expr><name><name>func</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>env</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return<expr><operator>&amp;</operator><name><name>L</name><operator>-&gt;</operator><name>env</name></name></expr>;</return>
</block_content>}</block>
<case>case<expr><operator>(</operator><operator>-</operator><literal type="number">10002</literal><operator>)</operator></expr>:</case><return>return <expr><call><name>gt</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</return>
<default>default:</default><block>{<block_content>
<decl_stmt><decl><type><name>Closure</name><modifier>*</modifier></type><name>func</name><init>=<expr><call><name>curr_func</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>idx</name><operator>=</operator><operator>(</operator><operator>-</operator><literal type="number">10002</literal><operator>)</operator><operator>-</operator><name>idx</name></expr>;</expr_stmt>
<return>return<expr><ternary><condition><expr><operator>(</operator><name>idx</name><operator>&lt;=</operator><name><name>func</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>nupvalues</name></name><operator>)</operator></expr>
?</condition><then><expr><operator>&amp;</operator><name><name>func</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>upvalue</name><index>[<expr><name>idx</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>
</then><else>:<expr><call><name>cast</name><argument_list>(<argument><expr><name>TValue</name><operator>*</operator></expr></argument>,<argument><expr><operator>(</operator><operator>&amp;</operator><name>luaO_nilobject_</name><operator>)</operator></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
</block_content>}</block>
</block_content>}</block></switch></block_content></block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>Table</name><modifier>*</modifier></type><name>getcurrenv</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name><name>L</name><operator>-&gt;</operator><name>ci</name></name><operator>==</operator><name><name>L</name><operator>-&gt;</operator><name>base_ci</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>hvalue</name><argument_list>(<argument><expr><call><name>gt</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block>{<block_content>
<decl_stmt><decl><type><name>Closure</name><modifier>*</modifier></type><name>func</name><init>=<expr><call><name>curr_func</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><name><name>func</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>env</name></name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lua_checkstack</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>res</name><init>=<expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>size</name><operator>&gt;</operator><literal type="number">8000</literal><operator>||</operator><operator>(</operator><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><name><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>+</operator><name>size</name><operator>)</operator><operator>&gt;</operator><literal type="number">8000</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>res</name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if<condition>(<expr><name>size</name><operator>&gt;</operator><literal type="number">0</literal></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>luaD_checkstack</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name><name>L</name><operator>-&gt;</operator><name>ci</name><operator>-&gt;</operator><name>top</name></name><operator>&lt;</operator><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>+</operator><name>size</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>ci</name><operator>-&gt;</operator><name>top</name></name><operator>=</operator><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>+</operator><name>size</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>lua_CFunction</name></type> <name>lua_atpanic</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>lua_CFunction</name></type> <name>panicf</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>lua_CFunction</name></type> <name>old</name></decl>;</decl_stmt>
<expr_stmt><expr><name>old</name><operator>=</operator><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>panic</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>panic</name><operator>=</operator><name>panicf</name></expr>;</expr_stmt>
<return>return <expr><name>old</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lua_gettop</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<return>return <expr><call><name>cast_int</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><name><name>L</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>lua_settop</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name>idx</name><operator>&gt;=</operator><literal type="number">0</literal></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>luai_apicheck</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>idx</name><operator>&lt;=</operator><name><name>L</name><operator>-&gt;</operator><name>stack_last</name></name><operator>-</operator><name><name>L</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while<condition>(<expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>&lt;</operator><name><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>+</operator><name>idx</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>setnilvalue</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>=</operator><name><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>+</operator><name>idx</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block>{<block_content>
<expr_stmt><expr><call><name>luai_apicheck</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><operator>(</operator><name>idx</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>&lt;=</operator><operator>(</operator><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><name><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>+=</operator><name>idx</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>lua_remove</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>StkId</name></type> <name>p</name></decl>;</decl_stmt>
<expr_stmt><expr><name>p</name><operator>=</operator><call><name>index2adr</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>api_checkvalidindex</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while<condition>(<expr><operator>++</operator><name>p</name><operator>&lt;</operator><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><call><name>setobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>p</name><operator>-</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>lua_insert</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>StkId</name></type> <name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>StkId</name></type> <name>q</name></decl>;</decl_stmt>
<expr_stmt><expr><name>p</name><operator>=</operator><call><name>index2adr</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>api_checkvalidindex</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for<control>(<init><expr><name>q</name><operator>=</operator><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr>;</init><condition><expr><name>q</name><operator>&gt;</operator><name>p</name></expr>;</condition><incr><expr><name>q</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content><expr_stmt><expr><call><name>setobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>q</name></expr></argument>,<argument><expr><name>q</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>setobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>p</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>lua_replace</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>StkId</name></type> <name>o</name></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>idx</name><operator>==</operator><operator>(</operator><operator>-</operator><literal type="number">10001</literal><operator>)</operator><operator>&amp;&amp;</operator><name><name>L</name><operator>-&gt;</operator><name>ci</name></name><operator>==</operator><name><name>L</name><operator>-&gt;</operator><name>base_ci</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaG_runerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"no calling environment"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>api_checknelems</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>o</name><operator>=</operator><call><name>index2adr</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>api_checkvalidindex</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>idx</name><operator>==</operator><operator>(</operator><operator>-</operator><literal type="number">10001</literal><operator>)</operator></expr>)</condition><block>{<block_content>
<decl_stmt><decl><type><name>Closure</name><modifier>*</modifier></type><name>func</name><init>=<expr><call><name>curr_func</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luai_apicheck</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>ttistable</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>func</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>env</name></name><operator>=</operator><call><name>hvalue</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaC_barrier</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>func</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block>{<block_content>
<expr_stmt><expr><call><name>setobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>o</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>idx</name><operator>&lt;</operator><operator>(</operator><operator>-</operator><literal type="number">10002</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaC_barrier</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>curr_func</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>lua_pushvalue</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>setobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>,<argument><expr><call><name>index2adr</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>api_incr_top</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lua_type</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>StkId</name></type> <name>o</name><init>=<expr><call><name>index2adr</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return<expr><ternary><condition><expr><operator>(</operator><name>o</name><operator>==</operator><operator>(</operator><operator>&amp;</operator><name>luaO_nilobject_</name><operator>)</operator><operator>)</operator></expr>?</condition><then><expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></then><else>:<expr><call><name>ttype</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>lua_typename</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>t</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return<expr><ternary><condition><expr><operator>(</operator><name>t</name><operator>==</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>?</condition><then><expr><literal type="string">"no value"</literal></expr></then><else>:<expr><name><name>luaT_typenames</name><index>[<expr><name>t</name></expr>]</index></name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lua_iscfunction</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>StkId</name></type> <name>o</name><init>=<expr><call><name>index2adr</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>iscfunction</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lua_isnumber</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>TValue</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>o</name><init>=<expr><call><name>index2adr</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>tonumber</name><argument_list>(<argument><expr><name>o</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lua_isstring</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>t</name><init>=<expr><call><name>lua_type</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return<expr><operator>(</operator><name>t</name><operator>==</operator><literal type="number">4</literal><operator>||</operator><name>t</name><operator>==</operator><literal type="number">3</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lua_rawequal</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>index1</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>index2</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>StkId</name></type> <name>o1</name><init>=<expr><call><name>index2adr</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>index1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>StkId</name></type> <name>o2</name><init>=<expr><call><name>index2adr</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>index2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return<expr><ternary><condition><expr><operator>(</operator><name>o1</name><operator>==</operator><operator>(</operator><operator>&amp;</operator><name>luaO_nilobject_</name><operator>)</operator><operator>||</operator><name>o2</name><operator>==</operator><operator>(</operator><operator>&amp;</operator><name>luaO_nilobject_</name><operator>)</operator><operator>)</operator></expr>?</condition><then><expr><literal type="number">0</literal></expr>
</then><else>:<expr><call><name>luaO_rawequalObj</name><argument_list>(<argument><expr><name>o1</name></expr></argument>,<argument><expr><name>o2</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lua_lessthan</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>index1</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>index2</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>StkId</name></type> <name>o1</name></decl>,<decl><type ref="prev"/><name>o2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><name>o1</name><operator>=</operator><call><name>index2adr</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>index1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>o2</name><operator>=</operator><call><name>index2adr</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>index2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name><operator>=</operator><ternary><condition><expr><operator>(</operator><name>o1</name><operator>==</operator><operator>(</operator><operator>&amp;</operator><name>luaO_nilobject_</name><operator>)</operator><operator>||</operator><name>o2</name><operator>==</operator><operator>(</operator><operator>&amp;</operator><name>luaO_nilobject_</name><operator>)</operator><operator>)</operator></expr>?</condition><then><expr><literal type="number">0</literal></expr>
</then><else>:<expr><call><name>luaV_lessthan</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>o1</name></expr></argument>,<argument><expr><name>o2</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
<return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>lua_Number</name></type> <name>lua_tonumber</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>TValue</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>o</name><init>=<expr><call><name>index2adr</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><call><name>tonumber</name><argument_list>(<argument><expr><name>o</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>nvalue</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>lua_Integer</name></type> <name>lua_tointeger</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>TValue</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>o</name><init>=<expr><call><name>index2adr</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><call><name>tonumber</name><argument_list>(<argument><expr><name>o</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<decl_stmt><decl><type><name>lua_Integer</name></type> <name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>lua_Number</name></type> <name>num</name><init>=<expr><call><name>nvalue</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>lua_number2integer</name><argument_list>(<argument><expr><name>res</name></expr></argument>,<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lua_toboolean</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>o</name><init>=<expr><call><name>index2adr</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return<expr><operator>!</operator><call><name>l_isfalse</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>lua_tolstring</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>,<parameter><decl><type><name>size_t</name><modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>StkId</name></type> <name>o</name><init>=<expr><call><name>index2adr</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ttisstring</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>luaV_tostring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name>len</name><operator>!=</operator><name>NULL</name></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><operator>*</operator><name>len</name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>luaC_checkGC</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>o</name><operator>=</operator><call><name>index2adr</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><name>len</name><operator>!=</operator><name>NULL</name></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><operator>*</operator><name>len</name><operator>=</operator><call><name>tsvalue</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>len</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><call><name>svalue</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>lua_objlen</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>StkId</name></type> <name>o</name><init>=<expr><call><name>index2adr</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<switch>switch<condition>(<expr><call><name>ttype</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<case>case <expr><literal type="number">4</literal></expr>:</case><return>return <expr><call><name>tsvalue</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>len</name></expr>;</return>
<case>case <expr><literal type="number">7</literal></expr>:</case><return>return <expr><call><name>uvalue</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>len</name></expr>;</return>
<case>case <expr><literal type="number">5</literal></expr>:</case><return>return <expr><call><name>luaH_getn</name><argument_list>(<argument><expr><call><name>hvalue</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><literal type="number">3</literal></expr>:</case><block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>l</name></decl>;</decl_stmt>
<expr_stmt><expr><name>l</name><operator>=</operator><operator>(</operator><ternary><condition><expr><call><name>luaV_tostring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>?</condition><then><expr><call><name>tsvalue</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>len</name></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><name>l</name></expr>;</return>
</block_content>}</block>
<default>default:</default><return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>lua_CFunction</name></type> <name>lua_tocfunction</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>StkId</name></type> <name>o</name><init>=<expr><call><name>index2adr</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return<expr><ternary><condition><expr><operator>(</operator><operator>!</operator><call><name>iscfunction</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call><operator>)</operator></expr>?</condition><then><expr><name>NULL</name></expr></then><else>:<expr><call><name>clvalue</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>c</name><operator>.</operator><name>f</name></name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name><modifier>*</modifier></type><name>lua_touserdata</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>StkId</name></type> <name>o</name><init>=<expr><call><name>index2adr</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<switch>switch<condition>(<expr><call><name>ttype</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<case>case <expr><literal type="number">7</literal></expr>:</case><return>return<expr><operator>(</operator><call><name>rawuvalue</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
<case>case <expr><literal type="number">2</literal></expr>:</case><return>return <expr><call><name>pvalue</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</return>
<default>default:</default><return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>lua_pushnil</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>setnilvalue</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>api_incr_top</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>lua_pushnumber</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>lua_Number</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>setnvalue</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>,<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>api_incr_top</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>lua_pushinteger</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>lua_Integer</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>setnvalue</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>,<argument><expr><call><name>cast_num</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>api_incr_top</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>lua_pushlstring</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>s</name></decl></parameter>,<parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>luaC_checkGC</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setsvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>,<argument><expr><call><name>luaS_newlstr</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>api_incr_top</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>lua_pushstring</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name>s</name><operator>==</operator><name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>lua_pushnil</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>lua_pushlstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>lua_pushvfstring</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>fmt</name></decl></parameter>,
<parameter><decl><type><name>va_list</name></type> <name>argp</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaC_checkGC</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name><operator>=</operator><call><name>luaO_pushvfstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>fmt</name></expr></argument>,<argument><expr><name>argp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>lua_pushfstring</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>va_list</name></type> <name>argp</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaC_checkGC</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>argp</name></expr></argument>,<argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name><operator>=</operator><call><name>luaO_pushvfstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>fmt</name></expr></argument>,<argument><expr><name>argp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>argp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>lua_pushcclosure</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>lua_CFunction</name></type> <name>fn</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>Closure</name><modifier>*</modifier></type><name>cl</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaC_checkGC</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>api_checknelems</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cl</name><operator>=</operator><call><name>luaF_newCclosure</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>n</name></expr></argument>,<argument><expr><call><name>getcurrenv</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cl</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>f</name></name><operator>=</operator><name>fn</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-=</operator><name>n</name></expr>;</expr_stmt>
<while>while<condition>(<expr><name>n</name><operator>--</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>setobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>cl</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>upvalue</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>+</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
<expr_stmt><expr><call><name>setclvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>,<argument><expr><name>cl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>api_incr_top</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>lua_pushboolean</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>b</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>setbvalue</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>,<argument><expr><operator>(</operator><name>b</name><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>api_incr_top</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lua_pushthread</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>setthvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>,<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>api_incr_top</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return<expr><operator>(</operator><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>mainthread</name><operator>==</operator><name>L</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>lua_gettable</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>StkId</name></type> <name>t</name></decl>;</decl_stmt>
<expr_stmt><expr><name>t</name><operator>=</operator><call><name>index2adr</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>api_checkvalidindex</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaV_gettable</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>t</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>lua_getfield</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>k</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>StkId</name></type> <name>t</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TValue</name></type> <name>key</name></decl>;</decl_stmt>
<expr_stmt><expr><name>t</name><operator>=</operator><call><name>index2adr</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>api_checkvalidindex</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setsvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>,<argument><expr><call><name>luaS_new</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaV_gettable</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>t</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>api_incr_top</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>lua_rawget</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>StkId</name></type> <name>t</name></decl>;</decl_stmt>
<expr_stmt><expr><name>t</name><operator>=</operator><call><name>index2adr</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luai_apicheck</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>ttistable</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>,<argument><expr><call><name>luaH_get</name><argument_list>(<argument><expr><call><name>hvalue</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>lua_rawgeti</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>StkId</name></type> <name>o</name></decl>;</decl_stmt>
<expr_stmt><expr><name>o</name><operator>=</operator><call><name>index2adr</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luai_apicheck</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>ttistable</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>,<argument><expr><call><name>luaH_getnum</name><argument_list>(<argument><expr><call><name>hvalue</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>api_incr_top</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>lua_createtable</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>narray</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>nrec</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>luaC_checkGC</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sethvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>,<argument><expr><call><name>luaH_new</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>narray</name></expr></argument>,<argument><expr><name>nrec</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>api_incr_top</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lua_getmetatable</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>objindex</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>TValue</name><modifier>*</modifier></type><name>obj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Table</name><modifier>*</modifier></type><name>mt</name><init>=<expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
<expr_stmt><expr><name>obj</name><operator>=</operator><call><name>index2adr</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>objindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch<condition>(<expr><call><name>ttype</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<case>case <expr><literal type="number">5</literal></expr>:</case>
<expr_stmt><expr><name>mt</name><operator>=</operator><call><name>hvalue</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>metatable</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">7</literal></expr>:</case>
<expr_stmt><expr><name>mt</name><operator>=</operator><call><name>uvalue</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>metatable</name></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><name>mt</name><operator>=</operator><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>mt</name><index>[<expr><call><name>ttype</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<if_stmt><if>if<condition>(<expr><name>mt</name><operator>==</operator><name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>res</name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block>{<block_content>
<expr_stmt><expr><call><name>sethvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>,<argument><expr><name>mt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>api_incr_top</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>res</name><operator>=</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>lua_getfenv</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>StkId</name></type> <name>o</name></decl>;</decl_stmt>
<expr_stmt><expr><name>o</name><operator>=</operator><call><name>index2adr</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>api_checkvalidindex</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch<condition>(<expr><call><name>ttype</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<case>case <expr><literal type="number">6</literal></expr>:</case>
<expr_stmt><expr><call><name>sethvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>,<argument><expr><call><name>clvalue</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>c</name><operator>.</operator><name>env</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">7</literal></expr>:</case>
<expr_stmt><expr><call><name>sethvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>,<argument><expr><call><name>uvalue</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">8</literal></expr>:</case>
<expr_stmt><expr><call><name>setobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>,<argument><expr><call><name>gt</name><argument_list>(<argument><expr><call><name>thvalue</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>setnilvalue</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>api_incr_top</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>lua_settable</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>StkId</name></type> <name>t</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>api_checknelems</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>t</name><operator>=</operator><call><name>index2adr</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>api_checkvalidindex</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaV_settable</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>t</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">2</literal></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-=</operator><literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>lua_setfield</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>k</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>StkId</name></type> <name>t</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TValue</name></type> <name>key</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>api_checknelems</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>t</name><operator>=</operator><call><name>index2adr</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>api_checkvalidindex</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setsvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>,<argument><expr><call><name>luaS_new</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaV_settable</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>t</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>lua_rawset</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>StkId</name></type> <name>t</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>api_checknelems</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>t</name><operator>=</operator><call><name>index2adr</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luai_apicheck</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>ttistable</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>luaH_set</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>hvalue</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaC_barriert</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>hvalue</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-=</operator><literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>lua_rawseti</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>StkId</name></type> <name>o</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>api_checknelems</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>o</name><operator>=</operator><call><name>index2adr</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luai_apicheck</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>ttistable</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>luaH_setnum</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>hvalue</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaC_barriert</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>hvalue</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lua_setmetatable</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>objindex</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>TValue</name><modifier>*</modifier></type><name>obj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Table</name><modifier>*</modifier></type><name>mt</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>api_checknelems</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>obj</name><operator>=</operator><call><name>index2adr</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>objindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>api_checkvalidindex</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><call><name>ttisnil</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>mt</name><operator>=</operator><name>NULL</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block>{<block_content>
<expr_stmt><expr><call><name>luai_apicheck</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>ttistable</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>mt</name><operator>=</operator><call><name>hvalue</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<switch>switch<condition>(<expr><call><name>ttype</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<case>case <expr><literal type="number">5</literal></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>hvalue</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>metatable</name><operator>=</operator><name>mt</name></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>mt</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaC_objbarriert</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>hvalue</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>mt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><literal type="number">7</literal></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>uvalue</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>metatable</name><operator>=</operator><name>mt</name></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>mt</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaC_objbarrier</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>rawuvalue</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>mt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
</block_content>}</block>
<default>default:</default><block>{<block_content>
<expr_stmt><expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>mt</name><index>[<expr><call><name>ttype</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>]</index></name><operator>=</operator><name>mt</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
</block_content>}</block></switch>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>--</operator></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lua_setfenv</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>StkId</name></type> <name>o</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>res</name><init>=<expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>api_checknelems</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>o</name><operator>=</operator><call><name>index2adr</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>api_checkvalidindex</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luai_apicheck</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>ttistable</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch<condition>(<expr><call><name>ttype</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<case>case <expr><literal type="number">6</literal></expr>:</case>
<expr_stmt><expr><call><name>clvalue</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>c</name><operator>.</operator><name>env</name></name><operator>=</operator><call><name>hvalue</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">7</literal></expr>:</case>
<expr_stmt><expr><call><name>uvalue</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>env</name><operator>=</operator><call><name>hvalue</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">8</literal></expr>:</case>
<expr_stmt><expr><call><name>sethvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>gt</name><argument_list>(<argument><expr><call><name>thvalue</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>hvalue</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><name>res</name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<if_stmt><if>if<condition>(<expr><name>res</name></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><call><name>luaC_objbarrier</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>gcvalue</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>hvalue</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>--</operator></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>adjustresults</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>nres</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>{if(nres==(-1)&amp;&amp;L-&gt;top&gt;=L-&gt;ci-&gt;top)L-&gt;ci-&gt;top=L-&gt;top;}</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>checkresults</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>na</name></type></parameter>,<parameter><type><name>nr</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>luai_apicheck(L,(nr)==(-1)||(L-&gt;ci-&gt;top-L-&gt;top&gt;=(nr)-(na)))</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>void</name></type> <name>lua_call</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>nresults</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>StkId</name></type> <name>func</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>api_checknelems</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>nargs</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>checkresults</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>nargs</name></expr></argument>,<argument><expr><name>nresults</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>func</name><operator>=</operator><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><operator>(</operator><name>nargs</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaD_call</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>func</name></expr></argument>,<argument><expr><name>nresults</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>adjustresults</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>nresults</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<struct>struct <name>CallS</name><block>{
<decl_stmt><decl><type><name>StkId</name></type> <name>func</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nresults</name></decl>;</decl_stmt>
}</block>;</struct>
<function><type><specifier>static</specifier> <name>void</name></type> <name>f_call</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>void</name><modifier>*</modifier></type><name>ud</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>CallS</name></name><modifier>*</modifier></type><name>c</name><init>=<expr><call><name>cast</name><argument_list>(<argument><expr>struct <name>CallS</name><operator>*</operator></expr></argument>,<argument><expr><name>ud</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaD_call</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>func</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>nresults</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lua_pcall</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>nresults</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>errfunc</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>CallS</name></name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>func</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>api_checknelems</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>nargs</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>checkresults</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>nargs</name></expr></argument>,<argument><expr><name>nresults</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>errfunc</name><operator>==</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>func</name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block>{<block_content>
<decl_stmt><decl><type><name>StkId</name></type> <name>o</name><init>=<expr><call><name>index2adr</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>errfunc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>api_checkvalidindex</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>func</name><operator>=</operator><call><name>savestack</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>c</name><operator>.</operator><name>func</name></name><operator>=</operator><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><operator>(</operator><name>nargs</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name><operator>.</operator><name>nresults</name></name><operator>=</operator><name>nresults</name></expr>;</expr_stmt>
<expr_stmt><expr><name>status</name><operator>=</operator><call><name>luaD_pcall</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>f_call</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>c</name></expr></argument>,<argument><expr><call><name>savestack</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>c</name><operator>.</operator><name>func</name></name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>adjustresults</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>nresults</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lua_load</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>lua_Reader</name></type> <name>reader</name></decl></parameter>,<parameter><decl><type><name>void</name><modifier>*</modifier></type><name>data</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>chunkname</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>ZIO</name></type> <name>z</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><operator>!</operator><name>chunkname</name></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><name>chunkname</name><operator>=</operator><literal type="string">"?"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>luaZ_init</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>,<argument><expr><name>reader</name></expr></argument>,<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>status</name><operator>=</operator><call><name>luaD_protectedparser</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>,<argument><expr><name>chunkname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lua_error</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>api_checknelems</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaG_errormsg</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lua_next</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>StkId</name></type> <name>t</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>more</name></decl>;</decl_stmt>
<expr_stmt><expr><name>t</name><operator>=</operator><call><name>index2adr</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luai_apicheck</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>ttistable</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>more</name><operator>=</operator><call><name>luaH_next</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>hvalue</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>more</name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>api_incr_top</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-=</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
<return>return <expr><name>more</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>lua_concat</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>api_checknelems</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>n</name><operator>&gt;=</operator><literal type="number">2</literal></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>luaC_checkGC</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaV_concat</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>n</name></expr></argument>,<argument><expr><call><name>cast_int</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><name><name>L</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-=</operator><operator>(</operator><name>n</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if<condition>(<expr><name>n</name><operator>==</operator><literal type="number">0</literal></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>setsvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>,<argument><expr><call><name>luaS_newlstr</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">""</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>api_incr_top</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name><modifier>*</modifier></type><name>lua_newuserdata</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>Udata</name><modifier>*</modifier></type><name>u</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaC_checkGC</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>u</name><operator>=</operator><call><name>luaS_newudata</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>size</name></expr></argument>,<argument><expr><call><name>getcurrenv</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setuvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>,<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>api_incr_top</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>u</name><operator>+</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>luaL_getn</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((int)lua_objlen(L,i))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>luaL_setn</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>i</name></type></parameter>,<parameter><type><name>j</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((void)0)</cpp:value></cpp:define>
<typedef>typedef <type><struct>struct <name>luaL_Reg</name><block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>lua_CFunction</name></type> <name>func</name></decl>;</decl_stmt>
}</block></struct></type><name>luaL_Reg</name>;</typedef>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>luaI_openlib</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>libname</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>luaL_Reg</name><modifier>*</modifier></type><name>l</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>nup</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>luaL_argerror</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>numarg</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>extramsg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>luaL_checklstring</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>numArg</name></decl></parameter>,
<parameter><decl><type><name>size_t</name><modifier>*</modifier></type><name>l</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>luaL_optlstring</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>numArg</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>def</name></decl></parameter>,<parameter><decl><type><name>size_t</name><modifier>*</modifier></type><name>l</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>lua_Integer</name></type> <name>luaL_checkinteger</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>numArg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>lua_Integer</name></type> <name>luaL_optinteger</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>,
<parameter><decl><type><name>lua_Integer</name></type> <name>def</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>luaL_error</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>luaL_findtable</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>fname</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>szhint</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>luaL_argcheck</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>cond</name></type></parameter>,<parameter><type><name>numarg</name></type></parameter>,<parameter><type><name>extramsg</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((void)((cond)||luaL_argerror(L,(numarg),(extramsg))))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>luaL_checkstring</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(luaL_checklstring(L,(n),NULL))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>luaL_optstring</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>n</name></type></parameter>,<parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(luaL_optlstring(L,(n),(d),NULL))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>luaL_checkint</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((int)luaL_checkinteger(L,(n)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>luaL_optint</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>n</name></type></parameter>,<parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((int)luaL_optinteger(L,(n),(d)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>luaL_typename</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>lua_typename(L,lua_type(L,(i)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>luaL_getmetatable</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(lua_getfield(L,(-10000),(n)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>luaL_opt</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>f</name></type></parameter>,<parameter><type><name>n</name></type></parameter>,<parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(lua_isnoneornil(L,(n))?(d):f(L,(n)))</cpp:value></cpp:define>
<typedef>typedef <type><struct>struct <name>luaL_Buffer</name><block>{
<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>lvl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr><name>BUFSIZ</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type><name>luaL_Buffer</name>;</typedef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>luaL_addchar</name><parameter_list>(<parameter><type><name>B</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((void)((B)-&gt;p&lt;((B)-&gt;buffer+BUFSIZ)||luaL_prepbuffer(B)),(*(B)-&gt;p++=(char)(c)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>luaL_addsize</name><parameter_list>(<parameter><type><name>B</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((B)-&gt;p+=(n))</cpp:value></cpp:define>
<function_decl><type><specifier>static</specifier> <name>char</name><modifier>*</modifier></type> <name>luaL_prepbuffer</name><parameter_list>(<parameter><decl><type><name>luaL_Buffer</name><modifier>*</modifier></type><name>B</name></decl></parameter>)</parameter_list>;</function_decl>
<function><type><specifier>static</specifier> <name>int</name></type> <name>luaL_argerror</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>narg</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>extramsg</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>lua_Debug</name></type> <name>ar</name></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>lua_getstack</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>ar</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>luaL_error</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"bad argument #%d (%s)"</literal></expr></argument>,<argument><expr><name>narg</name></expr></argument>,<argument><expr><name>extramsg</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>lua_getinfo</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"n"</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>ar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>ar</name><operator>.</operator><name>namewhat</name></name></expr></argument>,<argument><expr><literal type="string">"method"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>)</condition><block>{<block_content>
<expr_stmt><expr><name>narg</name><operator>--</operator></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>narg</name><operator>==</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>luaL_error</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"calling "</literal><call><name>LUA_QL</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>)</argument_list></call><literal type="string">" on bad self (%s)"</literal></expr></argument>,
<argument><expr><name><name>ar</name><operator>.</operator><name>name</name></name></expr></argument>,<argument><expr><name>extramsg</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><name><name>ar</name><operator>.</operator><name>name</name></name><operator>==</operator><name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ar</name><operator>.</operator><name>name</name></name><operator>=</operator><literal type="string">"?"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><call><name>luaL_error</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"bad argument #%d to "</literal><call><name>LUA_QL</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>)</argument_list></call><literal type="string">" (%s)"</literal></expr></argument>,
<argument><expr><name>narg</name></expr></argument>,<argument><expr><name><name>ar</name><operator>.</operator><name>name</name></name></expr></argument>,<argument><expr><name>extramsg</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>luaL_typerror</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>narg</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>tname</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>msg</name><init>=<expr><call><name>lua_pushfstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"%s expected, got %s"</literal></expr></argument>,
<argument><expr><name>tname</name></expr></argument>,<argument><expr><call><name>luaL_typename</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>narg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>luaL_argerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>narg</name></expr></argument>,<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>tag_error</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>narg</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>tag</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>luaL_typerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>narg</name></expr></argument>,<argument><expr><call><name>lua_typename</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaL_where</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>lua_Debug</name></type> <name>ar</name></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><call><name>lua_getstack</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>level</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>ar</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>lua_getinfo</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"Sl"</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>ar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name><name>ar</name><operator>.</operator><name>currentline</name></name><operator>&gt;</operator><literal type="number">0</literal></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>lua_pushfstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"%s:%d: "</literal></expr></argument>,<argument><expr><name><name>ar</name><operator>.</operator><name>short_src</name></name></expr></argument>,<argument><expr><name><name>ar</name><operator>.</operator><name>currentline</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>lua_pushliteral</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>luaL_error</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>va_list</name></type> <name>argp</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>argp</name></expr></argument>,<argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaL_where</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_pushvfstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>fmt</name></expr></argument>,<argument><expr><name>argp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>argp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_concat</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>lua_error</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>luaL_newmetatable</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>tname</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>lua_getfield</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>(</operator><operator>-</operator><literal type="number">10000</literal><operator>)</operator></expr></argument>,<argument><expr><name>tname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>lua_isnil</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_newtable</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_pushvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_setfield</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>(</operator><operator>-</operator><literal type="number">10000</literal><operator>)</operator></expr></argument>,<argument><expr><name>tname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name><modifier>*</modifier></type><name>luaL_checkudata</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>ud</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>tname</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>void</name><modifier>*</modifier></type><name>p</name><init>=<expr><call><name>lua_touserdata</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>ud</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>p</name><operator>!=</operator><name>NULL</name></expr>)</condition><block>{<block_content>
<if_stmt><if>if<condition>(<expr><call><name>lua_getmetatable</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>ud</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>lua_getfield</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>(</operator><operator>-</operator><literal type="number">10000</literal><operator>)</operator></expr></argument>,<argument><expr><name>tname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><call><name>lua_rawequal</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>luaL_typerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>ud</name></expr></argument>,<argument><expr><name>tname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaL_checkstack</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>space</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>mes</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>lua_checkstack</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>space</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaL_error</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"stack overflow (%s)"</literal></expr></argument>,<argument><expr><name>mes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaL_checktype</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>narg</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>t</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><call><name>lua_type</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>narg</name></expr></argument>)</argument_list></call><operator>!=</operator><name>t</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>tag_error</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>narg</name></expr></argument>,<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaL_checkany</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>narg</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><call><name>lua_type</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>narg</name></expr></argument>)</argument_list></call><operator>==</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaL_argerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>narg</name></expr></argument>,<argument><expr><literal type="string">"value expected"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>luaL_checklstring</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>narg</name></decl></parameter>,<parameter><decl><type><name>size_t</name><modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>s</name><init>=<expr><call><name>lua_tolstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>narg</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><operator>!</operator><name>s</name></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><call><name>tag_error</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>narg</name></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>s</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>luaL_optlstring</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>narg</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>def</name></decl></parameter>,<parameter><decl><type><name>size_t</name><modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><call><name>lua_isnoneornil</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>narg</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name>len</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>len</name><operator>=</operator><operator>(</operator><ternary><condition><expr><name>def</name></expr>?</condition><then><expr><call><name>strlen</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>def</name></expr>;</return>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content> <return>return <expr><call><name>luaL_checklstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>narg</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>lua_Number</name></type> <name>luaL_checknumber</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>narg</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>lua_Number</name></type> <name>d</name><init>=<expr><call><name>lua_tonumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>narg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>d</name><operator>==</operator><literal type="number">0</literal><operator>&amp;&amp;</operator><operator>!</operator><call><name>lua_isnumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>narg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>tag_error</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>narg</name></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>d</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>lua_Integer</name></type> <name>luaL_checkinteger</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>narg</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>lua_Integer</name></type> <name>d</name><init>=<expr><call><name>lua_tointeger</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>narg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>d</name><operator>==</operator><literal type="number">0</literal><operator>&amp;&amp;</operator><operator>!</operator><call><name>lua_isnumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>narg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>tag_error</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>narg</name></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>d</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>lua_Integer</name></type> <name>luaL_optinteger</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>narg</name></decl></parameter>,
<parameter><decl><type><name>lua_Integer</name></type> <name>def</name></decl></parameter>)</parameter_list><block>{<block_content>
<return>return <expr><call><name>luaL_opt</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>luaL_checkinteger</name></expr></argument>,<argument><expr><name>narg</name></expr></argument>,<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>luaL_getmetafield</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>obj</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>event</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>lua_getmetatable</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>lua_pushstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_rawget</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><call><name>lua_isnil</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if>
<else>else<block>{<block_content>
<expr_stmt><expr><call><name>lua_remove</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaL_register</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>libname</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>luaL_Reg</name><modifier>*</modifier></type><name>l</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>luaI_openlib</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>libname</name></expr></argument>,<argument><expr><name>l</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>libsize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>luaL_Reg</name><modifier>*</modifier></type><name>l</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>size</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<for>for<control>(<init>;</init><condition><expr><name><name>l</name><operator>-&gt;</operator><name>name</name></name></expr>;</condition><incr><expr><name>l</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content><expr_stmt><expr><name>size</name><operator>++</operator></expr>;</expr_stmt></block_content></block></for>
<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaI_openlib</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>libname</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>luaL_Reg</name><modifier>*</modifier></type><name>l</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>nup</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name>libname</name></expr>)</condition><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>size</name><init>=<expr><call><name>libsize</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaL_findtable</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>(</operator><operator>-</operator><literal type="number">10000</literal><operator>)</operator></expr></argument>,<argument><expr><literal type="string">"_LOADED"</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_getfield</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>libname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>lua_istable</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><call><name>luaL_findtable</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>(</operator><operator>-</operator><literal type="number">10002</literal><operator>)</operator></expr></argument>,<argument><expr><name>libname</name></expr></argument>,<argument><expr><name>size</name></expr></argument>)</argument_list></call><operator>!=</operator><name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaL_error</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"name conflict for module "</literal><call><name>LUA_QL</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>libname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>lua_pushvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_setfield</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">3</literal></expr></argument>,<argument><expr><name>libname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>lua_remove</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_insert</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><operator>(</operator><name>nup</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<for>for<control>(<init>;</init><condition><expr><name><name>l</name><operator>-&gt;</operator><name>name</name></name></expr>;</condition><incr><expr><name>l</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init><condition><expr><name>i</name><operator>&lt;</operator><name>nup</name></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>lua_pushvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><name>nup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>lua_pushcclosure</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>l</name><operator>-&gt;</operator><name>func</name></name></expr></argument>,<argument><expr><name>nup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_setfield</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><operator>(</operator><name>nup</name><operator>+</operator><literal type="number">2</literal><operator>)</operator></expr></argument>,<argument><expr><name><name>l</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>nup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>luaL_findtable</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>fname</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>szhint</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>lua_pushvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<do>do<block>{<block_content>
<expr_stmt><expr><name>e</name><operator>=</operator><call><name>strchr</name><argument_list>(<argument><expr><name>fname</name></expr></argument>,<argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>e</name><operator>==</operator><name>NULL</name></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><name>e</name><operator>=</operator><name>fname</name><operator>+</operator><call><name>strlen</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>lua_pushlstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>fname</name></expr></argument>,<argument><expr><name>e</name><operator>-</operator><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_rawget</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><call><name>lua_isnil</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_createtable</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><operator>(</operator><ternary><condition><expr><operator>*</operator><name>e</name><operator>==</operator><literal type="char">'.'</literal></expr>?</condition><then><expr><literal type="number">1</literal></expr></then><else>:<expr><name>szhint</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_pushlstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>fname</name></expr></argument>,<argument><expr><name>e</name><operator>-</operator><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_pushvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_settable</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if<condition>(<expr><operator>!</operator><call><name>lua_istable</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>fname</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>lua_remove</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>fname</name><operator>=</operator><name>e</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block>while<condition>(<expr><operator>*</operator><name>e</name><operator>==</operator><literal type="char">'.'</literal></expr>)</condition>;</do>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>bufflen</name><parameter_list>(<parameter><type><name>B</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((B)-&gt;p-(B)-&gt;buffer)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>bufffree</name><parameter_list>(<parameter><type><name>B</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((size_t)(BUFSIZ-bufflen(B)))</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>int</name></type> <name>emptybuffer</name><parameter_list>(<parameter><decl><type><name>luaL_Buffer</name><modifier>*</modifier></type><name>B</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>l</name><init>=<expr><call><name>bufflen</name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>l</name><operator>==</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content><return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>
<else>else<block>{<block_content>
<expr_stmt><expr><call><name>lua_pushlstring</name><argument_list>(<argument><expr><name><name>B</name><operator>-&gt;</operator><name>L</name></name></expr></argument>,<argument><expr><name><name>B</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>,<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>B</name><operator>-&gt;</operator><name>p</name></name><operator>=</operator><name><name>B</name><operator>-&gt;</operator><name>buffer</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>B</name><operator>-&gt;</operator><name>lvl</name></name><operator>++</operator></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>adjuststack</name><parameter_list>(<parameter><decl><type><name>luaL_Buffer</name><modifier>*</modifier></type><name>B</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name><name>B</name><operator>-&gt;</operator><name>lvl</name></name><operator>&gt;</operator><literal type="number">1</literal></expr>)</condition><block>{<block_content>
<decl_stmt><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name><init>=<expr><name><name>B</name><operator>-&gt;</operator><name>L</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>toget</name><init>=<expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>toplen</name><init>=<expr><call><name>lua_strlen</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<do>do<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>l</name><init>=<expr><call><name>lua_strlen</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><operator>(</operator><name>toget</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name><name>B</name><operator>-&gt;</operator><name>lvl</name></name><operator>-</operator><name>toget</name><operator>+</operator><literal type="number">1</literal><operator>&gt;=</operator><operator>(</operator><literal type="number">20</literal><operator>/</operator><literal type="number">2</literal><operator>)</operator><operator>||</operator><name>toplen</name><operator>&gt;</operator><name>l</name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><name>toplen</name><operator>+=</operator><name>l</name></expr>;</expr_stmt>
<expr_stmt><expr><name>toget</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content> <break>break;</break></block_content></block></else></if_stmt>
</block_content>}</block>while<condition>(<expr><name>toget</name><operator>&lt;</operator><name><name>B</name><operator>-&gt;</operator><name>lvl</name></name></expr>)</condition>;</do>
<expr_stmt><expr><call><name>lua_concat</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>toget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>B</name><operator>-&gt;</operator><name>lvl</name></name><operator>=</operator><name><name>B</name><operator>-&gt;</operator><name>lvl</name></name><operator>-</operator><name>toget</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>char</name><modifier>*</modifier></type><name>luaL_prepbuffer</name><parameter_list>(<parameter><decl><type><name>luaL_Buffer</name><modifier>*</modifier></type><name>B</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><call><name>emptybuffer</name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>adjuststack</name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name><name>B</name><operator>-&gt;</operator><name>buffer</name></name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaL_addlstring</name><parameter_list>(<parameter><decl><type><name>luaL_Buffer</name><modifier>*</modifier></type><name>B</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>s</name></decl></parameter>,<parameter><decl><type><name>size_t</name></type> <name>l</name></decl></parameter>)</parameter_list><block>{<block_content>
<while>while<condition>(<expr><name>l</name><operator>--</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaL_addchar</name><argument_list>(<argument><expr><name>B</name></expr></argument>,<argument><expr><operator>*</operator><name>s</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaL_pushresult</name><parameter_list>(<parameter><decl><type><name>luaL_Buffer</name><modifier>*</modifier></type><name>B</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>emptybuffer</name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_concat</name><argument_list>(<argument><expr><name><name>B</name><operator>-&gt;</operator><name>L</name></name></expr></argument>,<argument><expr><name><name>B</name><operator>-&gt;</operator><name>lvl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>B</name><operator>-&gt;</operator><name>lvl</name></name><operator>=</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaL_addvalue</name><parameter_list>(<parameter><decl><type><name>luaL_Buffer</name><modifier>*</modifier></type><name>B</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name><init>=<expr><name><name>B</name><operator>-&gt;</operator><name>L</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>vl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>s</name><init>=<expr><call><name>lua_tolstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>vl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>vl</name><operator>&lt;=</operator><call><name>bufffree</name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>B</name><operator>-&gt;</operator><name>p</name></name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>vl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>B</name><operator>-&gt;</operator><name>p</name></name><operator>+=</operator><name>vl</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block>{<block_content>
<if_stmt><if>if<condition>(<expr><call><name>emptybuffer</name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>lua_insert</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>B</name><operator>-&gt;</operator><name>lvl</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>adjuststack</name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaL_buffinit</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>luaL_Buffer</name><modifier>*</modifier></type><name>B</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><name><name>B</name><operator>-&gt;</operator><name>L</name></name><operator>=</operator><name>L</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>B</name><operator>-&gt;</operator><name>p</name></name><operator>=</operator><name><name>B</name><operator>-&gt;</operator><name>buffer</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>B</name><operator>-&gt;</operator><name>lvl</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>
<typedef>typedef <type><struct>struct <name>LoadF</name><block>{
<decl_stmt><decl><type><name>int</name></type> <name>extraline</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name><modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buff</name><index>[<expr><name>BUFSIZ</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type><name>LoadF</name>;</typedef>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>getF</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>void</name><modifier>*</modifier></type><name>ud</name></decl></parameter>,<parameter><decl><type><name>size_t</name><modifier>*</modifier></type><name>size</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>LoadF</name><modifier>*</modifier></type><name>lf</name><init>=<expr><operator>(</operator><name>LoadF</name><operator>*</operator><operator>)</operator><name>ud</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>L</name></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name><name>lf</name><operator>-&gt;</operator><name>extraline</name></name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><name><name>lf</name><operator>-&gt;</operator><name>extraline</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>size</name><operator>=</operator><literal type="number">1</literal></expr>;</expr_stmt>
<return>return<expr><literal type="string">"\n"</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><call><name>feof</name><argument_list>(<argument><expr><name><name>lf</name><operator>-&gt;</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content><return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>size</name><operator>=</operator><call><name>fread</name><argument_list>(<argument><expr><name><name>lf</name><operator>-&gt;</operator><name>buff</name></name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>lf</name><operator>-&gt;</operator><name>buff</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name><name>lf</name><operator>-&gt;</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return<expr><ternary><condition><expr><operator>(</operator><operator>*</operator><name>size</name><operator>&gt;</operator><literal type="number">0</literal><operator>)</operator></expr>?</condition><then><expr><name><name>lf</name><operator>-&gt;</operator><name>buff</name></name></expr></then><else>:<expr><name>NULL</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>errfile</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>what</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>fnameindex</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>serr</name><init>=<expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>filename</name><init>=<expr><call><name>lua_tostring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>fnameindex</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>lua_pushfstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"cannot %s %s: %s"</literal></expr></argument>,<argument><expr><name>what</name></expr></argument>,<argument><expr><name>filename</name></expr></argument>,<argument><expr><name>serr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_remove</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>fnameindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return<expr><operator>(</operator><literal type="number">5</literal><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>luaL_loadfile</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>LoadF</name></type> <name>lf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>,<decl><type ref="prev"/><name>readstatus</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>fnameindex</name><init>=<expr><call><name>lua_gettop</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>lf</name><operator>.</operator><name>extraline</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>filename</name><operator>==</operator><name>NULL</name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>lua_pushliteral</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"=stdin"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lf</name><operator>.</operator><name>f</name></name><operator>=</operator><name>stdin</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block>{<block_content>
<expr_stmt><expr><call><name>lua_pushfstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"@%s"</literal></expr></argument>,<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lf</name><operator>.</operator><name>f</name></name><operator>=</operator><call><name>fopen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>,<argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name><name>lf</name><operator>.</operator><name>f</name></name><operator>==</operator><name>NULL</name></expr>)</condition><block type="pseudo"><block_content><return>return <expr><call><name>errfile</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"open"</literal></expr></argument>,<argument><expr><name>fnameindex</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>c</name><operator>=</operator><call><name>getc</name><argument_list>(<argument><expr><name><name>lf</name><operator>.</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>c</name><operator>==</operator><literal type="char">'#'</literal></expr>)</condition><block>{<block_content>
<expr_stmt><expr><name><name>lf</name><operator>.</operator><name>extraline</name></name><operator>=</operator><literal type="number">1</literal></expr>;</expr_stmt>
<while>while<condition>(<expr><operator>(</operator><name>c</name><operator>=</operator><call><name>getc</name><argument_list>(<argument><expr><name><name>lf</name><operator>.</operator><name>f</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><name>EOF</name><operator>&amp;&amp;</operator><name>c</name><operator>!=</operator><literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></while>
<if_stmt><if>if<condition>(<expr><name>c</name><operator>==</operator><literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><name>c</name><operator>=</operator><call><name>getc</name><argument_list>(<argument><expr><name><name>lf</name><operator>.</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><name>c</name><operator>==</operator><literal type="string">"\033Lua"</literal><index>[<expr><literal type="number">0</literal></expr>]</index><operator>&amp;&amp;</operator><name>filename</name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><name><name>lf</name><operator>.</operator><name>f</name></name><operator>=</operator><call><name>freopen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>,<argument><expr><literal type="string">"rb"</literal></expr></argument>,<argument><expr><name><name>lf</name><operator>.</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name><name>lf</name><operator>.</operator><name>f</name></name><operator>==</operator><name>NULL</name></expr>)</condition><block type="pseudo"><block_content><return>return <expr><call><name>errfile</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"reopen"</literal></expr></argument>,<argument><expr><name>fnameindex</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<while>while<condition>(<expr><operator>(</operator><name>c</name><operator>=</operator><call><name>getc</name><argument_list>(<argument><expr><name><name>lf</name><operator>.</operator><name>f</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><name>EOF</name><operator>&amp;&amp;</operator><name>c</name><operator>!=</operator><literal type="string">"\033Lua"</literal><index>[<expr><literal type="number">0</literal></expr>]</index></expr>)</condition><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></while>
<expr_stmt><expr><name><name>lf</name><operator>.</operator><name>extraline</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>ungetc</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>lf</name><operator>.</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>status</name><operator>=</operator><call><name>lua_load</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>getF</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>lf</name></expr></argument>,<argument><expr><call><name>lua_tostring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>readstatus</name><operator>=</operator><call><name>ferror</name><argument_list>(<argument><expr><name><name>lf</name><operator>.</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>filename</name></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name><name>lf</name><operator>.</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><name>readstatus</name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>lua_settop</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>fnameindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>errfile</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"read"</literal></expr></argument>,<argument><expr><name>fnameindex</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>lua_remove</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>fnameindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>
<typedef>typedef <type><struct>struct <name>LoadS</name><block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>;</decl_stmt>
}</block></struct></type><name>LoadS</name>;</typedef>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>getS</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>void</name><modifier>*</modifier></type><name>ud</name></decl></parameter>,<parameter><decl><type><name>size_t</name><modifier>*</modifier></type><name>size</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>LoadS</name><modifier>*</modifier></type><name>ls</name><init>=<expr><operator>(</operator><name>LoadS</name><operator>*</operator><operator>)</operator><name>ud</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>L</name></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>size</name></name><operator>==</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content><return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>size</name><operator>=</operator><name><name>ls</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>size</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<return>return <expr><name><name>ls</name><operator>-&gt;</operator><name>s</name></name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>luaL_loadbuffer</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>buff</name></decl></parameter>,<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>LoadS</name></type> <name>ls</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>ls</name><operator>.</operator><name>s</name></name><operator>=</operator><name>buff</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ls</name><operator>.</operator><name>size</name></name><operator>=</operator><name>size</name></expr>;</expr_stmt>
<return>return <expr><call><name>lua_load</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>getS</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>ls</name></expr></argument>,<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name><modifier>*</modifier></type><name>l_alloc</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type><name>ud</name></decl></parameter>,<parameter><decl><type><name>void</name><modifier>*</modifier></type><name>ptr</name></decl></parameter>,<parameter><decl><type><name>size_t</name></type> <name>osize</name></decl></parameter>,<parameter><decl><type><name>size_t</name></type> <name>nsize</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>ud</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>osize</name></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>nsize</name><operator>==</operator><literal type="number">0</literal></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><call><name>realloc</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>,<argument><expr><name>nsize</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>panic</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>L</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"PANIC: unprotected error in call to Lua API (%s)\n"</literal></expr></argument>,
<argument><expr><call><name>lua_tostring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>lua_State</name><modifier>*</modifier></type><name>luaL_newstate</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name><init>=<expr><call><name>lua_newstate</name><argument_list>(<argument><expr><name>l_alloc</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>L</name></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><call><name>lua_atpanic</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>panic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>L</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>luaB_tonumber</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>base</name><init>=<expr><call><name>luaL_optint</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>,<argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>base</name><operator>==</operator><literal type="number">10</literal></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>luaL_checkany</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><call><name>lua_isnumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>lua_pushnumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>lua_tonumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<else>else<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>s1</name><init>=<expr><call><name>luaL_checkstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type><name>s2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>n</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaL_argcheck</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">2</literal><operator>&lt;=</operator><name>base</name><operator>&amp;&amp;</operator><name>base</name><operator>&lt;=</operator><literal type="number">36</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>,<argument><expr><literal type="string">"base out of range"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name><operator>=</operator><call><name>strtoul</name><argument_list>(<argument><expr><name>s1</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>s2</name></expr></argument>,<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>s1</name><operator>!=</operator><name>s2</name></expr>)</condition><block>{<block_content>
<while>while<condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>(</operator><operator>*</operator><name>s2</name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><name>s2</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
<if_stmt><if>if<condition>(<expr><operator>*</operator><name>s2</name><operator>==</operator><literal type="char">'\0'</literal></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>lua_pushnumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>(</operator><name>lua_Number</name><operator>)</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>lua_pushnil</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>luaB_error</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>level</name><init>=<expr><call><name>luaL_optint</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>lua_settop</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><call><name>lua_isstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>&amp;&amp;</operator><name>level</name><operator>&gt;</operator><literal type="number">0</literal></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>luaL_where</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_pushvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_concat</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>lua_error</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>luaB_setmetatable</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>t</name><init>=<expr><call><name>lua_type</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaL_checktype</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaL_argcheck</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>t</name><operator>==</operator><literal type="number">0</literal><operator>||</operator><name>t</name><operator>==</operator><literal type="number">5</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>,
<argument><expr><literal type="string">"nil or table expected"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><call><name>luaL_getmetafield</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="string">"__metatable"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaL_error</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"cannot change a protected metatable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>lua_settop</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_setmetatable</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>getfunc</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>opt</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><call><name>lua_isfunction</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><call><name>lua_pushvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block>{<block_content>
<decl_stmt><decl><type><name>lua_Debug</name></type> <name>ar</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>level</name><init>=<expr><ternary><condition><expr><name>opt</name></expr>?</condition><then><expr><call><name>luaL_optint</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></then><else>:<expr><call><name>luaL_checkint</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaL_argcheck</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>level</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="string">"level must be non-negative"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><call><name>lua_getstack</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>level</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>ar</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaL_argerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="string">"invalid level"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>lua_getinfo</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"f"</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>ar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><call><name>lua_isnil</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaL_error</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"no function environment for tail call at level %d"</literal></expr></argument>,
<argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>luaB_setfenv</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>luaL_checktype</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>getfunc</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_pushvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><call><name>lua_isnumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>&amp;&amp;</operator><call><name>lua_tonumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>lua_pushthread</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_insert</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_setfenv</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if>
<if type="elseif">else if<condition>(<expr><call><name>lua_iscfunction</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call><operator>||</operator><call><name>lua_setfenv</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaL_error</name><argument_list>(<argument><expr><name>L</name></expr></argument>,
<argument><expr><call><name>LUA_QL</name><argument_list>(<argument><expr><literal type="string">"setfenv"</literal></expr></argument>)</argument_list></call><literal type="string">" cannot change environment of given object"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>luaB_rawget</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>luaL_checktype</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaL_checkany</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_settop</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_rawget</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>luaB_type</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>luaL_checkany</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_pushstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>luaL_typename</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>luaB_next</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>luaL_checktype</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_settop</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><call><name>lua_next</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">2</literal></expr>;</return></block_content></block></if>
<else>else<block>{<block_content>
<expr_stmt><expr><call><name>lua_pushnil</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>luaB_pairs</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>luaL_checktype</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_pushvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>lua_upvalueindex</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_pushvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_pushnil</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">3</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ipairsaux</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name><init>=<expr><call><name>luaL_checkint</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaL_checktype</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_pushinteger</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_rawgeti</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return<expr><ternary><condition><expr><operator>(</operator><call><name>lua_isnil</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>?</condition><then><expr><literal type="number">0</literal></expr></then><else>:<expr><literal type="number">2</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>luaB_ipairs</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>luaL_checktype</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_pushvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>lua_upvalueindex</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_pushvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_pushinteger</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">3</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>load_aux</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name>status</name><operator>==</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
<else>else<block>{<block_content>
<expr_stmt><expr><call><name>lua_pushnil</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_insert</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">2</literal></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>luaB_loadstring</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>l</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>s</name><init>=<expr><call><name>luaL_checklstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>chunkname</name><init>=<expr><call><name>luaL_optstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>,<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>load_aux</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>luaL_loadbuffer</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>l</name></expr></argument>,<argument><expr><name>chunkname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>luaB_loadfile</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>fname</name><init>=<expr><call><name>luaL_optstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>load_aux</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>luaL_loadfile</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>luaB_assert</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>luaL_checkany</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>lua_toboolean</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>luaL_error</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"%s"</literal></expr></argument>,<argument><expr><call><name>luaL_optstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>,<argument><expr><literal type="string">"assertion failed!"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>lua_gettop</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>luaB_unpack</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>,<decl><type ref="prev"/><name>e</name></decl>,<decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaL_checktype</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name><operator>=</operator><call><name>luaL_optint</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>e</name><operator>=</operator><call><name>luaL_opt</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>luaL_checkint</name></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>,<argument><expr><call><name>luaL_getn</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>i</name><operator>&gt;</operator><name>e</name></expr>)</condition><block type="pseudo"><block_content><return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>n</name><operator>=</operator><name>e</name><operator>-</operator><name>i</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>n</name><operator>&lt;=</operator><literal type="number">0</literal><operator>||</operator><operator>!</operator><call><name>lua_checkstack</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>luaL_error</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"too many results to unpack"</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>lua_rawgeti</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while<condition>(<expr><name>i</name><operator>++</operator><operator>&lt;</operator><name>e</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>lua_rawgeti</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
<return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>luaB_pcall</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaL_checkany</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>status</name><operator>=</operator><call><name>lua_pcall</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>lua_gettop</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr></argument>,<argument><expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_pushboolean</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>(</operator><name>status</name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_insert</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>lua_gettop</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>luaB_newproxy</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>lua_settop</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_newuserdata</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><call><name>lua_toboolean</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
<if type="elseif">else if<condition>(<expr><call><name>lua_isboolean</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>lua_newtable</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_pushvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_pushboolean</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_rawset</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>lua_upvalueindex</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>validproxy</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><call><name>lua_getmetatable</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>lua_rawget</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>lua_upvalueindex</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>validproxy</name><operator>=</operator><call><name>lua_toboolean</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>luaL_argcheck</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>validproxy</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="string">"boolean or proxy expected"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_getmetatable</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>lua_setmetatable</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>luaL_Reg</name></type> <name><name>base_funcs</name><index>[]</index></name><init>=<expr><block>{
<expr><block>{<expr><literal type="string">"assert"</literal></expr>,<expr><name>luaB_assert</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"error"</literal></expr>,<expr><name>luaB_error</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"loadfile"</literal></expr>,<expr><name>luaB_loadfile</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"loadstring"</literal></expr>,<expr><name>luaB_loadstring</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"next"</literal></expr>,<expr><name>luaB_next</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"pcall"</literal></expr>,<expr><name>luaB_pcall</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"rawget"</literal></expr>,<expr><name>luaB_rawget</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"setfenv"</literal></expr>,<expr><name>luaB_setfenv</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"setmetatable"</literal></expr>,<expr><name>luaB_setmetatable</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"tonumber"</literal></expr>,<expr><name>luaB_tonumber</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"type"</literal></expr>,<expr><name>luaB_type</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"unpack"</literal></expr>,<expr><name>luaB_unpack</name></expr>}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>,<expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>void</name></type> <name>auxopen</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>name</name></decl></parameter>,
<parameter><decl><type><name>lua_CFunction</name></type> <name>f</name></decl></parameter>,<parameter><decl><type><name>lua_CFunction</name></type> <name>u</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>lua_pushcfunction</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_pushcclosure</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>f</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_setfield</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>,<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>base_open</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>lua_pushvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>(</operator><operator>-</operator><literal type="number">10002</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_setglobal</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"_G"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaL_register</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"_G"</literal></expr></argument>,<argument><expr><name>base_funcs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_pushliteral</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"Lua 5.1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_setglobal</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"_VERSION"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>auxopen</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"ipairs"</literal></expr></argument>,<argument><expr><name>luaB_ipairs</name></expr></argument>,<argument><expr><name>ipairsaux</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>auxopen</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"pairs"</literal></expr></argument>,<argument><expr><name>luaB_pairs</name></expr></argument>,<argument><expr><name>luaB_next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_createtable</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_pushvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_setmetatable</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_pushliteral</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"kv"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_setfield</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>,<argument><expr><literal type="string">"__mode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_pushcclosure</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>luaB_newproxy</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_setglobal</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"newproxy"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>luaopen_base</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>base_open</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>aux_getn</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>(luaL_checktype(L,n,5),luaL_getn(L,n))</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>int</name></type> <name>tinsert</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>e</name><init>=<expr><call><name>aux_getn</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pos</name></decl>;</decl_stmt>
<switch>switch<condition>(<expr><call><name>lua_gettop</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<case>case <expr><literal type="number">2</literal></expr>:</case><block>{<block_content>
<expr_stmt><expr><name>pos</name><operator>=</operator><name>e</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><literal type="number">3</literal></expr>:</case><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><name>pos</name><operator>=</operator><call><name>luaL_checkint</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>pos</name><operator>&gt;</operator><name>e</name></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><name>e</name><operator>=</operator><name>pos</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<for>for<control>(<init><expr><name>i</name><operator>=</operator><name>e</name></expr>;</init><condition><expr><name>i</name><operator>&gt;</operator><name>pos</name></expr>;</condition><incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
<expr_stmt><expr><call><name>lua_rawgeti</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_rawseti</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<break>break;</break>
</block_content>}</block>
<default>default:</default><block>{<block_content>
<return>return <expr><call><name>luaL_error</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"wrong number of arguments to "</literal><call><name>LUA_QL</name><argument_list>(<argument><expr><literal type="string">"insert"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>luaL_setn</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_rawseti</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>tremove</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>e</name><init>=<expr><call><name>aux_getn</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pos</name><init>=<expr><call><name>luaL_optint</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>,<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><operator>!</operator><operator>(</operator><literal type="number">1</literal><operator>&lt;=</operator><name>pos</name><operator>&amp;&amp;</operator><name>pos</name><operator>&lt;=</operator><name>e</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>luaL_setn</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>e</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_rawgeti</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for<control>(<init>;</init><condition><expr><name>pos</name><operator>&lt;</operator><name>e</name></expr>;</condition><incr><expr><name>pos</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
<expr_stmt><expr><call><name>lua_rawgeti</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>pos</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_rawseti</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>lua_pushnil</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_rawseti</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>addfield</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>luaL_Buffer</name><modifier>*</modifier></type><name>b</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>lua_rawgeti</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>lua_isstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaL_error</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"invalid value (%s) at index %d in table for "</literal>
<call><name>LUA_QL</name><argument_list>(<argument><expr><literal type="string">"concat"</literal></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>luaL_typename</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>luaL_addvalue</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>tconcat</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>luaL_Buffer</name></type> <name>b</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>lsep</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>,<decl><type ref="prev"/><name>last</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>sep</name><init>=<expr><call><name>luaL_optlstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>,<argument><expr><literal type="string">""</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>lsep</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaL_checktype</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name><operator>=</operator><call><name>luaL_optint</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>last</name><operator>=</operator><call><name>luaL_opt</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>luaL_checkint</name></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>,<argument><expr><call><name>luaL_getn</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaL_buffinit</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for<control>(<init>;</init><condition><expr><name>i</name><operator>&lt;</operator><name>last</name></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
<expr_stmt><expr><call><name>addfield</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaL_addlstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>,<argument><expr><name>sep</name></expr></argument>,<argument><expr><name>lsep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if<condition>(<expr><name>i</name><operator>==</operator><name>last</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>addfield</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>luaL_pushresult</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>set2</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>j</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>lua_rawseti</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_rawseti</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sort_comp</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>a</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>b</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>lua_isnil</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>lua_pushvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_pushvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>a</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_pushvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>b</name><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_call</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>res</name><operator>=</operator><call><name>lua_toboolean</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><call><name>lua_lessthan</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>a</name></expr></argument>,<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>auxsort</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>l</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>u</name></decl></parameter>)</parameter_list><block>{<block_content>
<while>while<condition>(<expr><name>l</name><operator>&lt;</operator><name>u</name></expr>)</condition><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>,<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>lua_rawgeti</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_rawgeti</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><call><name>sort_comp</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>set2</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>l</name></expr></argument>,<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if<condition>(<expr><name>u</name><operator>-</operator><name>l</name><operator>==</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content><break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>i</name><operator>=</operator><operator>(</operator><name>l</name><operator>+</operator><name>u</name><operator>)</operator><operator>/</operator><literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_rawgeti</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_rawgeti</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><call><name>sort_comp</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>set2</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>i</name></expr></argument>,<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block>{<block_content>
<expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_rawgeti</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><call><name>sort_comp</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>set2</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>i</name></expr></argument>,<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if<condition>(<expr><name>u</name><operator>-</operator><name>l</name><operator>==</operator><literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content><break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>lua_rawgeti</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_pushvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_rawgeti</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>u</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>set2</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>i</name></expr></argument>,<argument><expr><name>u</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name><operator>=</operator><name>l</name></expr>;</expr_stmt><expr_stmt><expr><name>j</name><operator>=</operator><name>u</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
<while>while<condition>(<expr><call><name>lua_rawgeti</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><operator>++</operator><name>i</name></expr></argument>)</argument_list></call></expr><operator>,</operator><expr><call><name>sort_comp</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name>i</name><operator>&gt;</operator><name>u</name></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><call><name>luaL_error</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"invalid order function for sorting"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<while>while<condition>(<expr><call><name>lua_rawgeti</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><operator>--</operator><name>j</name></expr></argument>)</argument_list></call></expr><operator>,</operator><expr><call><name>sort_comp</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">3</literal></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name>j</name><operator>&lt;</operator><name>l</name></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><call><name>luaL_error</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"invalid order function for sorting"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if<condition>(<expr><name>j</name><operator>&lt;</operator><name>i</name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>set2</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>i</name></expr></argument>,<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>lua_rawgeti</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>u</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_rawgeti</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>set2</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>u</name><operator>-</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>i</name><operator>-</operator><name>l</name><operator>&lt;</operator><name>u</name><operator>-</operator><name>i</name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><name>j</name><operator>=</operator><name>l</name></expr>;</expr_stmt><expr_stmt><expr><name>i</name><operator>=</operator><name>i</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt><expr_stmt><expr><name>l</name><operator>=</operator><name>i</name><operator>+</operator><literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block>{<block_content>
<expr_stmt><expr><name>j</name><operator>=</operator><name>i</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt><expr_stmt><expr><name>i</name><operator>=</operator><name>u</name></expr>;</expr_stmt><expr_stmt><expr><name>u</name><operator>=</operator><name>j</name><operator>-</operator><literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>auxsort</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>j</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sort</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>n</name><init>=<expr><call><name>aux_getn</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaL_checkstack</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">40</literal></expr></argument>,<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>lua_isnoneornil</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaL_checktype</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>,<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>lua_settop</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>auxsort</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>luaL_Reg</name></type> <name><name>tab_funcs</name><index>[]</index></name><init>=<expr><block>{
<expr><block>{<expr><literal type="string">"concat"</literal></expr>,<expr><name>tconcat</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"insert"</literal></expr>,<expr><name>tinsert</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"remove"</literal></expr>,<expr><name>tremove</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"sort"</literal></expr>,<expr><name>sort</name></expr>}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>,<expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>int</name></type> <name>luaopen_table</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>luaL_register</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"table"</literal></expr></argument>,<argument><expr><name>tab_funcs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name><modifier>*</modifier><specifier>const</specifier></type> <name><name>fnames</name><index>[]</index></name><init>=<expr><block>{<expr><literal type="string">"input"</literal></expr>,<expr><literal type="string">"output"</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pushresult</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>en</name><init>=<expr><name>errno</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>i</name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>lua_pushboolean</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if>
<else>else<block>{<block_content>
<expr_stmt><expr><call><name>lua_pushnil</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>filename</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>lua_pushfstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"%s: %s"</literal></expr></argument>,<argument><expr><name>filename</name></expr></argument>,<argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>en</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>lua_pushfstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"%s"</literal></expr></argument>,<argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>en</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>lua_pushinteger</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>en</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">3</literal></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fileerror</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>arg</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>lua_pushfstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"%s: %s"</literal></expr></argument>,<argument><expr><name>filename</name></expr></argument>,<argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaL_argerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>arg</name></expr></argument>,<argument><expr><call><name>lua_tostring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>tofilep</name><parameter_list>(<parameter><type><name>L</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((FILE**)luaL_checkudata(L,1,"FILE*"))</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>int</name></type> <name>io_type</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>void</name><modifier>*</modifier></type><name>ud</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaL_checkany</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ud</name><operator>=</operator><call><name>lua_touserdata</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_getfield</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>(</operator><operator>-</operator><literal type="number">10000</literal><operator>)</operator></expr></argument>,<argument><expr><literal type="string">"FILE*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>ud</name><operator>==</operator><name>NULL</name><operator>||</operator><operator>!</operator><call><name>lua_getmetatable</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>||</operator><operator>!</operator><call><name>lua_rawequal</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>lua_pushnil</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if<condition>(<expr><operator>*</operator><operator>(</operator><operator>(</operator><name>FILE</name><operator>*</operator><operator>*</operator><operator>)</operator><name>ud</name><operator>)</operator><operator>==</operator><name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>lua_pushliteral</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"closed file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>lua_pushliteral</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>FILE</name><modifier>*</modifier></type><name>tofile</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>FILE</name><modifier>*</modifier><modifier>*</modifier></type><name>f</name><init>=<expr><call><name>tofilep</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><operator>*</operator><name>f</name><operator>==</operator><name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaL_error</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"attempt to use a closed file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return<expr><operator>*</operator><name>f</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>FILE</name><modifier>*</modifier><modifier>*</modifier></type><name>newfile</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>FILE</name><modifier>*</modifier><modifier>*</modifier></type><name>pf</name><init>=<expr><operator>(</operator><name>FILE</name><operator>*</operator><operator>*</operator><operator>)</operator><call><name>lua_newuserdata</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FILE</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>pf</name><operator>=</operator><name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaL_getmetatable</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"FILE*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_setmetatable</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>pf</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>io_noclose</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>lua_pushnil</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_pushliteral</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"cannot close standard file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">2</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>io_pclose</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>FILE</name><modifier>*</modifier><modifier>*</modifier></type><name>p</name><init>=<expr><call><name>tofilep</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ok</name><init>=<expr><call><name>lua_pclose</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>p</name><operator>=</operator><name>NULL</name></expr>;</expr_stmt>
<return>return <expr><call><name>pushresult</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>ok</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>io_fclose</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>FILE</name><modifier>*</modifier><modifier>*</modifier></type><name>p</name><init>=<expr><call><name>tofilep</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ok</name><init>=<expr><operator>(</operator><call><name>fclose</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>p</name><operator>=</operator><name>NULL</name></expr>;</expr_stmt>
<return>return <expr><call><name>pushresult</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>ok</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>aux_close</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>lua_getfenv</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_getfield</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="string">"__close"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return<expr><operator>(</operator><call><name>lua_tocfunction</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>(</operator><name>L</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>io_close</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><call><name>lua_isnone</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>lua_rawgeti</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>(</operator><operator>-</operator><literal type="number">10001</literal><operator>)</operator></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>tofile</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>aux_close</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>io_gc</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>FILE</name><modifier>*</modifier></type><name>f</name><init>=<expr><operator>*</operator><call><name>tofilep</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>f</name><operator>!=</operator><name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>aux_close</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>io_open</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>filename</name><init>=<expr><call><name>luaL_checkstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>mode</name><init>=<expr><call><name>luaL_optstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>,<argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name><modifier>*</modifier><modifier>*</modifier></type><name>pf</name><init>=<expr><call><name>newfile</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>pf</name><operator>=</operator><call><name>fopen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>,<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return<expr><ternary><condition><expr><operator>(</operator><operator>*</operator><name>pf</name><operator>==</operator><name>NULL</name><operator>)</operator></expr>?</condition><then><expr><call><name>pushresult</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr></then><else>:<expr><literal type="number">1</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>FILE</name><modifier>*</modifier></type><name>getiofile</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>findex</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>FILE</name><modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>lua_rawgeti</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>(</operator><operator>-</operator><literal type="number">10001</literal><operator>)</operator></expr></argument>,<argument><expr><name>findex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>f</name><operator>=</operator><operator>*</operator><operator>(</operator><name>FILE</name><operator>*</operator><operator>*</operator><operator>)</operator><call><name>lua_touserdata</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>f</name><operator>==</operator><name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaL_error</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"standard %s file is closed"</literal></expr></argument>,<argument><expr><name><name>fnames</name><index>[<expr><name>findex</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>f</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>g_iofile</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>f</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>mode</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>lua_isnoneornil</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>filename</name><init>=<expr><call><name>lua_tostring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>filename</name></expr>)</condition><block>{<block_content>
<decl_stmt><decl><type><name>FILE</name><modifier>*</modifier><modifier>*</modifier></type><name>pf</name><init>=<expr><call><name>newfile</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>pf</name><operator>=</operator><call><name>fopen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>,<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><operator>*</operator><name>pf</name><operator>==</operator><name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fileerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if>
<else>else<block>{<block_content>
<expr_stmt><expr><call><name>tofile</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_pushvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>lua_rawseti</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>(</operator><operator>-</operator><literal type="number">10001</literal><operator>)</operator></expr></argument>,<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>lua_rawgeti</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>(</operator><operator>-</operator><literal type="number">10001</literal><operator>)</operator></expr></argument>,<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>io_input</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<return>return <expr><call><name>g_iofile</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>io_output</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<return>return <expr><call><name>g_iofile</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>,<argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>io_readline</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list>;</function_decl>
<function><type><specifier>static</specifier> <name>void</name></type> <name>aux_lines</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>toclose</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>lua_pushvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_pushboolean</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>toclose</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_pushcclosure</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>io_readline</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>f_lines</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>tofile</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>aux_lines</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>io_lines</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><call><name>lua_isnoneornil</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>lua_rawgeti</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>(</operator><operator>-</operator><literal type="number">10001</literal><operator>)</operator></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>f_lines</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if>
<else>else<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>filename</name><init>=<expr><call><name>luaL_checkstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name><modifier>*</modifier><modifier>*</modifier></type><name>pf</name><init>=<expr><call><name>newfile</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>pf</name><operator>=</operator><call><name>fopen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>,<argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><operator>*</operator><name>pf</name><operator>==</operator><name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fileerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>aux_lines</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>lua_gettop</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>read_number</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>FILE</name><modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>lua_Number</name></type> <name>d</name></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><call><name>fscanf</name><argument_list>(<argument><expr><name>f</name></expr></argument>,<argument><expr><literal type="string">"%lf"</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>d</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">1</literal></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>lua_pushnumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if>
<else>else<block>{<block_content>
<expr_stmt><expr><call><name>lua_pushnil</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>test_eof</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>FILE</name><modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>c</name><init>=<expr><call><name>getc</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ungetc</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_pushlstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return<expr><operator>(</operator><name>c</name><operator>!=</operator><name>EOF</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>read_line</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>FILE</name><modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>luaL_Buffer</name></type> <name>b</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaL_buffinit</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>l</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type><name>p</name><init>=<expr><call><name>luaL_prepbuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><call><name>fgets</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>BUFSIZ</name></expr></argument>,<argument><expr><name>f</name></expr></argument>)</argument_list></call><operator>==</operator><name>NULL</name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>luaL_pushresult</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return<expr><operator>(</operator><call><name>lua_objlen</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>&gt;</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>l</name><operator>=</operator><call><name>strlen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>l</name><operator>==</operator><literal type="number">0</literal><operator>||</operator><name><name>p</name><index>[<expr><name>l</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>!=</operator><literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaL_addsize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>,<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block>{<block_content>
<expr_stmt><expr><call><name>luaL_addsize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>,<argument><expr><name>l</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaL_pushresult</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>read_chars</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>FILE</name><modifier>*</modifier></type><name>f</name></decl></parameter>,<parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>rlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>nr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>luaL_Buffer</name></type> <name>b</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaL_buffinit</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rlen</name><operator>=</operator><name>BUFSIZ</name></expr>;</expr_stmt>
<do>do<block>{<block_content>
<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type><name>p</name><init>=<expr><call><name>luaL_prepbuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>rlen</name><operator>&gt;</operator><name>n</name></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><name>rlen</name><operator>=</operator><name>n</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>nr</name><operator>=</operator><call><name>fread</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>rlen</name></expr></argument>,<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaL_addsize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>,<argument><expr><name>nr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name><operator>-=</operator><name>nr</name></expr>;</expr_stmt>
</block_content>}</block>while<condition>(<expr><name>n</name><operator>&gt;</operator><literal type="number">0</literal><operator>&amp;&amp;</operator><name>nr</name><operator>==</operator><name>rlen</name></expr>)</condition>;</do>
<expr_stmt><expr><call><name>luaL_pushresult</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return<expr><operator>(</operator><name>n</name><operator>==</operator><literal type="number">0</literal><operator>||</operator><call><name>lua_objlen</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>&gt;</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>g_read</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>FILE</name><modifier>*</modifier></type><name>f</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>first</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>nargs</name><init>=<expr><call><name>lua_gettop</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>success</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>clearerr</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>nargs</name><operator>==</operator><literal type="number">0</literal></expr>)</condition><block>{<block_content>
<expr_stmt><expr><name>success</name><operator>=</operator><call><name>read_line</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name><operator>=</operator><name>first</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block>{<block_content>
<expr_stmt><expr><call><name>luaL_checkstack</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>nargs</name><operator>+</operator><literal type="number">20</literal></expr></argument>,<argument><expr><literal type="string">"too many arguments"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>success</name><operator>=</operator><literal type="number">1</literal></expr>;</expr_stmt>
<for>for<control>(<init><expr><name>n</name><operator>=</operator><name>first</name></expr>;</init><condition><expr><name>nargs</name><operator>--</operator><operator>&amp;&amp;</operator><name>success</name></expr>;</condition><incr><expr><name>n</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
<if_stmt><if>if<condition>(<expr><call><name>lua_type</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">3</literal></expr>)</condition><block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>l</name><init>=<expr><operator>(</operator><name>size_t</name><operator>)</operator><call><name>lua_tointeger</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>success</name><operator>=</operator><ternary><condition><expr><operator>(</operator><name>l</name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr>?</condition><then><expr><call><name>test_eof</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr></then><else>:<expr><call><name>read_chars</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>f</name></expr></argument>,<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>p</name><init>=<expr><call><name>lua_tostring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaL_argcheck</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>p</name><operator>&amp;&amp;</operator><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'*'</literal></expr></argument>,<argument><expr><name>n</name></expr></argument>,<argument><expr><literal type="string">"invalid option"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch<condition>(<expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition><block>{<block_content>
<case>case<expr><literal type="char">'n'</literal></expr>:</case>
<expr_stmt><expr><name>success</name><operator>=</operator><call><name>read_number</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case<expr><literal type="char">'l'</literal></expr>:</case>
<expr_stmt><expr><name>success</name><operator>=</operator><call><name>read_line</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case<expr><literal type="char">'a'</literal></expr>:</case>
<expr_stmt><expr><call><name>read_chars</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>f</name></expr></argument>,<argument><expr><operator>~</operator><operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>success</name><operator>=</operator><literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<return>return <expr><call><name>luaL_argerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>n</name></expr></argument>,<argument><expr><literal type="string">"invalid format"</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if<condition>(<expr><call><name>ferror</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>pushresult</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><operator>!</operator><name>success</name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_pushnil</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>n</name><operator>-</operator><name>first</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>io_read</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<return>return <expr><call><name>g_read</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>getiofile</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>f_read</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<return>return <expr><call><name>g_read</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>tofile</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>io_readline</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>FILE</name><modifier>*</modifier></type><name>f</name><init>=<expr><operator>*</operator><operator>(</operator><name>FILE</name><operator>*</operator><operator>*</operator><operator>)</operator><call><name>lua_touserdata</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>lua_upvalueindex</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sucess</name></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>f</name><operator>==</operator><name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaL_error</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"file is already closed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>sucess</name><operator>=</operator><call><name>read_line</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><call><name>ferror</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>luaL_error</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"%s"</literal></expr></argument>,<argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><name>sucess</name></expr>)</condition><block type="pseudo"><block_content><return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
<else>else<block>{<block_content>
<if_stmt><if>if<condition>(<expr><call><name>lua_toboolean</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>lua_upvalueindex</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>lua_settop</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_pushvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>lua_upvalueindex</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>aux_close</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>g_write</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>FILE</name><modifier>*</modifier></type><name>f</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>arg</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>nargs</name><init>=<expr><call><name>lua_gettop</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>status</name><init>=<expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<for>for<control>(<init>;</init><condition><expr><name>nargs</name><operator>--</operator></expr>;</condition><incr><expr><name>arg</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
<if_stmt><if>if<condition>(<expr><call><name>lua_type</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>arg</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">3</literal></expr>)</condition><block>{<block_content>
<expr_stmt><expr><name>status</name><operator>=</operator><name>status</name><operator>&amp;&amp;</operator>
<call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>,<argument><expr><literal type="string">"%.14g"</literal></expr></argument>,<argument><expr><call><name>lua_tonumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>&gt;</operator><literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>l</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>s</name><init>=<expr><call><name>luaL_checklstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>arg</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>status</name><operator>=</operator><name>status</name><operator>&amp;&amp;</operator><operator>(</operator><call><name>fwrite</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>l</name></expr></argument>,<argument><expr><name>f</name></expr></argument>)</argument_list></call><operator>==</operator><name>l</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
<return>return <expr><call><name>pushresult</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>status</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>io_write</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<return>return <expr><call><name>g_write</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>getiofile</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>f_write</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<return>return <expr><call><name>g_write</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>tofile</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>io_flush</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<return>return <expr><call><name>pushresult</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>fflush</name><argument_list>(<argument><expr><call><name>getiofile</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>f_flush</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<return>return <expr><call><name>pushresult</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>fflush</name><argument_list>(<argument><expr><call><name>tofile</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>luaL_Reg</name></type> <name><name>iolib</name><index>[]</index></name><init>=<expr><block>{
<expr><block>{<expr><literal type="string">"close"</literal></expr>,<expr><name>io_close</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"flush"</literal></expr>,<expr><name>io_flush</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"input"</literal></expr>,<expr><name>io_input</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"lines"</literal></expr>,<expr><name>io_lines</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"open"</literal></expr>,<expr><name>io_open</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"output"</literal></expr>,<expr><name>io_output</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"read"</literal></expr>,<expr><name>io_read</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"type"</literal></expr>,<expr><name>io_type</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"write"</literal></expr>,<expr><name>io_write</name></expr>}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>,<expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>luaL_Reg</name></type> <name><name>flib</name><index>[]</index></name><init>=<expr><block>{
<expr><block>{<expr><literal type="string">"close"</literal></expr>,<expr><name>io_close</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"flush"</literal></expr>,<expr><name>f_flush</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"lines"</literal></expr>,<expr><name>f_lines</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"read"</literal></expr>,<expr><name>f_read</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"write"</literal></expr>,<expr><name>f_write</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"__gc"</literal></expr>,<expr><name>io_gc</name></expr>}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>,<expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>void</name></type> <name>createmeta</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>luaL_newmetatable</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"FILE*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_pushvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_setfield</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>,<argument><expr><literal type="string">"__index"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaL_register</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>flib</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>createstdfile</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>FILE</name><modifier>*</modifier></type><name>f</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>k</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>fname</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><operator>*</operator><call><name>newfile</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>=</operator><name>f</name></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>k</name><operator>&gt;</operator><literal type="number">0</literal></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>lua_pushvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_rawseti</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>(</operator><operator>-</operator><literal type="number">10001</literal><operator>)</operator></expr></argument>,<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>lua_pushvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_setfenv</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_setfield</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">3</literal></expr></argument>,<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>newfenv</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>lua_CFunction</name></type> <name>cls</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>lua_createtable</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_pushcfunction</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>cls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_setfield</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>,<argument><expr><literal type="string">"__close"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>luaopen_io</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>createmeta</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>newfenv</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>io_fclose</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_replace</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>(</operator><operator>-</operator><literal type="number">10001</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaL_register</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"io"</literal></expr></argument>,<argument><expr><name>iolib</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>newfenv</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>io_noclose</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>createstdfile</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>stdin</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="string">"stdin"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>createstdfile</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>stdout</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>,<argument><expr><literal type="string">"stdout"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>createstdfile</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="string">"stderr"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_getfield</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="string">"popen"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>newfenv</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>io_pclose</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_setfenv</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>os_pushresult</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>en</name><init>=<expr><name>errno</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>i</name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>lua_pushboolean</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if>
<else>else<block>{<block_content>
<expr_stmt><expr><call><name>lua_pushnil</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_pushfstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"%s: %s"</literal></expr></argument>,<argument><expr><name>filename</name></expr></argument>,<argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>en</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_pushinteger</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>en</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">3</literal></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>os_remove</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>filename</name><init>=<expr><call><name>luaL_checkstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>os_pushresult</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>remove</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr></argument>,<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>os_exit</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><call><name>luaL_optint</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>EXIT_SUCCESS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>luaL_Reg</name></type> <name><name>syslib</name><index>[]</index></name><init>=<expr><block>{
<expr><block>{<expr><literal type="string">"exit"</literal></expr>,<expr><name>os_exit</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"remove"</literal></expr>,<expr><name>os_remove</name></expr>}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>,<expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>int</name></type> <name>luaopen_os</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>luaL_register</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"os"</literal></expr></argument>,<argument><expr><name>syslib</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>uchar</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>((unsigned char)(c))</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>ptrdiff_t</name></type> <name>posrelat</name><parameter_list>(<parameter><decl><type><name>ptrdiff_t</name></type> <name>pos</name></decl></parameter>,<parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name>pos</name><operator>&lt;</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><name>pos</name><operator>+=</operator><operator>(</operator><name>ptrdiff_t</name><operator>)</operator><name>len</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return<expr><ternary><condition><expr><operator>(</operator><name>pos</name><operator>&gt;=</operator><literal type="number">0</literal><operator>)</operator></expr>?</condition><then><expr><name>pos</name></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>str_sub</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>l</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>s</name><init>=<expr><call><name>luaL_checklstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>start</name><init>=<expr><call><name>posrelat</name><argument_list>(<argument><expr><call><name>luaL_checkinteger</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>end</name><init>=<expr><call><name>posrelat</name><argument_list>(<argument><expr><call><name>luaL_optinteger</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>start</name><operator>&lt;</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><name>start</name><operator>=</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><name>end</name><operator>&gt;</operator><operator>(</operator><name>ptrdiff_t</name><operator>)</operator><name>l</name></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><name>end</name><operator>=</operator><operator>(</operator><name>ptrdiff_t</name><operator>)</operator><name>l</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><name>start</name><operator>&lt;=</operator><name>end</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>lua_pushlstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>s</name><operator>+</operator><name>start</name><operator>-</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>end</name><operator>-</operator><name>start</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>lua_pushliteral</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>str_lower</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>l</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>luaL_Buffer</name></type> <name>b</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>s</name><init>=<expr><call><name>luaL_checklstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaL_buffinit</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init><condition><expr><name>i</name><operator>&lt;</operator><name>l</name></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaL_addchar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>,<argument><expr><call><name>tolower</name><argument_list>(<argument><expr><call><name>uchar</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>luaL_pushresult</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>str_upper</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>l</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>luaL_Buffer</name></type> <name>b</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>s</name><init>=<expr><call><name>luaL_checklstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaL_buffinit</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init><condition><expr><name>i</name><operator>&lt;</operator><name>l</name></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaL_addchar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>,<argument><expr><call><name>toupper</name><argument_list>(<argument><expr><call><name>uchar</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>luaL_pushresult</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>str_rep</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>l</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>luaL_Buffer</name></type> <name>b</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>s</name><init>=<expr><call><name>luaL_checklstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name><init>=<expr><call><name>luaL_checkint</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaL_buffinit</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while<condition>(<expr><name>n</name><operator>--</operator><operator>&gt;</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaL_addlstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
<expr_stmt><expr><call><name>luaL_pushresult</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>str_byte</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>l</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>s</name><init>=<expr><call><name>luaL_checklstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>posi</name><init>=<expr><call><name>posrelat</name><argument_list>(<argument><expr><call><name>luaL_optinteger</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>pose</name><init>=<expr><call><name>posrelat</name><argument_list>(<argument><expr><call><name>luaL_optinteger</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>,<argument><expr><name>posi</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>,<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>posi</name><operator>&lt;=</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><name>posi</name><operator>=</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><operator>(</operator><name>size_t</name><operator>)</operator><name>pose</name><operator>&gt;</operator><name>l</name></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><name>pose</name><operator>=</operator><name>l</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><name>posi</name><operator>&gt;</operator><name>pose</name></expr>)</condition><block type="pseudo"><block_content><return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>n</name><operator>=</operator><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pose</name><operator>-</operator><name>posi</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>posi</name><operator>+</operator><name>n</name><operator>&lt;=</operator><name>pose</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaL_error</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"string slice too long"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>luaL_checkstack</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>n</name></expr></argument>,<argument><expr><literal type="string">"string slice too long"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init><condition><expr><name>i</name><operator>&lt;</operator><name>n</name></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>lua_pushinteger</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>uchar</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><name>posi</name><operator>+</operator><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>str_char</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>n</name><init>=<expr><call><name>lua_gettop</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>luaL_Buffer</name></type> <name>b</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaL_buffinit</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init><condition><expr><name>i</name><operator>&lt;=</operator><name>n</name></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>c</name><init>=<expr><call><name>luaL_checkint</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaL_argcheck</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>uchar</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call><operator>==</operator><name>c</name></expr></argument>,<argument><expr><name>i</name></expr></argument>,<argument><expr><literal type="string">"invalid value"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaL_addchar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>,<argument><expr><call><name>uchar</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>luaL_pushresult</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<typedef>typedef <type><struct>struct <name>MatchState</name><block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>src_init</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>src_end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>level</name></decl>;</decl_stmt>
<struct>struct<block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>init</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>len</name></decl>;</decl_stmt>
}</block><decl><name><name>capture</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</struct>
}</block></struct></type><name>MatchState</name>;</typedef>
<function><type><specifier>static</specifier> <name>int</name></type> <name>check_capture</name><parameter_list>(<parameter><decl><type><name>MatchState</name><modifier>*</modifier></type><name>ms</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>l</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><name>l</name><operator>-=</operator><literal type="char">'1'</literal></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>l</name><operator>&lt;</operator><literal type="number">0</literal><operator>||</operator><name>l</name><operator>&gt;=</operator><name><name>ms</name><operator>-&gt;</operator><name>level</name></name><operator>||</operator><name><name>ms</name><operator>-&gt;</operator><name>capture</name><index>[<expr><name>l</name></expr>]</index></name><operator>.</operator><name>len</name><operator>==</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>luaL_error</name><argument_list>(<argument><expr><name><name>ms</name><operator>-&gt;</operator><name>L</name></name></expr></argument>,<argument><expr><literal type="string">"invalid capture index"</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>l</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>capture_to_close</name><parameter_list>(<parameter><decl><type><name>MatchState</name><modifier>*</modifier></type><name>ms</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>level</name><init>=<expr><name><name>ms</name><operator>-&gt;</operator><name>level</name></name></expr></init></decl>;</decl_stmt>
<for>for<control>(<init><expr><name>level</name><operator>--</operator></expr>;</init><condition><expr><name>level</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition><incr><expr><name>level</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if<condition>(<expr><name><name>ms</name><operator>-&gt;</operator><name>capture</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>len</name><operator>==</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content><return>return <expr><name>level</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>
<return>return <expr><call><name>luaL_error</name><argument_list>(<argument><expr><name><name>ms</name><operator>-&gt;</operator><name>L</name></name></expr></argument>,<argument><expr><literal type="string">"invalid pattern capture"</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>classend</name><parameter_list>(<parameter><decl><type><name>MatchState</name><modifier>*</modifier></type><name>ms</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
<switch>switch<condition>(<expr><operator>*</operator><name>p</name><operator>++</operator></expr>)</condition><block>{<block_content>
<case>case<expr><literal type="char">'%'</literal></expr>:</case><block>{<block_content>
<if_stmt><if>if<condition>(<expr><operator>*</operator><name>p</name><operator>==</operator><literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaL_error</name><argument_list>(<argument><expr><name><name>ms</name><operator>-&gt;</operator><name>L</name></name></expr></argument>,<argument><expr><literal type="string">"malformed pattern (ends with "</literal><call><name>LUA_QL</name><argument_list>(<argument><expr><literal type="string">"%%"</literal></expr></argument>)</argument_list></call><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>p</name><operator>+</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block>
<case>case<expr><literal type="char">'['</literal></expr>:</case><block>{<block_content>
<if_stmt><if>if<condition>(<expr><operator>*</operator><name>p</name><operator>==</operator><literal type="char">'^'</literal></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<do>do<block>{<block_content>
<if_stmt><if>if<condition>(<expr><operator>*</operator><name>p</name><operator>==</operator><literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaL_error</name><argument_list>(<argument><expr><name><name>ms</name><operator>-&gt;</operator><name>L</name></name></expr></argument>,<argument><expr><literal type="string">"malformed pattern (missing "</literal><call><name>LUA_QL</name><argument_list>(<argument><expr><literal type="string">"]"</literal></expr></argument>)</argument_list></call><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><operator>*</operator><operator>(</operator><name>p</name><operator>++</operator><operator>)</operator><operator>==</operator><literal type="char">'%'</literal><operator>&amp;&amp;</operator><operator>*</operator><name>p</name><operator>!=</operator><literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>while<condition>(<expr><operator>*</operator><name>p</name><operator>!=</operator><literal type="char">']'</literal></expr>)</condition>;</do>
<return>return <expr><name>p</name><operator>+</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block>
<default>default:</default><block>{<block_content>
<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block>
</block_content>}</block></switch>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>match_class</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>cl</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
<switch>switch<condition>(<expr><call><name>tolower</name><argument_list>(<argument><expr><name>cl</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<case>case<expr><literal type="char">'a'</literal></expr>:</case><expr_stmt><expr><name>res</name><operator>=</operator><call><name>isalpha</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt><break>break;</break>
<case>case<expr><literal type="char">'c'</literal></expr>:</case><expr_stmt><expr><name>res</name><operator>=</operator><call><name>iscntrl</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt><break>break;</break>
<case>case<expr><literal type="char">'d'</literal></expr>:</case><expr_stmt><expr><name>res</name><operator>=</operator><call><name>isdigit</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt><break>break;</break>
<case>case<expr><literal type="char">'l'</literal></expr>:</case><expr_stmt><expr><name>res</name><operator>=</operator><call><name>islower</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt><break>break;</break>
<case>case<expr><literal type="char">'p'</literal></expr>:</case><expr_stmt><expr><name>res</name><operator>=</operator><call><name>ispunct</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt><break>break;</break>
<case>case<expr><literal type="char">'s'</literal></expr>:</case><expr_stmt><expr><name>res</name><operator>=</operator><call><name>isspace</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt><break>break;</break>
<case>case<expr><literal type="char">'u'</literal></expr>:</case><expr_stmt><expr><name>res</name><operator>=</operator><call><name>isupper</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt><break>break;</break>
<case>case<expr><literal type="char">'w'</literal></expr>:</case><expr_stmt><expr><name>res</name><operator>=</operator><call><name>isalnum</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt><break>break;</break>
<case>case<expr><literal type="char">'x'</literal></expr>:</case><expr_stmt><expr><name>res</name><operator>=</operator><call><name>isxdigit</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt><break>break;</break>
<case>case<expr><literal type="char">'z'</literal></expr>:</case><expr_stmt><expr><name>res</name><operator>=</operator><operator>(</operator><name>c</name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt><break>break;</break>
<default>default:</default><return>return<expr><operator>(</operator><name>cl</name><operator>==</operator><name>c</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
<return>return<expr><operator>(</operator><ternary><condition><expr><call><name>islower</name><argument_list>(<argument><expr><name>cl</name></expr></argument>)</argument_list></call></expr>?</condition><then><expr><name>res</name></expr></then><else>:<expr><operator>!</operator><name>res</name></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>matchbracketclass</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>p</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>ec</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>sig</name><init>=<expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><operator>*</operator><operator>(</operator><name>p</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>==</operator><literal type="char">'^'</literal></expr>)</condition><block>{<block_content>
<expr_stmt><expr><name>sig</name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<while>while<condition>(<expr><operator>++</operator><name>p</name><operator>&lt;</operator><name>ec</name></expr>)</condition><block>{<block_content>
<if_stmt><if>if<condition>(<expr><operator>*</operator><name>p</name><operator>==</operator><literal type="char">'%'</literal></expr>)</condition><block>{<block_content>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><call><name>match_class</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>uchar</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>sig</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if<condition>(<expr><operator>(</operator><operator>*</operator><operator>(</operator><name>p</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>==</operator><literal type="char">'-'</literal><operator>)</operator><operator>&amp;&amp;</operator><operator>(</operator><name>p</name><operator>+</operator><literal type="number">2</literal><operator>&lt;</operator><name>ec</name><operator>)</operator></expr>)</condition><block>{<block_content>
<expr_stmt><expr><name>p</name><operator>+=</operator><literal type="number">2</literal></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><call><name>uchar</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>p</name><operator>-</operator><literal type="number">2</literal><operator>)</operator></expr></argument>)</argument_list></call><operator>&lt;=</operator><name>c</name><operator>&amp;&amp;</operator><name>c</name><operator>&lt;=</operator><call><name>uchar</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>sig</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if<condition>(<expr><call><name>uchar</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call><operator>==</operator><name>c</name></expr>)</condition><block type="pseudo"><block_content><return>return <expr><name>sig</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></while>
<return>return<expr><operator>!</operator><name>sig</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>singlematch</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>p</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>ep</name></decl></parameter>)</parameter_list><block>{<block_content>
<switch>switch<condition>(<expr><operator>*</operator><name>p</name></expr>)</condition><block>{<block_content>
<case>case<expr><literal type="char">'.'</literal></expr>:</case><return>return <expr><literal type="number">1</literal></expr>;</return>
<case>case<expr><literal type="char">'%'</literal></expr>:</case><return>return <expr><call><name>match_class</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>uchar</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>p</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<case>case<expr><literal type="char">'['</literal></expr>:</case><return>return <expr><call><name>matchbracketclass</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>p</name></expr></argument>,<argument><expr><name>ep</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
<default>default:</default><return>return<expr><operator>(</operator><call><name>uchar</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call><operator>==</operator><name>c</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>match</name><parameter_list>(<parameter><decl><type><name>MatchState</name><modifier>*</modifier></type><name>ms</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>s</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>;</function_decl>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>matchbalance</name><parameter_list>(<parameter><decl><type><name>MatchState</name><modifier>*</modifier></type><name>ms</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><operator>*</operator><name>p</name><operator>==</operator><literal type="number">0</literal><operator>||</operator><operator>*</operator><operator>(</operator><name>p</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaL_error</name><argument_list>(<argument><expr><name><name>ms</name><operator>-&gt;</operator><name>L</name></name></expr></argument>,<argument><expr><literal type="string">"unbalanced pattern"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><operator>*</operator><name>s</name><operator>!=</operator><operator>*</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content><return>return <expr><name>NULL</name></expr>;</return></block_content></block></if>
<else>else<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>b</name><init>=<expr><operator>*</operator><name>p</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>e</name><init>=<expr><operator>*</operator><operator>(</operator><name>p</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cont</name><init>=<expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<while>while<condition>(<expr><operator>++</operator><name>s</name><operator>&lt;</operator><name><name>ms</name><operator>-&gt;</operator><name>src_end</name></name></expr>)</condition><block>{<block_content>
<if_stmt><if>if<condition>(<expr><operator>*</operator><name>s</name><operator>==</operator><name>e</name></expr>)</condition><block>{<block_content>
<if_stmt><if>if<condition>(<expr><operator>--</operator><name>cont</name><operator>==</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content><return>return <expr><name>s</name><operator>+</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if<condition>(<expr><operator>*</operator><name>s</name><operator>==</operator><name>b</name></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><name>cont</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></while>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>max_expand</name><parameter_list>(<parameter><decl><type><name>MatchState</name><modifier>*</modifier></type><name>ms</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>p</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>ep</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>i</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<while>while<condition>(<expr><operator>(</operator><name>s</name><operator>+</operator><name>i</name><operator>)</operator><operator>&lt;</operator><name><name>ms</name><operator>-&gt;</operator><name>src_end</name></name><operator>&amp;&amp;</operator><call><name>singlematch</name><argument_list>(<argument><expr><call><name>uchar</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>s</name><operator>+</operator><name>i</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>p</name></expr></argument>,<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
<while>while<condition>(<expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr>)</condition><block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>res</name><init>=<expr><call><name>match</name><argument_list>(<argument><expr><name>ms</name></expr></argument>,<argument><expr><operator>(</operator><name>s</name><operator>+</operator><name>i</name><operator>)</operator></expr></argument>,<argument><expr><name>ep</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>res</name></expr>)</condition><block type="pseudo"><block_content><return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>i</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>min_expand</name><parameter_list>(<parameter><decl><type><name>MatchState</name><modifier>*</modifier></type><name>ms</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>p</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>ep</name></decl></parameter>)</parameter_list><block>{<block_content>
<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>res</name><init>=<expr><call><name>match</name><argument_list>(<argument><expr><name>ms</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>ep</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>res</name><operator>!=</operator><name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>res</name></expr>;</return></block_content></block></if>
<if type="elseif">else if<condition>(<expr><name>s</name><operator>&lt;</operator><name><name>ms</name><operator>-&gt;</operator><name>src_end</name></name><operator>&amp;&amp;</operator><call><name>singlematch</name><argument_list>(<argument><expr><call><name>uchar</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>p</name></expr></argument>,<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>start_capture</name><parameter_list>(<parameter><decl><type><name>MatchState</name><modifier>*</modifier></type><name>ms</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>p</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>what</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>level</name><init>=<expr><name><name>ms</name><operator>-&gt;</operator><name>level</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>level</name><operator>&gt;=</operator><literal type="number">32</literal></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><call><name>luaL_error</name><argument_list>(<argument><expr><name><name>ms</name><operator>-&gt;</operator><name>L</name></name></expr></argument>,<argument><expr><literal type="string">"too many captures"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>capture</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>init</name><operator>=</operator><name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>capture</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>len</name><operator>=</operator><name>what</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>level</name></name><operator>=</operator><name>level</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><operator>(</operator><name>res</name><operator>=</operator><call><name>match</name><argument_list>(<argument><expr><name>ms</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>)</operator><operator>==</operator><name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>level</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>end_capture</name><parameter_list>(<parameter><decl><type><name>MatchState</name><modifier>*</modifier></type><name>ms</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>l</name><init>=<expr><call><name>capture_to_close</name><argument_list>(<argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>capture</name><index>[<expr><name>l</name></expr>]</index></name><operator>.</operator><name>len</name><operator>=</operator><name>s</name><operator>-</operator><name><name>ms</name><operator>-&gt;</operator><name>capture</name><index>[<expr><name>l</name></expr>]</index></name><operator>.</operator><name>init</name></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><operator>(</operator><name>res</name><operator>=</operator><call><name>match</name><argument_list>(<argument><expr><name>ms</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>)</operator><operator>==</operator><name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>capture</name><index>[<expr><name>l</name></expr>]</index></name><operator>.</operator><name>len</name><operator>=</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>match_capture</name><parameter_list>(<parameter><decl><type><name>MatchState</name><modifier>*</modifier></type><name>ms</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>s</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>l</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
<expr_stmt><expr><name>l</name><operator>=</operator><call><name>check_capture</name><argument_list>(<argument><expr><name>ms</name></expr></argument>,<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name><operator>=</operator><name><name>ms</name><operator>-&gt;</operator><name>capture</name><index>[<expr><name>l</name></expr>]</index></name><operator>.</operator><name>len</name></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name><name>ms</name><operator>-&gt;</operator><name>src_end</name></name><operator>-</operator><name>s</name><operator>)</operator><operator>&gt;=</operator><name>len</name><operator>&amp;&amp;</operator>
<call><name>memcmp</name><argument_list>(<argument><expr><name><name>ms</name><operator>-&gt;</operator><name>capture</name><index>[<expr><name>l</name></expr>]</index></name><operator>.</operator><name>init</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>s</name><operator>+</operator><name>len</name></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>match</name><parameter_list>(<parameter><decl><type><name>MatchState</name><modifier>*</modifier></type><name>ms</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>s</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
<label><name>init</name>:</label>
<switch>switch<condition>(<expr><operator>*</operator><name>p</name></expr>)</condition><block>{<block_content>
<case>case<expr><literal type="char">'('</literal></expr>:</case><block>{<block_content>
<if_stmt><if>if<condition>(<expr><operator>*</operator><operator>(</operator><name>p</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>==</operator><literal type="char">')'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>start_capture</name><argument_list>(<argument><expr><name>ms</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>p</name><operator>+</operator><literal type="number">2</literal></expr></argument>,<argument><expr><operator>(</operator><operator>-</operator><literal type="number">2</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><call><name>start_capture</name><argument_list>(<argument><expr><name>ms</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>p</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block>
<case>case<expr><literal type="char">')'</literal></expr>:</case><block>{<block_content>
<return>return <expr><call><name>end_capture</name><argument_list>(<argument><expr><name>ms</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>p</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>
<case>case<expr><literal type="char">'%'</literal></expr>:</case><block>{<block_content>
<switch>switch<condition>(<expr><operator>*</operator><operator>(</operator><name>p</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition><block>{<block_content>
<case>case<expr><literal type="char">'b'</literal></expr>:</case><block>{<block_content>
<expr_stmt><expr><name>s</name><operator>=</operator><call><name>matchbalance</name><argument_list>(<argument><expr><name>ms</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>p</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>s</name><operator>==</operator><name>NULL</name></expr>)</condition><block type="pseudo"><block_content><return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>p</name><operator>+=</operator><literal type="number">4</literal></expr>;</expr_stmt><goto>goto <name>init</name>;</goto>
</block_content>}</block>
<case>case<expr><literal type="char">'f'</literal></expr>:</case><block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>ep</name></decl>;</decl_stmt><decl_stmt><decl><type><name>char</name></type> <name>previous</name></decl>;</decl_stmt>
<expr_stmt><expr><name>p</name><operator>+=</operator><literal type="number">2</literal></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><operator>*</operator><name>p</name><operator>!=</operator><literal type="char">'['</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaL_error</name><argument_list>(<argument><expr><name><name>ms</name><operator>-&gt;</operator><name>L</name></name></expr></argument>,<argument><expr><literal type="string">"missing "</literal><call><name>LUA_QL</name><argument_list>(<argument><expr><literal type="string">"["</literal></expr></argument>)</argument_list></call><literal type="string">" after "</literal>
<call><name>LUA_QL</name><argument_list>(<argument><expr><literal type="string">"%%f"</literal></expr></argument>)</argument_list></call><literal type="string">" in pattern"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>ep</name><operator>=</operator><call><name>classend</name><argument_list>(<argument><expr><name>ms</name></expr></argument>,<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>previous</name><operator>=</operator><ternary><condition><expr><operator>(</operator><name>s</name><operator>==</operator><name><name>ms</name><operator>-&gt;</operator><name>src_init</name></name><operator>)</operator></expr>?</condition><then><expr><literal type="char">'\0'</literal></expr></then><else>:<expr><operator>*</operator><operator>(</operator><name>s</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><call><name>matchbracketclass</name><argument_list>(<argument><expr><call><name>uchar</name><argument_list>(<argument><expr><name>previous</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>p</name></expr></argument>,<argument><expr><name>ep</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>||</operator>
<operator>!</operator><call><name>matchbracketclass</name><argument_list>(<argument><expr><call><name>uchar</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>p</name></expr></argument>,<argument><expr><name>ep</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content><return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>p</name><operator>=</operator><name>ep</name></expr>;</expr_stmt><goto>goto <name>init</name>;</goto>
</block_content>}</block>
<default>default:</default><block>{<block_content>
<if_stmt><if>if<condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><call><name>uchar</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>p</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<expr_stmt><expr><name>s</name><operator>=</operator><call><name>match_capture</name><argument_list>(<argument><expr><name>ms</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><call><name>uchar</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>p</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>s</name><operator>==</operator><name>NULL</name></expr>)</condition><block type="pseudo"><block_content><return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>p</name><operator>+=</operator><literal type="number">2</literal></expr>;</expr_stmt><goto>goto <name>init</name>;</goto>
</block_content>}</block></if></if_stmt>
<goto>goto <name>dflt</name>;</goto>
</block_content>}</block>
</block_content>}</block></switch>
</block_content>}</block>
<case>case<expr><literal type="char">'\0'</literal></expr>:</case><block>{<block_content>
<return>return <expr><name>s</name></expr>;</return>
</block_content>}</block>
<case>case<expr><literal type="char">'$'</literal></expr>:</case><block>{<block_content>
<if_stmt><if>if<condition>(<expr><operator>*</operator><operator>(</operator><name>p</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>==</operator><literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return<expr><ternary><condition><expr><operator>(</operator><name>s</name><operator>==</operator><name><name>ms</name><operator>-&gt;</operator><name>src_end</name></name><operator>)</operator></expr>?</condition><then><expr><name>s</name></expr></then><else>:<expr><name>NULL</name></expr></else></ternary></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content> <goto>goto <name>dflt</name>;</goto></block_content></block></else></if_stmt>
</block_content>}</block>
<default>default:</default><label><name>dflt</name>:</label><block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>ep</name><init>=<expr><call><name>classend</name><argument_list>(<argument><expr><name>ms</name></expr></argument>,<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>m</name><init>=<expr><name>s</name><operator>&lt;</operator><name><name>ms</name><operator>-&gt;</operator><name>src_end</name></name><operator>&amp;&amp;</operator><call><name>singlematch</name><argument_list>(<argument><expr><call><name>uchar</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>p</name></expr></argument>,<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<switch>switch<condition>(<expr><operator>*</operator><name>ep</name></expr>)</condition><block>{<block_content>
<case>case<expr><literal type="char">'?'</literal></expr>:</case><block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>m</name><operator>&amp;&amp;</operator><operator>(</operator><operator>(</operator><name>res</name><operator>=</operator><call><name>match</name><argument_list>(<argument><expr><name>ms</name></expr></argument>,<argument><expr><name>s</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>ep</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><name>NULL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>p</name><operator>=</operator><name>ep</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt><goto>goto <name>init</name>;</goto>
</block_content>}</block>
<case>case<expr><literal type="char">'*'</literal></expr>:</case><block>{<block_content>
<return>return <expr><call><name>max_expand</name><argument_list>(<argument><expr><name>ms</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>p</name></expr></argument>,<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>
<case>case<expr><literal type="char">'+'</literal></expr>:</case><block>{<block_content>
<return>return<expr><operator>(</operator><ternary><condition><expr><name>m</name></expr>?</condition><then><expr><call><name>max_expand</name><argument_list>(<argument><expr><name>ms</name></expr></argument>,<argument><expr><name>s</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>p</name></expr></argument>,<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr></then><else>:<expr><name>NULL</name></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block>
<case>case<expr><literal type="char">'-'</literal></expr>:</case><block>{<block_content>
<return>return <expr><call><name>min_expand</name><argument_list>(<argument><expr><name>ms</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>p</name></expr></argument>,<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>
<default>default:</default><block>{<block_content>
<if_stmt><if>if<condition>(<expr><operator>!</operator><name>m</name></expr>)</condition><block type="pseudo"><block_content><return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt><expr_stmt><expr><name>p</name><operator>=</operator><name>ep</name></expr>;</expr_stmt><goto>goto <name>init</name>;</goto>
</block_content>}</block>
</block_content>}</block></switch>
</block_content>}</block>
</block_content>}</block></switch>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>lmemfind</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>s1</name></decl></parameter>,<parameter><decl><type><name>size_t</name></type> <name>l1</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>s2</name></decl></parameter>,<parameter><decl><type><name>size_t</name></type> <name>l2</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name>l2</name><operator>==</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content><return>return <expr><name>s1</name></expr>;</return></block_content></block></if>
<if type="elseif">else if<condition>(<expr><name>l2</name><operator>&gt;</operator><name>l1</name></expr>)</condition><block type="pseudo"><block_content><return>return <expr><name>NULL</name></expr>;</return></block_content></block></if>
<else>else<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>init</name></decl>;</decl_stmt>
<expr_stmt><expr><name>l2</name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>l1</name><operator>=</operator><name>l1</name><operator>-</operator><name>l2</name></expr>;</expr_stmt>
<while>while<condition>(<expr><name>l1</name><operator>&gt;</operator><literal type="number">0</literal><operator>&amp;&amp;</operator><operator>(</operator><name>init</name><operator>=</operator><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>memchr</name><argument_list>(<argument><expr><name>s1</name></expr></argument>,<argument><expr><operator>*</operator><name>s2</name></expr></argument>,<argument><expr><name>l1</name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><name>NULL</name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><name>init</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>init</name></expr></argument>,<argument><expr><name>s2</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>l2</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>init</name><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
<else>else<block>{<block_content>
<expr_stmt><expr><name>l1</name><operator>-=</operator><name>init</name><operator>-</operator><name>s1</name></expr>;</expr_stmt>
<expr_stmt><expr><name>s1</name><operator>=</operator><name>init</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>push_onecapture</name><parameter_list>(<parameter><decl><type><name>MatchState</name><modifier>*</modifier></type><name>ms</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name>i</name><operator>&gt;=</operator><name><name>ms</name><operator>-&gt;</operator><name>level</name></name></expr>)</condition><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name>i</name><operator>==</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>lua_pushlstring</name><argument_list>(<argument><expr><name><name>ms</name><operator>-&gt;</operator><name>L</name></name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>e</name><operator>-</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaL_error</name><argument_list>(<argument><expr><name><name>ms</name><operator>-&gt;</operator><name>L</name></name></expr></argument>,<argument><expr><literal type="string">"invalid capture index"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if>
<else>else<block>{<block_content>
<decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>l</name><init>=<expr><name><name>ms</name><operator>-&gt;</operator><name>capture</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>len</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>l</name><operator>==</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><call><name>luaL_error</name><argument_list>(<argument><expr><name><name>ms</name><operator>-&gt;</operator><name>L</name></name></expr></argument>,<argument><expr><literal type="string">"unfinished capture"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><name>l</name><operator>==</operator><operator>(</operator><operator>-</operator><literal type="number">2</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>lua_pushinteger</name><argument_list>(<argument><expr><name><name>ms</name><operator>-&gt;</operator><name>L</name></name></expr></argument>,<argument><expr><name><name>ms</name><operator>-&gt;</operator><name>capture</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>init</name><operator>-</operator><name><name>ms</name><operator>-&gt;</operator><name>src_init</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>lua_pushlstring</name><argument_list>(<argument><expr><name><name>ms</name><operator>-&gt;</operator><name>L</name></name></expr></argument>,<argument><expr><name><name>ms</name><operator>-&gt;</operator><name>capture</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>init</name></expr></argument>,<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>push_captures</name><parameter_list>(<parameter><decl><type><name>MatchState</name><modifier>*</modifier></type><name>ms</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>s</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nlevels</name><init>=<expr><ternary><condition><expr><operator>(</operator><name><name>ms</name><operator>-&gt;</operator><name>level</name></name><operator>==</operator><literal type="number">0</literal><operator>&amp;&amp;</operator><name>s</name><operator>)</operator></expr>?</condition><then><expr><literal type="number">1</literal></expr></then><else>:<expr><name><name>ms</name><operator>-&gt;</operator><name>level</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaL_checkstack</name><argument_list>(<argument><expr><name><name>ms</name><operator>-&gt;</operator><name>L</name></name></expr></argument>,<argument><expr><name>nlevels</name></expr></argument>,<argument><expr><literal type="string">"too many captures"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init><condition><expr><name>i</name><operator>&lt;</operator><name>nlevels</name></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>push_onecapture</name><argument_list>(<argument><expr><name>ms</name></expr></argument>,<argument><expr><name>i</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<return>return <expr><name>nlevels</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>str_find_aux</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>find</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>l1</name></decl>,<decl><type ref="prev"/><name>l2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>s</name><init>=<expr><call><name>luaL_checklstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>l1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>p</name><init>=<expr><call><name>luaL_checklstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>l2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>init</name><init>=<expr><call><name>posrelat</name><argument_list>(<argument><expr><call><name>luaL_optinteger</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>l1</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>init</name><operator>&lt;</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><name>init</name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if<condition>(<expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>init</name><operator>)</operator><operator>&gt;</operator><name>l1</name></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><name>init</name><operator>=</operator><operator>(</operator><name>ptrdiff_t</name><operator>)</operator><name>l1</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><name>find</name><operator>&amp;&amp;</operator><operator>(</operator><call><name>lua_toboolean</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call><operator>||</operator>
<call><name>strpbrk</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><literal type="string">"^$*+?.([%-"</literal></expr></argument>)</argument_list></call><operator>==</operator><name>NULL</name><operator>)</operator></expr>)</condition><block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>s2</name><init>=<expr><call><name>lmemfind</name><argument_list>(<argument><expr><name>s</name><operator>+</operator><name>init</name></expr></argument>,<argument><expr><name>l1</name><operator>-</operator><name>init</name></expr></argument>,<argument><expr><name>p</name></expr></argument>,<argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>s2</name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>lua_pushinteger</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>s2</name><operator>-</operator><name>s</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_pushinteger</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>s2</name><operator>-</operator><name>s</name><operator>+</operator><name>l2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">2</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<else>else<block>{<block_content>
<decl_stmt><decl><type><name>MatchState</name></type> <name>ms</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>anchor</name><init>=<expr><ternary><condition><expr><operator>(</operator><operator>*</operator><name>p</name><operator>==</operator><literal type="char">'^'</literal><operator>)</operator></expr>?</condition><then><expr><operator>(</operator><name>p</name><operator>++</operator>,<literal type="number">1</literal><operator>)</operator></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>s1</name><init>=<expr><name>s</name><operator>+</operator><name>init</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>ms</name><operator>.</operator><name>L</name></name><operator>=</operator><name>L</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ms</name><operator>.</operator><name>src_init</name></name><operator>=</operator><name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ms</name><operator>.</operator><name>src_end</name></name><operator>=</operator><name>s</name><operator>+</operator><name>l1</name></expr>;</expr_stmt>
<do>do<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>ms</name><operator>.</operator><name>level</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><operator>(</operator><name>res</name><operator>=</operator><call><name>match</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ms</name></expr></argument>,<argument><expr><name>s1</name></expr></argument>,<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><name>NULL</name></expr>)</condition><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name>find</name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>lua_pushinteger</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>s1</name><operator>-</operator><name>s</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_pushinteger</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>res</name><operator>-</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>push_captures</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ms</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">2</literal></expr>;</return>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><call><name>push_captures</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ms</name></expr></argument>,<argument><expr><name>s1</name></expr></argument>,<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>while<condition>(<expr><name>s1</name><operator>++</operator><operator>&lt;</operator><name><name>ms</name><operator>.</operator><name>src_end</name></name><operator>&amp;&amp;</operator><operator>!</operator><name>anchor</name></expr>)</condition>;</do>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>lua_pushnil</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>str_find</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<return>return <expr><call><name>str_find_aux</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>str_match</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<return>return <expr><call><name>str_find_aux</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>gmatch_aux</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>MatchState</name></type> <name>ms</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>ls</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>s</name><init>=<expr><call><name>lua_tolstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>lua_upvalueindex</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><operator>&amp;</operator><name>ls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>p</name><init>=<expr><call><name>lua_tostring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>lua_upvalueindex</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>src</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>ms</name><operator>.</operator><name>L</name></name><operator>=</operator><name>L</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ms</name><operator>.</operator><name>src_init</name></name><operator>=</operator><name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ms</name><operator>.</operator><name>src_end</name></name><operator>=</operator><name>s</name><operator>+</operator><name>ls</name></expr>;</expr_stmt>
<for>for<control>(<init><expr><name>src</name><operator>=</operator><name>s</name><operator>+</operator><operator>(</operator><name>size_t</name><operator>)</operator><call><name>lua_tointeger</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>lua_upvalueindex</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</init>
<condition><expr><name>src</name><operator>&lt;=</operator><name><name>ms</name><operator>.</operator><name>src_end</name></name></expr>;</condition>
<incr><expr><name>src</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>ms</name><operator>.</operator><name>level</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><operator>(</operator><name>e</name><operator>=</operator><call><name>match</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ms</name></expr></argument>,<argument><expr><name>src</name></expr></argument>,<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><name>NULL</name></expr>)</condition><block>{<block_content>
<decl_stmt><decl><type><name>lua_Integer</name></type> <name>newstart</name><init>=<expr><name>e</name><operator>-</operator><name>s</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>e</name><operator>==</operator><name>src</name></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><name>newstart</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>lua_pushinteger</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>newstart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_replace</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><call><name>lua_upvalueindex</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>push_captures</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ms</name></expr></argument>,<argument><expr><name>src</name></expr></argument>,<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>gmatch</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>luaL_checkstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaL_checkstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_settop</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_pushinteger</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_pushcclosure</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>gmatch_aux</name></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>add_s</name><parameter_list>(<parameter><decl><type><name>MatchState</name><modifier>*</modifier></type><name>ms</name></decl></parameter>,<parameter><decl><type><name>luaL_Buffer</name><modifier>*</modifier></type><name>b</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>l</name></decl>,<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>news</name><init>=<expr><call><name>lua_tolstring</name><argument_list>(<argument><expr><name><name>ms</name><operator>-&gt;</operator><name>L</name></name></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init><condition><expr><name>i</name><operator>&lt;</operator><name>l</name></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
<if_stmt><if>if<condition>(<expr><name><name>news</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><literal type="char">'%'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaL_addchar</name><argument_list>(<argument><expr><name>b</name></expr></argument>,<argument><expr><name><name>news</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block>{<block_content>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>isdigit</name><argument_list>(<argument><expr><call><name>uchar</name><argument_list>(<argument><expr><name><name>news</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaL_addchar</name><argument_list>(<argument><expr><name>b</name></expr></argument>,<argument><expr><name><name>news</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if<condition>(<expr><name><name>news</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="char">'0'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaL_addlstring</name><argument_list>(<argument><expr><name>b</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>e</name><operator>-</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block>{<block_content>
<expr_stmt><expr><call><name>push_onecapture</name><argument_list>(<argument><expr><name>ms</name></expr></argument>,<argument><expr><name><name>news</name><index>[<expr><name>i</name></expr>]</index></name><operator>-</operator><literal type="char">'1'</literal></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaL_addvalue</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>add_value</name><parameter_list>(<parameter><decl><type><name>MatchState</name><modifier>*</modifier></type><name>ms</name></decl></parameter>,<parameter><decl><type><name>luaL_Buffer</name><modifier>*</modifier></type><name>b</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name><init>=<expr><name><name>ms</name><operator>-&gt;</operator><name>L</name></name></expr></init></decl>;</decl_stmt>
<switch>switch<condition>(<expr><call><name>lua_type</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<case>case <expr><literal type="number">3</literal></expr>:</case>
<case>case <expr><literal type="number">4</literal></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>add_s</name><argument_list>(<argument><expr><name>ms</name></expr></argument>,<argument><expr><name>b</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block>
<case>case <expr><literal type="number">6</literal></expr>:</case><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>lua_pushvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name><operator>=</operator><call><name>push_captures</name><argument_list>(<argument><expr><name>ms</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_call</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>n</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><literal type="number">5</literal></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>push_onecapture</name><argument_list>(<argument><expr><name>ms</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_gettable</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
</block_content>}</block></switch>
<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>lua_toboolean</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_pushlstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>e</name><operator>-</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if<condition>(<expr><operator>!</operator><call><name>lua_isstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaL_error</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"invalid replacement value (a %s)"</literal></expr></argument>,<argument><expr><call><name>luaL_typename</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>luaL_addvalue</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>str_gsub</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>srcl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>src</name><init>=<expr><call><name>luaL_checklstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>srcl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>p</name><init>=<expr><call><name>luaL_checkstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tr</name><init>=<expr><call><name>lua_type</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>max_s</name><init>=<expr><call><name>luaL_optint</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>,<argument><expr><name>srcl</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>anchor</name><init>=<expr><ternary><condition><expr><operator>(</operator><operator>*</operator><name>p</name><operator>==</operator><literal type="char">'^'</literal><operator>)</operator></expr>?</condition><then><expr><operator>(</operator><name>p</name><operator>++</operator>,<literal type="number">1</literal><operator>)</operator></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MatchState</name></type> <name>ms</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>luaL_Buffer</name></type> <name>b</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaL_argcheck</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>tr</name><operator>==</operator><literal type="number">3</literal><operator>||</operator><name>tr</name><operator>==</operator><literal type="number">4</literal><operator>||</operator>
<name>tr</name><operator>==</operator><literal type="number">6</literal><operator>||</operator><name>tr</name><operator>==</operator><literal type="number">5</literal></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>,
<argument><expr><literal type="string">"string/function/table expected"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaL_buffinit</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ms</name><operator>.</operator><name>L</name></name><operator>=</operator><name>L</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ms</name><operator>.</operator><name>src_init</name></name><operator>=</operator><name>src</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ms</name><operator>.</operator><name>src_end</name></name><operator>=</operator><name>src</name><operator>+</operator><name>srcl</name></expr>;</expr_stmt>
<while>while<condition>(<expr><name>n</name><operator>&lt;</operator><name>max_s</name></expr>)</condition><block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>ms</name><operator>.</operator><name>level</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>e</name><operator>=</operator><call><name>match</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ms</name></expr></argument>,<argument><expr><name>src</name></expr></argument>,<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>e</name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>add_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ms</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>,<argument><expr><name>src</name></expr></argument>,<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><name>e</name><operator>&amp;&amp;</operator><name>e</name><operator>&gt;</operator><name>src</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>src</name><operator>=</operator><name>e</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if<condition>(<expr><name>src</name><operator>&lt;</operator><name><name>ms</name><operator>.</operator><name>src_end</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaL_addchar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>,<argument><expr><operator>*</operator><name>src</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content> <break>break;</break></block_content></block></else></if_stmt>
<if_stmt><if>if<condition>(<expr><name>anchor</name></expr>)</condition><block type="pseudo"><block_content><break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>luaL_addlstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>,<argument><expr><name>src</name></expr></argument>,<argument><expr><name><name>ms</name><operator>.</operator><name>src_end</name></name><operator>-</operator><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaL_pushresult</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_pushinteger</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">2</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>addquoted</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>luaL_Buffer</name><modifier>*</modifier></type><name>b</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>arg</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>l</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>s</name><init>=<expr><call><name>luaL_checklstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>arg</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaL_addchar</name><argument_list>(<argument><expr><name>b</name></expr></argument>,<argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while<condition>(<expr><name>l</name><operator>--</operator></expr>)</condition><block>{<block_content>
<switch>switch<condition>(<expr><operator>*</operator><name>s</name></expr>)</condition><block>{<block_content>
<case>case<expr><literal type="char">'"'</literal></expr>:</case><case>case<expr><literal type="char">'\\'</literal></expr>:</case><case>case<expr><literal type="char">'\n'</literal></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>luaL_addchar</name><argument_list>(<argument><expr><name>b</name></expr></argument>,<argument><expr><literal type="char">'\\'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaL_addchar</name><argument_list>(<argument><expr><name>b</name></expr></argument>,<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case<expr><literal type="char">'\r'</literal></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>luaL_addlstring</name><argument_list>(<argument><expr><name>b</name></expr></argument>,<argument><expr><literal type="string">"\\r"</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case<expr><literal type="char">'\0'</literal></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>luaL_addlstring</name><argument_list>(<argument><expr><name>b</name></expr></argument>,<argument><expr><literal type="string">"\\000"</literal></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<default>default:</default><block>{<block_content>
<expr_stmt><expr><call><name>luaL_addchar</name><argument_list>(<argument><expr><name>b</name></expr></argument>,<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
</block_content>}</block></switch>
<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>luaL_addchar</name><argument_list>(<argument><expr><name>b</name></expr></argument>,<argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>scanformat</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>strfrmt</name></decl></parameter>,<parameter><decl><type><name>char</name><modifier>*</modifier></type><name>form</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>p</name><init>=<expr><name>strfrmt</name></expr></init></decl>;</decl_stmt>
<while>while<condition>(<expr><operator>*</operator><name>p</name><operator>!=</operator><literal type="char">'\0'</literal><operator>&amp;&amp;</operator><call><name>strchr</name><argument_list>(<argument><expr><literal type="string">"-+ #0"</literal></expr></argument>,<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call><operator>!=</operator><name>NULL</name></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
<if_stmt><if>if<condition>(<expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>p</name><operator>-</operator><name>strfrmt</name><operator>)</operator><operator>&gt;=</operator><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"-+ #0"</literal></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaL_error</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"invalid format (repeated flags)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><call><name>uchar</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><call><name>uchar</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><operator>*</operator><name>p</name><operator>==</operator><literal type="char">'.'</literal></expr>)</condition><block>{<block_content>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><call><name>uchar</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><call><name>uchar</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><call><name>uchar</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaL_error</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"invalid format (width or precision too long)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><operator>(</operator><name>form</name><operator>++</operator><operator>)</operator><operator>=</operator><literal type="char">'%'</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>form</name></expr></argument>,<argument><expr><name>strfrmt</name></expr></argument>,<argument><expr><name>p</name><operator>-</operator><name>strfrmt</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>form</name><operator>+=</operator><name>p</name><operator>-</operator><name>strfrmt</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>form</name><operator>=</operator><literal type="char">'\0'</literal></expr>;</expr_stmt>
<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>addintlen</name><parameter_list>(<parameter><decl><type><name>char</name><modifier>*</modifier></type><name>form</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>l</name><init>=<expr><call><name>strlen</name><argument_list>(<argument><expr><name>form</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>spec</name><init>=<expr><name><name>form</name><index>[<expr><name>l</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>form</name><operator>+</operator><name>l</name><operator>-</operator><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="string">"l"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>form</name><index>[<expr><name>l</name><operator>+</operator><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"l"</literal></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">2</literal></expr>]</index></name><operator>=</operator><name>spec</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>form</name><index>[<expr><name>l</name><operator>+</operator><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"l"</literal></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>=</operator><literal type="char">'\0'</literal></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>str_format</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>top</name><init>=<expr><call><name>lua_gettop</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>arg</name><init>=<expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>sfl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>strfrmt</name><init>=<expr><call><name>luaL_checklstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>arg</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>sfl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>strfrmt_end</name><init>=<expr><name>strfrmt</name><operator>+</operator><name>sfl</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>luaL_Buffer</name></type> <name>b</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaL_buffinit</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while<condition>(<expr><name>strfrmt</name><operator>&lt;</operator><name>strfrmt_end</name></expr>)</condition><block>{<block_content>
<if_stmt><if>if<condition>(<expr><operator>*</operator><name>strfrmt</name><operator>!=</operator><literal type="char">'%'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaL_addchar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>,<argument><expr><operator>*</operator><name>strfrmt</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if<condition>(<expr><operator>*</operator><operator>++</operator><name>strfrmt</name><operator>==</operator><literal type="char">'%'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaL_addchar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>,<argument><expr><operator>*</operator><name>strfrmt</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>form</name><index>[<expr><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"-+ #0"</literal></expr></argument>)</argument_list></sizeof><operator>+</operator><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"l"</literal></expr></argument>)</argument_list></sizeof><operator>+</operator><literal type="number">10</literal><operator>)</operator></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buff</name><index>[<expr><literal type="number">512</literal></expr>]</index></name></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><operator>++</operator><name>arg</name><operator>&gt;</operator><name>top</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaL_argerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>arg</name></expr></argument>,<argument><expr><literal type="string">"no value"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>strfrmt</name><operator>=</operator><call><name>scanformat</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>strfrmt</name></expr></argument>,<argument><expr><name>form</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch<condition>(<expr><operator>*</operator><name>strfrmt</name><operator>++</operator></expr>)</condition><block>{<block_content>
<case>case<expr><literal type="char">'c'</literal></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buff</name></expr></argument>,<argument><expr><name>form</name></expr></argument>,<argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>luaL_checknumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case<expr><literal type="char">'d'</literal></expr>:</case><case>case<expr><literal type="char">'i'</literal></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>addintlen</name><argument_list>(<argument><expr><name>form</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buff</name></expr></argument>,<argument><expr><name>form</name></expr></argument>,<argument><expr><operator>(</operator><name>long</name><operator>)</operator><call><name>luaL_checknumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case<expr><literal type="char">'o'</literal></expr>:</case><case>case<expr><literal type="char">'u'</literal></expr>:</case><case>case<expr><literal type="char">'x'</literal></expr>:</case><case>case<expr><literal type="char">'X'</literal></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>addintlen</name><argument_list>(<argument><expr><name>form</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buff</name></expr></argument>,<argument><expr><name>form</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator><call><name>luaL_checknumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case<expr><literal type="char">'e'</literal></expr>:</case><case>case<expr><literal type="char">'E'</literal></expr>:</case><case>case<expr><literal type="char">'f'</literal></expr>:</case>
<case>case<expr><literal type="char">'g'</literal></expr>:</case><case>case<expr><literal type="char">'G'</literal></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buff</name></expr></argument>,<argument><expr><name>form</name></expr></argument>,<argument><expr><operator>(</operator><name>double</name><operator>)</operator><call><name>luaL_checknumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case<expr><literal type="char">'q'</literal></expr>:</case><block>{<block_content>
<expr_stmt><expr><call><name>addquoted</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>,<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block>
<case>case<expr><literal type="char">'s'</literal></expr>:</case><block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>l</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>s</name><init>=<expr><call><name>luaL_checklstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>arg</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>strchr</name><argument_list>(<argument><expr><name>form</name></expr></argument>,<argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call><operator>&amp;&amp;</operator><name>l</name><operator>&gt;=</operator><literal type="number">100</literal></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>lua_pushvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaL_addvalue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if>
<else>else<block>{<block_content>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buff</name></expr></argument>,<argument><expr><name>form</name></expr></argument>,<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></else></if_stmt>
</block_content>}</block>
<default>default:</default><block>{<block_content>
<return>return <expr><call><name>luaL_error</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"invalid option "</literal><call><name>LUA_QL</name><argument_list>(<argument><expr><literal type="string">"%%%c"</literal></expr></argument>)</argument_list></call><literal type="string">" to "</literal>
<call><name>LUA_QL</name><argument_list>(<argument><expr><literal type="string">"format"</literal></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><operator>*</operator><operator>(</operator><name>strfrmt</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>luaL_addlstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>,<argument><expr><name>buff</name></expr></argument>,<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>luaL_pushresult</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>luaL_Reg</name></type> <name><name>strlib</name><index>[]</index></name><init>=<expr><block>{
<expr><block>{<expr><literal type="string">"byte"</literal></expr>,<expr><name>str_byte</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"char"</literal></expr>,<expr><name>str_char</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"find"</literal></expr>,<expr><name>str_find</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"format"</literal></expr>,<expr><name>str_format</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"gmatch"</literal></expr>,<expr><name>gmatch</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"gsub"</literal></expr>,<expr><name>str_gsub</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"lower"</literal></expr>,<expr><name>str_lower</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"match"</literal></expr>,<expr><name>str_match</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"rep"</literal></expr>,<expr><name>str_rep</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"sub"</literal></expr>,<expr><name>str_sub</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"upper"</literal></expr>,<expr><name>str_upper</name></expr>}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>,<expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>void</name></type> <name>createmetatable</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>lua_createtable</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_pushliteral</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_pushvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_setmetatable</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_pushvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_setfield</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>,<argument><expr><literal type="string">"__index"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>luaopen_string</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<expr_stmt><expr><call><name>luaL_register</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"string"</literal></expr></argument>,<argument><expr><name>strlib</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>createmetatable</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>luaL_Reg</name></type> <name><name>lualibs</name><index>[]</index></name><init>=<expr><block>{
<expr><block>{<expr><literal type="string">""</literal></expr>,<expr><name>luaopen_base</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"table"</literal></expr>,<expr><name>luaopen_table</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"io"</literal></expr>,<expr><name>luaopen_io</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"os"</literal></expr>,<expr><name>luaopen_os</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"string"</literal></expr>,<expr><name>luaopen_string</name></expr>}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>,<expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>void</name></type> <name>luaL_openlibs</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>luaL_Reg</name><modifier>*</modifier></type><name>lib</name><init>=<expr><name>lualibs</name></expr></init></decl>;</decl_stmt>
<for>for<control>(<init>;</init><condition><expr><name><name>lib</name><operator>-&gt;</operator><name>func</name></name></expr>;</condition><incr><expr><name>lib</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
<expr_stmt><expr><call><name>lua_pushcfunction</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>lib</name><operator>-&gt;</operator><name>func</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_pushstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>lib</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_call</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>
<typedef>typedef <type><name>unsigned</name> <name>int</name></type> <name>UB</name>;</typedef>
<function><type><specifier>static</specifier> <name>UB</name></type> <name>barg</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list><block>{<block_content>
<union>union<block>{<decl_stmt><decl><type><name>lua_Number</name></type> <name>n</name></decl>;</decl_stmt><decl_stmt><decl><type><name>U64</name></type> <name>b</name></decl>;</decl_stmt>}</block><decl><name>bn</name></decl>;</union>
<expr_stmt><expr><name><name>bn</name><operator>.</operator><name>n</name></name><operator>=</operator><call><name>lua_tonumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>idx</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">6755399441055744.0</literal></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name><name>bn</name><operator>.</operator><name>n</name></name><operator>==</operator><literal type="number">0.0</literal><operator>&amp;&amp;</operator><operator>!</operator><call><name>lua_isnumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><call><name>luaL_typerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>idx</name></expr></argument>,<argument><expr><literal type="string">"number"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return<expr><operator>(</operator><name>UB</name><operator>)</operator><name><name>bn</name><operator>.</operator><name>b</name></name></expr>;</return>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BRET</name><parameter_list>(<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>lua_pushnumber(L,(lua_Number)(int)(b));return 1;</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>int</name></type> <name>tobit</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<macro><name>BRET</name><argument_list>(<argument>barg(L,<literal type="number">1</literal>)</argument>)</argument_list></macro></block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>bnot</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<macro><name>BRET</name><argument_list>(<argument>~barg(L,<literal type="number">1</literal>)</argument>)</argument_list></macro></block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>band</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt><decl_stmt><decl><type><name>UB</name></type> <name>b</name><init>=<expr><call><name>barg</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt><for>for<control>(<init><expr><name>i</name><operator>=</operator><call><name>lua_gettop</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</init><condition><expr><name>i</name><operator>&gt;</operator><literal type="number">1</literal></expr>;</condition><incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content><expr_stmt><expr><name>b</name><operator>&amp;=</operator><call><name>barg</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for><macro><name>BRET</name><argument_list>(<argument>b</argument>)</argument_list></macro></block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>bor</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt><decl_stmt><decl><type><name>UB</name></type> <name>b</name><init>=<expr><call><name>barg</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt><for>for<control>(<init><expr><name>i</name><operator>=</operator><call><name>lua_gettop</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</init><condition><expr><name>i</name><operator>&gt;</operator><literal type="number">1</literal></expr>;</condition><incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content><expr_stmt><expr><name>b</name><operator>|=</operator><call><name>barg</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for><macro><name>BRET</name><argument_list>(<argument>b</argument>)</argument_list></macro></block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>bxor</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt><decl_stmt><decl><type><name>UB</name></type> <name>b</name><init>=<expr><call><name>barg</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt><for>for<control>(<init><expr><name>i</name><operator>=</operator><call><name>lua_gettop</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</init><condition><expr><name>i</name><operator>&gt;</operator><literal type="number">1</literal></expr>;</condition><incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content><expr_stmt><expr><name>b</name><operator>^=</operator><call><name>barg</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for><macro><name>BRET</name><argument_list>(<argument>b</argument>)</argument_list></macro></block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lshift</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>UB</name></type> <name>b</name><init>=<expr><call><name>barg</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>,<decl><type ref="prev"/><name>n</name><init>=<expr><call><name>barg</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call><operator>&amp;</operator><literal type="number">31</literal></expr></init></decl>;</decl_stmt><macro><name>BRET</name><argument_list>(<argument>b&lt;&lt;n</argument>)</argument_list></macro></block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>rshift</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>UB</name></type> <name>b</name><init>=<expr><call><name>barg</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>,<decl><type ref="prev"/><name>n</name><init>=<expr><call><name>barg</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call><operator>&amp;</operator><literal type="number">31</literal></expr></init></decl>;</decl_stmt><macro><name>BRET</name><argument_list>(<argument>b&gt;&gt;n</argument>)</argument_list></macro></block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>arshift</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>UB</name></type> <name>b</name><init>=<expr><call><name>barg</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>,<decl><type ref="prev"/><name>n</name><init>=<expr><call><name>barg</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call><operator>&amp;</operator><literal type="number">31</literal></expr></init></decl>;</decl_stmt><macro><name>BRET</name><argument_list>(<argument>(int)b&gt;&gt;n</argument>)</argument_list></macro></block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>rol</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>UB</name></type> <name>b</name><init>=<expr><call><name>barg</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>,<decl><type ref="prev"/><name>n</name><init>=<expr><call><name>barg</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call><operator>&amp;</operator><literal type="number">31</literal></expr></init></decl>;</decl_stmt><macro><name>BRET</name><argument_list>(<argument>(b&lt;&lt;n)|(b&gt;&gt;(<literal type="number">32</literal>-n))</argument>)</argument_list></macro></block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ror</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>UB</name></type> <name>b</name><init>=<expr><call><name>barg</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>,<decl><type ref="prev"/><name>n</name><init>=<expr><call><name>barg</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call><operator>&amp;</operator><literal type="number">31</literal></expr></init></decl>;</decl_stmt><macro><name>BRET</name><argument_list>(<argument>(b&gt;&gt;n)|(b&lt;&lt;(<literal type="number">32</literal>-n))</argument>)</argument_list></macro></block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>bswap</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>UB</name></type> <name>b</name><init>=<expr><call><name>barg</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt><expr_stmt><expr><name>b</name><operator>=</operator><operator>(</operator><name>b</name><operator>&gt;&gt;</operator><literal type="number">24</literal><operator>)</operator><operator>|</operator><operator>(</operator><operator>(</operator><name>b</name><operator>&gt;&gt;</operator><literal type="number">8</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0xff00</literal><operator>)</operator><operator>|</operator><operator>(</operator><operator>(</operator><name>b</name><operator>&amp;</operator><literal type="number">0xff00</literal><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator><operator>|</operator><operator>(</operator><name>b</name><operator>&lt;&lt;</operator><literal type="number">24</literal><operator>)</operator></expr>;</expr_stmt><macro><name>BRET</name><argument_list>(<argument>b</argument>)</argument_list></macro></block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>tohex</name><parameter_list>(<parameter><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>UB</name></type> <name>b</name><init>=<expr><call><name>barg</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name><init>=<expr><ternary><condition><expr><call><name>lua_isnone</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>?</condition><then><expr><literal type="number">8</literal></expr></then><else>:<expr><operator>(</operator><name>int</name><operator>)</operator><call><name>barg</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>hexdigits</name><init>=<expr><literal type="string">"0123456789abcdef"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>n</name><operator>&lt;</operator><literal type="number">0</literal></expr>)</condition><block>{<block_content><expr_stmt><expr><name>n</name><operator>=</operator><operator>-</operator><name>n</name></expr>;</expr_stmt><expr_stmt><expr><name>hexdigits</name><operator>=</operator><literal type="string">"0123456789ABCDEF"</literal></expr>;</expr_stmt></block_content>}</block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><name>n</name><operator>&gt;</operator><literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><name>n</name><operator>=</operator><literal type="number">8</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<for>for<control>(<init><expr><name>i</name><operator>=</operator><operator>(</operator><name>int</name><operator>)</operator><name>n</name></expr>;</init><condition><expr><operator>--</operator><name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition><incr/>)</control><block>{<block_content><expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name><operator>=</operator><name><name>hexdigits</name><index>[<expr><name>b</name><operator>&amp;</operator><literal type="number">15</literal></expr>]</index></name></expr>;</expr_stmt><expr_stmt><expr><name>b</name><operator>&gt;&gt;=</operator><literal type="number">4</literal></expr>;</expr_stmt></block_content>}</block></for>
<expr_stmt><expr><call><name>lua_pushlstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>luaL_Reg</name></name></type> <name><name>bitlib</name><index>[]</index></name><init>=<expr><block>{
<expr><block>{<expr><literal type="string">"tobit"</literal></expr>,<expr><name>tobit</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"bnot"</literal></expr>,<expr><name>bnot</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"band"</literal></expr>,<expr><name>band</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"bor"</literal></expr>,<expr><name>bor</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"bxor"</literal></expr>,<expr><name>bxor</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"lshift"</literal></expr>,<expr><name>lshift</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"rshift"</literal></expr>,<expr><name>rshift</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"arshift"</literal></expr>,<expr><name>arshift</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"rol"</literal></expr>,<expr><name>rol</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"ror"</literal></expr>,<expr><name>ror</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"bswap"</literal></expr>,<expr><name>bswap</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"tohex"</literal></expr>,<expr><name>tohex</name></expr>}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>,<expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><name>int</name></type> <name>main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,<parameter><decl><type><name>char</name><modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list><block>{<block_content>
<decl_stmt><decl><type><name>lua_State</name><modifier>*</modifier></type><name>L</name><init>=<expr><call><name>luaL_newstate</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaL_openlibs</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaL_register</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"bit"</literal></expr></argument>,<argument><expr><name>bitlib</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>argc</name><operator>&lt;</operator><literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content><return>return <expr><sizeof>sizeof<argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>lua_createtable</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_pushstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_rawseti</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_setglobal</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><literal type="string">"arg"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><call><name>luaL_loadfile</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">2</literal></expr>;</init><condition><expr><name>i</name><operator>&lt;</operator><name>argc</name></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>lua_pushstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<if_stmt><if>if<condition>(<expr><call><name>lua_pcall</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><name>argc</name><operator>-</operator><literal type="number">2</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<label><name>err</name>:</label>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"Error: %s\n"</literal></expr></argument>,<argument><expr><call><name>lua_tostring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>lua_close</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
</unit>
