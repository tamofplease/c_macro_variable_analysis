<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/sysbench/third_party/luajit/luajit/src/host/buildvm_lib.c"><comment type="block">/*
** LuaJIT VM builder: library definition compiler.
** Copyright (C) 2005-2020 Mike Pall. See Copyright Notice in luajit.h
*/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"buildvm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_obj.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_bc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_lib.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"buildvm_libbc.h"</cpp:file></cpp:include>

<comment type="block">/* Context for library definitions. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint8_t</name></type> <name><name>obuf</name><index>[<expr><literal type="number">8192</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>optr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>modname</name><index>[<expr><literal type="number">80</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>size_t</name></type> <name>modnamelen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>funcname</name><index>[<expr><literal type="number">80</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>modstate</name></decl>, <decl><type ref="prev"/><name>regfunc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>ffid</name></decl>, <decl><type ref="prev"/><name>recffid</name></decl>, <decl><type ref="prev"/><name>ffasmfunc</name></decl>;</decl_stmt>

<enum>enum <block>{
  <decl><name>REGFUNC_OK</name></decl>,
  <decl><name>REGFUNC_NOREG</name></decl>,
  <decl><name>REGFUNC_NOREGUV</name></decl>
}</block>;</enum>

<function><type><specifier>static</specifier> <name>void</name></type> <name>libdef_name</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>size_t</name></type> <name>n</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>kind</name> <operator>!=</operator> <name>LIBINIT_STRING</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <name>modnamelen</name> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><name>modnamelen</name></expr>]</index></name> <operator>==</operator> <literal type="char">'_'</literal> <operator>&amp;&amp;</operator>
	<operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>modname</name></expr></argument>, <argument><expr><name>modnamelen</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>modnamelen</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>n</name> <operator>-=</operator> <name>modnamelen</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <name>LIBINIT_MAXSTR</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: string too long: '%s'\n"</literal></expr></argument>,  <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>optr</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><name>n</name><operator>+</operator><literal type="number">2</literal> <operator>&gt;</operator> <name>obuf</name><operator>+</operator><sizeof>sizeof<argument_list>(<argument><expr><name>obuf</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>  <comment type="block">/* +2 for caller. */</comment>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: output buffer overflow\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>optr</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><name>n</name> <operator>|</operator> <name>kind</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>optr</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>optr</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>libdef_endmodule</name><parameter_list>(<parameter><decl><type><name>BuildCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>modstate</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>line</name><index>[<expr><literal type="number">80</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>modstate</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>fp</name></name></expr></argument>, <argument><expr><literal type="string">"  (lua_CFunction)0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>fp</name></name></expr></argument>, <argument><expr><literal type="string">"\n};\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>fp</name></name></expr></argument>, <argument><expr><literal type="string">"static const uint8_t %s%s[] = {\n"</literal></expr></argument>,
	    <argument><expr><name>LABEL_PREFIX_LIBINIT</name></expr></argument>, <argument><expr><name>modname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>line</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>p</name> <operator>=</operator> <name>obuf</name></expr>;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>optr</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <expr_stmt><expr><name>n</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>line</name><operator>+</operator><name>n</name></expr></argument>, <argument><expr><literal type="string">"%d,"</literal></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;=</operator> <literal type="number">75</literal></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>fp</name></name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>line</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>fp</name></name></expr></argument>, <argument><expr><literal type="string">"%s%d\n};\n#endif\n\n"</literal></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>LIBINIT_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>libdef_module</name><parameter_list>(<parameter><decl><type><name>BuildCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>BUILD_libdef</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>libdef_endmodule</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>optr</name> <operator>=</operator> <name>obuf</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>optr</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name>ffid</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>optr</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name>ffasmfunc</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>optr</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* Hash table size. */</comment>
    <expr_stmt><expr><name>modstate</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>fp</name></name></expr></argument>, <argument><expr><literal type="string">"#ifdef %sMODULE_%s\n"</literal></expr></argument>, <argument><expr><name>LIBDEF_PREFIX</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>fp</name></name></expr></argument>, <argument><expr><literal type="string">"#undef %sMODULE_%s\n"</literal></expr></argument>, <argument><expr><name>LIBDEF_PREFIX</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>fp</name></name></expr></argument>, <argument><expr><literal type="string">"static const lua_CFunction %s%s[] = {\n"</literal></expr></argument>,
	    <argument><expr><name>LABEL_PREFIX_LIBCF</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>modnamelen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>modnamelen</name> <operator>&gt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>modname</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: module name too long: '%s'\n"</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>modname</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>find_ffofs</name><parameter_list>(<parameter><decl><type><name>BuildCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>nglob</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>gl</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>globnames</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>gl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'f'</literal> <operator>&amp;&amp;</operator> <name><name>gl</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'f'</literal> <operator>&amp;&amp;</operator> <name><name>gl</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'_'</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>gl</name><operator>+</operator><literal type="number">3</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name><name>ctx</name><operator>-&gt;</operator><name>glob</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <name><name>ctx</name><operator>-&gt;</operator><name>code</name></name><operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: undefined fast function %s%s\n"</literal></expr></argument>,
	  <argument><expr><name>LABEL_PREFIX_FF</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>libdef_func</name><parameter_list>(<parameter><decl><type><name>BuildCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>arg</name> <operator>!=</operator> <name>LIBINIT_CF</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>ffasmfunc</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>BUILD_libdef</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>modstate</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: no module for function definition %s\n"</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>regfunc</name> <operator>==</operator> <name>REGFUNC_NOREG</name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>optr</name><operator>+</operator><literal type="number">1</literal> <operator>&gt;</operator> <name>obuf</name><operator>+</operator><sizeof>sizeof<argument_list>(<argument><expr><name>obuf</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: output buffer overflow\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>optr</name><operator>++</operator> <operator>=</operator> <name>LIBINIT_FFID</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>arg</name> <operator>!=</operator> <name>LIBINIT_ASM_</name></expr>)</condition> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>modstate</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>fp</name></name></expr></argument>, <argument><expr><literal type="string">",\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>modstate</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>fp</name></name></expr></argument>, <argument><expr><literal type="string">"  %s%s"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>arg</name></expr> ?</condition><then> <expr><name>LABEL_PREFIX_FFH</name></expr> </then><else>: <expr><name>LABEL_PREFIX_CF</name></expr></else></ternary></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>regfunc</name> <operator>!=</operator> <name>REGFUNC_NOREGUV</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>obuf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Bump hash table size. */</comment>
      <expr_stmt><expr><call><name>libdef_name</name><argument_list>(<argument><expr><ternary><condition><expr><name>regfunc</name> <operator>==</operator> <name>REGFUNC_NOREGUV</name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><name>p</name></expr></else></ternary></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>BUILD_ffdef</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>fp</name></name></expr></argument>, <argument><expr><literal type="string">"FFDEF(%s)\n"</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>BUILD_recdef</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>funcname</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: function name too long: '%s'\n"</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>BUILD_vmdef</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>modname</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
      <if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'_'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'.'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>fp</name></name></expr></argument>, <argument><expr><literal type="string">"\"%s\",\n"</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>BUILD_bcdef</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>arg</name> <operator>!=</operator> <name>LIBINIT_CF</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>fp</name></name></expr></argument>, <argument><expr><literal type="string">",\n%d"</literal></expr></argument>, <argument><expr><call><name>find_ffofs</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>ffid</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>regfunc</name> <operator>=</operator> <name>REGFUNC_OK</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>libdef_uleb128</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>vv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>v</name> <init>= <expr><operator>*</operator><name>p</name><operator>++</operator></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>v</name> <operator>&gt;=</operator> <literal type="number">0x80</literal></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>sh</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <expr_stmt><expr><name>v</name> <operator>&amp;=</operator> <literal type="number">0x7f</literal></expr>;</expr_stmt>
    <do>do <block>{<block_content> <expr_stmt><expr><name>v</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><operator>*</operator><name>p</name> <operator>&amp;</operator> <literal type="number">0x7f</literal><operator>)</operator> <operator>&lt;&lt;</operator> <operator>(</operator><name>sh</name> <operator>+=</operator> <literal type="number">7</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt> </block_content>}</block> while <condition>(<expr><operator>*</operator><name>p</name><operator>++</operator> <operator>&gt;=</operator> <literal type="number">0x80</literal></expr>)</condition>;</do>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>vv</name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>libdef_fixupbc</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>sizebc</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>libdef_uleb128</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sizebc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>libdef_uleb128</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sizebc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>libdef_uleb128</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sizebc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>sizebc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>p</name> <operator>+=</operator> <literal type="number">4</literal></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>uint8_t</name></type> <name>op</name> <init>= <expr><name><name>p</name><index>[<expr><ternary><condition><expr><name>libbc_endian</name></expr> ?</condition><then> <expr><literal type="number">3</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint8_t</name></type> <name>ra</name> <init>= <expr><name><name>p</name><index>[<expr><ternary><condition><expr><name>libbc_endian</name></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint8_t</name></type> <name>rc</name> <init>= <expr><name><name>p</name><index>[<expr><ternary><condition><expr><name>libbc_endian</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">2</literal></expr></else></ternary></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint8_t</name></type> <name>rb</name> <init>= <expr><name><name>p</name><index>[<expr><ternary><condition><expr><name>libbc_endian</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">3</literal></expr></else></ternary></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>LJ_DUALNUM</name> <operator>&amp;&amp;</operator> <name>op</name> <operator>==</operator> <name>BC_ISTYPE</name> <operator>&amp;&amp;</operator> <name>rc</name> <operator>==</operator> <operator>~</operator><name>LJ_TNUMX</name><operator>+</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>op</name> <operator>=</operator> <name>BC_ISNUM</name></expr>;</expr_stmt> <expr_stmt><expr><name>rc</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>p</name><index>[<expr><call><name>LJ_ENDIAN_SELECT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>op</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><index>[<expr><call><name>LJ_ENDIAN_SELECT</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>ra</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><index>[<expr><call><name>LJ_ENDIAN_SELECT</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><index>[<expr><call><name>LJ_ENDIAN_SELECT</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>rb</name></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>libdef_lua</name><parameter_list>(<parameter><decl><type><name>BuildCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>BUILD_libdef</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>libbc_map</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>libbc_map</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>ofs</name> <init>= <expr><name><name>libbc_map</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ofs</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><name><name>libbc_map</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>ofs</name> <operator>-</operator> <name>ofs</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>obuf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>  <comment type="block">/* Bump hash table size. */</comment>
	<expr_stmt><expr><operator>*</operator><name>optr</name><operator>++</operator> <operator>=</operator> <name>LIBINIT_LUA</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>libdef_name</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>optr</name></expr></argument>, <argument><expr><name>libbc_code</name> <operator>+</operator> <name>ofs</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>libdef_fixupbc</name><argument_list>(<argument><expr><name>optr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>optr</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
	<return>return;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: missing libbc definition for %s\n"</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint32_t</name></type> <name>find_rec</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>obuf</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>n</name></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>n</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if <condition>(<expr><name>p</name><operator>+</operator><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal> <operator>&gt;=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>obuf</name><operator>+</operator><sizeof>sizeof<argument_list>(<argument><expr><name>obuf</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: output buffer overflow\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>libdef_rec</name><parameter_list>(<parameter><decl><type><name>BuildCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>BUILD_recdef</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>q</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>n</name></decl>;</decl_stmt>
    <for>for <control>(<init>;</init> <condition><expr><name>recffid</name><operator>+</operator><literal type="number">1</literal> <operator>&lt;</operator> <name>ffid</name></expr>;</condition> <incr><expr><name>recffid</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>fp</name></name></expr></argument>, <argument><expr><literal type="string">",\n0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><name>recffid</name> <operator>=</operator> <name>ffid</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name> <operator>=</operator> <name>funcname</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>q</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>q</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>find_rec</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>q</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>fp</name></name></expr></argument>, <argument><expr><literal type="string">",\n0x%02x00+(%s)"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>fp</name></name></expr></argument>, <argument><expr><literal type="string">",\n0x%02x00"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>memcpy_endian</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <union>union <block>{ <decl_stmt><decl><type><name>uint8_t</name></type> <name>b</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>uint32_t</name></type> <name>u</name></decl>;</decl_stmt> }</block> <decl><name>host_endian</name></decl>;</union>
  <expr_stmt><expr><name><name>host_endian</name><operator>.</operator><name>u</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>host_endian</name><operator>.</operator><name>b</name></name> <operator>==</operator> <call><name>LJ_ENDIAN_SELECT</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
      <expr_stmt><expr><operator>(</operator><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>dst</name><operator>)</operator><index>[<expr><name>i</name></expr>]</index> <operator>=</operator> <operator>(</operator><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>src</name><operator>)</operator><index>[<expr><name>n</name><operator>-</operator><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></expr>;</expr_stmt></block_content></block></for>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>libdef_push</name><parameter_list>(<parameter><decl><type><name>BuildCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>BUILD_libdef</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><name>len</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name><name>p</name><index>[<expr><name>len</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>libdef_name</name><argument_list>(<argument><expr><name>p</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>LIBINIT_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>*</operator><name>p</name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>&lt;=</operator> <literal type="char">'9'</literal></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ep</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>double</name></type> <name>d</name> <init>= <expr><call><name>strtod</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ep</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><operator>*</operator><name>ep</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>optr</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof> <operator>&gt;</operator> <name>obuf</name><operator>+</operator><sizeof>sizeof<argument_list>(<argument><expr><name>obuf</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: output buffer overflow\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>optr</name><operator>++</operator> <operator>=</operator> <name>LIBINIT_NUMBER</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy_endian</name><argument_list>(<argument><expr><name>optr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>d</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>optr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<return>return;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"lastcl"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>optr</name><operator>+</operator><literal type="number">1</literal> <operator>&gt;</operator> <name>obuf</name><operator>+</operator><sizeof>sizeof<argument_list>(<argument><expr><name>obuf</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: output buffer overflow\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>optr</name><operator>++</operator> <operator>=</operator> <name>LIBINIT_LASTCL</name></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"top-"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>optr</name><operator>+</operator><literal type="number">2</literal> <operator>&gt;</operator> <name>obuf</name><operator>+</operator><sizeof>sizeof<argument_list>(<argument><expr><name>obuf</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: output buffer overflow\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>optr</name><operator>++</operator> <operator>=</operator> <name>LIBINIT_COPY</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>optr</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><call><name>atoi</name><argument_list>(<argument><expr><name>p</name><operator>+</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: bad value for %sPUSH(%s)\n"</literal></expr></argument>, <argument><expr><name>LIBDEF_PREFIX</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>libdef_set</name><parameter_list>(<parameter><decl><type><name>BuildCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>BUILD_libdef</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'!'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Set env. */</comment>
    <expr_stmt><expr><call><name>libdef_name</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>LIBINIT_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>optr</name><operator>++</operator> <operator>=</operator> <name>LIBINIT_SET</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>obuf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>  <comment type="block">/* Bump hash table size. */</comment>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>libdef_regfunc</name><parameter_list>(<parameter><decl><type><name>BuildCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>regfunc</name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>
</block_content>}</block></function>

<typedef>typedef <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>LibDefFunc</name>)<parameter_list>(<parameter><decl><type><name>BuildCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>arg</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<typedef>typedef <type><struct>struct <name>LibDefHandler</name> <block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>suffix</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stop</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>LibDefFunc</name></type> <name>func</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>arg</name></decl>;</decl_stmt>
}</block></struct></type> <name>LibDefHandler</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>LibDefHandler</name></type> <name><name>libdef_handlers</name><index>[]</index></name> <init>= <expr><block>{
  <expr><block>{ <expr><literal type="string">"MODULE_"</literal></expr>,	<expr><literal type="string">" \t\r\n"</literal></expr>,	<expr><name>libdef_module</name></expr>,		<expr><literal type="number">0</literal></expr> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"CF("</literal></expr>,	<expr><literal type="string">")"</literal></expr>,		<expr><name>libdef_func</name></expr>,		<expr><name>LIBINIT_CF</name></expr> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"ASM("</literal></expr>,	<expr><literal type="string">")"</literal></expr>,		<expr><name>libdef_func</name></expr>,		<expr><name>LIBINIT_ASM</name></expr> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"ASM_("</literal></expr>,	<expr><literal type="string">")"</literal></expr>,		<expr><name>libdef_func</name></expr>,		<expr><name>LIBINIT_ASM_</name></expr> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"LUA("</literal></expr>,	<expr><literal type="string">")"</literal></expr>,		<expr><name>libdef_lua</name></expr>,		<expr><literal type="number">0</literal></expr> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"REC("</literal></expr>,	<expr><literal type="string">")"</literal></expr>,		<expr><name>libdef_rec</name></expr>,		<expr><literal type="number">0</literal></expr> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"PUSH("</literal></expr>,	<expr><literal type="string">")"</literal></expr>,		<expr><name>libdef_push</name></expr>,		<expr><literal type="number">0</literal></expr> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"SET("</literal></expr>,	<expr><literal type="string">")"</literal></expr>,		<expr><name>libdef_set</name></expr>,		<expr><literal type="number">0</literal></expr> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"NOREGUV"</literal></expr>,	<expr><name>NULL</name></expr>,		<expr><name>libdef_regfunc</name></expr>,		<expr><name>REGFUNC_NOREGUV</name></expr> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"NOREG"</literal></expr>,	<expr><name>NULL</name></expr>,		<expr><name>libdef_regfunc</name></expr>,		<expr><name>REGFUNC_NOREG</name></expr> }</block></expr>,
  <expr><block>{ <expr><name>NULL</name></expr>,	<expr><name>NULL</name></expr>,		<expr><operator>(</operator><name>LibDefFunc</name><operator>)</operator><literal type="number">0</literal></expr>,		<expr><literal type="number">0</literal></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Emit C source code for library function definitions. */</comment>
<function><type><name>void</name></type> <name>emit_lib</name><parameter_list>(<parameter><decl><type><name>BuildCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname</name></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>BUILD_ffdef</name> <operator>||</operator> <name><name>ctx</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>BUILD_libdef</name> <operator>||</operator>
      <name><name>ctx</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>BUILD_recdef</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>fp</name></name></expr></argument>, <argument><expr><literal type="string">"/* This is a generated file. DO NOT EDIT! */\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>BUILD_vmdef</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>fp</name></name></expr></argument>, <argument><expr><literal type="string">"ffnames = {\n[0]=\"Lua\",\n\"C\",\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>BUILD_recdef</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>fp</name></name></expr></argument>, <argument><expr><literal type="string">"static const uint16_t recff_idmap[] = {\n0,\n0x0100"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>recffid</name> <operator>=</operator> <name>ffid</name> <operator>=</operator> <name>FF_C</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>ffasmfunc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <while>while <condition>(<expr><operator>(</operator><name>fname</name> <operator>=</operator> <operator>*</operator><name><name>ctx</name><operator>-&gt;</operator><name>args</name></name><operator>++</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>  <comment type="block">/* We don't care about analyzing lines longer than that. */</comment>
    <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>fname</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal> <operator>&amp;&amp;</operator> <name><name>fname</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>fp</name> <operator>=</operator> <name>stdin</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>fp</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>fp</name></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: cannot open input file '%s': %s\n"</literal></expr></argument>,
		<argument><expr><name>fname</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>modstate</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>regfunc</name> <operator>=</operator> <name>REGFUNC_OK</name></expr>;</expr_stmt>
    <while>while <condition>(<expr><call><name>fgets</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
      <comment type="block">/* Simplistic pre-processor. Only handles top-level #if/#endif. */</comment>
      <if_stmt><if>if <condition>(<expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'#'</literal> <operator>&amp;&amp;</operator> <name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'i'</literal> <operator>&amp;&amp;</operator> <name><name>buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'f'</literal></expr>)</condition> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>ok</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"#if LJ_52\n"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><name>ok</name> <operator>=</operator> <name>LJ_52</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"#if LJ_HASJIT\n"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><name>ok</name> <operator>=</operator> <name>LJ_HASJIT</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"#if LJ_HASFFI\n"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><name>ok</name> <operator>=</operator> <name>LJ_HASFFI</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok</name></expr>)</condition> <block>{<block_content>
	  <decl_stmt><decl><type><name>int</name></type> <name>lvl</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	  <while>while <condition>(<expr><call><name>fgets</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
	    <if_stmt><if>if <condition>(<expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'#'</literal> <operator>&amp;&amp;</operator> <name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'e'</literal> <operator>&amp;&amp;</operator> <name><name>buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'n'</literal></expr>)</condition> <block>{<block_content>
	      <if_stmt><if>if <condition>(<expr><operator>--</operator><name>lvl</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
	    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'#'</literal> <operator>&amp;&amp;</operator> <name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'i'</literal> <operator>&amp;&amp;</operator> <name><name>buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'f'</literal></expr>)</condition> <block>{<block_content>
	      <expr_stmt><expr><name>lvl</name><operator>++</operator></expr>;</expr_stmt>
	    </block_content>}</block></if></if_stmt>
	  </block_content>}</block></while>
	  <continue>continue;</continue>
	</block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>buf</name></expr>;</init> <condition><expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>LIBDEF_PREFIX</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr/>)</control> <block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>LibDefHandler</name> <modifier>*</modifier></type><name>ldh</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>p</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>LIBDEF_PREFIX</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>ldh</name> <operator>=</operator> <name>libdef_handlers</name></expr>;</init> <condition><expr><name><name>ldh</name><operator>-&gt;</operator><name>suffix</name></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>ldh</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
	  <decl_stmt><decl><type><name>size_t</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>ldh</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>ldh</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	    <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name>n</name> <operator>=</operator> <ternary><condition><expr><name><name>ldh</name><operator>-&gt;</operator><name>stop</name></name></expr> ?</condition><then> <expr><call><name>strcspn</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>ldh</name><operator>-&gt;</operator><name>stop</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
	    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>p</name><index>[<expr><name>n</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
	    <expr_stmt><expr><name><name>p</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name><name>ldh</name><operator>-&gt;</operator><name>func</name></name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>ldh</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>n</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
	    <break>break;</break>
	  </block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><name><name>ldh</name><operator>-&gt;</operator><name>suffix</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><name><name>buf</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: unknown library definition tag %s%s\n"</literal></expr></argument>,
		  <argument><expr><name>LIBDEF_PREFIX</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>BUILD_libdef</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>libdef_endmodule</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>

  <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>BUILD_ffdef</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>fp</name></name></expr></argument>, <argument><expr><literal type="string">"\n#undef FFDEF\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>fp</name></name></expr></argument>,
      <argument><expr><literal type="string">"#ifndef FF_NUM_ASMFUNC\n#define FF_NUM_ASMFUNC %d\n#endif\n\n"</literal></expr></argument>,
      <argument><expr><name>ffasmfunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>BUILD_vmdef</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>fp</name></name></expr></argument>, <argument><expr><literal type="string">"},\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>BUILD_bcdef</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>fp</name></name></expr></argument>, <argument><expr><literal type="string">"\n};\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>fp</name></name></expr></argument>, <argument><expr><literal type="string">"LJ_DATADEF const uint16_t lj_bc_mode[] = {\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>fp</name></name></expr></argument>, <argument><expr><literal type="string">"BCDEF(BCMODE)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>ffasmfunc</name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>fp</name></name></expr></argument>, <argument><expr><literal type="string">"BCMODE_FF,\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>fp</name></name></expr></argument>, <argument><expr><literal type="string">"BCMODE_FF\n};\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>BUILD_recdef</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>obuf</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>fp</name></name></expr></argument>, <argument><expr><literal type="string">"\n};\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>fp</name></name></expr></argument>, <argument><expr><literal type="string">"static const RecordFunc recff_func[] = {\n"</literal>
	    <literal type="string">"recff_nyi,\n"</literal>
	    <literal type="string">"recff_c"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>*</operator><name>p</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>fp</name></name></expr></argument>, <argument><expr><literal type="string">",\nrecff_%s"</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>fp</name></name></expr></argument>, <argument><expr><literal type="string">"\n};\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

</unit>
