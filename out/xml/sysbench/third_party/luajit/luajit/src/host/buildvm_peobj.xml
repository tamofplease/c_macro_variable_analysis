<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/sysbench/third_party/luajit/luajit/src/host/buildvm_peobj.c"><comment type="block">/*
** LuaJIT VM builder: PE object emitter.
** Copyright (C) 2005-2020 Mike Pall. See Copyright Notice in luajit.h
**
** Only used for building on Windows, since we cannot assume the presence
** of a suitable assembler. The host and target byte order must match.
*/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"buildvm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_bc.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_X86ORX64</name></expr></cpp:if>

<comment type="block">/* Context for PE object emitter. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>strtab</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>size_t</name></type> <name>strtabofs</name></decl>;</decl_stmt>

<comment type="block">/* -- PE object definitions ----------------------------------------------- */</comment>

<comment type="block">/* PE header. */</comment>
<typedef>typedef <type><struct>struct <name>PEheader</name> <block>{
  <decl_stmt><decl><type><name>uint16_t</name></type> <name>arch</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint16_t</name></type> <name>nsects</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>time</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>symtabofs</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>nsyms</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint16_t</name></type> <name>opthdrsz</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint16_t</name></type> <name>flags</name></decl>;</decl_stmt>
}</block></struct></type> <name>PEheader</name>;</typedef>

<comment type="block">/* PE section. */</comment>
<typedef>typedef <type><struct>struct <name>PEsection</name> <block>{
  <decl_stmt><decl><type><name>char</name></type> <name><name>name</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>vsize</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>vaddr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>size</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>ofs</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>relocofs</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>lineofs</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint16_t</name></type> <name>nreloc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint16_t</name></type> <name>nline</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>flags</name></decl>;</decl_stmt>
}</block></struct></type> <name>PEsection</name>;</typedef>

<comment type="block">/* PE relocation. */</comment>
<typedef>typedef <type><struct>struct <name>PEreloc</name> <block>{
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>vaddr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>symidx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint16_t</name></type> <name>type</name></decl>;</decl_stmt>
}</block></struct></type> <name>PEreloc</name>;</typedef>

<comment type="block">/* Cannot use sizeof, because it pads up to the max. alignment. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PEOBJ_RELOC_SIZE</name></cpp:macro>	<cpp:value>(4+4+2)</cpp:value></cpp:define>

<comment type="block">/* PE symbol table entry. */</comment>
<typedef>typedef <type><struct>struct <name>PEsym</name> <block>{
  <union>union <block>{
    <decl_stmt><decl><type><name>char</name></type> <name><name>name</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name><name>nameref</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
  }</block> <decl><name>n</name></decl>;</union>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>value</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int16_t</name></type> <name>sect</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint16_t</name></type> <name>type</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>scl</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>naux</name></decl>;</decl_stmt>
}</block></struct></type> <name>PEsym</name>;</typedef>

<comment type="block">/* PE symbol table auxiliary entry for a section. */</comment>
<typedef>typedef <type><struct>struct <name>PEsymaux</name> <block>{
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>size</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint16_t</name></type> <name>nreloc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint16_t</name></type> <name>nline</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>cksum</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint16_t</name></type> <name>assoc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>comdatsel</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name><name>unused</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>PEsymaux</name>;</typedef>

<comment type="block">/* Cannot use sizeof, because it pads up to the max. alignment. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PEOBJ_SYM_SIZE</name></cpp:macro>	<cpp:value>(8+4+2+2+1+1)</cpp:value></cpp:define>

<comment type="block">/* PE object CPU specific defines. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_X86</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PEOBJ_ARCH_TARGET</name></cpp:macro>	<cpp:value>0x014c</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PEOBJ_RELOC_REL32</name></cpp:macro>	<cpp:value>0x14</cpp:value></cpp:define>  <comment type="block">/* MS: REL32, GNU: DISP32. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PEOBJ_RELOC_DIR32</name></cpp:macro>	<cpp:value>0x06</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PEOBJ_RELOC_OFS</name></cpp:macro>		<cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PEOBJ_TEXT_FLAGS</name></cpp:macro>	<cpp:value>0x60500020</cpp:value></cpp:define>  <comment type="block">/* 60=r+x, 50=align16, 20=code. */</comment>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_X64</name></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PEOBJ_ARCH_TARGET</name></cpp:macro>	<cpp:value>0x8664</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PEOBJ_RELOC_REL32</name></cpp:macro>	<cpp:value>0x04</cpp:value></cpp:define>  <comment type="block">/* MS: REL32, GNU: DISP32. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PEOBJ_RELOC_DIR32</name></cpp:macro>	<cpp:value>0x02</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PEOBJ_RELOC_ADDR32NB</name></cpp:macro>	<cpp:value>0x03</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PEOBJ_RELOC_OFS</name></cpp:macro>		<cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PEOBJ_TEXT_FLAGS</name></cpp:macro>	<cpp:value>0x60500020</cpp:value></cpp:define>  <comment type="block">/* 60=r+x, 50=align16, 20=code. */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Section numbers (0-based). */</comment>
<enum>enum <block>{
  <decl><name>PEOBJ_SECT_ABS</name> <init>= <expr><operator>-</operator><literal type="number">2</literal></expr></init></decl>,
  <decl><name>PEOBJ_SECT_UNDEF</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>,
  <decl><name>PEOBJ_SECT_TEXT</name></decl>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_X64</name></expr></cpp:if>
  <decl><name>PEOBJ_SECT_PDATA</name></decl>,
  <decl><name>PEOBJ_SECT_XDATA</name></decl>,
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_X86</name></expr></cpp:elif>
  <decl><name>PEOBJ_SECT_SXDATA</name></decl>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <decl><name>PEOBJ_SECT_RDATA_Z</name></decl>,
  <decl><name>PEOBJ_NSECTIONS</name></decl>
}</block>;</enum>

<comment type="block">/* Symbol types. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PEOBJ_TYPE_NULL</name></cpp:macro>		<cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PEOBJ_TYPE_FUNC</name></cpp:macro>		<cpp:value>0x20</cpp:value></cpp:define>

<comment type="block">/* Symbol storage class. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PEOBJ_SCL_EXTERN</name></cpp:macro>	<cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PEOBJ_SCL_STATIC</name></cpp:macro>	<cpp:value>3</cpp:value></cpp:define>

<comment type="block">/* -- PE object emitter --------------------------------------------------- */</comment>

<comment type="block">/* Emit PE object symbol. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>emit_peobj_sym</name><parameter_list>(<parameter><decl><type><name>BuildCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>value</name></decl></parameter>,
			   <parameter><decl><type><name>int</name></type> <name>sect</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>scl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>PEsym</name></type> <name>sym</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>strtab</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Pass 1: only calculate string table length. */</comment>
    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>strtabofs</name> <operator>+=</operator> <name>len</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;=</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>sym</name><operator>.</operator><name>n</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>sym</name><operator>.</operator><name>n</name><operator>.</operator><name>name</name></name><operator>+</operator><name>len</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">8</literal><operator>-</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name><name>sym</name><operator>.</operator><name>n</name><operator>.</operator><name>nameref</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sym</name><operator>.</operator><name>n</name><operator>.</operator><name>nameref</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>strtabofs</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>strtab</name> <operator>+</operator> <name>strtabofs</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>strtab</name><index>[<expr><name>strtabofs</name><operator>+</operator><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>strtabofs</name> <operator>+=</operator> <name>len</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>sym</name><operator>.</operator><name>value</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sym</name><operator>.</operator><name>sect</name></name> <operator>=</operator> <operator>(</operator><name>int16_t</name><operator>)</operator><operator>(</operator><name>sect</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>  <comment type="block">/* 1-based section number. */</comment>
  <expr_stmt><expr><name><name>sym</name><operator>.</operator><name>type</name></name> <operator>=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><name>type</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sym</name><operator>.</operator><name>scl</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name>scl</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sym</name><operator>.</operator><name>naux</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>owrite</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sym</name></expr></argument>, <argument><expr><name>PEOBJ_SYM_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Emit PE object section symbol. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>emit_peobj_sym_sect</name><parameter_list>(<parameter><decl><type><name>BuildCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>PEsection</name> <modifier>*</modifier></type><name>pesect</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sect</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>PEsym</name></type> <name>sym</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PEsymaux</name></type> <name>aux</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>strtab</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>  <comment type="block">/* Pass 1: no output. */</comment>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>sym</name><operator>.</operator><name>n</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>pesect</name><index>[<expr><name>sect</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sym</name><operator>.</operator><name>value</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sym</name><operator>.</operator><name>sect</name></name> <operator>=</operator> <operator>(</operator><name>int16_t</name><operator>)</operator><operator>(</operator><name>sect</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>  <comment type="block">/* 1-based section number. */</comment>
  <expr_stmt><expr><name><name>sym</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>PEOBJ_TYPE_NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sym</name><operator>.</operator><name>scl</name></name> <operator>=</operator> <name>PEOBJ_SCL_STATIC</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sym</name><operator>.</operator><name>naux</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>owrite</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sym</name></expr></argument>, <argument><expr><name>PEOBJ_SYM_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>aux</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PEsymaux</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aux</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name><name>pesect</name><index>[<expr><name>sect</name></expr>]</index></name><operator>.</operator><name>size</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aux</name><operator>.</operator><name>nreloc</name></name> <operator>=</operator> <name><name>pesect</name><index>[<expr><name>sect</name></expr>]</index></name><operator>.</operator><name>nreloc</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>owrite</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aux</name></expr></argument>, <argument><expr><name>PEOBJ_SYM_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Emit Windows PE object file. */</comment>
<function><type><name>void</name></type> <name>emit_peobj</name><parameter_list>(<parameter><decl><type><name>BuildCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>PEheader</name></type> <name>pehdr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PEsection</name></type> <name><name>pesect</name><index>[<expr><name>PEOBJ_NSECTIONS</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>sofs</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>nrsym</name></decl>;</decl_stmt>
  <union>union <block>{ <decl_stmt><decl><type><name>uint8_t</name></type> <name>b</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>uint32_t</name></type> <name>u</name></decl>;</decl_stmt> }</block> <decl><name>host_endian</name></decl>;</union>

  <expr_stmt><expr><name>sofs</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PEheader</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>PEOBJ_NSECTIONS</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>PEsection</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

  <comment type="block">/* Fill in PE sections. */</comment>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pesect</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>PEOBJ_NSECTIONS</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>PEsection</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pesect</name><index>[<expr><name>PEOBJ_SECT_TEXT</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><literal type="string">".text"</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">".text"</literal></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pesect</name><index>[<expr><name>PEOBJ_SECT_TEXT</name></expr>]</index></name><operator>.</operator><name>ofs</name> <operator>=</operator> <name>sofs</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>sofs</name> <operator>+=</operator> <operator>(</operator><name><name>pesect</name><index>[<expr><name>PEOBJ_SECT_TEXT</name></expr>]</index></name><operator>.</operator><name>size</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>ctx</name><operator>-&gt;</operator><name>codesz</name></name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pesect</name><index>[<expr><name>PEOBJ_SECT_TEXT</name></expr>]</index></name><operator>.</operator><name>relocofs</name> <operator>=</operator> <name>sofs</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>sofs</name> <operator>+=</operator> <operator>(</operator><name><name>pesect</name><index>[<expr><name>PEOBJ_SECT_TEXT</name></expr>]</index></name><operator>.</operator><name>nreloc</name> <operator>=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><name><name>ctx</name><operator>-&gt;</operator><name>nreloc</name></name><operator>)</operator> <operator>*</operator> <name>PEOBJ_RELOC_SIZE</name></expr>;</expr_stmt>
  <comment type="block">/* Flags: 60 = read+execute, 50 = align16, 20 = code. */</comment>
  <expr_stmt><expr><name><name>pesect</name><index>[<expr><name>PEOBJ_SECT_TEXT</name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>=</operator> <name>PEOBJ_TEXT_FLAGS</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_X64</name></expr></cpp:if>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pesect</name><index>[<expr><name>PEOBJ_SECT_PDATA</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><literal type="string">".pdata"</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">".pdata"</literal></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pesect</name><index>[<expr><name>PEOBJ_SECT_PDATA</name></expr>]</index></name><operator>.</operator><name>ofs</name> <operator>=</operator> <name>sofs</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>sofs</name> <operator>+=</operator> <operator>(</operator><name><name>pesect</name><index>[<expr><name>PEOBJ_SECT_PDATA</name></expr>]</index></name><operator>.</operator><name>size</name> <operator>=</operator> <literal type="number">6</literal><operator>*</operator><literal type="number">4</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pesect</name><index>[<expr><name>PEOBJ_SECT_PDATA</name></expr>]</index></name><operator>.</operator><name>relocofs</name> <operator>=</operator> <name>sofs</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>sofs</name> <operator>+=</operator> <operator>(</operator><name><name>pesect</name><index>[<expr><name>PEOBJ_SECT_PDATA</name></expr>]</index></name><operator>.</operator><name>nreloc</name> <operator>=</operator> <literal type="number">6</literal><operator>)</operator> <operator>*</operator> <name>PEOBJ_RELOC_SIZE</name></expr>;</expr_stmt>
  <comment type="block">/* Flags: 40 = read, 30 = align4, 40 = initialized data. */</comment>
  <expr_stmt><expr><name><name>pesect</name><index>[<expr><name>PEOBJ_SECT_PDATA</name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>=</operator> <literal type="number">0x40300040</literal></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pesect</name><index>[<expr><name>PEOBJ_SECT_XDATA</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><literal type="string">".xdata"</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">".xdata"</literal></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pesect</name><index>[<expr><name>PEOBJ_SECT_XDATA</name></expr>]</index></name><operator>.</operator><name>ofs</name> <operator>=</operator> <name>sofs</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>sofs</name> <operator>+=</operator> <operator>(</operator><name><name>pesect</name><index>[<expr><name>PEOBJ_SECT_XDATA</name></expr>]</index></name><operator>.</operator><name>size</name> <operator>=</operator> <literal type="number">8</literal><operator>*</operator><literal type="number">2</literal><operator>+</operator><literal type="number">4</literal><operator>+</operator><literal type="number">6</literal><operator>*</operator><literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>  <comment type="block">/* See below. */</comment>
  <expr_stmt><expr><name><name>pesect</name><index>[<expr><name>PEOBJ_SECT_XDATA</name></expr>]</index></name><operator>.</operator><name>relocofs</name> <operator>=</operator> <name>sofs</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>sofs</name> <operator>+=</operator> <operator>(</operator><name><name>pesect</name><index>[<expr><name>PEOBJ_SECT_XDATA</name></expr>]</index></name><operator>.</operator><name>nreloc</name> <operator>=</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>PEOBJ_RELOC_SIZE</name></expr>;</expr_stmt>
  <comment type="block">/* Flags: 40 = read, 30 = align4, 40 = initialized data. */</comment>
  <expr_stmt><expr><name><name>pesect</name><index>[<expr><name>PEOBJ_SECT_XDATA</name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>=</operator> <literal type="number">0x40300040</literal></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_X86</name></expr></cpp:elif>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pesect</name><index>[<expr><name>PEOBJ_SECT_SXDATA</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><literal type="string">".sxdata"</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">".sxdata"</literal></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pesect</name><index>[<expr><name>PEOBJ_SECT_SXDATA</name></expr>]</index></name><operator>.</operator><name>ofs</name> <operator>=</operator> <name>sofs</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>sofs</name> <operator>+=</operator> <operator>(</operator><name><name>pesect</name><index>[<expr><name>PEOBJ_SECT_SXDATA</name></expr>]</index></name><operator>.</operator><name>size</name> <operator>=</operator> <literal type="number">4</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pesect</name><index>[<expr><name>PEOBJ_SECT_SXDATA</name></expr>]</index></name><operator>.</operator><name>relocofs</name> <operator>=</operator> <name>sofs</name></expr>;</expr_stmt>
  <comment type="block">/* Flags: 40 = read, 30 = align4, 02 = lnk_info, 40 = initialized data. */</comment>
  <expr_stmt><expr><name><name>pesect</name><index>[<expr><name>PEOBJ_SECT_SXDATA</name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>=</operator> <literal type="number">0x40300240</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pesect</name><index>[<expr><name>PEOBJ_SECT_RDATA_Z</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><literal type="string">".rdata$Z"</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">".rdata$Z"</literal></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pesect</name><index>[<expr><name>PEOBJ_SECT_RDATA_Z</name></expr>]</index></name><operator>.</operator><name>ofs</name> <operator>=</operator> <name>sofs</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>sofs</name> <operator>+=</operator> <operator>(</operator><name><name>pesect</name><index>[<expr><name>PEOBJ_SECT_RDATA_Z</name></expr>]</index></name><operator>.</operator><name>size</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>dasm_ident</name></name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
  <comment type="block">/* Flags: 40 = read, 30 = align4, 40 = initialized data. */</comment>
  <expr_stmt><expr><name><name>pesect</name><index>[<expr><name>PEOBJ_SECT_RDATA_Z</name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>=</operator> <literal type="number">0x40300040</literal></expr>;</expr_stmt>

  <comment type="block">/* Fill in PE header. */</comment>
  <expr_stmt><expr><name><name>pehdr</name><operator>.</operator><name>arch</name></name> <operator>=</operator> <name>PEOBJ_ARCH_TARGET</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pehdr</name><operator>.</operator><name>nsects</name></name> <operator>=</operator> <name>PEOBJ_NSECTIONS</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pehdr</name><operator>.</operator><name>time</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* Timestamp is optional. */</comment>
  <expr_stmt><expr><name><name>pehdr</name><operator>.</operator><name>symtabofs</name></name> <operator>=</operator> <name>sofs</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pehdr</name><operator>.</operator><name>opthdrsz</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pehdr</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <comment type="block">/* Compute the size of the symbol table:
  ** @feat.00 + nsections*2
  ** + asm_start + nsym
  ** + nrsym
  */</comment>
  <expr_stmt><expr><name>nrsym</name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>nrelocsym</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pehdr</name><operator>.</operator><name>nsyms</name></name> <operator>=</operator> <literal type="number">1</literal><operator>+</operator><name>PEOBJ_NSECTIONS</name><operator>*</operator><literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal><operator>+</operator><name><name>ctx</name><operator>-&gt;</operator><name>nsym</name></name> <operator>+</operator> <name>nrsym</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_X64</name></expr></cpp:if>
  <expr_stmt><expr><name><name>pehdr</name><operator>.</operator><name>nsyms</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* Symbol for lj_err_unwind_win. */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Write PE object header and all sections. */</comment>
  <expr_stmt><expr><call><name>owrite</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pehdr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PEheader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>owrite</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pesect</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PEsection</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>PEOBJ_NSECTIONS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Write .text section. */</comment>
  <expr_stmt><expr><name><name>host_endian</name><operator>.</operator><name>u</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>host_endian</name><operator>.</operator><name>b</name></name> <operator>!=</operator> <call><name>LJ_ENDIAN_SELECT</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: different byte order for host and target\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>owrite</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>code</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>codesz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>nreloc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>PEreloc</name></type> <name>reloc</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>reloc</name><operator>.</operator><name>vaddr</name></name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>ctx</name><operator>-&gt;</operator><name>reloc</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ofs</name> <operator>+</operator> <name>PEOBJ_RELOC_OFS</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>reloc</name><operator>.</operator><name>symidx</name></name> <operator>=</operator> <literal type="number">1</literal><operator>+</operator><literal type="number">2</literal><operator>+</operator><name><name>ctx</name><operator>-&gt;</operator><name>reloc</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sym</name></expr>;</expr_stmt>  <comment type="block">/* Reloc syms are after .text sym. */</comment>
    <expr_stmt><expr><name><name>reloc</name><operator>.</operator><name>type</name></name> <operator>=</operator> <ternary><condition><expr><name><name>ctx</name><operator>-&gt;</operator><name>reloc</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name></expr> ?</condition><then> <expr><name>PEOBJ_RELOC_REL32</name></expr> </then><else>: <expr><name>PEOBJ_RELOC_DIR32</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>owrite</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reloc</name></expr></argument>, <argument><expr><name>PEOBJ_RELOC_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_X64</name></expr></cpp:if>
  <block>{<block_content> <comment type="block">/* Write .pdata section. */</comment>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>fcofs</name> <init>= <expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>ctx</name><operator>-&gt;</operator><name>sym</name><index>[<expr><name><name>ctx</name><operator>-&gt;</operator><name>nsym</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>ofs</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name><name>pdata</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>  <comment type="block">/* Start of .text, end of .text and .xdata. */</comment>
    <decl_stmt><decl><type><name>PEreloc</name></type> <name>reloc</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pdata</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <expr_stmt><expr><name><name>pdata</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>fcofs</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>pdata</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>owrite</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pdata</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pdata</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pdata</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>fcofs</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>pdata</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>ctx</name><operator>-&gt;</operator><name>codesz</name></name></expr>;</expr_stmt> <expr_stmt><expr><name><name>pdata</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">20</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>owrite</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pdata</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pdata</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>reloc</name><operator>.</operator><name>vaddr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <expr_stmt><expr><name><name>reloc</name><operator>.</operator><name>symidx</name></name> <operator>=</operator> <literal type="number">1</literal><operator>+</operator><literal type="number">2</literal><operator>+</operator><name>nrsym</name><operator>+</operator><literal type="number">2</literal><operator>+</operator><literal type="number">2</literal><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>reloc</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>PEOBJ_RELOC_ADDR32NB</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>owrite</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reloc</name></expr></argument>, <argument><expr><name>PEOBJ_RELOC_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>reloc</name><operator>.</operator><name>vaddr</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt> <expr_stmt><expr><name><name>reloc</name><operator>.</operator><name>symidx</name></name> <operator>=</operator> <literal type="number">1</literal><operator>+</operator><literal type="number">2</literal><operator>+</operator><name>nrsym</name><operator>+</operator><literal type="number">2</literal><operator>+</operator><literal type="number">2</literal><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>reloc</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>PEOBJ_RELOC_ADDR32NB</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>owrite</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reloc</name></expr></argument>, <argument><expr><name>PEOBJ_RELOC_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>reloc</name><operator>.</operator><name>vaddr</name></name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt> <expr_stmt><expr><name><name>reloc</name><operator>.</operator><name>symidx</name></name> <operator>=</operator> <literal type="number">1</literal><operator>+</operator><literal type="number">2</literal><operator>+</operator><name>nrsym</name><operator>+</operator><literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>reloc</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>PEOBJ_RELOC_ADDR32NB</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>owrite</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reloc</name></expr></argument>, <argument><expr><name>PEOBJ_RELOC_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>reloc</name><operator>.</operator><name>vaddr</name></name> <operator>=</operator> <literal type="number">12</literal></expr>;</expr_stmt> <expr_stmt><expr><name><name>reloc</name><operator>.</operator><name>symidx</name></name> <operator>=</operator> <literal type="number">1</literal><operator>+</operator><literal type="number">2</literal><operator>+</operator><name>nrsym</name><operator>+</operator><literal type="number">2</literal><operator>+</operator><literal type="number">2</literal><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>reloc</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>PEOBJ_RELOC_ADDR32NB</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>owrite</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reloc</name></expr></argument>, <argument><expr><name>PEOBJ_RELOC_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>reloc</name><operator>.</operator><name>vaddr</name></name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt> <expr_stmt><expr><name><name>reloc</name><operator>.</operator><name>symidx</name></name> <operator>=</operator> <literal type="number">1</literal><operator>+</operator><literal type="number">2</literal><operator>+</operator><name>nrsym</name><operator>+</operator><literal type="number">2</literal><operator>+</operator><literal type="number">2</literal><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>reloc</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>PEOBJ_RELOC_ADDR32NB</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>owrite</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reloc</name></expr></argument>, <argument><expr><name>PEOBJ_RELOC_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>reloc</name><operator>.</operator><name>vaddr</name></name> <operator>=</operator> <literal type="number">20</literal></expr>;</expr_stmt> <expr_stmt><expr><name><name>reloc</name><operator>.</operator><name>symidx</name></name> <operator>=</operator> <literal type="number">1</literal><operator>+</operator><literal type="number">2</literal><operator>+</operator><name>nrsym</name><operator>+</operator><literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>reloc</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>PEOBJ_RELOC_ADDR32NB</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>owrite</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reloc</name></expr></argument>, <argument><expr><name>PEOBJ_RELOC_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block>
  <block>{<block_content> <comment type="block">/* Write .xdata section. */</comment>
    <decl_stmt><decl><type><name>uint16_t</name></type> <name><name>xdata</name><index>[<expr><literal type="number">8</literal><operator>+</operator><literal type="number">2</literal><operator>+</operator><literal type="number">6</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PEreloc</name></type> <name>reloc</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>xdata</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x01</literal><operator>|</operator><literal type="number">0x08</literal><operator>|</operator><literal type="number">0x10</literal></expr>;</expr_stmt>  <comment type="block">/* Ver. 1, uhandler/ehandler, prolog size 0. */</comment>
    <expr_stmt><expr><name><name>xdata</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x0005</literal></expr>;</expr_stmt>  <comment type="block">/* Number of unwind codes, no frame pointer. */</comment>
    <expr_stmt><expr><name><name>xdata</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x4200</literal></expr>;</expr_stmt>  <comment type="block">/* Stack offset 4*8+8 = aword*5. */</comment>
    <expr_stmt><expr><name><name>xdata</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x3000</literal></expr>;</expr_stmt>  <comment type="block">/* Push rbx. */</comment>
    <expr_stmt><expr><name><name>xdata</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x6000</literal></expr>;</expr_stmt>  <comment type="block">/* Push rsi. */</comment>
    <expr_stmt><expr><name><name>xdata</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x7000</literal></expr>;</expr_stmt>  <comment type="block">/* Push rdi. */</comment>
    <expr_stmt><expr><name><name>xdata</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x5000</literal></expr>;</expr_stmt>  <comment type="block">/* Push rbp. */</comment>
    <expr_stmt><expr><name><name>xdata</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* Alignment. */</comment>
    <expr_stmt><expr><name><name>xdata</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>=</operator> <name><name>xdata</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* Relocated address of exception handler. */</comment>
    <expr_stmt><expr><name><name>xdata</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x01</literal></expr>;</expr_stmt>  <comment type="block">/* Ver. 1, no handler, prolog size 0. */</comment>
    <expr_stmt><expr><name><name>xdata</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x1504</literal></expr>;</expr_stmt>  <comment type="block">/* Number of unwind codes, fp = rbp, fpofs = 16. */</comment>
    <expr_stmt><expr><name><name>xdata</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x0300</literal></expr>;</expr_stmt>  <comment type="block">/* set_fpreg. */</comment>
    <expr_stmt><expr><name><name>xdata</name><index>[<expr><literal type="number">13</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x0200</literal></expr>;</expr_stmt>  <comment type="block">/* stack offset 0*8+8 = aword*1. */</comment>
    <expr_stmt><expr><name><name>xdata</name><index>[<expr><literal type="number">14</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x3000</literal></expr>;</expr_stmt>  <comment type="block">/* Push rbx. */</comment>
    <expr_stmt><expr><name><name>xdata</name><index>[<expr><literal type="number">15</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x5000</literal></expr>;</expr_stmt>  <comment type="block">/* Push rbp. */</comment>
    <expr_stmt><expr><call><name>owrite</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xdata</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xdata</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>reloc</name><operator>.</operator><name>vaddr</name></name> <operator>=</operator> <literal type="number">2</literal><operator>*</operator><literal type="number">8</literal></expr>;</expr_stmt> <expr_stmt><expr><name><name>reloc</name><operator>.</operator><name>symidx</name></name> <operator>=</operator> <literal type="number">1</literal><operator>+</operator><literal type="number">2</literal><operator>+</operator><name>nrsym</name><operator>+</operator><literal type="number">2</literal><operator>+</operator><literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>reloc</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>PEOBJ_RELOC_ADDR32NB</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>owrite</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reloc</name></expr></argument>, <argument><expr><name>PEOBJ_RELOC_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_X86</name></expr></cpp:elif>
  <comment type="block">/* Write .sxdata section. */</comment>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nrsym</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>relocsym</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"_lj_err_unwind_win"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>symidx</name> <init>= <expr><literal type="number">1</literal><operator>+</operator><literal type="number">2</literal><operator>+</operator><name>i</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>owrite</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>symidx</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>nrsym</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: extern lj_err_unwind_win not used\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Write .rdata$Z section. */</comment>
  <expr_stmt><expr><call><name>owrite</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>dasm_ident</name></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>dasm_ident</name></name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Write symbol table. */</comment>
  <expr_stmt><expr><name>strtab</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>  <comment type="block">/* 1st pass: collect string sizes. */</comment>
  <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
    <expr_stmt><expr><name>strtabofs</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    <comment type="block">/* Mark as SafeSEH compliant. */</comment>
    <expr_stmt><expr><call><name>emit_peobj_sym</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="string">"@feat.00"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
		   <argument><expr><name>PEOBJ_SECT_ABS</name></expr></argument>, <argument><expr><name>PEOBJ_TYPE_NULL</name></expr></argument>, <argument><expr><name>PEOBJ_SCL_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>emit_peobj_sym_sect</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pesect</name></expr></argument>, <argument><expr><name>PEOBJ_SECT_TEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nrsym</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>emit_peobj_sym</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>relocsym</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
		     <argument><expr><name>PEOBJ_SECT_UNDEF</name></expr></argument>, <argument><expr><name>PEOBJ_TYPE_FUNC</name></expr></argument>, <argument><expr><name>PEOBJ_SCL_EXTERN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_X64</name></expr></cpp:if>
    <expr_stmt><expr><call><name>emit_peobj_sym_sect</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pesect</name></expr></argument>, <argument><expr><name>PEOBJ_SECT_PDATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>emit_peobj_sym_sect</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pesect</name></expr></argument>, <argument><expr><name>PEOBJ_SECT_XDATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>emit_peobj_sym</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="string">"lj_err_unwind_win"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
		   <argument><expr><name>PEOBJ_SECT_UNDEF</name></expr></argument>, <argument><expr><name>PEOBJ_TYPE_FUNC</name></expr></argument>, <argument><expr><name>PEOBJ_SCL_EXTERN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_X86</name></expr></cpp:elif>
    <expr_stmt><expr><call><name>emit_peobj_sym_sect</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pesect</name></expr></argument>, <argument><expr><name>PEOBJ_SECT_SXDATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>emit_peobj_sym</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>beginsym</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
		   <argument><expr><name>PEOBJ_SECT_TEXT</name></expr></argument>, <argument><expr><name>PEOBJ_TYPE_NULL</name></expr></argument>, <argument><expr><name>PEOBJ_SCL_EXTERN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>nsym</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>emit_peobj_sym</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>sym</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>ctx</name><operator>-&gt;</operator><name>sym</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ofs</name></expr></argument>,
		     <argument><expr><name>PEOBJ_SECT_TEXT</name></expr></argument>, <argument><expr><name>PEOBJ_TYPE_FUNC</name></expr></argument>, <argument><expr><name>PEOBJ_SCL_EXTERN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

    <expr_stmt><expr><call><name>emit_peobj_sym_sect</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pesect</name></expr></argument>, <argument><expr><name>PEOBJ_SECT_RDATA_Z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>strtab</name></expr>)</condition><block type="pseudo"><block_content>
      <break>break;</break></block_content></block></if></if_stmt>
    <comment type="block">/* 2nd pass: alloc strtab, write syms and copy strings. */</comment>
    <expr_stmt><expr><name>strtab</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><name>strtabofs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><name>strtab</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>strtabofs</name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Write string table. */</comment>
  <expr_stmt><expr><call><name>owrite</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>strtab</name></expr></argument>, <argument><expr><name>strtabofs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<function><type><name>void</name></type> <name>emit_peobj</name><parameter_list>(<parameter><decl><type><name>BuildCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: no PE object support for this target\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
