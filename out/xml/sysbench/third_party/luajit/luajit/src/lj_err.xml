<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/sysbench/third_party/luajit/luajit/src/lj_err.c"><comment type="block">/*
** Error handling.
** Copyright (C) 2005-2020 Mike Pall. See Copyright Notice in luajit.h
*/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lj_err_c</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUA_CORE</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_obj.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_err.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_debug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_str.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_func.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_state.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_frame.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_ff.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_trace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_vm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_strfmt.h"</cpp:file></cpp:include>

<comment type="block">/*
** LuaJIT can either use internal or external frame unwinding:
**
** - Internal frame unwinding (INT) is free-standing and doesn't require
**   any OS or library support.
**
** - External frame unwinding (EXT) uses the system-provided unwind handler.
**
** Pros and Cons:
**
** - EXT requires unwind tables for *all* functions on the C stack between
**   the pcall/catch and the error/throw. This is the default on x64,
**   but needs to be manually enabled on x86/PPC for non-C++ code.
**
** - INT is faster when actually throwing errors (but this happens rarely).
**   Setting up error handlers is zero-cost in any case.
**
** - EXT provides full interoperability with C++ exceptions. You can throw
**   Lua errors or C++ exceptions through a mix of Lua frames and C++ frames.
**   C++ destructors are called as needed. C++ exceptions caught by pcall
**   are converted to the string "C++ exception". Lua errors can be caught
**   with catch (...) in C++.
**
** - INT has only limited support for automatically catching C++ exceptions
**   on POSIX systems using DWARF2 stack unwinding. Other systems may use
**   the wrapper function feature. Lua errors thrown through C++ frames
**   cannot be caught by C++ code and C++ destructors are not run.
**
** EXT is the default on x64 systems and on Windows, INT is the default on all
** other systems.
**
** EXT can be manually enabled on POSIX systems using GCC and DWARF2 stack
** unwinding with -DLUAJIT_UNWIND_EXTERNAL. *All* C code must be compiled
** with -funwind-tables (or -fexceptions). This includes LuaJIT itself (set
** TARGET_CFLAGS), all of your C/Lua binding code, all loadable C modules
** and all C libraries that have callbacks which may be used to call back
** into Lua. C++ code must *not* be compiled with -fno-exceptions.
**
** EXT is mandatory on WIN64 since the calling convention has an abundance
** of callee-saved registers (rbx, rbp, rsi, rdi, r12-r15, xmm6-xmm15).
** The POSIX/x64 interpreter only saves r12/r13 for INT (e.g. PS4).
*/</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>LJ_TARGET_X64</name> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>LUAJIT_UNWIND_EXTERNAL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name>LJ_NO_UNWIND</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LJ_UNWIND_EXT</name></cpp:macro>	<cpp:value>1</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_WINDOWS</name></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LJ_UNWIND_EXT</name></cpp:macro>	<cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* -- Error messages ------------------------------------------------------ */</comment>

<comment type="block">/* Error message strings. */</comment>
<decl_stmt><decl><type><name>LJ_DATADEF</name> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>lj_err_allmsg</name> <init>=</init></decl>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ERRDEF</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>msg</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>msg "\0"</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_errmsg.h"</cpp:file></cpp:include>
;</decl_stmt>

<comment type="block">/* -- Internal frame unwinding -------------------------------------------- */</comment>

<comment type="block">/* Unwind Lua stack and move error message to new top. */</comment>
<function><type><name>LJ_NOINLINE</name> <specifier>static</specifier> <name>void</name></type> <name>unwindstack</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>TValue</name> <modifier>*</modifier></type><name>top</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>lj_func_closeuv</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>top</name> <operator>&lt;</operator> <name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>top</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name>top</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>lj_state_relimitstack</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Unwind until stop frame. Optionally cleanup frames. */</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>err_unwind</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>stopcf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>errcode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>frame</name> <init>= <expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>cf</name> <init>= <expr><name><name>L</name><operator>-&gt;</operator><name>cframe</name></name></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><name>cf</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>nres</name> <init>= <expr><call><name>cframe_nres</name><argument_list>(<argument><expr><call><name>cframe_raw</name><argument_list>(<argument><expr><name>cf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>nres</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* C frame without Lua frame? */</comment>
      <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>top</name> <init>= <expr><call><name>restorestack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><name>nres</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>frame</name> <operator>&lt;</operator> <name>top</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Frame reached? */</comment>
	<if_stmt><if>if <condition>(<expr><name>errcode</name></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <name>frame</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>cframe</name></name> <operator>=</operator> <call><name>cframe_prev</name><argument_list>(<argument><expr><name>cf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><call><name>unwindstack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>cf</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>frame</name> <operator>&lt;=</operator> <call><name>tvref</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call><operator>+</operator><name>LJ_FR2</name></expr>)</condition><block type="pseudo"><block_content>
      <break>break;</break></block_content></block></if></if_stmt>
    <switch>switch <condition>(<expr><call><name>frame_typep</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>FRAME_LUA</name></expr>:</case>  <comment type="block">/* Lua frame. */</comment>
    <case>case <expr><name>FRAME_LUAP</name></expr>:</case>
      <expr_stmt><expr><name>frame</name> <operator>=</operator> <call><name>frame_prevl</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>FRAME_C</name></expr>:</case>  <comment type="block">/* C frame. */</comment>
    <label><name>unwind_c</name>:</label>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_UNWIND_EXT</name></expr></cpp:if>
      <if_stmt><if>if <condition>(<expr><name>errcode</name></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <call><name>frame_prevd</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>cframe</name></name> <operator>=</operator> <call><name>cframe_prev</name><argument_list>(<argument><expr><name>cf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>unwindstack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>frame</name> <operator>-</operator> <name>LJ_FR2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>cf</name> <operator>!=</operator> <name>stopcf</name></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name>cf</name> <operator>=</operator> <call><name>cframe_prev</name><argument_list>(<argument><expr><name>cf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>frame</name> <operator>=</operator> <call><name>frame_prevd</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><name>NULL</name></expr>;</return>  <comment type="block">/* Continue unwinding. */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>stopcf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>cf</name> <operator>=</operator> <call><name>cframe_prev</name><argument_list>(<argument><expr><name>cf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>frame</name> <operator>=</operator> <call><name>frame_prevd</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <case>case <expr><name>FRAME_CP</name></expr>:</case>  <comment type="block">/* Protected C frame. */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>cframe_canyield</name><argument_list>(<argument><expr><name>cf</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Resume? */</comment>
	<if_stmt><if>if <condition>(<expr><name>errcode</name></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><call><name>hook_leave</name><argument_list>(<argument><expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Assumes nobody uses coroutines inside hooks. */</comment>
	  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>cframe</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name>errcode</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>cf</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>errcode</name></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <call><name>frame_prevd</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>cframe</name></name> <operator>=</operator> <call><name>cframe_prev</name><argument_list>(<argument><expr><name>cf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>unwindstack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>frame</name> <operator>-</operator> <name>LJ_FR2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><name>cf</name></expr>;</return>
    <case>case <expr><name>FRAME_CONT</name></expr>:</case>  <comment type="block">/* Continuation frame. */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>frame_iscont_fficb</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	<goto>goto <name>unwind_c</name>;</goto></block_content></block></if></if_stmt>
      <comment type="block">/* fallthrough */</comment>
    <case>case <expr><name>FRAME_VARG</name></expr>:</case>  <comment type="block">/* Vararg frame. */</comment>
      <expr_stmt><expr><name>frame</name> <operator>=</operator> <call><name>frame_prevd</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>FRAME_PCALL</name></expr>:</case>  <comment type="block">/* FF pcall() frame. */</comment>
    <case>case <expr><name>FRAME_PCALLH</name></expr>:</case>  <comment type="block">/* FF pcall() frame inside hook. */</comment>
      <if_stmt><if>if <condition>(<expr><name>errcode</name></expr>)</condition> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>errcode</name> <operator>==</operator> <name>LUA_YIELD</name></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><name>frame</name> <operator>=</operator> <call><name>frame_prevd</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <break>break;</break>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>frame_typep</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FRAME_PCALL</name></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><call><name>hook_leave</name><argument_list>(<argument><expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <call><name>frame_prevd</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>cframe</name></name> <operator>=</operator> <name>cf</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>unwindstack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>intptr_t</name><operator>)</operator><name>cf</name> <operator>|</operator> <name>CFRAME_UNWIND_FF</name><operator>)</operator></expr>;</return>
    </block_content>}</block></switch>
  </block_content>}</block></while>
  <comment type="block">/* No C frame. */</comment>
  <if_stmt><if>if <condition>(<expr><name>errcode</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <call><name>tvref</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal><operator>+</operator><name>LJ_FR2</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>cframe</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>unwindstack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>panic</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>panic</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>L</name></expr>;</return>  <comment type="block">/* Anything non-NULL will do. */</comment>
</block_content>}</block></function>

<comment type="block">/* -- External frame unwinding -------------------------------------------- */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>LJ_NO_UNWIND</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>LJ_ABI_WIN</name></expr></cpp:if>

<comment type="block">/*
** We have to use our own definitions instead of the mandatory (!) unwind.h,
** since various OS, distros and compilers mess up the header installation.
*/</comment>

<typedef>typedef <type><name><name>struct</name> <name>_Unwind_Context</name></name></type> <name>_Unwind_Context</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_URC_OK</name></cpp:macro>			<cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_URC_FATAL_PHASE1_ERROR</name></cpp:macro>	<cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_URC_HANDLER_FOUND</name></cpp:macro>	<cpp:value>6</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_URC_INSTALL_CONTEXT</name></cpp:macro>	<cpp:value>7</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_URC_CONTINUE_UNWIND</name></cpp:macro>	<cpp:value>8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_URC_FAILURE</name></cpp:macro>		<cpp:value>9</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LJ_UEXCLASS</name></cpp:macro>		<cpp:value>0x4c55414a49543200ULL</cpp:value></cpp:define>	<comment type="block">/* LUAJIT2\0 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LJ_UEXCLASS_MAKE</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(LJ_UEXCLASS | (uint64_t)(c))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LJ_UEXCLASS_CHECK</name><parameter_list>(<parameter><type><name>cl</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(((cl) ^ LJ_UEXCLASS) &lt;= 0xff)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LJ_UEXCLASS_ERRCODE</name><parameter_list>(<parameter><type><name>cl</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((int)((cl) &amp; 0xff))</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>LJ_TARGET_ARM</name></expr></cpp:if>

<typedef>typedef <type><struct>struct <name>_Unwind_Exception</name>
<block>{
  <decl_stmt><decl><type><name>uint64_t</name></type> <name>exclass</name></decl>;</decl_stmt>
  <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>excleanup</name>)<parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>_Unwind_Exception</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
  <decl_stmt><decl><type><name>uintptr_t</name></type> <name>p1</name></decl>, <name>p2</name>;</decl_stmt>
}</block></struct></type> <name>__attribute__</name>((<name>__aligned__</name>)) <name>_Unwind_Exception</name>;</typedef>

<function_decl><type><specifier>extern</specifier> <name>uintptr_t</name></type> <name>_Unwind_GetCFA</name><parameter_list>(<parameter><decl><type><name>_Unwind_Context</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>_Unwind_SetGR</name><parameter_list>(<parameter><decl><type><name>_Unwind_Context</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>uintptr_t</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>_Unwind_SetIP</name><parameter_list>(<parameter><decl><type><name>_Unwind_Context</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>uintptr_t</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>_Unwind_DeleteException</name><parameter_list>(<parameter><decl><type><name>_Unwind_Exception</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>_Unwind_RaiseException</name><parameter_list>(<parameter><decl><type><name>_Unwind_Exception</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_UA_SEARCH_PHASE</name></cpp:macro>	<cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_UA_CLEANUP_PHASE</name></cpp:macro>	<cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_UA_HANDLER_FRAME</name></cpp:macro>	<cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_UA_FORCE_UNWIND</name></cpp:macro>	<cpp:value>8</cpp:value></cpp:define>

<comment type="block">/* DWARF2 personality handler referenced from interpreter .eh_frame. */</comment>
<function><type><name>LJ_FUNCA</name> <name>int</name></type> <name>lj_err_unwind_dwarf</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>version</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>actions</name></decl></parameter>,
  <parameter><decl><type><name>uint64_t</name></type> <name>uexclass</name></decl></parameter>, <parameter><decl><type><name>_Unwind_Exception</name> <modifier>*</modifier></type><name>uex</name></decl></parameter>, <parameter><decl><type><name>_Unwind_Context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>cf</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>version</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>_URC_FATAL_PHASE1_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>uexclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>cf</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><call><name>_Unwind_GetCFA</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>L</name> <operator>=</operator> <call><name>cframe_L</name><argument_list>(<argument><expr><name>cf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>actions</name> <operator>&amp;</operator> <name>_UA_SEARCH_PHASE</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_UNWIND_EXT</name></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><call><name>err_unwind</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>cf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>_URC_CONTINUE_UNWIND</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>LJ_UEXCLASS_CHECK</name><argument_list>(<argument><expr><name>uexclass</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>setstrV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>++</operator></expr></argument>, <argument><expr><call><name>lj_err_str</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LJ_ERR_ERRCPP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>_URC_HANDLER_FOUND</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>actions</name> <operator>&amp;</operator> <name>_UA_CLEANUP_PHASE</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>errcode</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>LJ_UEXCLASS_CHECK</name><argument_list>(<argument><expr><name>uexclass</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>errcode</name> <operator>=</operator> <call><name>LJ_UEXCLASS_ERRCODE</name><argument_list>(<argument><expr><name>uexclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>actions</name> <operator>&amp;</operator> <name>_UA_HANDLER_FRAME</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>_Unwind_DeleteException</name><argument_list>(<argument><expr><name>uex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>errcode</name> <operator>=</operator> <name>LUA_ERRRUN</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_UNWIND_EXT</name></expr></cpp:if>
    <expr_stmt><expr><name>cf</name> <operator>=</operator> <call><name>err_unwind</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>cf</name></expr></argument>, <argument><expr><name>errcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>actions</name> <operator>&amp;</operator> <name>_UA_FORCE_UNWIND</name><operator>)</operator></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>_URC_CONTINUE_UNWIND</name></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>cf</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>_Unwind_SetGR</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>LJ_TARGET_EHRETREG</name></expr></argument>, <argument><expr><name>errcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>_Unwind_SetIP</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><operator>(</operator><ternary><condition><expr><call><name>cframe_unwind_ff</name><argument_list>(<argument><expr><name>cf</name></expr></argument>)</argument_list></call></expr> ?</condition><then>
				     <expr><name>lj_vm_unwind_ff_eh</name></expr> </then><else>:
				     <expr><name>lj_vm_unwind_c_eh</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>_URC_INSTALL_CONTEXT</name></expr>;</return>
    </block_content>}</block></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_X86ORX64</name></expr></cpp:if>
    <if type="elseif">else if <condition>(<expr><operator>(</operator><name>actions</name> <operator>&amp;</operator> <name>_UA_HANDLER_FRAME</name><operator>)</operator></expr>)</condition> <block>{<block_content>
      <comment type="block">/* Workaround for ancient libgcc bug. Still present in RHEL 5.5. :-/
      ** Real fix: http://gcc.gnu.org/viewcvs/trunk/gcc/unwind-dw2.c?r1=121165&amp;r2=124837&amp;pathrev=153877&amp;diff_format=h
      */</comment>
      <expr_stmt><expr><call><name>_Unwind_SetGR</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>LJ_TARGET_EHRETREG</name></expr></argument>, <argument><expr><name>errcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>_Unwind_SetIP</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>lj_vm_unwind_rethrow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>_URC_INSTALL_CONTEXT</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <comment type="block">/* This is not the proper way to escape from the unwinder. We get away with
    ** it on non-x64 because the interpreter restores all callee-saved regs.
    */</comment>
    <expr_stmt><expr><call><name>lj_err_throw</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>errcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>_URC_CONTINUE_UNWIND</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_UNWIND_EXT</name></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name>__thread</name> <name>_Unwind_Exception</name></type> <name>static_uex</name></decl>;</decl_stmt>

<comment type="block">/* Raise DWARF2 exception. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>err_raise_ext</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>errcode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><name><name>static_uex</name><operator>.</operator><name>exclass</name></name> <operator>=</operator> <call><name>LJ_UEXCLASS_MAKE</name><argument_list>(<argument><expr><name>errcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>static_uex</name><operator>.</operator><name>excleanup</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>_Unwind_RaiseException</name><argument_list>(<argument><expr><operator>&amp;</operator><name>static_uex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* LJ_TARGET_ARM */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_US_VIRTUAL_UNWIND_FRAME</name></cpp:macro>	<cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_US_UNWIND_FRAME_STARTING</name></cpp:macro>	<cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_US_ACTION_MASK</name></cpp:macro>			<cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_US_FORCE_UNWIND</name></cpp:macro>		<cpp:value>8</cpp:value></cpp:define>

<typedef>typedef <type><name><name>struct</name> <name>_Unwind_Control_Block</name></name></type> <name>_Unwind_Control_Block</name>;</typedef>

<struct>struct <name>_Unwind_Control_Block</name> <block>{
  <decl_stmt><decl><type><name>uint64_t</name></type> <name>exclass</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name><name>misc</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></decl>;</decl_stmt>
}</block>;</struct>

<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>_Unwind_RaiseException</name><parameter_list>(<parameter><decl><type><name>_Unwind_Control_Block</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>__gnu_unwind_frame</name><parameter_list>(<parameter><decl><type><name>_Unwind_Control_Block</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>_Unwind_Context</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>_Unwind_VRS_Set</name><parameter_list>(<parameter><decl><type><name>_Unwind_Context</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>_Unwind_VRS_Get</name><parameter_list>(<parameter><decl><type><name>_Unwind_Context</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>uint32_t</name></type> <name>_Unwind_GetGR</name><parameter_list>(<parameter><decl><type><name>_Unwind_Context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>r</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>v</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>_Unwind_VRS_Get</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>v</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>_Unwind_SetGR</name><parameter_list>(<parameter><decl><type><name>_Unwind_Context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>r</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>v</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>_Unwind_VRS_Set</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>lj_vm_unwind_ext</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* ARM unwinder personality handler referenced from interpreter .ARM.extab. */</comment>
<function><type><name>LJ_FUNCA</name> <name>int</name></type> <name>lj_err_unwind_arm</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>_Unwind_Control_Block</name> <modifier>*</modifier></type><name>ucb</name></decl></parameter>,
			       <parameter><decl><type><name>_Unwind_Context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>cf</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><call><name>_Unwind_GetGR</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name> <init>= <expr><call><name>cframe_L</name><argument_list>(<argument><expr><name>cf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>errcode</name></decl>;</decl_stmt>

  <switch>switch <condition>(<expr><operator>(</operator><name>state</name> <operator>&amp;</operator> <name>_US_ACTION_MASK</name><operator>)</operator></expr>)</condition> <block>{<block_content>
  <case>case <expr><name>_US_VIRTUAL_UNWIND_FRAME</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>state</name> <operator>&amp;</operator> <name>_US_FORCE_UNWIND</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <return>return <expr><name>_URC_HANDLER_FOUND</name></expr>;</return>
  <case>case <expr><name>_US_UNWIND_FRAME_STARTING</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><call><name>LJ_UEXCLASS_CHECK</name><argument_list>(<argument><expr><name><name>ucb</name><operator>-&gt;</operator><name>exclass</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>errcode</name> <operator>=</operator> <call><name>LJ_UEXCLASS_ERRCODE</name><argument_list>(<argument><expr><name><name>ucb</name><operator>-&gt;</operator><name>exclass</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>errcode</name> <operator>=</operator> <name>LUA_ERRRUN</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>setstrV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>++</operator></expr></argument>, <argument><expr><call><name>lj_err_str</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LJ_ERR_ERRCPP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>cf</name> <operator>=</operator> <call><name>err_unwind</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>cf</name></expr></argument>, <argument><expr><name>errcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>state</name> <operator>&amp;</operator> <name>_US_FORCE_UNWIND</name><operator>)</operator> <operator>||</operator> <name>cf</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>_Unwind_SetGR</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>lj_vm_unwind_ext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>_Unwind_SetGR</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>ucb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>_Unwind_SetGR</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>errcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>_Unwind_SetGR</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><ternary><condition><expr><call><name>cframe_unwind_ff</name><argument_list>(<argument><expr><name>cf</name></expr></argument>)</argument_list></call></expr> ?</condition><then>
			    <expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>lj_vm_unwind_ff_eh</name></expr> </then><else>:
			    <expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>lj_vm_unwind_c_eh</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>_URC_INSTALL_CONTEXT</name></expr>;</return>
  <default>default:</default>
    <return>return <expr><name>_URC_FAILURE</name></expr>;</return>
  </block_content>}</block></switch>
  <if_stmt><if>if <condition>(<expr><call><name>__gnu_unwind_frame</name><argument_list>(<argument><expr><name>ucb</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>_URC_OK</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>_URC_FAILURE</name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name>_URC_CONTINUE_UNWIND</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_UNWIND_EXT</name></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name>__thread</name> <name>_Unwind_Control_Block</name></type> <name>static_uex</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>err_raise_ext</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>errcode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>static_uex</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>static_uex</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>static_uex</name><operator>.</operator><name>exclass</name></name> <operator>=</operator> <call><name>LJ_UEXCLASS_MAKE</name><argument_list>(<argument><expr><name>errcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>_Unwind_RaiseException</name><argument_list>(<argument><expr><operator>&amp;</operator><name>static_uex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* LJ_TARGET_ARM */</comment>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_ABI_WIN</name></expr></cpp:elif>

<comment type="block">/*
** Someone in Redmond owes me several days of my life. A lot of this is
** undocumented or just plain wrong on MSDN. Some of it can be gathered
** from 3rd party docs or must be found by trial-and-error. They really
** don't want you to write your own language-specific exception handler
** or to interact gracefully with MSVC. :-(
**
** Apparently MSVC doesn't call C++ destructors for foreign exceptions
** unless you compile your C++ code with /EHa. Unfortunately this means
** catch (...) also catches things like access violations. The use of
** _set_se_translator doesn't really help, because it requires /EHa, too.
*/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WIN32_LEAN_AND_MEAN</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_X64</name></expr></cpp:if>
<comment type="block">/* Taken from: http://www.nynaeve.net/?p=99 */</comment>
<typedef>typedef <type><struct>struct <name>UndocumentedDispatcherContext</name> <block>{
  <decl_stmt><decl><type><name>ULONG64</name></type> <name>ControlPc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ULONG64</name></type> <name>ImageBase</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRUNTIME_FUNCTION</name></type> <name>FunctionEntry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ULONG64</name></type> <name>EstablisherFrame</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ULONG64</name></type> <name>TargetIp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PCONTEXT</name></type> <name>ContextRecord</name></decl>;</decl_stmt>
  <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>LanguageHandler</name>)<parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
  <decl_stmt><decl><type><name>PVOID</name></type> <name>HandlerData</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PUNWIND_HISTORY_TABLE</name></type> <name>HistoryTable</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ULONG</name></type> <name>ScopeIndex</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ULONG</name></type> <name>Fill0</name></decl>;</decl_stmt>
}</block></struct></type> <name>UndocumentedDispatcherContext</name>;</typedef>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<typedef>typedef <type><name>void</name> <modifier>*</modifier></type><name>UndocumentedDispatcherContext</name>;</typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Another wild guess. */</comment>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>__DestructExceptionObject</name><parameter_list>(<parameter><decl><type><name>EXCEPTION_RECORD</name> <modifier>*</modifier></type><name>rec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nothrow</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_X64</name> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>MINGW_SDK_INIT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/* Workaround for broken MinGW64 declaration. */</comment>
<decl_stmt><decl><type><name>VOID</name></type> <name>RtlUnwindEx_FIXED</name><argument_list>(<argument><expr><name>PVOID</name></expr></argument>,<argument><expr><name>PVOID</name></expr></argument>,<argument><expr><name>PVOID</name></expr></argument>,<argument><expr><name>PVOID</name></expr></argument>,<argument><expr><name>PVOID</name></expr></argument>,<argument><expr><name>PVOID</name></expr></argument>)</argument_list> <name>asm</name><argument_list>(<argument><expr><literal type="string">"RtlUnwindEx"</literal></expr></argument>)</argument_list></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RtlUnwindEx</name></cpp:macro> <cpp:value>RtlUnwindEx_FIXED</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LJ_MSVC_EXCODE</name></cpp:macro>		<cpp:value>((DWORD)0xe06d7363)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LJ_GCC_EXCODE</name></cpp:macro>		<cpp:value>((DWORD)0x20474343)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LJ_EXCODE</name></cpp:macro>		<cpp:value>((DWORD)0xe24c4a00)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LJ_EXCODE_MAKE</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(LJ_EXCODE | (DWORD)(c))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LJ_EXCODE_CHECK</name><parameter_list>(<parameter><type><name>cl</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(((cl) ^ LJ_EXCODE) &lt;= 0xff)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LJ_EXCODE_ERRCODE</name><parameter_list>(<parameter><type><name>cl</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((int)((cl) &amp; 0xff))</cpp:value></cpp:define>

<comment type="block">/* Windows exception handler for interpreter frame. */</comment>
<function><type><name>LJ_FUNCA</name> <name>int</name></type> <name>lj_err_unwind_win</name><parameter_list>(<parameter><decl><type><name>EXCEPTION_RECORD</name> <modifier>*</modifier></type><name>rec</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>f</name></decl></parameter>, <parameter><decl><type><name>CONTEXT</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>UndocumentedDispatcherContext</name> <modifier>*</modifier></type><name>dispatch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_X64</name></expr></cpp:if>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>cf</name> <init>= <expr><name>f</name></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>cf</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>f</name> <operator>-</operator> <name>CFRAME_OFS_SEH</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <decl_stmt><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name> <init>= <expr><call><name>cframe_L</name><argument_list>(<argument><expr><name>cf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>errcode</name> <init>= <expr><ternary><condition><expr><call><name>LJ_EXCODE_CHECK</name><argument_list>(<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>ExceptionCode</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then>
		<expr><call><name>LJ_EXCODE_ERRCODE</name><argument_list>(<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>ExceptionCode</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>LUA_ERRRUN</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>rec</name><operator>-&gt;</operator><name>ExceptionFlags</name></name> <operator>&amp;</operator> <literal type="number">6</literal><operator>)</operator></expr>)</condition> <block>{<block_content>  <comment type="block">/* EH_UNWINDING|EH_EXIT_UNWIND */</comment>
    <comment type="block">/* Unwind internal frames. */</comment>
    <expr_stmt><expr><call><name>err_unwind</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>cf</name></expr></argument>, <argument><expr><name>errcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>cf2</name> <init>= <expr><call><name>err_unwind</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>cf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>cf2</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* We catch it, so start unwinding the upper frames. */</comment>
      <if_stmt><if>if <condition>(<expr><name><name>rec</name><operator>-&gt;</operator><name>ExceptionCode</name></name> <operator>==</operator> <name>LJ_MSVC_EXCODE</name> <operator>||</operator>
	  <name><name>rec</name><operator>-&gt;</operator><name>ExceptionCode</name></name> <operator>==</operator> <name>LJ_GCC_EXCODE</name></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_WINDOWS</name></expr></cpp:if>
	<expr_stmt><expr><call><name>__DestructExceptionObject</name><argument_list>(<argument><expr><name>rec</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>setstrV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>++</operator></expr></argument>, <argument><expr><call><name>lj_err_str</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LJ_ERR_ERRCPP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>LJ_EXCODE_CHECK</name><argument_list>(<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>ExceptionCode</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<comment type="block">/* Don't catch access violations etc. */</comment>
	<return>return <expr><literal type="number">1</literal></expr>;</return>  <comment type="block">/* ExceptionContinueSearch */</comment>
      </block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_X64</name></expr></cpp:if>
      <comment type="block">/* Unwind the stack and call all handlers for all lower C frames
      ** (including ourselves) again with EH_UNWINDING set. Then set
      ** rsp = cf, rax = errcode and jump to the specified target.
      */</comment>
      <expr_stmt><expr><call><name>RtlUnwindEx</name><argument_list>(<argument><expr><name>cf</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><ternary><condition><expr><operator>(</operator><call><name>cframe_unwind_ff</name><argument_list>(<argument><expr><name>cf2</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>errcode</name> <operator>!=</operator> <name>LUA_YIELD</name><operator>)</operator></expr> ?</condition><then>
			       <expr><name>lj_vm_unwind_ff_eh</name></expr> </then><else>:
			       <expr><name>lj_vm_unwind_c_eh</name></expr></else></ternary><operator>)</operator></expr></argument>,
		  <argument><expr><name>rec</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>errcode</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>dispatch</name><operator>-&gt;</operator><name>HistoryTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* RtlUnwindEx should never return. */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>dispatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* Call all handlers for all lower C frames (including ourselves) again
      ** with EH_UNWINDING set. Then call the specified function, passing cf
      ** and errcode.
      */</comment>
      <expr_stmt><expr><call><name>lj_vm_rtlunwind</name><argument_list>(<argument><expr><name>cf</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>rec</name></expr></argument>,
	<argument><expr><ternary><condition><expr><operator>(</operator><call><name>cframe_unwind_ff</name><argument_list>(<argument><expr><name>cf2</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>errcode</name> <operator>!=</operator> <name>LUA_YIELD</name><operator>)</operator></expr> ?</condition><then>
	<expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>lj_vm_unwind_ff</name></expr> </then><else>: <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>lj_vm_unwind_c</name></expr></else></ternary></expr></argument>, <argument><expr><name>errcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* lj_vm_rtlunwind does not return. */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>  <comment type="block">/* ExceptionContinueSearch */</comment>
</block_content>}</block></function>

<comment type="block">/* Raise Windows exception. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>err_raise_ext</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>errcode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>RaiseException</name><argument_list>(<argument><expr><call><name>LJ_EXCODE_MAKE</name><argument_list>(<argument><expr><name>errcode</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument> <comment type="block">/* EH_NONCONTINUABLE */</comment>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* -- Error handling ------------------------------------------------------ */</comment>

<comment type="block">/* Throw error. Find catch frame, unwind stack and continue. */</comment>
<function><type><name>LJ_NOINLINE</name> <name>void</name> <name>LJ_FASTCALL</name></type> <name>lj_err_throw</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>errcode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name> <init>= <expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lj_trace_abort</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setmref</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>jit_base</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>LUA_OK</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_UNWIND_EXT</name></expr></cpp:if>
  <expr_stmt><expr><call><name>err_raise_ext</name><argument_list>(<argument><expr><name>errcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/*
  ** A return from this function signals a corrupt C stack that cannot be
  ** unwound. We have no choice but to call the panic function and exit.
  **
  ** Usually this is caused by a C function without unwind information.
  ** This should never happen on x64, but may happen if you've manually
  ** enabled LUAJIT_UNWIND_EXTERNAL and forgot to recompile *every*
  ** non-C++ file with -funwind-tables.
  */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>panic</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>panic</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <block>{<block_content>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>cf</name> <init>= <expr><call><name>err_unwind</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>errcode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>cframe_unwind_ff</name><argument_list>(<argument><expr><name>cf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>lj_vm_unwind_ff</name><argument_list>(<argument><expr><call><name>cframe_raw</name><argument_list>(<argument><expr><name>cf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>lj_vm_unwind_c</name><argument_list>(<argument><expr><call><name>cframe_raw</name><argument_list>(<argument><expr><name>cf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>errcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Return string object for error message. */</comment>
<function><type><name>LJ_NOINLINE</name> <name>GCstr</name> <modifier>*</modifier></type><name>lj_err_str</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>ErrMsg</name></type> <name>em</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><call><name>lj_str_newz</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>err2msg</name><argument_list>(<argument><expr><name>em</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Out-of-memory error. */</comment>
<function><type><name>LJ_NOINLINE</name> <name>void</name></type> <name>lj_err_mem</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>L</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>LUA_ERRERR</name><operator>+</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* Don't touch the stack during lua_open. */</comment>
    <expr_stmt><expr><call><name>lj_vm_unwind_c</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>cframe</name></name></expr></argument>, <argument><expr><name>LUA_ERRMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>setstrV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>++</operator></expr></argument>, <argument><expr><call><name>lj_err_str</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LJ_ERR_ERRMEM</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lj_err_throw</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LUA_ERRMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Find error function for runtime errors. Requires an extra stack traversal. */</comment>
<function><type><specifier>static</specifier> <name>ptrdiff_t</name></type> <name>finderrfunc</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>frame</name> <init>= <expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>-</operator><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>bot</name> <init>= <expr><call><name>tvref</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call><operator>+</operator><name>LJ_FR2</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>cf</name> <init>= <expr><name><name>L</name><operator>-&gt;</operator><name>cframe</name></name></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><name>frame</name> <operator>&gt;</operator> <name>bot</name> <operator>&amp;&amp;</operator> <name>cf</name></expr>)</condition> <block>{<block_content>
    <while>while <condition>(<expr><call><name>cframe_nres</name><argument_list>(<argument><expr><call><name>cframe_raw</name><argument_list>(<argument><expr><name>cf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* cframe without frame? */</comment>
      <if_stmt><if>if <condition>(<expr><name>frame</name> <operator>&gt;=</operator> <call><name>restorestack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><call><name>cframe_nres</name><argument_list>(<argument><expr><name>cf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	<break>break;</break></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>cframe_errfunc</name><argument_list>(<argument><expr><name>cf</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* Error handler not inherited (-1)? */</comment>
	<return>return <expr><call><name>cframe_errfunc</name><argument_list>(<argument><expr><name>cf</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>cf</name> <operator>=</operator> <call><name>cframe_prev</name><argument_list>(<argument><expr><name>cf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Else unwind cframe and continue searching. */</comment>
      <if_stmt><if>if <condition>(<expr><name>cf</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
	<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></while>
    <switch>switch <condition>(<expr><call><name>frame_typep</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>FRAME_LUA</name></expr>:</case>
    <case>case <expr><name>FRAME_LUAP</name></expr>:</case>
      <expr_stmt><expr><name>frame</name> <operator>=</operator> <call><name>frame_prevl</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>FRAME_C</name></expr>:</case>
      <expr_stmt><expr><name>cf</name> <operator>=</operator> <call><name>cframe_prev</name><argument_list>(<argument><expr><name>cf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* fallthrough */</comment>
    <case>case <expr><name>FRAME_VARG</name></expr>:</case>
      <expr_stmt><expr><name>frame</name> <operator>=</operator> <call><name>frame_prevd</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>FRAME_CONT</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><call><name>frame_iscont_fficb</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>cf</name> <operator>=</operator> <call><name>cframe_prev</name><argument_list>(<argument><expr><name>cf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>frame</name> <operator>=</operator> <call><name>frame_prevd</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>FRAME_CP</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><call><name>cframe_canyield</name><argument_list>(<argument><expr><name>cf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>cframe_errfunc</name><argument_list>(<argument><expr><name>cf</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	<return>return <expr><call><name>cframe_errfunc</name><argument_list>(<argument><expr><name>cf</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>frame</name> <operator>=</operator> <call><name>frame_prevd</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>FRAME_PCALL</name></expr>:</case>
    <case>case <expr><name>FRAME_PCALLH</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><call><name>frame_func</name><argument_list>(<argument><expr><call><name>frame_prevd</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>c</name><operator>.</operator><name>ffid</name></name> <operator>==</operator> <name>FF_xpcall</name></expr>)</condition><block type="pseudo"><block_content>
	<return>return <expr><call><name>savestack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>frame_prevd</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* xpcall's errorfunc. */</comment>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    <default>default:</default>
      <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></switch>
  </block_content>}</block></while>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Runtime error. */</comment>
<function><type><name>LJ_NOINLINE</name> <name>void</name></type> <name>lj_err_run</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>ef</name> <init>= <expr><call><name>finderrfunc</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>ef</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>errfunc</name> <init>= <expr><call><name>restorestack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>ef</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>top</name> <init>= <expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>lj_trace_abort</name><argument_list>(<argument><expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tvisfunc</name><argument_list>(<argument><expr><name>errfunc</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>L</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>LUA_ERRERR</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>setstrV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>top</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>lj_err_str</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LJ_ERR_ERRERR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lj_err_throw</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LUA_ERRERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>LUA_ERRERR</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>top</name><operator>+</operator><name>LJ_FR2</name></expr></argument>, <argument><expr><name>top</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>top</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>errfunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>LJ_FR2</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>setnilV</name><argument_list>(<argument><expr><name>top</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name>top</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lj_vm_call</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>top</name></expr></argument>, <argument><expr><literal type="number">1</literal><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Stack: |errfunc|msg| -&gt; |msg| */</comment>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>lj_err_throw</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LUA_ERRRUN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Formatted runtime error message. */</comment>
<function><type><name>LJ_NORET</name> <name>LJ_NOINLINE</name> <specifier>static</specifier> <name>void</name></type> <name>err_msgv</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>ErrMsg</name></type> <name>em</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>va_list</name></type> <name>argp</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>argp</name></expr></argument>, <argument><expr><name>em</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>curr_funcisL</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <call><name>curr_topL</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>lj_strfmt_pushvf</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>err2msg</name><argument_list>(<argument><expr><name>em</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>argp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>argp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lj_debug_addloc</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lj_err_run</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Non-vararg variant for better calling conventions. */</comment>
<function><type><name>LJ_NOINLINE</name> <name>void</name></type> <name>lj_err_msg</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>ErrMsg</name></type> <name>em</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>err_msgv</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>em</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Lexer error. */</comment>
<function><type><name>LJ_NOINLINE</name> <name>void</name></type> <name>lj_err_lex</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>GCstr</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tok</name></decl></parameter>,
			    <parameter><decl><type><name>BCLine</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><name>ErrMsg</name></type> <name>em</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>argp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>char</name></type> <name><name>buff</name><index>[<expr><name>LUA_IDSIZE</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lj_debug_shortname</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>lj_strfmt_pushvf</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>err2msg</name><argument_list>(<argument><expr><name>em</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>argp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>lj_strfmt_pushf</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"%s:%d: %s"</literal></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>tok</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_strfmt_pushf</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>err2msg</name><argument_list>(<argument><expr><name>LJ_ERR_XNEAR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>lj_err_throw</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LUA_ERRSYNTAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Typecheck error for operands. */</comment>
<function><type><name>LJ_NOINLINE</name> <name>void</name></type> <name>lj_err_optype</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>o</name></decl></parameter>, <parameter><decl><type><name>ErrMsg</name></type> <name>opm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tname</name> <init>= <expr><call><name>lj_typename</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>opname</name> <init>= <expr><call><name>err2msg</name><argument_list>(<argument><expr><name>opm</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>curr_funcisL</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>GCproto</name> <modifier>*</modifier></type><name>pt</name> <init>= <expr><call><name>curr_proto</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BCIns</name> <modifier>*</modifier></type><name>pc</name> <init>= <expr><call><name>cframe_Lpc</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>kind</name> <init>= <expr><call><name>lj_debug_slotname</name><argument_list>(<argument><expr><name>pt</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><operator>(</operator><name>BCReg</name><operator>)</operator><operator>(</operator><name>o</name><operator>-</operator><name><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>oname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>kind</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>err_msgv</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LJ_ERR_BADOPRT</name></expr></argument>, <argument><expr><name>opname</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>, <argument><expr><name>oname</name></expr></argument>, <argument><expr><name>tname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>err_msgv</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LJ_ERR_BADOPRV</name></expr></argument>, <argument><expr><name>opname</name></expr></argument>, <argument><expr><name>tname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Typecheck error for ordered comparisons. */</comment>
<function><type><name>LJ_NOINLINE</name> <name>void</name></type> <name>lj_err_comp</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>o1</name></decl></parameter>, <parameter><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>o2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>t1</name> <init>= <expr><call><name>lj_typename</name><argument_list>(<argument><expr><name>o1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>t2</name> <init>= <expr><call><name>lj_typename</name><argument_list>(<argument><expr><name>o2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>err_msgv</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><ternary><condition><expr><name>t1</name> <operator>==</operator> <name>t2</name></expr> ?</condition><then> <expr><name>LJ_ERR_BADCMPV</name></expr> </then><else>: <expr><name>LJ_ERR_BADCMPT</name></expr></else></ternary></expr></argument>, <argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* This assumes the two "boolean" entries are commoned by the C compiler. */</comment>
</block_content>}</block></function>

<comment type="block">/* Typecheck error for __call. */</comment>
<function><type><name>LJ_NOINLINE</name> <name>void</name></type> <name>lj_err_optype_call</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>TValue</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Gross hack if lua_[p]call or pcall/xpcall fail for a non-callable object:
  ** L-&gt;base still points to the caller. So add a dummy frame with L instead
  ** of a function. See lua_getstack().
  */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>BCIns</name> <modifier>*</modifier></type><name>pc</name> <init>= <expr><call><name>cframe_Lpc</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>ptrdiff_t</name><operator>)</operator><name>pc</name> <operator>&amp;</operator> <name>FRAME_TYPE</name><operator>)</operator> <operator>!=</operator> <name>FRAME_LUA</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tname</name> <init>= <expr><call><name>lj_typename</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>LJ_FR2</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>o</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>setframe_pc</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setframe_gc</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><call><name>obj2gco</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LJ_TTHREAD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <name>o</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>err_msgv</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LJ_ERR_BADCALL</name></expr></argument>, <argument><expr><name>tname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>lj_err_optype</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><name>LJ_ERR_OPCALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Error in context of caller. */</comment>
<function><type><name>LJ_NOINLINE</name> <name>void</name></type> <name>lj_err_callermsg</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>frame</name> <init>= <expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>pframe</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>frame_islua</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>pframe</name> <operator>=</operator> <call><name>frame_prevl</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>frame_iscont</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>frame_iscont_fficb</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>pframe</name> <operator>=</operator> <name>frame</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>frame</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>pframe</name> <operator>=</operator> <call><name>frame_prevd</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>
      <comment type="block">/* Remove frame for FFI metamethods. */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>frame_func</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>c</name><operator>.</operator><name>ffid</name></name> <operator>&gt;=</operator> <name>FF_ffi_meta___index</name> <operator>&amp;&amp;</operator>
	  <call><name>frame_func</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>c</name><operator>.</operator><name>ffid</name></name> <operator>&lt;=</operator> <name>FF_ffi_meta___tostring</name></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <name>pframe</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name>frame</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>setcframe_pc</name><argument_list>(<argument><expr><call><name>cframe_raw</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>cframe</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>frame_contpc</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>lj_debug_addloc</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>pframe</name></expr></argument>, <argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lj_err_run</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Formatted error in context of caller. */</comment>
<function><type><name>LJ_NOINLINE</name> <name>void</name></type> <name>lj_err_callerv</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>ErrMsg</name></type> <name>em</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>va_list</name></type> <name>argp</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>argp</name></expr></argument>, <argument><expr><name>em</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>lj_strfmt_pushvf</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>err2msg</name><argument_list>(<argument><expr><name>em</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>argp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>argp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lj_err_callermsg</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Error in context of caller. */</comment>
<function><type><name>LJ_NOINLINE</name> <name>void</name></type> <name>lj_err_caller</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>ErrMsg</name></type> <name>em</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>lj_err_callermsg</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>err2msg</name><argument_list>(<argument><expr><name>em</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Argument error message. */</comment>
<function><type><name>LJ_NORET</name> <name>LJ_NOINLINE</name> <specifier>static</specifier> <name>void</name></type> <name>err_argmsg</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>narg</name></decl></parameter>,
					    <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname</name> <init>= <expr><literal type="string">"?"</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ftype</name> <init>= <expr><call><name>lj_debug_funcname</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>fname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>narg</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>narg</name></expr></argument> &gt;</argument_list></name> <name>LUA_REGISTRYINDEX</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>narg</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>-</operator> <name><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>)</operator> <operator>+</operator> <name>narg</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>ftype</name> <operator>&amp;&amp;</operator> <name><name>ftype</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'h'</literal> <operator>&amp;&amp;</operator> <operator>--</operator><name>narg</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* Check for "method". */</comment>
    <expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>lj_strfmt_pushf</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>err2msg</name><argument_list>(<argument><expr><name>LJ_ERR_BADSELF</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>lj_strfmt_pushf</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>err2msg</name><argument_list>(<argument><expr><name>LJ_ERR_BADARG</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>narg</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  <expr_stmt><expr><call><name>lj_err_callermsg</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Formatted argument error. */</comment>
<function><type><name>LJ_NOINLINE</name> <name>void</name></type> <name>lj_err_argv</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>narg</name></decl></parameter>, <parameter><decl><type><name>ErrMsg</name></type> <name>em</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>va_list</name></type> <name>argp</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>argp</name></expr></argument>, <argument><expr><name>em</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>lj_strfmt_pushvf</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>err2msg</name><argument_list>(<argument><expr><name>em</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>argp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>argp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>err_argmsg</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>narg</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Argument error. */</comment>
<function><type><name>LJ_NOINLINE</name> <name>void</name></type> <name>lj_err_arg</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>narg</name></decl></parameter>, <parameter><decl><type><name>ErrMsg</name></type> <name>em</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>err_argmsg</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>narg</name></expr></argument>, <argument><expr><call><name>err2msg</name><argument_list>(<argument><expr><name>em</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Typecheck error for arguments. */</comment>
<function><type><name>LJ_NOINLINE</name> <name>void</name></type> <name>lj_err_argtype</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>narg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>xname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tname</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>msg</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>narg</name> <operator>&lt;=</operator> <name>LUA_REGISTRYINDEX</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>narg</name> <operator>&gt;=</operator> <name>LUA_GLOBALSINDEX</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>tname</name> <operator>=</operator> <name><name>lj_obj_itypename</name><index>[<expr><operator>~</operator><name>LJ_TTAB</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <decl_stmt><decl><type><name>GCfunc</name> <modifier>*</modifier></type><name>fn</name> <init>= <expr><call><name>curr_func</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><name>LUA_GLOBALSINDEX</name> <operator>-</operator> <name>narg</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&lt;=</operator> <name><name>fn</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>nupvalues</name></name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>tname</name> <operator>=</operator> <call><name>lj_typename</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fn</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>upvalue</name><index>[<expr><name>idx</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
      <else>else<block type="pseudo"><block_content>
	<expr_stmt><expr><name>tname</name> <operator>=</operator> <name><name>lj_obj_typename</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><ternary><condition><expr><name>narg</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>+</operator> <name>narg</name></expr> </then><else>: <expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>+</operator> <name>narg</name><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>tname</name> <operator>=</operator> <ternary><condition><expr><name>o</name> <operator>&lt;</operator> <name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr> ?</condition><then> <expr><call><name>lj_typename</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name><name>lj_obj_typename</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></else></ternary></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>lj_strfmt_pushf</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>err2msg</name><argument_list>(<argument><expr><name>LJ_ERR_BADTYPE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>xname</name></expr></argument>, <argument><expr><name>tname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>err_argmsg</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>narg</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Typecheck error for arguments. */</comment>
<function><type><name>LJ_NOINLINE</name> <name>void</name></type> <name>lj_err_argt</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>narg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>lj_err_argtype</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>narg</name></expr></argument>, <argument><expr><name><name>lj_obj_typename</name><index>[<expr><name>tt</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* -- Public error handling API ------------------------------------------- */</comment>

<function><type><name>LUA_API</name> <name>lua_CFunction</name></type> <name>lua_atpanic</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>lua_CFunction</name></type> <name>panicf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>lua_CFunction</name></type> <name>old</name> <init>= <expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>panic</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>panic</name> <operator>=</operator> <name>panicf</name></expr>;</expr_stmt>
  <return>return <expr><name>old</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Forwarders for the public API (C calling convention and no LJ_NORET). */</comment>
<function><type><name>LUA_API</name> <name>int</name></type> <name>lua_error</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>lj_err_run</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* unreachable */</comment>
</block_content>}</block></function>

<function><type><name>LUALIB_API</name> <name>int</name></type> <name>luaL_argerror</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>narg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>err_argmsg</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>narg</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* unreachable */</comment>
</block_content>}</block></function>

<function><type><name>LUALIB_API</name> <name>int</name></type> <name>luaL_typerror</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>narg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>xname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>lj_err_argtype</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>narg</name></expr></argument>, <argument><expr><name>xname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* unreachable */</comment>
</block_content>}</block></function>

<function><type><name>LUALIB_API</name> <name>void</name></type> <name>luaL_where</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>size</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>frame</name> <init>= <expr><call><name>lj_debug_frame</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lj_debug_addloc</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>frame</name></expr></argument>, <argument><expr><ternary><condition><expr><name>size</name></expr> ?</condition><then> <expr><name>frame</name><operator>+</operator><name>size</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>LUALIB_API</name> <name>int</name></type> <name>luaL_error</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>va_list</name></type> <name>argp</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>argp</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>lj_strfmt_pushvf</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>argp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>argp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lj_err_callermsg</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* unreachable */</comment>
</block_content>}</block></function>

</unit>
