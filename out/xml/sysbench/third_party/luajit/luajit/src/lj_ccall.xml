<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/sysbench/third_party/luajit/luajit/src/lj_ccall.c"><comment type="block">/*
** FFI C call handling.
** Copyright (C) 2005-2020 Mike Pall. See Copyright Notice in luajit.h
*/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_obj.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_gc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_err.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_tab.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_ctype.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_cconv.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_cdata.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_ccall.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_trace.h"</cpp:file></cpp:include>

<comment type="block">/* Target-specific handling of register arguments. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_X86</name></expr></cpp:if>
<comment type="block">/* -- x86 calling conventions --------------------------------------------- */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_ABI_WIN</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_STRUCTRET</name></cpp:macro> \
  <comment type="block">/* Return structs bigger than 8 by reference (on stack only). */</comment> \
  <cpp:value>cc-&gt;retref = (sz &gt; 8); \
  if (cc-&gt;retref) cc-&gt;stack[nsp++] = (GPRArg)dp;</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_COMPLEXRET</name></cpp:macro> <cpp:value>CCALL_HANDLE_STRUCTRET</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_OSX</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_STRUCTRET</name></cpp:macro> \
  <comment type="block">/* Return structs of size 1, 2, 4 or 8 in registers. */</comment> \
  <cpp:value>cc-&gt;retref = !(sz == 1 || sz == 2 || sz == 4 || sz == 8); \
  if (cc-&gt;retref) { \
    if (ngpr &lt; maxgpr) \
      cc-&gt;gpr[ngpr++] = (GPRArg)dp; \
    else \
      cc-&gt;stack[nsp++] = (GPRArg)dp; \
  } else {  <comment type="block">/* Struct with single FP field ends up in FPR. */</comment> \
    cc-&gt;resx87 = ccall_classify_struct(cts, ctr); \
  }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_STRUCTRET2</name></cpp:macro> \
  <cpp:value>if (cc-&gt;resx87) sp = (uint8_t *)&amp;cc-&gt;fpr[0]; \
  memcpy(dp, sp, ctr-&gt;size);</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_STRUCTRET</name></cpp:macro> \
  <cpp:value>cc-&gt;retref = 1;  <comment type="block">/* Return all structs by reference (in reg or on stack). */</comment> \
  if (ngpr &lt; maxgpr) \
    cc-&gt;gpr[ngpr++] = (GPRArg)dp; \
  else \
    cc-&gt;stack[nsp++] = (GPRArg)dp;</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_COMPLEXRET</name></cpp:macro> \
  <comment type="block">/* Return complex float in GPRs and complex double by reference. */</comment> \
  <cpp:value>cc-&gt;retref = (sz &gt; 8); \
  if (cc-&gt;retref) { \
    if (ngpr &lt; maxgpr) \
      cc-&gt;gpr[ngpr++] = (GPRArg)dp; \
    else \
      cc-&gt;stack[nsp++] = (GPRArg)dp; \
  }</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_COMPLEXRET2</name></cpp:macro> \
  <cpp:value>if (!cc-&gt;retref) \
    *(int64_t *)dp = *(int64_t *)sp;</cpp:value></cpp:define>  <comment type="block">/* Copy complex float from GPRs. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_STRUCTARG</name></cpp:macro> \
  <cpp:value>ngpr = maxgpr;</cpp:value></cpp:define>  <comment type="block">/* Pass all structs by value on the stack. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_COMPLEXARG</name></cpp:macro> \
  <cpp:value>isfp = 1;</cpp:value></cpp:define>  <comment type="block">/* Pass complex by value on stack. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_REGARG</name></cpp:macro> \
  <cpp:value>if (!isfp) {  <comment type="block">/* Only non-FP values may be passed in registers. */</comment> \
    if (n &gt; 1) {  <comment type="block">/* Anything &gt; 32 bit is passed on the stack. */</comment> \
      if (!LJ_ABI_WIN) ngpr = maxgpr;  <comment type="block">/* Prevent reordering. */</comment> \
    } else if (ngpr + 1 &lt;= maxgpr) { \
      dp = &amp;cc-&gt;gpr[ngpr]; \
      ngpr += n; \
      goto done; \
    } \
  }</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_X64</name> <operator>&amp;&amp;</operator> <name>LJ_ABI_WIN</name></expr></cpp:elif>
<comment type="block">/* -- Windows/x64 calling conventions ------------------------------------- */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_STRUCTRET</name></cpp:macro> \
  <comment type="block">/* Return structs of size 1, 2, 4 or 8 in a GPR. */</comment> \
  <cpp:value>cc-&gt;retref = !(sz == 1 || sz == 2 || sz == 4 || sz == 8); \
  if (cc-&gt;retref) cc-&gt;gpr[ngpr++] = (GPRArg)dp;</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_COMPLEXRET</name></cpp:macro> <cpp:value>CCALL_HANDLE_STRUCTRET</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_COMPLEXRET2</name></cpp:macro> \
  <cpp:value>if (!cc-&gt;retref) \
    *(int64_t *)dp = *(int64_t *)sp;</cpp:value></cpp:define>  <comment type="block">/* Copy complex float from GPRs. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_STRUCTARG</name></cpp:macro> \
  <comment type="block">/* Pass structs of size 1, 2, 4 or 8 in a GPR by value. */</comment> \
  <cpp:value>if (!(sz == 1 || sz == 2 || sz == 4 || sz == 8)) { \
    rp = cdataptr(lj_cdata_new(cts, did, sz)); \
    sz = CTSIZE_PTR;  <comment type="block">/* Pass all other structs by reference. */</comment> \
  }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_COMPLEXARG</name></cpp:macro> \
  <comment type="block">/* Pass complex float in a GPR and complex double by reference. */</comment> \
  <cpp:value>if (sz != 2*sizeof(float)) { \
    rp = cdataptr(lj_cdata_new(cts, did, sz)); \
    sz = CTSIZE_PTR; \
  }</cpp:value></cpp:define>

<comment type="block">/* Windows/x64 argument registers are strictly positional (use ngpr). */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_REGARG</name></cpp:macro> \
  <cpp:value>if (isfp) { \
    if (ngpr &lt; maxgpr) { dp = &amp;cc-&gt;fpr[ngpr++]; nfpr = ngpr; goto done; } \
  } else { \
    if (ngpr &lt; maxgpr) { dp = &amp;cc-&gt;gpr[ngpr++]; goto done; } \
  }</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_X64</name></expr></cpp:elif>
<comment type="block">/* -- POSIX/x64 calling conventions --------------------------------------- */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_STRUCTRET</name></cpp:macro> \
  <cpp:value>int rcl[2]; rcl[0] = rcl[1] = 0; \
  if (ccall_classify_struct(cts, ctr, rcl, 0)) { \
    cc-&gt;retref = 1;  <comment type="block">/* Return struct by reference. */</comment> \
    cc-&gt;gpr[ngpr++] = (GPRArg)dp; \
  } else { \
    cc-&gt;retref = 0;  <comment type="block">/* Return small structs in registers. */</comment> \
  }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_STRUCTRET2</name></cpp:macro> \
  <cpp:value>int rcl[2]; rcl[0] = rcl[1] = 0; \
  ccall_classify_struct(cts, ctr, rcl, 0); \
  ccall_struct_ret(cc, rcl, dp, ctr-&gt;size);</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_COMPLEXRET</name></cpp:macro> \
  <comment type="block">/* Complex values are returned in one or two FPRs. */</comment> \
  <cpp:value>cc-&gt;retref = 0;</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_COMPLEXRET2</name></cpp:macro> \
  <cpp:value>if (ctr-&gt;size == 2*sizeof(float)) {  <comment type="block">/* Copy complex float from FPR. */</comment> \
    *(int64_t *)dp = cc-&gt;fpr[0].l[0]; \
  } else {  <comment type="block">/* Copy non-contiguous complex double from FPRs. */</comment> \
    ((int64_t *)dp)[0] = cc-&gt;fpr[0].l[0]; \
    ((int64_t *)dp)[1] = cc-&gt;fpr[1].l[0]; \
  }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_STRUCTARG</name></cpp:macro> \
  <cpp:value>int rcl[2]; rcl[0] = rcl[1] = 0; \
  if (!ccall_classify_struct(cts, d, rcl, 0)) { \
    cc-&gt;nsp = nsp; cc-&gt;ngpr = ngpr; cc-&gt;nfpr = nfpr; \
    if (ccall_struct_arg(cc, cts, d, rcl, o, narg)) goto err_nyi; \
    nsp = cc-&gt;nsp; ngpr = cc-&gt;ngpr; nfpr = cc-&gt;nfpr; \
    continue; \
  }</cpp:value></cpp:define>  <comment type="block">/* Pass all other structs by value on stack. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_COMPLEXARG</name></cpp:macro> \
  <cpp:value>isfp = 2;</cpp:value></cpp:define>  <comment type="block">/* Pass complex in FPRs or on stack. Needs postprocessing. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_REGARG</name></cpp:macro> \
  <cpp:value>if (isfp) {  <comment type="block">/* Try to pass argument in FPRs. */</comment> \
    int n2 = ctype_isvector(d-&gt;info) ? 1 : n; \
    if (nfpr + n2 &lt;= CCALL_NARG_FPR) { \
      dp = &amp;cc-&gt;fpr[nfpr]; \
      nfpr += n2; \
      goto done; \
    } \
  } else {  <comment type="block">/* Try to pass argument in GPRs. */</comment> \
    <comment type="block">/* Note that reordering is explicitly allowed in the x64 ABI. */</comment> \
    if (n &lt;= 2 &amp;&amp; ngpr + n &lt;= maxgpr) { \
      dp = &amp;cc-&gt;gpr[ngpr]; \
      ngpr += n; \
      goto done; \
    } \
  }</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_ARM</name></expr></cpp:elif>
<comment type="block">/* -- ARM calling conventions --------------------------------------------- */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_ABI_SOFTFP</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_STRUCTRET</name></cpp:macro> \
  <comment type="block">/* Return structs of size &lt;= 4 in a GPR. */</comment> \
  <cpp:value>cc-&gt;retref = !(sz &lt;= 4); \
  if (cc-&gt;retref) cc-&gt;gpr[ngpr++] = (GPRArg)dp;</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_COMPLEXRET</name></cpp:macro> \
  <cpp:value>cc-&gt;retref = 1;  <comment type="block">/* Return all complex values by reference. */</comment> \
  cc-&gt;gpr[ngpr++] = (GPRArg)dp;</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_COMPLEXRET2</name></cpp:macro> \
  <cpp:value>UNUSED(dp);</cpp:value></cpp:define> <comment type="block">/* Nothing to do. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_STRUCTARG</name></cpp:macro></cpp:define> \
  <comment type="block">/* Pass all structs by value in registers and/or on the stack. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_COMPLEXARG</name></cpp:macro></cpp:define> \
  <comment type="block">/* Pass complex by value in 2 or 4 GPRs. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_REGARG_FP1</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_REGARG_FP2</name></cpp:macro></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_STRUCTRET</name></cpp:macro> \
  <cpp:value>cc-&gt;retref = !ccall_classify_struct(cts, ctr, ct); \
  if (cc-&gt;retref) cc-&gt;gpr[ngpr++] = (GPRArg)dp;</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_STRUCTRET2</name></cpp:macro> \
  <cpp:value>if (ccall_classify_struct(cts, ctr, ct) &gt; 1) sp = (uint8_t *)&amp;cc-&gt;fpr[0]; \
  memcpy(dp, sp, ctr-&gt;size);</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_COMPLEXRET</name></cpp:macro> \
  <cpp:value>if (!(ct-&gt;info &amp; CTF_VARARG)) cc-&gt;retref = 0;</cpp:value></cpp:define>  <comment type="block">/* Return complex in FPRs. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_COMPLEXRET2</name></cpp:macro> \
  <cpp:value>if (!(ct-&gt;info &amp; CTF_VARARG)) memcpy(dp, &amp;cc-&gt;fpr[0], ctr-&gt;size);</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_STRUCTARG</name></cpp:macro> \
  <cpp:value>isfp = (ccall_classify_struct(cts, d, ct) &gt; 1);</cpp:value></cpp:define>
  <comment type="block">/* Pass all structs by value in registers and/or on the stack. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_COMPLEXARG</name></cpp:macro> \
  <cpp:value>isfp = 1;</cpp:value></cpp:define>  <comment type="block">/* Pass complex by value in FPRs or on stack. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_REGARG_FP1</name></cpp:macro> \
  <cpp:value>if (isfp &amp;&amp; !(ct-&gt;info &amp; CTF_VARARG)) { \
    if ((d-&gt;info &amp; CTF_ALIGN) &gt; CTALIGN_PTR) { \
      if (nfpr + (n &gt;&gt; 1) &lt;= CCALL_NARG_FPR) { \
	dp = &amp;cc-&gt;fpr[nfpr]; \
	nfpr += (n &gt;&gt; 1); \
	goto done; \
      } \
    } else { \
      if (sz &gt; 1 &amp;&amp; fprodd != nfpr) fprodd = 0; \
      if (fprodd) { \
	if (2*nfpr+n &lt;= 2*CCALL_NARG_FPR+1) { \
	  dp = (void *)&amp;cc-&gt;fpr[fprodd-1].f[1]; \
	  nfpr += (n &gt;&gt; 1); \
	  if ((n &amp; 1)) fprodd = 0; else fprodd = nfpr-1; \
	  goto done; \
	} \
      } else { \
	if (2*nfpr+n &lt;= 2*CCALL_NARG_FPR) { \
	  dp = (void *)&amp;cc-&gt;fpr[nfpr]; \
	  nfpr += (n &gt;&gt; 1); \
	  if ((n &amp; 1)) fprodd = ++nfpr; else fprodd = 0; \
	  goto done; \
	} \
      } \
    } \
    fprodd = 0;  <comment type="block">/* No reordering after the first FP value is on stack. */</comment> \
  } else {</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_REGARG_FP2</name></cpp:macro>	<cpp:value>}</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_REGARG</name></cpp:macro> \
  <cpp:value>CCALL_HANDLE_REGARG_FP1 \
  if ((d-&gt;info &amp; CTF_ALIGN) &gt; CTALIGN_PTR) { \
    if (ngpr &lt; maxgpr) \
      ngpr = (ngpr + 1u) &amp; ~1u;  <comment type="block">/* Align to regpair. */</comment> \
  } \
  if (ngpr &lt; maxgpr) { \
    dp = &amp;cc-&gt;gpr[ngpr]; \
    if (ngpr + n &gt; maxgpr) { \
      nsp += ngpr + n - maxgpr;  <comment type="block">/* Assumes contiguous gpr/stack fields. */</comment> \
      if (nsp &gt; CCALL_MAXSTACK) goto err_nyi;  <comment type="block">/* Too many arguments. */</comment> \
      ngpr = maxgpr; \
    } else { \
      ngpr += n; \
    } \
    goto done; \
  } CCALL_HANDLE_REGARG_FP2</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_RET</name></cpp:macro> \
  <cpp:value>if ((ct-&gt;info &amp; CTF_VARARG)) sp = (uint8_t *)&amp;cc-&gt;gpr[0];</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_ARM64</name></expr></cpp:elif>
<comment type="block">/* -- ARM64 calling conventions ------------------------------------------- */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_STRUCTRET</name></cpp:macro> \
  <cpp:value>cc-&gt;retref = !ccall_classify_struct(cts, ctr); \
  if (cc-&gt;retref) cc-&gt;retp = dp;</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_STRUCTRET2</name></cpp:macro> \
  <cpp:value>unsigned int cl = ccall_classify_struct(cts, ctr); \
  if ((cl &amp; 4)) { <comment type="block">/* Combine float HFA from separate registers. */</comment> \
    CTSize i = (cl &gt;&gt; 8) - 1; \
    do { ((uint32_t *)dp)[i] = cc-&gt;fpr[i].lo; } while (i--); \
  } else { \
    if (cl &gt; 1) sp = (uint8_t *)&amp;cc-&gt;fpr[0]; \
    memcpy(dp, sp, ctr-&gt;size); \
  }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_COMPLEXRET</name></cpp:macro> \
  <comment type="block">/* Complex values are returned in one or two FPRs. */</comment> \
  <cpp:value>cc-&gt;retref = 0;</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_COMPLEXRET2</name></cpp:macro> \
  <cpp:value>if (ctr-&gt;size == 2*sizeof(float)) {  <comment type="block">/* Copy complex float from FPRs. */</comment> \
    ((float *)dp)[0] = cc-&gt;fpr[0].f; \
    ((float *)dp)[1] = cc-&gt;fpr[1].f; \
  } else {  <comment type="block">/* Copy complex double from FPRs. */</comment> \
    ((double *)dp)[0] = cc-&gt;fpr[0].d; \
    ((double *)dp)[1] = cc-&gt;fpr[1].d; \
  }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_STRUCTARG</name></cpp:macro> \
  <cpp:value>unsigned int cl = ccall_classify_struct(cts, d); \
  if (cl == 0) {  <comment type="block">/* Pass struct by reference. */</comment> \
    rp = cdataptr(lj_cdata_new(cts, did, sz)); \
    sz = CTSIZE_PTR; \
  } else if (cl &gt; 1) {  <comment type="block">/* Pass struct in FPRs or on stack. */</comment> \
    isfp = (cl &amp; 4) ? 2 : 1; \
  }</cpp:value></cpp:define>  <comment type="block">/* else: Pass struct in GPRs or on stack. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_COMPLEXARG</name></cpp:macro> \
  <comment type="block">/* Pass complex by value in separate (!) FPRs or on stack. */</comment> \
  <cpp:value>isfp = sz == 2*sizeof(float) ? 2 : 1;</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_REGARG</name></cpp:macro> \
  <cpp:value>if (LJ_TARGET_IOS &amp;&amp; isva) { \
    <comment type="block">/* IOS: All variadic arguments are on the stack. */</comment> \
  } else if (isfp) {  <comment type="block">/* Try to pass argument in FPRs. */</comment> \
    int n2 = ctype_isvector(d-&gt;info) ? 1 : \
	     isfp == 1 ? n : (d-&gt;size &gt;&gt; (4-isfp)); \
    if (nfpr + n2 &lt;= CCALL_NARG_FPR) { \
      dp = &amp;cc-&gt;fpr[nfpr]; \
      nfpr += n2; \
      goto done; \
    } else { \
      nfpr = CCALL_NARG_FPR;  <comment type="block">/* Prevent reordering. */</comment> \
      if (LJ_TARGET_IOS &amp;&amp; d-&gt;size &lt; 8) goto err_nyi; \
    } \
  } else {  <comment type="block">/* Try to pass argument in GPRs. */</comment> \
    if (!LJ_TARGET_IOS &amp;&amp; (d-&gt;info &amp; CTF_ALIGN) &gt; CTALIGN_PTR) \
      ngpr = (ngpr + 1u) &amp; ~1u;  <comment type="block">/* Align to regpair. */</comment> \
    if (ngpr + n &lt;= maxgpr) { \
      dp = &amp;cc-&gt;gpr[ngpr]; \
      ngpr += n; \
      goto done; \
    } else { \
      ngpr = maxgpr;  <comment type="block">/* Prevent reordering. */</comment> \
      if (LJ_TARGET_IOS &amp;&amp; d-&gt;size &lt; 8) goto err_nyi; \
    } \
  }</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_BE</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_RET</name></cpp:macro> \
  <cpp:value>if (ctype_isfp(ctr-&gt;info) &amp;&amp; ctr-&gt;size == sizeof(float)) \
    sp = (uint8_t *)&amp;cc-&gt;fpr[0].f;</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_PPC</name></expr></cpp:elif>
<comment type="block">/* -- PPC calling conventions --------------------------------------------- */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_STRUCTRET</name></cpp:macro> \
  <cpp:value>cc-&gt;retref = 1;  <comment type="block">/* Return all structs by reference. */</comment> \
  cc-&gt;gpr[ngpr++] = (GPRArg)dp;</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_COMPLEXRET</name></cpp:macro> \
  <comment type="block">/* Complex values are returned in 2 or 4 GPRs. */</comment> \
  <cpp:value>cc-&gt;retref = 0;</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_COMPLEXRET2</name></cpp:macro> \
  <cpp:value>memcpy(dp, sp, ctr-&gt;size);</cpp:value></cpp:define>  <comment type="block">/* Copy complex from GPRs. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_STRUCTARG</name></cpp:macro> \
  <cpp:value>rp = cdataptr(lj_cdata_new(cts, did, sz)); \
  sz = CTSIZE_PTR;</cpp:value></cpp:define>  <comment type="block">/* Pass all structs by reference. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_COMPLEXARG</name></cpp:macro></cpp:define> \
  <comment type="block">/* Pass complex by value in 2 or 4 GPRs. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_GPR</name></cpp:macro> \
  <comment type="block">/* Try to pass argument in GPRs. */</comment> \
  <cpp:value>if (n &gt; 1) { \
    lua_assert(n == 2 || n == 4);  <comment type="block">/* int64_t or complex (float). */</comment> \
    if (ctype_isinteger(d-&gt;info) || ctype_isfp(d-&gt;info)) \
      ngpr = (ngpr + 1u) &amp; ~1u;  <comment type="block">/* Align int64_t to regpair. */</comment> \
    else if (ngpr + n &gt; maxgpr) \
      ngpr = maxgpr;  <comment type="block">/* Prevent reordering. */</comment> \
  } \
  if (ngpr + n &lt;= maxgpr) { \
    dp = &amp;cc-&gt;gpr[ngpr]; \
    ngpr += n; \
    goto done; \
  } \

#if LJ_ARCH_PPC64</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_REGARG</name></cpp:macro> \
  <cpp:value>if (isva) {  <comment type="block">/* only GPRs will be used on C ellipsis operator */</comment> \
    goto gpr; \
  } \
  else { \
    if (isfp) {  <comment type="block">/* Try to pass argument in FPRs. */</comment> \
      if (nfpr + 1 &lt;= CCALL_NARG_FPR) { \
	dp = &amp;cc-&gt;fpr[nfpr]; \
	nfpr += 1; \
	d = ctype_get(cts, CTID_DOUBLE);  <comment type="block">/* FPRs always hold doubles. */</comment> \
	if (ngpr + 1 &lt;= maxgpr) \
	  ngpr += 1;  <comment type="block">/* align GPRs */</comment> \
	else if (nsp + 1 &lt;= CCALL_MAXSTACK) \
	  nsp += 1; <comment type="block">/* align save area slots */</comment> \
	else \
	  goto err_nyi; <comment type="block">/* Too many args */</comment> \
	goto done; \
      } \
    } else {  <comment type="block">/* Try to pass argument in GPRs. */</comment> \
  gpr: \
      CCALL_HANDLE_GPR \
    } \
  }</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>	<comment type="block">/* 32 bits */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_ABI_SOFTFP</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_REGARG</name></cpp:macro>  <cpp:value>CCALL_HANDLE_GPR</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_REGARG</name></cpp:macro> \
  <cpp:value>if (isfp) {  <comment type="block">/* Try to pass argument in FPRs. */</comment> \
    if (nfpr + 1 &lt;= CCALL_NARG_FPR) { \
      dp = &amp;cc-&gt;fpr[nfpr]; \
      nfpr += 1; \
      d = ctype_get(cts, CTID_DOUBLE);  <comment type="block">/* FPRs always hold doubles. */</comment> \
      goto done; \
    } \
  } else { \
    CCALL_HANDLE_GPR \
  }</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* LJ_ABI_SOFTFP */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* LJ_ARCH_PPC64 */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>LJ_ABI_SOFTFP</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_RET</name></cpp:macro> \
  <cpp:value>if (ctype_isfp(ctr-&gt;info) &amp;&amp; ctr-&gt;size == sizeof(float)) \
    ctr = ctype_get(cts, CTID_DOUBLE);</cpp:value></cpp:define>  <comment type="block">/* FPRs always hold doubles. */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_MIPS32</name></expr></cpp:elif>
<comment type="block">/* -- MIPS o32 calling conventions ---------------------------------------- */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_STRUCTRET</name></cpp:macro> \
  <cpp:value>cc-&gt;retref = 1;  <comment type="block">/* Return all structs by reference. */</comment> \
  cc-&gt;gpr[ngpr++] = (GPRArg)dp;</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_COMPLEXRET</name></cpp:macro> \
  <comment type="block">/* Complex values are returned in 1 or 2 FPRs. */</comment> \
  <cpp:value>cc-&gt;retref = 0;</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_ABI_SOFTFP</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_COMPLEXRET2</name></cpp:macro> \
  <cpp:value>if (ctr-&gt;size == 2*sizeof(float)) {  <comment type="block">/* Copy complex float from GPRs. */</comment> \
    ((intptr_t *)dp)[0] = cc-&gt;gpr[0]; \
    ((intptr_t *)dp)[1] = cc-&gt;gpr[1]; \
  } else {  <comment type="block">/* Copy complex double from GPRs. */</comment> \
    ((intptr_t *)dp)[0] = cc-&gt;gpr[0]; \
    ((intptr_t *)dp)[1] = cc-&gt;gpr[1]; \
    ((intptr_t *)dp)[2] = cc-&gt;gpr[2]; \
    ((intptr_t *)dp)[3] = cc-&gt;gpr[3]; \
  }</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_COMPLEXRET2</name></cpp:macro> \
  <cpp:value>if (ctr-&gt;size == 2*sizeof(float)) {  <comment type="block">/* Copy complex float from FPRs. */</comment> \
    ((float *)dp)[0] = cc-&gt;fpr[0].f; \
    ((float *)dp)[1] = cc-&gt;fpr[1].f; \
  } else {  <comment type="block">/* Copy complex double from FPRs. */</comment> \
    ((double *)dp)[0] = cc-&gt;fpr[0].d; \
    ((double *)dp)[1] = cc-&gt;fpr[1].d; \
  }</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_STRUCTARG</name></cpp:macro></cpp:define> \
  <comment type="block">/* Pass all structs by value in registers and/or on the stack. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_COMPLEXARG</name></cpp:macro></cpp:define> \
  <comment type="block">/* Pass complex by value in 2 or 4 GPRs. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_GPR</name></cpp:macro> \
  <cpp:value>if ((d-&gt;info &amp; CTF_ALIGN) &gt; CTALIGN_PTR) \
    ngpr = (ngpr + 1u) &amp; ~1u;  <comment type="block">/* Align to regpair. */</comment> \
  if (ngpr &lt; maxgpr) { \
    dp = &amp;cc-&gt;gpr[ngpr]; \
    if (ngpr + n &gt; maxgpr) { \
     nsp += ngpr + n - maxgpr;  <comment type="block">/* Assumes contiguous gpr/stack fields. */</comment> \
     if (nsp &gt; CCALL_MAXSTACK) goto err_nyi;  <comment type="block">/* Too many arguments. */</comment> \
     ngpr = maxgpr; \
    } else { \
     ngpr += n; \
    } \
    goto done; \
  }</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>LJ_ABI_SOFTFP</name></expr></cpp:if>	<comment type="block">/* MIPS32 hard-float */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_REGARG</name></cpp:macro> \
  <cpp:value>if (isfp &amp;&amp; nfpr &lt; CCALL_NARG_FPR &amp;&amp; !(ct-&gt;info &amp; CTF_VARARG)) { \
    <comment type="block">/* Try to pass argument in FPRs. */</comment> \
    dp = n == 1 ? (void *)&amp;cc-&gt;fpr[nfpr].f : (void *)&amp;cc-&gt;fpr[nfpr].d; \
    nfpr++; ngpr += n; \
    goto done; \
  } else {  <comment type="block">/* Try to pass argument in GPRs. */</comment> \
    nfpr = CCALL_NARG_FPR; \
    CCALL_HANDLE_GPR \
  }</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>			<comment type="block">/* MIPS32 soft-float */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_REGARG</name></cpp:macro> <cpp:value>CCALL_HANDLE_GPR</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>LJ_ABI_SOFTFP</name></expr></cpp:if>
<comment type="block">/* On MIPS64 soft-float, position of float return values is endian-dependant. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_RET</name></cpp:macro> \
  <cpp:value>if (ctype_isfp(ctr-&gt;info) &amp;&amp; ctr-&gt;size == sizeof(float)) \
    sp = (uint8_t *)&amp;cc-&gt;fpr[0].f;</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_MIPS64</name></expr></cpp:elif>
<comment type="block">/* -- MIPS n64 calling conventions ---------------------------------------- */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_STRUCTRET</name></cpp:macro> \
  <cpp:value>cc-&gt;retref = !(sz &lt;= 16); \
  if (cc-&gt;retref) cc-&gt;gpr[ngpr++] = (GPRArg)dp;</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_STRUCTRET2</name></cpp:macro> \
  <cpp:value>ccall_copy_struct(cc, ctr, dp, sp, ccall_classify_struct(cts, ctr, ct));</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_COMPLEXRET</name></cpp:macro> \
  <comment type="block">/* Complex values are returned in 1 or 2 FPRs. */</comment> \
  <cpp:value>cc-&gt;retref = 0;</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_ABI_SOFTFP</name></expr></cpp:if>	<comment type="block">/* MIPS64 soft-float */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_COMPLEXRET2</name></cpp:macro> \
  <cpp:value>if (ctr-&gt;size == 2*sizeof(float)) {  <comment type="block">/* Copy complex float from GPRs. */</comment> \
    ((intptr_t *)dp)[0] = cc-&gt;gpr[0]; \
  } else {  <comment type="block">/* Copy complex double from GPRs. */</comment> \
    ((intptr_t *)dp)[0] = cc-&gt;gpr[0]; \
    ((intptr_t *)dp)[1] = cc-&gt;gpr[1]; \
  }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_COMPLEXARG</name></cpp:macro></cpp:define> \
  <comment type="block">/* Pass complex by value in 2 or 4 GPRs. */</comment>

<comment type="block">/* Position of soft-float 'float' return value depends on endianess.  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_RET</name></cpp:macro> \
  <cpp:value>if (ctype_isfp(ctr-&gt;info) &amp;&amp; ctr-&gt;size == sizeof(float)) \
    sp = (uint8_t *)cc-&gt;gpr + LJ_ENDIAN_SELECT(0, 4);</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>			<comment type="block">/* MIPS64 hard-float */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_COMPLEXRET2</name></cpp:macro> \
  <cpp:value>if (ctr-&gt;size == 2*sizeof(float)) {  <comment type="block">/* Copy complex float from FPRs. */</comment> \
    ((float *)dp)[0] = cc-&gt;fpr[0].f; \
    ((float *)dp)[1] = cc-&gt;fpr[1].f; \
  } else {  <comment type="block">/* Copy complex double from FPRs. */</comment> \
    ((double *)dp)[0] = cc-&gt;fpr[0].d; \
    ((double *)dp)[1] = cc-&gt;fpr[1].d; \
  }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_COMPLEXARG</name></cpp:macro> \
  <cpp:value>if (sz == 2*sizeof(float)) { \
    isfp = 2; \
    if (ngpr &lt; maxgpr) \
      sz *= 2; \
  }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_RET</name></cpp:macro> \
  <cpp:value>if (ctype_isfp(ctr-&gt;info) &amp;&amp; ctr-&gt;size == sizeof(float)) \
    sp = (uint8_t *)&amp;cc-&gt;fpr[0].f;</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_STRUCTARG</name></cpp:macro></cpp:define> \
  <comment type="block">/* Pass all structs by value in registers and/or on the stack. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_REGARG</name></cpp:macro> \
  <cpp:value>if (ngpr &lt; maxgpr) { \
    dp = &amp;cc-&gt;gpr[ngpr]; \
    if (ngpr + n &gt; maxgpr) { \
      nsp += ngpr + n - maxgpr;  <comment type="block">/* Assumes contiguous gpr/stack fields. */</comment> \
      if (nsp &gt; CCALL_MAXSTACK) goto err_nyi;  <comment type="block">/* Too many arguments. */</comment> \
      ngpr = maxgpr; \
    } else { \
      ngpr += n; \
    } \
    goto done; \
  }</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#<cpp:directive>error</cpp:directive> <cpp:literal>"Missing calling convention definitions for this architecture"</cpp:literal></cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>CCALL_HANDLE_STRUCTRET2</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_HANDLE_STRUCTRET2</name></cpp:macro> \
  <cpp:value>memcpy(dp, sp, ctr-&gt;size);</cpp:value></cpp:define>  <comment type="block">/* Copy struct return value from GPRs. */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* -- x86 OSX ABI struct classification ----------------------------------- */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_X86</name> <operator>&amp;&amp;</operator> <name>LJ_TARGET_OSX</name></expr></cpp:if>

<comment type="block">/* Check for struct with single FP field. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ccall_classify_struct</name><parameter_list>(<parameter><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name></decl></parameter>, <parameter><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CTSize</name></type> <name>sz</name> <init>= <expr><name><name>ct</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>sz</name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>float</name></expr></argument>)</argument_list></sizeof> <operator>||</operator> <name>sz</name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ct</name><operator>-&gt;</operator><name>info</name></name> <operator>&amp;</operator> <name>CTF_UNION</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <while>while <condition>(<expr><name><name>ct</name><operator>-&gt;</operator><name>sib</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name><name>ct</name><operator>-&gt;</operator><name>sib</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ctype_isfield</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>sct</name> <init>= <expr><call><name>ctype_rawchild</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>ctype_isfp</name><argument_list>(<argument><expr><name><name>sct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>sct</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <name>sz</name></expr>)</condition><block type="pseudo"><block_content>
	  <return>return <expr><operator>(</operator><name>sz</name> <operator>&gt;&gt;</operator> <literal type="number">2</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* Return 1 for float or 2 for double. */</comment>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ctype_isstruct</name><argument_list>(<argument><expr><name><name>sct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>sct</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition><block type="pseudo"><block_content>
	  <return>return <expr><call><name>ccall_classify_struct</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>sct</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<break>break;</break>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ctype_isbitfield</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <break>break;</break>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ctype_isxattrib</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>, <argument><expr><name>CTA_SUBTYPE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>sct</name> <init>= <expr><call><name>ctype_rawchild</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>sct</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition><block type="pseudo"><block_content>
	<return>return <expr><call><name>ccall_classify_struct</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>sct</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* -- x64 struct classification ------------------------------------------- */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_X64</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>LJ_ABI_WIN</name></expr></cpp:if>

<comment type="block">/* Register classes for x64 struct classification. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_RCL_INT</name></cpp:macro>	<cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_RCL_SSE</name></cpp:macro>	<cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCALL_RCL_MEM</name></cpp:macro>	<cpp:value>4</cpp:value></cpp:define>
<comment type="block">/* NYI: classify vectors. */</comment>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>ccall_classify_struct</name><parameter_list>(<parameter><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name></decl></parameter>, <parameter><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>rcl</name></decl></parameter>, <parameter><decl><type><name>CTSize</name></type> <name>ofs</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Classify a C type. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ccall_classify_ct</name><parameter_list>(<parameter><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name></decl></parameter>, <parameter><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>rcl</name></decl></parameter>, <parameter><decl><type><name>CTSize</name></type> <name>ofs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>ctype_isarray</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>cct</name> <init>= <expr><call><name>ctype_rawchild</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CTSize</name></type> <name>eofs</name></decl>, <decl><type ref="prev"/><name>esz</name> <init>= <expr><name><name>cct</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl>, <decl><type ref="prev"/><name>asz</name> <init>= <expr><name><name>ct</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>eofs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>eofs</name> <operator>&lt;</operator> <name>asz</name></expr>;</condition> <incr><expr><name>eofs</name> <operator>+=</operator> <name>esz</name></expr></incr>)</control><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>ccall_classify_ct</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>cct</name></expr></argument>, <argument><expr><name>rcl</name></expr></argument>, <argument><expr><name>ofs</name><operator>+</operator><name>eofs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ctype_isstruct</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>ccall_classify_struct</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>, <argument><expr><name>rcl</name></expr></argument>, <argument><expr><name>ofs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>cl</name> <init>= <expr><ternary><condition><expr><call><name>ctype_isfp</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>CCALL_RCL_SSE</name></expr> </then><else>: <expr><name>CCALL_RCL_INT</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>ctype_hassize</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ofs</name> <operator>&amp;</operator> <operator>(</operator><name><name>ct</name><operator>-&gt;</operator><name>size</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cl</name> <operator>=</operator> <name>CCALL_RCL_MEM</name></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Unaligned. */</comment>
    <expr_stmt><expr><name><name>rcl</name><index>[<expr><operator>(</operator><name>ofs</name> <operator>&gt;=</operator> <literal type="number">8</literal><operator>)</operator></expr>]</index></name> <operator>|=</operator> <name>cl</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Recursively classify a struct based on its fields. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ccall_classify_struct</name><parameter_list>(<parameter><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name></decl></parameter>, <parameter><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>rcl</name></decl></parameter>, <parameter><decl><type><name>CTSize</name></type> <name>ofs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>ct</name><operator>-&gt;</operator><name>size</name></name> <operator>&gt;</operator> <literal type="number">16</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>CCALL_RCL_MEM</name></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* Too big, gets memory class. */</comment>
  <while>while <condition>(<expr><name><name>ct</name><operator>-&gt;</operator><name>sib</name></name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>CTSize</name></type> <name>fofs</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name><name>ct</name><operator>-&gt;</operator><name>sib</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>fofs</name> <operator>=</operator> <name>ofs</name><operator>+</operator><name><name>ct</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ctype_isfield</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>ccall_classify_ct</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><call><name>ctype_rawchild</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rcl</name></expr></argument>, <argument><expr><name>fofs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>ctype_isbitfield</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>rcl</name><index>[<expr><operator>(</operator><name>fofs</name> <operator>&gt;=</operator> <literal type="number">8</literal><operator>)</operator></expr>]</index></name> <operator>|=</operator> <name>CCALL_RCL_INT</name></expr>;</expr_stmt></block_content></block></if>  <comment type="block">/* NYI: unaligned bitfields? */</comment>
    <if type="elseif">else if <condition>(<expr><call><name>ctype_isxattrib</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>, <argument><expr><name>CTA_SUBTYPE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>ccall_classify_struct</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><call><name>ctype_rawchild</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rcl</name></expr></argument>, <argument><expr><name>fofs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></while>
  <return>return <expr><operator>(</operator><operator>(</operator><name><name>rcl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>|</operator><name><name>rcl</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator> <operator>&amp;</operator> <name>CCALL_RCL_MEM</name><operator>)</operator></expr>;</return>  <comment type="block">/* Memory class? */</comment>
</block_content>}</block></function>

<comment type="block">/* Try to split up a small struct into registers. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ccall_struct_reg</name><parameter_list>(<parameter><decl><type><name>CCallState</name> <modifier>*</modifier></type><name>cc</name></decl></parameter>, <parameter><decl><type><name>GPRArg</name> <modifier>*</modifier></type><name>dp</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>rcl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>MSize</name></type> <name>ngpr</name> <init>= <expr><name><name>cc</name><operator>-&gt;</operator><name>ngpr</name></name></expr></init></decl>, <decl><type ref="prev"/><name>nfpr</name> <init>= <expr><name><name>cc</name><operator>-&gt;</operator><name>nfpr</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name><name>rcl</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <name>CCALL_RCL_MEM</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>rcl</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <name>CCALL_RCL_INT</name><operator>)</operator></expr>)</condition> <block>{<block_content>  <comment type="block">/* Integer class takes precedence. */</comment>
      <if_stmt><if>if <condition>(<expr><name>ngpr</name> <operator>&gt;=</operator> <name>CCALL_NARG_GPR</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* Register overflow. */</comment>
      <expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>gpr</name><index>[<expr><name>ngpr</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>dp</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>rcl</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <name>CCALL_RCL_SSE</name><operator>)</operator></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>nfpr</name> <operator>&gt;=</operator> <name>CCALL_NARG_FPR</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* Register overflow. */</comment>
      <expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>fpr</name><index>[<expr><name>nfpr</name><operator>++</operator></expr>]</index></name><operator>.</operator><name><name>l</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>dp</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>ngpr</name></name> <operator>=</operator> <name>ngpr</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>nfpr</name></name> <operator>=</operator> <name>nfpr</name></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* Ok. */</comment>
</block_content>}</block></function>

<comment type="block">/* Pass a small struct argument. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ccall_struct_arg</name><parameter_list>(<parameter><decl><type><name>CCallState</name> <modifier>*</modifier></type><name>cc</name></decl></parameter>, <parameter><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name></decl></parameter>, <parameter><decl><type><name>CType</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>rcl</name></decl></parameter>,
			    <parameter><decl><type><name>TValue</name> <modifier>*</modifier></type><name>o</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>narg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>GPRArg</name></type> <name><name>dp</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>dp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>dp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <comment type="block">/* Convert to temp. struct. */</comment>
  <expr_stmt><expr><call><name>lj_cconv_ct_tv</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>dp</name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><call><name>CCF_ARG</name><argument_list>(<argument><expr><name>narg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>ccall_struct_reg</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>dp</name></expr></argument>, <argument><expr><name>rcl</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Register overflow? Pass on stack. */</comment>
    <decl_stmt><decl><type><name>MSize</name></type> <name>nsp</name> <init>= <expr><name><name>cc</name><operator>-&gt;</operator><name>nsp</name></name></expr></init></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr><ternary><condition><expr><name><name>rcl</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>nsp</name> <operator>+</operator> <name>n</name> <operator>&gt;</operator> <name>CCALL_MAXSTACK</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* Too many arguments. */</comment>
    <expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>nsp</name></name> <operator>=</operator> <name>nsp</name> <operator>+</operator> <name>n</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cc</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>nsp</name></expr>]</index></name></expr></argument>, <argument><expr><name>dp</name></expr></argument>, <argument><expr><name>n</name><operator>*</operator><name>CTSIZE_PTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* Ok. */</comment>
</block_content>}</block></function>

<comment type="block">/* Combine returned small struct. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ccall_struct_ret</name><parameter_list>(<parameter><decl><type><name>CCallState</name> <modifier>*</modifier></type><name>cc</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>rcl</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>dp</name></decl></parameter>, <parameter><decl><type><name>CTSize</name></type> <name>sz</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>GPRArg</name></type> <name><name>sp</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MSize</name></type> <name>ngpr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>nfpr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>rcl</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <name>CCALL_RCL_INT</name><operator>)</operator></expr>)</condition> <block>{<block_content>  <comment type="block">/* Integer class takes precedence. */</comment>
      <expr_stmt><expr><name><name>sp</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>cc</name><operator>-&gt;</operator><name>gpr</name><index>[<expr><name>ngpr</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>rcl</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <name>CCALL_RCL_SSE</name><operator>)</operator></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>sp</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>cc</name><operator>-&gt;</operator><name>fpr</name><index>[<expr><name>nfpr</name><operator>++</operator></expr>]</index></name><operator>.</operator><name><name>l</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dp</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* -- ARM hard-float ABI struct classification ---------------------------- */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_ARM</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>LJ_ABI_SOFTFP</name></expr></cpp:if>

<comment type="block">/* Classify a struct based on its fields. */</comment>
<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>ccall_classify_struct</name><parameter_list>(<parameter><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name></decl></parameter>, <parameter><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name></decl></parameter>, <parameter><decl><type><name>CType</name> <modifier>*</modifier></type><name>ctf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CTSize</name></type> <name>sz</name> <init>= <expr><name><name>ct</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>r</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>isu</name> <init>= <expr><operator>(</operator><name><name>ct</name><operator>-&gt;</operator><name>info</name></name> <operator>&amp;</operator> <name>CTF_UNION</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ctf</name><operator>-&gt;</operator><name>info</name></name> <operator>&amp;</operator> <name>CTF_VARARG</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>noth</name>;</goto></block_content></block></if></if_stmt>
  <while>while <condition>(<expr><name><name>ct</name><operator>-&gt;</operator><name>sib</name></name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>sct</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name><name>ct</name><operator>-&gt;</operator><name>sib</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ctype_isfield</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>sct</name> <operator>=</operator> <call><name>ctype_rawchild</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>ctype_isfp</name><argument_list>(<argument><expr><name><name>sct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name>r</name> <operator>|=</operator> <name><name>sct</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isu</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if> <if type="elseif">else if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ctype_iscomplex</name><argument_list>(<argument><expr><name><name>sct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name>r</name> <operator>|=</operator> <operator>(</operator><name><name>sct</name><operator>-&gt;</operator><name>size</name></name> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isu</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if> <if type="elseif">else if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ctype_isstruct</name><argument_list>(<argument><expr><name><name>sct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<goto>goto <name>substruct</name>;</goto>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<goto>goto <name>noth</name>;</goto>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ctype_isbitfield</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <goto>goto <name>noth</name>;</goto>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ctype_isxattrib</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>, <argument><expr><name>CTA_SUBTYPE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>sct</name> <operator>=</operator> <call><name>ctype_rawchild</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <label><name>substruct</name>:</label>
      <if_stmt><if>if <condition>(<expr><name><name>sct</name><operator>-&gt;</operator><name>size</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>s</name> <init>= <expr><call><name>ccall_classify_struct</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>sct</name></expr></argument>, <argument><expr><name>ctf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>s</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>noth</name>;</goto></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>r</name> <operator>|=</operator> <operator>(</operator><name>s</name> <operator>&amp;</operator> <literal type="number">255</literal><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isu</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name> <operator>+=</operator> <operator>(</operator><name>s</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if> <if type="elseif">else if <condition>(<expr><name>n</name> <operator>&lt;</operator> <operator>(</operator><name>s</name> <operator>&gt;&gt;</operator><literal type="number">8</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>s</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>r</name> <operator>==</operator> <literal type="number">4</literal> <operator>||</operator> <name>r</name> <operator>==</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name>n</name> <operator>&lt;=</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>r</name> <operator>+</operator> <operator>(</operator><name>n</name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<label><name>noth</name>:</label>  <comment type="block">/* Not a homogeneous float/double aggregate. */</comment>
  <return>return <expr><operator>(</operator><name>sz</name> <operator>&lt;=</operator> <literal type="number">4</literal><operator>)</operator></expr>;</return>  <comment type="block">/* Return structs of size &lt;= 4 in a GPR. */</comment>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* -- ARM64 ABI struct classification ------------------------------------- */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_ARM64</name></expr></cpp:if>

<comment type="block">/* Classify a struct based on its fields. */</comment>
<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>ccall_classify_struct</name><parameter_list>(<parameter><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name></decl></parameter>, <parameter><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CTSize</name></type> <name>sz</name> <init>= <expr><name><name>ct</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>r</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>isu</name> <init>= <expr><operator>(</operator><name><name>ct</name><operator>-&gt;</operator><name>info</name></name> <operator>&amp;</operator> <name>CTF_UNION</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><name><name>ct</name><operator>-&gt;</operator><name>sib</name></name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>sct</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name><name>ct</name><operator>-&gt;</operator><name>sib</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ctype_isfield</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>sct</name> <operator>=</operator> <call><name>ctype_rawchild</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>ctype_isfp</name><argument_list>(<argument><expr><name><name>sct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name>r</name> <operator>|=</operator> <name><name>sct</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isu</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if> <if type="elseif">else if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ctype_iscomplex</name><argument_list>(<argument><expr><name><name>sct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name>r</name> <operator>|=</operator> <operator>(</operator><name><name>sct</name><operator>-&gt;</operator><name>size</name></name> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isu</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if> <if type="elseif">else if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ctype_isstruct</name><argument_list>(<argument><expr><name><name>sct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<goto>goto <name>substruct</name>;</goto>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<goto>goto <name>noth</name>;</goto>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ctype_isbitfield</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <goto>goto <name>noth</name>;</goto>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ctype_isxattrib</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>, <argument><expr><name>CTA_SUBTYPE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>sct</name> <operator>=</operator> <call><name>ctype_rawchild</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <label><name>substruct</name>:</label>
      <if_stmt><if>if <condition>(<expr><name><name>sct</name><operator>-&gt;</operator><name>size</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>s</name> <init>= <expr><call><name>ccall_classify_struct</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>sct</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>s</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>noth</name>;</goto></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>r</name> <operator>|=</operator> <operator>(</operator><name>s</name> <operator>&amp;</operator> <literal type="number">255</literal><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isu</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name> <operator>+=</operator> <operator>(</operator><name>s</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if> <if type="elseif">else if <condition>(<expr><name>n</name> <operator>&lt;</operator> <operator>(</operator><name>s</name> <operator>&gt;&gt;</operator><literal type="number">8</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>s</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>r</name> <operator>==</operator> <literal type="number">4</literal> <operator>||</operator> <name>r</name> <operator>==</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name>n</name> <operator>&lt;=</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>r</name> <operator>+</operator> <operator>(</operator><name>n</name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<label><name>noth</name>:</label>  <comment type="block">/* Not a homogeneous float/double aggregate. */</comment>
  <return>return <expr><operator>(</operator><name>sz</name> <operator>&lt;=</operator> <literal type="number">16</literal><operator>)</operator></expr>;</return>  <comment type="block">/* Return structs of size &lt;= 16 in GPRs. */</comment>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* -- MIPS64 ABI struct classification ---------------------------- */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_MIPS64</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FTYPE_FLOAT</name></cpp:macro>	<cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FTYPE_DOUBLE</name></cpp:macro>	<cpp:value>2</cpp:value></cpp:define>

<comment type="block">/* Classify FP fields (max. 2) and their types. */</comment>
<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>ccall_classify_struct</name><parameter_list>(<parameter><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name></decl></parameter>, <parameter><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name></decl></parameter>, <parameter><decl><type><name>CType</name> <modifier>*</modifier></type><name>ctf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>ft</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ctf</name><operator>-&gt;</operator><name>info</name></name> <operator>&amp;</operator> <name>CTF_VARARG</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>ct</name><operator>-&gt;</operator><name>info</name></name> <operator>&amp;</operator> <name>CTF_UNION</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
    <goto>goto <name>noth</name>;</goto></block_content></block></if></if_stmt>
  <while>while <condition>(<expr><name><name>ct</name><operator>-&gt;</operator><name>sib</name></name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>sct</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name><name>ct</name><operator>-&gt;</operator><name>sib</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
      <goto>goto <name>noth</name>;</goto>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ctype_isfield</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>sct</name> <operator>=</operator> <call><name>ctype_rawchild</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>ctype_isfp</name><argument_list>(<argument><expr><name><name>sct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name>ft</name> <operator>|=</operator> <operator>(</operator><ternary><condition><expr><name><name>sct</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <literal type="number">4</literal></expr> ?</condition><then> <expr><name>FTYPE_FLOAT</name></expr> </then><else>: <expr><name>FTYPE_DOUBLE</name></expr></else></ternary><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>*</operator><name>n</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<goto>goto <name>noth</name>;</goto>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ctype_isbitfield</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
	       <call><name>ctype_isxattrib</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>, <argument><expr><name>CTA_SUBTYPE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <goto>goto <name>noth</name>;</goto>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>ft</name></expr>;</return></block_content></block></if></if_stmt>
<label><name>noth</name>:</label>  <comment type="block">/* Not a homogeneous float/double aggregate. */</comment>
  <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* Struct is in GPRs. */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ccall_copy_struct</name><parameter_list>(<parameter><decl><type><name>CCallState</name> <modifier>*</modifier></type><name>cc</name></decl></parameter>, <parameter><decl><type><name>CType</name> <modifier>*</modifier></type><name>ctr</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>dp</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>sp</name></decl></parameter>,
			      <parameter><decl><type><name>int</name></type> <name>ft</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><ternary><condition><expr><name>LJ_ABI_SOFTFP</name></expr> ?</condition><then> <expr><name>ft</name></expr> </then><else>:
      <expr><operator>(</operator><operator>(</operator><name>ft</name> <operator>&amp;</operator> <literal type="number">3</literal><operator>)</operator> <operator>==</operator> <name>FTYPE_FLOAT</name> <operator>||</operator> <operator>(</operator><name>ft</name> <operator>&gt;&gt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>==</operator> <name>FTYPE_FLOAT</name><operator>)</operator></expr></else></ternary></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>ofs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ft</name> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>ft</name> <operator>&gt;&gt;=</operator> <literal type="number">2</literal></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ft</name> <operator>&amp;</operator> <literal type="number">3</literal><operator>)</operator> <operator>==</operator> <name>FTYPE_FLOAT</name></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_ABI_SOFTFP</name></expr></cpp:if>
	<comment type="block">/* The 2nd FP struct result is in CARG1 (gpr[2]) and not CRET2. */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>dp</name> <operator>+</operator> <name>ofs</name></expr></argument>,
	       <argument><expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>cc</name><operator>-&gt;</operator><name>gpr</name><index>[<expr><literal type="number">2</literal><operator>*</operator><name>i</name></expr>]</index></name> <operator>+</operator> <call><name>LJ_ENDIAN_SELECT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><operator>*</operator><operator>(</operator><name>float</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>dp</name> <operator>+</operator> <name>ofs</name><operator>)</operator> <operator>=</operator> <name><name>cc</name><operator>-&gt;</operator><name>fpr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>f</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name>ofs</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<expr_stmt><expr><name>ofs</name> <operator>=</operator> <operator>(</operator><name>ofs</name> <operator>+</operator> <literal type="number">7</literal><operator>)</operator> <operator>&amp;</operator> <operator>~</operator><literal type="number">7</literal></expr>;</expr_stmt>  <comment type="block">/* 64 bit alignment. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_ABI_SOFTFP</name></expr></cpp:if>
	<expr_stmt><expr><operator>*</operator><operator>(</operator><name>intptr_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>dp</name> <operator>+</operator> <name>ofs</name><operator>)</operator> <operator>=</operator> <name><name>cc</name><operator>-&gt;</operator><name>gpr</name><index>[<expr><literal type="number">2</literal><operator>*</operator><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><operator>*</operator><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>dp</name> <operator>+</operator> <name>ofs</name><operator>)</operator> <operator>=</operator> <name><name>cc</name><operator>-&gt;</operator><name>fpr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>d</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name>ofs</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if> <else>else <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>LJ_ABI_SOFTFP</name></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><name>ft</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>sp</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>cc</name><operator>-&gt;</operator><name>fpr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dp</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name><name>ctr</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* -- Common C call handling ---------------------------------------------- */</comment>

<comment type="block">/* Infer the destination CTypeID for a vararg argument. */</comment>
<function><type><name>CTypeID</name></type> <name>lj_ccall_ctid_vararg</name><parameter_list>(<parameter><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name></decl></parameter>, <parameter><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>tvisnumber</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>CTID_DOUBLE</name></expr>;</return>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>tviscdata</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>CTypeID</name></type> <name>id</name> <init>= <expr><call><name>cdataV</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ctypeid</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ctype_isrefarray</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <return>return <expr><call><name>lj_ctype_intern</name><argument_list>(<argument><expr><name>cts</name></expr></argument>,
	       <argument><expr><call><name>CTINFO</name><argument_list>(<argument><expr><name>CT_PTR</name></expr></argument>, <argument><expr><name>CTALIGN_PTR</name><operator>|</operator><call><name>ctype_cid</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>CTSIZE_PTR</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ctype_isstruct</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ctype_isfunc</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <comment type="block">/* NYI: how to pass a struct by value in a vararg argument? */</comment>
      <return>return <expr><call><name>lj_ctype_intern</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><call><name>CTINFO</name><argument_list>(<argument><expr><name>CT_PTR</name></expr></argument>, <argument><expr><name>CTALIGN_PTR</name><operator>|</operator><name>id</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>CTSIZE_PTR</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ctype_isfp</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>float</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>CTID_DOUBLE</name></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <return>return <expr><name>id</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>tvisstr</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>CTID_P_CCHAR</name></expr>;</return>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>tvisbool</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>CTID_BOOL</name></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <return>return <expr><name>CTID_P_VOID</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Setup arguments for C call. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ccall_set_args</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name></decl></parameter>, <parameter><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name></decl></parameter>,
			  <parameter><decl><type><name>CCallState</name> <modifier>*</modifier></type><name>cc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>gcsteps</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>o</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>top</name> <init>= <expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTypeID</name></type> <name>fid</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ctr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MSize</name></type> <name>maxgpr</name></decl>, <decl><type ref="prev"/><name>ngpr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>nsp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>narg</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CCALL_NARG_FPR</name></expr></cpp:if>
  <decl_stmt><decl><type><name>MSize</name></type> <name>nfpr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_ARM</name></expr></cpp:if>
  <decl_stmt><decl><type><name>MSize</name></type> <name>fprodd</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Clear unused regs to get some determinism in case of misdeclaration. */</comment>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>gpr</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>gpr</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CCALL_NUM_FPR</name></expr></cpp:if>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>fpr</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>fpr</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_X86</name></expr></cpp:if>
  <comment type="block">/* x86 has several different calling conventions. */</comment>
  <expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>resx87</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <switch>switch <condition>(<expr><call><name>ctype_cconv</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
  <case>case <expr><name>CTCC_FASTCALL</name></expr>:</case> <expr_stmt><expr><name>maxgpr</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>CTCC_THISCALL</name></expr>:</case> <expr_stmt><expr><name>maxgpr</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <break>break;</break>
  <default>default:</default> <expr_stmt><expr><name>maxgpr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <break>break;</break>
  </block_content>}</block></switch>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name>maxgpr</name> <operator>=</operator> <name>CCALL_NARG_GPR</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Perform required setup for some result types. */</comment>
  <expr_stmt><expr><name>ctr</name> <operator>=</operator> <call><name>ctype_rawchild</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>ctype_isvector</name><argument_list>(<argument><expr><name><name>ctr</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>CCALL_VECTOR_REG</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>ctr</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <literal type="number">8</literal> <operator>||</operator> <name><name>ctr</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <literal type="number">16</literal><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
      <goto>goto <name>err_nyi</name>;</goto></block_content></block></if></if_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ctype_iscomplex</name><argument_list>(<argument><expr><name><name>ctr</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ctype_isstruct</name><argument_list>(<argument><expr><name><name>ctr</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <comment type="block">/* Preallocate cdata object and anchor it after arguments. */</comment>
    <decl_stmt><decl><type><name>CTSize</name></type> <name>sz</name> <init>= <expr><name><name>ctr</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GCcdata</name> <modifier>*</modifier></type><name>cd</name> <init>= <expr><call><name>lj_cdata_new</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><call><name>ctype_cid</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>dp</name> <init>= <expr><call><name>cdataptr</name><argument_list>(<argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>setcdataV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>++</operator></expr></argument>, <argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ctype_isstruct</name><argument_list>(<argument><expr><name><name>ctr</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>CCALL_HANDLE_STRUCTRET</name></expr></expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>CCALL_HANDLE_COMPLEXRET</name></expr></expr_stmt>
    </block_content>}</block></else></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_X86</name></expr></cpp:if>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ctype_isfp</name><argument_list>(<argument><expr><name><name>ctr</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>resx87</name></name> <operator>=</operator> <ternary><condition><expr><name><name>ctr</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>float</name></expr></argument>)</argument_list></sizeof></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">2</literal></expr></else></ternary></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Skip initial attributes. */</comment>
  <expr_stmt><expr><name>fid</name> <operator>=</operator> <name><name>ct</name><operator>-&gt;</operator><name>sib</name></name></expr>;</expr_stmt>
  <while>while <condition>(<expr><name>fid</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ctf</name> <init>= <expr><call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>fid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ctype_isattrib</name><argument_list>(<argument><expr><name><name>ctf</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>fid</name> <operator>=</operator> <name><name>ctf</name><operator>-&gt;</operator><name>sib</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>

  <comment type="block">/* Walk through all passed arguments. */</comment>
  <for>for <control>(<init><expr><name>o</name> <operator>=</operator> <name><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>+</operator><literal type="number">1</literal></expr><operator>,</operator> <expr><name>narg</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>o</name> <operator>&lt;</operator> <name>top</name></expr>;</condition> <incr><expr><name>o</name><operator>++</operator></expr><operator>,</operator> <expr><name>narg</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>CTypeID</name></type> <name>did</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>d</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CTSize</name></type> <name>sz</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MSize</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>isfp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>isva</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>dp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>rp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>fid</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Get argument type from field. */</comment>
      <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ctf</name> <init>= <expr><call><name>ctype_get</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>fid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>fid</name> <operator>=</operator> <name><name>ctf</name><operator>-&gt;</operator><name>sib</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>ctype_isfield</name><argument_list>(<argument><expr><name><name>ctf</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>did</name> <operator>=</operator> <call><name>ctype_cid</name><argument_list>(<argument><expr><name><name>ctf</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>ct</name><operator>-&gt;</operator><name>info</name></name> <operator>&amp;</operator> <name>CTF_VARARG</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>lj_err_caller</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LJ_ERR_FFI_NUMARG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Too many arguments. */</comment>
      <expr_stmt><expr><name>did</name> <operator>=</operator> <call><name>lj_ccall_ctid_vararg</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Infer vararg type. */</comment>
      <expr_stmt><expr><name>isva</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>ctype_raw</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>did</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>sz</name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>

    <comment type="block">/* Find out how (by value/ref) and where (GPR/FPR) to pass an argument. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ctype_isnum</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>sz</name> <operator>&gt;</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err_nyi</name>;</goto></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>d</name><operator>-&gt;</operator><name>info</name></name> <operator>&amp;</operator> <name>CTF_FP</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>isfp</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ctype_isvector</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>CCALL_VECTOR_REG</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>sz</name> <operator>==</operator> <literal type="number">8</literal> <operator>||</operator> <name>sz</name> <operator>==</operator> <literal type="number">16</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>isfp</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
      <else>else<block type="pseudo"><block_content>
	<goto>goto <name>err_nyi</name>;</goto></block_content></block></else></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ctype_isstruct</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>CCALL_HANDLE_STRUCTARG</name></expr></expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ctype_iscomplex</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>CCALL_HANDLE_COMPLEXARG</name></expr></expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>sz</name> <operator>=</operator> <name>CTSIZE_PTR</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>sz</name> <operator>=</operator> <operator>(</operator><name>sz</name> <operator>+</operator> <name>CTSIZE_PTR</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>CTSIZE_PTR</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <name>sz</name> <operator>/</operator> <name>CTSIZE_PTR</name></expr>;</expr_stmt>  <comment type="block">/* Number of GPRs or stack slots needed. */</comment>

    <macro><name>CCALL_HANDLE_REGARG</name></macro>  <comment type="block">/* Handle register arguments. */</comment>

    <comment type="block">/* Otherwise pass argument on stack. */</comment>
    <if_stmt><if>if <condition>(<expr><name>CCALL_ALIGN_STACKARG</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>rp</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>d</name><operator>-&gt;</operator><name>info</name></name> <operator>&amp;</operator> <name>CTF_ALIGN</name><operator>)</operator> <operator>&gt;</operator> <name>CTALIGN_PTR</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>MSize</name></type> <name>align</name> <init>= <expr><operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <call><name>ctype_align</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>info</name></name><operator>-</operator><name>CTALIGN_PTR</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>nsp</name> <operator>=</operator> <operator>(</operator><name>nsp</name> <operator>+</operator> <name>align</name><operator>)</operator> <operator>&amp;</operator> <operator>~</operator><name>align</name></expr>;</expr_stmt>  <comment type="block">/* Align argument on stack. */</comment>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>nsp</name> <operator>+</operator> <name>n</name> <operator>&gt;</operator> <name>CCALL_MAXSTACK</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Too many arguments. */</comment>
    <label><name>err_nyi</name>:</label>
      <expr_stmt><expr><call><name>lj_err_caller</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LJ_ERR_FFI_NYICALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>dp</name> <operator>=</operator> <operator>&amp;</operator><name><name>cc</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>nsp</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nsp</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>isva</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <label><name>done</name>:</label>
    <if_stmt><if>if <condition>(<expr><name>rp</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Pass by reference. */</comment>
      <expr_stmt><expr><name>gcsteps</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>dp</name> <operator>=</operator> <name>rp</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>dp</name> <operator>=</operator> <name>rp</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>lj_cconv_ct_tv</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>dp</name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><call><name>CCF_ARG</name><argument_list>(<argument><expr><name>narg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Extend passed integers to 32 bits at least. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ctype_isinteger_or_bool</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>d</name><operator>-&gt;</operator><name>size</name></name> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>info</name></name> <operator>&amp;</operator> <name>CTF_UNSIGNED</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><name>dp</name> <operator>=</operator> <ternary><condition><expr><name><name>d</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>*</operator><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>dp</name></expr> </then><else>:
					 <expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>*</operator><operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator><name>dp</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if>
      <else>else<block type="pseudo"><block_content>
	<expr_stmt><expr><operator>*</operator><operator>(</operator><name>int32_t</name> <operator>*</operator><operator>)</operator><name>dp</name> <operator>=</operator> <ternary><condition><expr><name><name>d</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><operator>(</operator><name>int32_t</name><operator>)</operator><operator>*</operator><operator>(</operator><name>int8_t</name> <operator>*</operator><operator>)</operator><name>dp</name></expr> </then><else>:
					<expr><operator>(</operator><name>int32_t</name><operator>)</operator><operator>*</operator><operator>(</operator><name>int16_t</name> <operator>*</operator><operator>)</operator><name>dp</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_ARM64</name> <operator>&amp;&amp;</operator> <name>LJ_BE</name></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><name>isfp</name> <operator>&amp;&amp;</operator> <name><name>d</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>float</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><operator>(</operator><operator>(</operator><name>float</name> <operator>*</operator><operator>)</operator><name>dp</name><operator>)</operator><index>[<expr><literal type="number">1</literal></expr>]</index> <operator>=</operator> <operator>(</operator><operator>(</operator><name>float</name> <operator>*</operator><operator>)</operator><name>dp</name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Floats occupy high slot. */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_MIPS64</name> <operator>||</operator> <operator>(</operator><name>LJ_TARGET_ARM64</name> <operator>&amp;&amp;</operator> <name>LJ_BE</name><operator>)</operator></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>ctype_isinteger_or_bool</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ctype_isenum</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_MIPS64</name></expr></cpp:if>
	 <operator>||</operator> <operator>(</operator><name>isfp</name> <operator>&amp;&amp;</operator> <name>nsp</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	 <operator>)</operator> <operator>&amp;&amp;</operator> <name><name>d</name><operator>-&gt;</operator><name>size</name></name> <operator>&lt;=</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator><name>dp</name> <operator>=</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><operator>*</operator><operator>(</operator><name>int32_t</name> <operator>*</operator><operator>)</operator><name>dp</name></expr>;</expr_stmt>  <comment type="block">/* Sign-extend to 64 bit. */</comment>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_X64</name> <operator>&amp;&amp;</operator> <name>LJ_ABI_WIN</name></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><name>isva</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Windows/x64 mirrors varargs in both register sets. */</comment>
      <if_stmt><if>if <condition>(<expr><name>nfpr</name> <operator>==</operator> <name>ngpr</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>gpr</name><index>[<expr><name>ngpr</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>cc</name><operator>-&gt;</operator><name>fpr</name><index>[<expr><name>ngpr</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>l</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
      <else>else<block type="pseudo"><block_content>
	<expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>fpr</name><index>[<expr><name>ngpr</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>l</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>cc</name><operator>-&gt;</operator><name>gpr</name><index>[<expr><name>ngpr</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>isva</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_X64</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>LJ_ABI_WIN</name></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><name>isfp</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>n</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>dp</name> <operator>==</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>cc</name><operator>-&gt;</operator><name>fpr</name><index>[<expr><name>nfpr</name><operator>-</operator><literal type="number">2</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>fpr</name><index>[<expr><name>nfpr</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>d</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>cc</name><operator>-&gt;</operator><name>fpr</name><index>[<expr><name>nfpr</name><operator>-</operator><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name><name>d</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>  <comment type="block">/* Split complex double. */</comment>
      <expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>fpr</name><index>[<expr><name>nfpr</name><operator>-</operator><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name><name>d</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_ARM64</name> <operator>||</operator> <operator>(</operator><name>LJ_TARGET_MIPS64</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>LJ_ABI_SOFTFP</name><operator>)</operator></expr></cpp:elif>
    <if_stmt><if>if <condition>(<expr><name>isfp</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>dp</name> <operator>&lt;</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name><name>cc</name><operator>-&gt;</operator><name>stack</name></name></expr>)</condition> <block>{<block_content>
      <comment type="block">/* Split float HFA or complex float into separate registers. */</comment>
      <decl_stmt><decl><type><name>CTSize</name></type> <name>i</name> <init>= <expr><operator>(</operator><name>sz</name> <operator>&gt;&gt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
      <do>do <block>{<block_content> <expr_stmt><expr><operator>(</operator><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator><name>dp</name><operator>)</operator><index>[<expr><name>i</name></expr>]</index> <operator>=</operator> <operator>(</operator><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><name>dp</name><operator>)</operator><index>[<expr><name>i</name></expr>]</index></expr>;</expr_stmt> </block_content>}</block> while <condition>(<expr><name>i</name><operator>--</operator></expr>)</condition>;</do>
    </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>isfp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></for>
  <if_stmt><if>if <condition>(<expr><name>fid</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>lj_err_caller</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LJ_ERR_FFI_NUMARG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Too few arguments. */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_X64</name> <operator>||</operator> <operator>(</operator><name>LJ_TARGET_PPC</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>LJ_ABI_SOFTFP</name><operator>)</operator></expr></cpp:if>
  <expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>nfpr</name></name> <operator>=</operator> <name>nfpr</name></expr>;</expr_stmt>  <comment type="block">/* Required for vararg functions. */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>nsp</name></name> <operator>=</operator> <name>nsp</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>spadj</name></name> <operator>=</operator> <operator>(</operator><name>CCALL_SPS_FREE</name> <operator>+</operator> <name>CCALL_SPS_EXTRA</name><operator>)</operator><operator>*</operator><name>CTSIZE_PTR</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>nsp</name> <operator>&gt;</operator> <name>CCALL_SPS_FREE</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>spadj</name></name> <operator>+=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>nsp</name><operator>-</operator><name>CCALL_SPS_FREE</name><operator>)</operator><operator>*</operator><name>CTSIZE_PTR</name> <operator>+</operator> <literal type="number">15u</literal><operator>)</operator> <operator>&amp;</operator> <operator>~</operator><literal type="number">15u</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>gcsteps</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Get results from C call. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ccall_get_results</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name></decl></parameter>, <parameter><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name></decl></parameter>,
			     <parameter><decl><type><name>CCallState</name> <modifier>*</modifier></type><name>cc</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>ret</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ctr</name> <init>= <expr><call><name>ctype_rawchild</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>sp</name> <init>= <expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>cc</name><operator>-&gt;</operator><name>gpr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>ctype_isvoid</name><argument_list>(<argument><expr><name><name>ctr</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* Zero results. */</comment>
    <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* No additional GC step. */</comment>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>ret</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* One result. */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>ctype_isstruct</name><argument_list>(<argument><expr><name><name>ctr</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <comment type="block">/* Return cdata object which is already on top of stack. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cc</name><operator>-&gt;</operator><name>retref</name></name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>dp</name> <init>= <expr><call><name>cdataptr</name><argument_list>(<argument><expr><call><name>cdataV</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* Use preallocated object. */</comment>
      <expr_stmt><expr><name>CCALL_HANDLE_STRUCTRET2</name></expr></expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>  <comment type="block">/* One GC step. */</comment>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>ctype_iscomplex</name><argument_list>(<argument><expr><name><name>ctr</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <comment type="block">/* Return cdata object which is already on top of stack. */</comment>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>dp</name> <init>= <expr><call><name>cdataptr</name><argument_list>(<argument><expr><call><name>cdataV</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* Use preallocated object. */</comment>
    <macro><name>CCALL_HANDLE_COMPLEXRET2</name></macro>
    <return>return <expr><literal type="number">1</literal></expr>;</return>  <comment type="block">/* One GC step. */</comment>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>LJ_BE</name> <operator>&amp;&amp;</operator> <name><name>ctr</name><operator>-&gt;</operator><name>size</name></name> <operator>&lt;</operator> <name>CTSIZE_PTR</name> <operator>&amp;&amp;</operator>
      <operator>(</operator><call><name>ctype_isinteger_or_bool</name><argument_list>(<argument><expr><name><name>ctr</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ctype_isenum</name><argument_list>(<argument><expr><name><name>ctr</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>sp</name> <operator>+=</operator> <operator>(</operator><name>CTSIZE_PTR</name> <operator>-</operator> <name><name>ctr</name><operator>-&gt;</operator><name>size</name></name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CCALL_NUM_FPR</name></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><call><name>ctype_isfp</name><argument_list>(<argument><expr><name><name>ctr</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ctype_isvector</name><argument_list>(<argument><expr><name><name>ctr</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>sp</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>cc</name><operator>-&gt;</operator><name>fpr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CCALL_HANDLE_RET</name></cpp:ifdef>
  <decl_stmt><decl><type><name>CCALL_HANDLE_RET</name></type>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <comment type="block">/* No reference types end up here, so there's no need for the CTypeID. */</comment>
  <name>lua_assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><call><name>ctype_isrefarray</name><argument_list>(<argument><expr><name><name>ctr</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ctype_isstruct</name><argument_list>(<argument><expr><name><name>ctr</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
  <return>return <expr><call><name>lj_cconv_tv_ct</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ctr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Call C function. */</comment>
<function><type><name>int</name></type> <name>lj_ccall_func</name><parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>GCcdata</name> <modifier>*</modifier></type><name>cd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name> <init>= <expr><call><name>ctype_cts</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CType</name> <modifier>*</modifier></type><name>ct</name> <init>= <expr><call><name>ctype_raw</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name><name>cd</name><operator>-&gt;</operator><name>ctypeid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CTSize</name></type> <name>sz</name> <init>= <expr><name>CTSIZE_PTR</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>ctype_isptr</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>sz</name> <operator>=</operator> <name><name>ct</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>ctype_rawchild</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>ctype_isfunc</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>CCallState</name></type> <name>cc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>gcsteps</name></decl>, <decl><type ref="prev"/><name>ret</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>cc</name><operator>.</operator><name>func</name></name> <operator>=</operator> <operator>(</operator><call><call><name>void</name> <argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call><operator>)</operator><call><name>cdata_getptr</name><argument_list>(<argument><expr><call><name>cdataptr</name><argument_list>(<argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>gcsteps</name> <operator>=</operator> <call><name>ccall_set_args</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ct</name> <operator>=</operator> <operator>(</operator><name>CType</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>intptr_t</name><operator>)</operator><name>ct</name><operator>-</operator><operator>(</operator><name>intptr_t</name><operator>)</operator><name><name>cts</name><operator>-&gt;</operator><name>tab</name></name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cts</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <operator>~</operator><literal type="number">0u</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lj_vm_ffi_call</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>cts</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>slot</name></name> <operator>!=</operator> <operator>~</operator><literal type="number">0u</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* Blacklist function that called a callback. */</comment>
      <decl_stmt><decl><type><name>TValue</name></type> <name>tv</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>setlightudV</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>cc</name><operator>.</operator><name>func</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>setboolV</name><argument_list>(<argument><expr><call><name>lj_tab_set</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>cts</name><operator>-&gt;</operator><name>miscmap</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>ct</name> <operator>=</operator> <operator>(</operator><name>CType</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>intptr_t</name><operator>)</operator><name>ct</name><operator>+</operator><operator>(</operator><name>intptr_t</name><operator>)</operator><name><name>cts</name><operator>-&gt;</operator><name>tab</name></name><operator>)</operator></expr>;</expr_stmt>  <comment type="block">/* May be reallocated. */</comment>
    <expr_stmt><expr><name>gcsteps</name> <operator>+=</operator> <call><name>ccall_get_results</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>cts</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_X86</name> <operator>&amp;&amp;</operator> <name>LJ_ABI_WIN</name></expr></cpp:if>
    <comment type="block">/* Automatically detect __stdcall and fix up C function declaration. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>cc</name><operator>.</operator><name>spadj</name></name> <operator>&amp;&amp;</operator> <call><name>ctype_cconv</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CTCC_CDECL</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>CTF_INSERT</name><argument_list>(<argument><expr><name><name>ct</name><operator>-&gt;</operator><name>info</name></name></expr></argument>, <argument><expr><name>CCONV</name></expr></argument>, <argument><expr><name>CTCC_STDCALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lj_trace_abort</name><argument_list>(<argument><expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <while>while <condition>(<expr><name>gcsteps</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>lj_gc_check</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
    <return>return <expr><name>ret</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>  <comment type="block">/* Not a function. */</comment>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
