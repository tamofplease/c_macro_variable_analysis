<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/sysbench/third_party/luajit/luajit/src/lj_alloc.c"><comment type="block">/*
** Bundled memory allocator.
**
** Beware: this is a HEAVILY CUSTOMIZED version of dlmalloc.
** The original bears the following remark:
**
**   This is a version (aka dlmalloc) of malloc/free/realloc written by
**   Doug Lea and released to the public domain, as explained at
**   http://creativecommons.org/licenses/publicdomain.
**
**   * Version pre-2.8.4 Wed Mar 29 19:46:29 2006    (dl at gee)
**
** No additional copyright is claimed over the customizations.
** Please do NOT bother the original author about this version here!
**
** If you want to use dlmalloc in another project, you should get
** the original from: ftp://gee.cs.oswego.edu/pub/misc/
** For thread-safe derivatives, take a look at:
** - ptmalloc: http://www.malloc.de/
** - nedmalloc: http://www.nedprod.com/programs/portable/nedmalloc/
*/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lj_alloc_c</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUA_CORE</name></cpp:macro></cpp:define>

<comment type="block">/* To get the mremap prototype. Must be defined before any system includes. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__linux__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_GNU_SOURCE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_GNU_SOURCE</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_def.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_arch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_alloc.h"</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>LUAJIT_USE_SYSMALLOC</name></cpp:ifndef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_SIZE_T</name></cpp:macro>		<cpp:value>(~(size_t)0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MALLOC_ALIGNMENT</name></cpp:macro>	<cpp:value>((size_t)8U)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_GRANULARITY</name></cpp:macro>	<cpp:value>((size_t)128U * (size_t)1024U)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_TRIM_THRESHOLD</name></cpp:macro>	<cpp:value>((size_t)2U * (size_t)1024U * (size_t)1024U)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_MMAP_THRESHOLD</name></cpp:macro>	<cpp:value>((size_t)128U * (size_t)1024U)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_RELEASE_CHECK_RATE</name></cpp:macro>	<cpp:value>255</cpp:value></cpp:define>

<comment type="block">/* ------------------- size_t and alignment properties -------------------- */</comment>

<comment type="block">/* The byte and bit size of a size_t */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIZE_T_SIZE</name></cpp:macro>		<cpp:value>(sizeof(size_t))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIZE_T_BITSIZE</name></cpp:macro>		<cpp:value>(sizeof(size_t) &lt;&lt; 3)</cpp:value></cpp:define>

<comment type="block">/* Some constants coerced to size_t */</comment>
<comment type="block">/* Annoying but necessary to avoid errors on some platforms */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIZE_T_ZERO</name></cpp:macro>		<cpp:value>((size_t)0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIZE_T_ONE</name></cpp:macro>		<cpp:value>((size_t)1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIZE_T_TWO</name></cpp:macro>		<cpp:value>((size_t)2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TWO_SIZE_T_SIZES</name></cpp:macro>	<cpp:value>(SIZE_T_SIZE&lt;&lt;1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FOUR_SIZE_T_SIZES</name></cpp:macro>	<cpp:value>(SIZE_T_SIZE&lt;&lt;2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIX_SIZE_T_SIZES</name></cpp:macro>	<cpp:value>(FOUR_SIZE_T_SIZES+TWO_SIZE_T_SIZES)</cpp:value></cpp:define>

<comment type="block">/* The bit mask value corresponding to MALLOC_ALIGNMENT */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHUNK_ALIGN_MASK</name></cpp:macro>	<cpp:value>(MALLOC_ALIGNMENT - SIZE_T_ONE)</cpp:value></cpp:define>

<comment type="block">/* the number of bytes to offset an address to align it */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>align_offset</name><parameter_list>(<parameter><type><name>A</name></type></parameter>)</parameter_list></cpp:macro>\
 <cpp:value>((((size_t)(A) &amp; CHUNK_ALIGN_MASK) == 0)? 0 :\
  ((MALLOC_ALIGNMENT - ((size_t)(A) &amp; CHUNK_ALIGN_MASK)) &amp; CHUNK_ALIGN_MASK))</cpp:value></cpp:define>

<comment type="block">/* -------------------------- MMAP support ------------------------------- */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MFAIL</name></cpp:macro>			<cpp:value>((void *)(MAX_SIZE_T))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CMFAIL</name></cpp:macro>			<cpp:value>((char *)(MFAIL))</cpp:value></cpp:define> <comment type="block">/* defined for convenience */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_DIRECT_BIT</name></cpp:macro>		<cpp:value>(SIZE_T_ONE)</cpp:value></cpp:define>


<comment type="block">/* Determine system-specific block allocation method. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_WINDOWS</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WIN32_LEAN_AND_MEAN</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LJ_ALLOC_VIRTUALALLOC</name></cpp:macro>	<cpp:value>1</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_64</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>LJ_GC64</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LJ_ALLOC_NTAVM</name></cpp:macro>		<cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<comment type="block">/* If this include fails, then rebuild with: -DLUAJIT_USE_SYSMALLOC */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/mman.h&gt;</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LJ_ALLOC_MMAP</name></cpp:macro>		<cpp:value>1</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_64</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LJ_ALLOC_MMAP_PROBE</name></cpp:macro>	<cpp:value>1</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_GC64</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LJ_ALLOC_MBITS</name></cpp:macro>		<cpp:value>47</cpp:value></cpp:define>	<comment type="block">/* 128 TB in LJ_GC64 mode. */</comment>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_TARGET_X64</name> <operator>&amp;&amp;</operator> <name>LJ_HASJIT</name></expr></cpp:elif>
<comment type="block">/* Due to limitations in the x64 compiler backend. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LJ_ALLOC_MBITS</name></cpp:macro>		<cpp:value>31</cpp:value></cpp:define>	<comment type="block">/* 2 GB on x64 with !LJ_GC64. */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LJ_ALLOC_MBITS</name></cpp:macro>		<cpp:value>32</cpp:value></cpp:define>	<comment type="block">/* 4 GB on other archs with !LJ_GC64. */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_64</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>LJ_GC64</name> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>MAP_32BIT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LJ_ALLOC_MMAP32</name></cpp:macro>		<cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_LINUX</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LJ_ALLOC_MREMAP</name></cpp:macro>		<cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_ALLOC_VIRTUALALLOC</name></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_ALLOC_NTAVM</name></expr></cpp:if>
<comment type="block">/* Undocumented, but hey, that's what we all love so much about Windows. */</comment>
<typedef>typedef <function_decl><type><name>long</name></type> (<modifier>*</modifier><name>PNTAVM</name>)<parameter_list>(<parameter><decl><type><name>HANDLE</name></type> <name>handle</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>addr</name></decl></parameter>, <parameter><decl><type><name>ULONG</name></type> <name>zbits</name></decl></parameter>,
		       <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>size</name></decl></parameter>, <parameter><decl><type><name>ULONG</name></type> <name>alloctype</name></decl></parameter>, <parameter><decl><type><name>ULONG</name></type> <name>prot</name></decl></parameter>)</parameter_list>;</function_decl></typedef>
<decl_stmt><decl><type><specifier>static</specifier> <name>PNTAVM</name></type> <name>ntavm</name></decl>;</decl_stmt>

<comment type="block">/* Number of top bits of the lower 32 bits of an address that must be zero.
** Apparently 0 gives us full 64 bit addresses and 1 gives us the lower 2GB.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NTAVM_ZEROBITS</name></cpp:macro>		<cpp:value>1</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type> <name>init_mmap</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><name>ntavm</name> <operator>=</operator> <operator>(</operator><name>PNTAVM</name><operator>)</operator><call><name>GetProcAddress</name><argument_list>(<argument><expr><call><name>GetModuleHandleA</name><argument_list>(<argument><expr><literal type="string">"ntdll.dll"</literal></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr><literal type="string">"NtAllocateVirtualMemory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INIT_MMAP</name><parameter_list>()</parameter_list></cpp:macro>	<cpp:value>init_mmap()</cpp:value></cpp:define>

<comment type="block">/* Win64 32 bit MMAP via NtAllocateVirtualMemory. */</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>CALL_MMAP</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>olderr</name> <init>= <expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>long</name></type> <name>st</name> <init>= <expr><call><name>ntavm</name><argument_list>(<argument><expr><name>INVALID_HANDLE_VALUE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>, <argument><expr><name>NTAVM_ZEROBITS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>,
		  <argument><expr><name>MEM_RESERVE</name><operator>|</operator><name>MEM_COMMIT</name></expr></argument>, <argument><expr><name>PAGE_READWRITE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>SetLastError</name><argument_list>(<argument><expr><name>olderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><ternary><condition><expr><name>st</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>ptr</name></expr> </then><else>: <expr><name>MFAIL</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* For direct MMAP, use MEM_TOP_DOWN to minimize interference */</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>direct_mmap</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>olderr</name> <init>= <expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>long</name></type> <name>st</name> <init>= <expr><call><name>ntavm</name><argument_list>(<argument><expr><name>INVALID_HANDLE_VALUE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>, <argument><expr><name>NTAVM_ZEROBITS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>,
		  <argument><expr><name>MEM_RESERVE</name><operator>|</operator><name>MEM_COMMIT</name><operator>|</operator><name>MEM_TOP_DOWN</name></expr></argument>, <argument><expr><name>PAGE_READWRITE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>SetLastError</name><argument_list>(<argument><expr><name>olderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><ternary><condition><expr><name>st</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>ptr</name></expr> </then><else>: <expr><name>MFAIL</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<comment type="block">/* Win32 MMAP via VirtualAlloc */</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>CALL_MMAP</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>olderr</name> <init>= <expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>LJ_WIN_VALLOC</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>MEM_RESERVE</name><operator>|</operator><name>MEM_COMMIT</name></expr></argument>, <argument><expr><name>PAGE_READWRITE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>SetLastError</name><argument_list>(<argument><expr><name>olderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><ternary><condition><expr><name>ptr</name></expr> ?</condition><then> <expr><name>ptr</name></expr> </then><else>: <expr><name>MFAIL</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* For direct MMAP, use MEM_TOP_DOWN to minimize interference */</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>direct_mmap</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>olderr</name> <init>= <expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>LJ_WIN_VALLOC</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>MEM_RESERVE</name><operator>|</operator><name>MEM_COMMIT</name><operator>|</operator><name>MEM_TOP_DOWN</name></expr></argument>,
			    <argument><expr><name>PAGE_READWRITE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>SetLastError</name><argument_list>(<argument><expr><name>olderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><ternary><condition><expr><name>ptr</name></expr> ?</condition><then> <expr><name>ptr</name></expr> </then><else>: <expr><name>MFAIL</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DIRECT_MMAP</name><parameter_list>(<parameter><type><name>size</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>direct_mmap(size)</cpp:value></cpp:define>

<comment type="block">/* This function supports releasing coalesed segments */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>CALL_MUNMAP</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>olderr</name> <init>= <expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MEMORY_BASIC_INFORMATION</name></type> <name>minfo</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cptr</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>ptr</name></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><name>size</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>VirtualQuery</name><argument_list>(<argument><expr><name>cptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>minfo</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>minfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>minfo</name><operator>.</operator><name>BaseAddress</name></name> <operator>!=</operator> <name>cptr</name> <operator>||</operator> <name><name>minfo</name><operator>.</operator><name>AllocationBase</name></name> <operator>!=</operator> <name>cptr</name> <operator>||</operator>
	<name><name>minfo</name><operator>.</operator><name>State</name></name> <operator>!=</operator> <name>MEM_COMMIT</name> <operator>||</operator> <name><name>minfo</name><operator>.</operator><name>RegionSize</name></name> <operator>&gt;</operator> <name>size</name></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>VirtualFree</name><argument_list>(<argument><expr><name>cptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>MEM_RELEASE</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>cptr</name> <operator>+=</operator> <name><name>minfo</name><operator>.</operator><name>RegionSize</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>size</name> <operator>-=</operator> <name><name>minfo</name><operator>.</operator><name>RegionSize</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>SetLastError</name><argument_list>(<argument><expr><name>olderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_ALLOC_MMAP</name></expr></cpp:elif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MMAP_PROT</name></cpp:macro>		<cpp:value>(PROT_READ|PROT_WRITE)</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MAP_ANONYMOUS</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>MAP_ANON</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAP_ANONYMOUS</name></cpp:macro>		<cpp:value>MAP_ANON</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MMAP_FLAGS</name></cpp:macro>		<cpp:value>(MAP_PRIVATE|MAP_ANONYMOUS)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_ALLOC_MMAP_PROBE</name></expr></cpp:if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MAP_TRYFIXED</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MMAP_FLAGS_PROBE</name></cpp:macro>	<cpp:value>(MMAP_FLAGS|MAP_TRYFIXED)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MMAP_FLAGS_PROBE</name></cpp:macro>	<cpp:value>MMAP_FLAGS</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LJ_ALLOC_MMAP_PROBE_MAX</name></cpp:macro>		<cpp:value>30</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LJ_ALLOC_MMAP_PROBE_LINEAR</name></cpp:macro>	<cpp:value>5</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LJ_ALLOC_MMAP_PROBE_LOWER</name></cpp:macro>	<cpp:value>((uintptr_t)0x4000)</cpp:value></cpp:define>

<comment type="block">/* No point in a giant ifdef mess. Just try to open /dev/urandom.
** It doesn't really matter if this fails, since we get some ASLR bits from
** every unsuitable allocation, too. And we prefer linear allocation, anyway.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<function><type><specifier>static</specifier> <name>uintptr_t</name></type> <name>mmap_probe_seed</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uintptr_t</name></type> <name>val</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>fd</name> <init>= <expr><call><name>open</name><argument_list>(<argument><expr><literal type="string">"/dev/urandom"</literal></expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>fd</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ok</name> <init>= <expr><operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator><call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ok</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>val</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>  <comment type="block">/* Punt. */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>mmap_probe</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Hint for next allocation. Doesn't need to be thread-safe. */</comment>
  <decl_stmt><decl><type><specifier>static</specifier> <name>uintptr_t</name></type> <name>hint_addr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <name>uintptr_t</name></type> <name>hint_prng</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>olderr</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>retry</name></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>retry</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>retry</name> <operator>&lt;</operator> <name>LJ_ALLOC_MMAP_PROBE_MAX</name></expr>;</condition> <incr><expr><name>retry</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>mmap</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>hint_addr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>MMAP_PROT</name></expr></argument>, <argument><expr><name>MMAP_FLAGS_PROBE</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uintptr_t</name></type> <name>addr</name> <init>= <expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>p</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>addr</name> <operator>&gt;&gt;</operator> <name>LJ_ALLOC_MBITS</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>addr</name> <operator>&gt;=</operator> <name>LJ_ALLOC_MMAP_PROBE_LOWER</name> <operator>&amp;&amp;</operator>
	<operator>(</operator><operator>(</operator><name>addr</name> <operator>+</operator> <name>size</name><operator>)</operator> <operator>&gt;&gt;</operator> <name>LJ_ALLOC_MBITS</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <comment type="block">/* We got a suitable address. Bump the hint address. */</comment>
      <expr_stmt><expr><name>hint_addr</name> <operator>=</operator> <name>addr</name> <operator>+</operator> <name>size</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>olderr</name></expr>;</expr_stmt>
      <return>return <expr><name>p</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <name>MFAIL</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>munmap</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOMEM</name></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>MFAIL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>hint_addr</name></expr>)</condition> <block>{<block_content>
      <comment type="block">/* First, try linear probing. */</comment>
      <if_stmt><if>if <condition>(<expr><name>retry</name> <operator>&lt;</operator> <name>LJ_ALLOC_MMAP_PROBE_LINEAR</name></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name>hint_addr</name> <operator>+=</operator> <literal type="number">0x1000000</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>hint_addr</name> <operator>+</operator> <name>size</name><operator>)</operator> <operator>&gt;&gt;</operator> <name>LJ_ALLOC_MBITS</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><name>hint_addr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<continue>continue;</continue>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>retry</name> <operator>==</operator> <name>LJ_ALLOC_MMAP_PROBE_LINEAR</name></expr>)</condition> <block>{<block_content>
	<comment type="block">/* Next, try a no-hint probe to get back an ASLR address. */</comment>
	<expr_stmt><expr><name>hint_addr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<continue>continue;</continue>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Finally, try pseudo-random probing. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>LJ_UNLIKELY</name><argument_list>(<argument><expr><name>hint_prng</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>hint_prng</name> <operator>=</operator> <call><name>mmap_probe_seed</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* The unsuitable address we got has some ASLR PRNG bits. */</comment>
    <expr_stmt><expr><name>hint_addr</name> <operator>^=</operator> <name>addr</name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><operator>(</operator><name>LJ_PAGESIZE</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
    <do>do <block>{<block_content>  <comment type="block">/* The PRNG itself is very weak, but see above. */</comment>
      <expr_stmt><expr><name>hint_prng</name> <operator>=</operator> <name>hint_prng</name> <operator>*</operator> <literal type="number">1103515245</literal> <operator>+</operator> <literal type="number">12345</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>hint_addr</name> <operator>^=</operator> <name>hint_prng</name> <operator>*</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><name>LJ_PAGESIZE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>hint_addr</name> <operator>&amp;=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>LJ_ALLOC_MBITS</name><operator>)</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block> while <condition>(<expr><name>hint_addr</name> <operator>&lt;</operator> <name>LJ_ALLOC_MMAP_PROBE_LOWER</name></expr>)</condition>;</do>
  </block_content>}</block></for>
  <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>olderr</name></expr>;</expr_stmt>
  <return>return <expr><name>MFAIL</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_ALLOC_MMAP32</name></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__sun__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LJ_ALLOC_MMAP32_START</name></cpp:macro>	<cpp:value>((uintptr_t)0x1000)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LJ_ALLOC_MMAP32_START</name></cpp:macro>	<cpp:value>((uintptr_t)0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>mmap_map32</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_ALLOC_MMAP_PROBE</name></expr></cpp:if>
  <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>fallback</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>fallback</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>mmap_probe</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>olderr</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>mmap</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>LJ_ALLOC_MMAP32_START</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>MMAP_PROT</name></expr></argument>, <argument><expr><name>MAP_32BIT</name><operator>|</operator><name>MMAP_FLAGS</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>olderr</name></expr>;</expr_stmt>
    <comment type="block">/* This only allows 1GB on Linux. So fallback to probing to get 2GB. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_ALLOC_MMAP_PROBE</name></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>==</operator> <name>MFAIL</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>fallback</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <return>return <expr><call><name>mmap_probe</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><name>ptr</name></expr>;</return>
  </block_content>}</block>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_ALLOC_MMAP32</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALL_MMAP</name><parameter_list>(<parameter><type><name>size</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>mmap_map32(size)</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_ALLOC_MMAP_PROBE</name></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALL_MMAP</name><parameter_list>(<parameter><type><name>size</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>mmap_probe(size)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>CALL_MMAP</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>olderr</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>mmap</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>MMAP_PROT</name></expr></argument>, <argument><expr><name>MMAP_FLAGS</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>olderr</name></expr>;</expr_stmt>
  <return>return <expr><name>ptr</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_64</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>LJ_GC64</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>__FreeBSD__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>__FreeBSD__</name> <operator>&lt;</operator> <literal type="number">10</literal><operator>)</operator> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__FreeBSD_kernel__</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name>LJ_TARGET_PS4</name></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/resource.h&gt;</cpp:file></cpp:include>

<function><type><specifier>static</specifier> <name>void</name></type> <name>init_mmap</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>rlimit</name></name></type> <name>rlim</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>rlim</name><operator>.</operator><name>rlim_cur</name></name> <operator>=</operator> <name><name>rlim</name><operator>.</operator><name>rlim_max</name></name> <operator>=</operator> <literal type="number">0x10000</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setrlimit</name><argument_list>(<argument><expr><name>RLIMIT_DATA</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rlim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Ignore result. May fail later. */</comment>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INIT_MMAP</name><parameter_list>()</parameter_list></cpp:macro>	<cpp:value>init_mmap()</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name></type> <name>CALL_MUNMAP</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>olderr</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>munmap</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>olderr</name></expr>;</expr_stmt>
  <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_ALLOC_MREMAP</name></expr></cpp:if>
<comment type="block">/* Need to define _GNU_SOURCE to get the mremap prototype. */</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>CALL_MREMAP_</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>osz</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nsz</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>olderr</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>mremap</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>osz</name></expr></argument>, <argument><expr><name>nsz</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>olderr</name></expr>;</expr_stmt>
  <return>return <expr><name>ptr</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALL_MREMAP</name><parameter_list>(<parameter><type><name>addr</name></type></parameter>, <parameter><type><name>osz</name></type></parameter>, <parameter><type><name>nsz</name></type></parameter>, <parameter><type><name>mv</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>CALL_MREMAP_((addr), (osz), (nsz), (mv))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALL_MREMAP_NOMOVE</name></cpp:macro>	<cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALL_MREMAP_MAYMOVE</name></cpp:macro>	<cpp:value>1</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_64</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>LJ_GC64</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALL_MREMAP_MV</name></cpp:macro>		<cpp:value>CALL_MREMAP_NOMOVE</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALL_MREMAP_MV</name></cpp:macro>		<cpp:value>CALL_MREMAP_MAYMOVE</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>INIT_MMAP</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INIT_MMAP</name><parameter_list>()</parameter_list></cpp:macro>		<cpp:value>((void)0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>DIRECT_MMAP</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DIRECT_MMAP</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>CALL_MMAP(s)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>CALL_MREMAP</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALL_MREMAP</name><parameter_list>(<parameter><type><name>addr</name></type></parameter>, <parameter><type><name>osz</name></type></parameter>, <parameter><type><name>nsz</name></type></parameter>, <parameter><type><name>mv</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((void)osz, MFAIL)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* -----------------------  Chunk representations ------------------------ */</comment>

<struct>struct <name>malloc_chunk</name> <block>{
  <decl_stmt><decl><type><name>size_t</name></type>               <name>prev_foot</name></decl>;</decl_stmt>  <comment type="block">/* Size of previous chunk (if free).  */</comment>
  <decl_stmt><decl><type><name>size_t</name></type>               <name>head</name></decl>;</decl_stmt>       <comment type="block">/* Size and inuse bits. */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>malloc_chunk</name></name> <modifier>*</modifier></type><name>fd</name></decl>;</decl_stmt>         <comment type="block">/* double links -- used only if free. */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>malloc_chunk</name></name> <modifier>*</modifier></type><name>bk</name></decl>;</decl_stmt>
}</block>;</struct>

<typedef>typedef <type><name><name>struct</name> <name>malloc_chunk</name></name></type>  <name>mchunk</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>malloc_chunk</name></name> <modifier>*</modifier></type><name>mchunkptr</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>malloc_chunk</name></name> <modifier>*</modifier></type><name>sbinptr</name>;</typedef>  <comment type="block">/* The type of bins of chunks */</comment>
<typedef>typedef <type><name>size_t</name></type> <name>bindex_t</name>;</typedef>               <comment type="block">/* Described below */</comment>
<typedef>typedef <type><name>unsigned</name> <name>int</name></type> <name>binmap_t</name>;</typedef>         <comment type="block">/* Described below */</comment>
<typedef>typedef <type><name>unsigned</name> <name>int</name></type> <name>flag_t</name>;</typedef>           <comment type="block">/* The type of various bit flag sets */</comment>

<comment type="block">/* ------------------- Chunks sizes and alignments ----------------------- */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MCHUNK_SIZE</name></cpp:macro>		<cpp:value>(sizeof(mchunk))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHUNK_OVERHEAD</name></cpp:macro>		<cpp:value>(SIZE_T_SIZE)</cpp:value></cpp:define>

<comment type="block">/* Direct chunks need a second word of overhead ... */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DIRECT_CHUNK_OVERHEAD</name></cpp:macro>	<cpp:value>(TWO_SIZE_T_SIZES)</cpp:value></cpp:define>
<comment type="block">/* ... and additional padding for fake next-chunk at foot */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DIRECT_FOOT_PAD</name></cpp:macro>		<cpp:value>(FOUR_SIZE_T_SIZES)</cpp:value></cpp:define>

<comment type="block">/* The smallest size we can malloc is an aligned minimal chunk */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN_CHUNK_SIZE</name></cpp:macro>\
  <cpp:value>((MCHUNK_SIZE + CHUNK_ALIGN_MASK) &amp; ~CHUNK_ALIGN_MASK)</cpp:value></cpp:define>

<comment type="block">/* conversion from malloc headers to user pointers, and back */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>chunk2mem</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>((void *)((char *)(p) + TWO_SIZE_T_SIZES))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>mem2chunk</name><parameter_list>(<parameter><type><name>mem</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>((mchunkptr)((char *)(mem) - TWO_SIZE_T_SIZES))</cpp:value></cpp:define>
<comment type="block">/* chunk associated with aligned address A */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>align_as_chunk</name><parameter_list>(<parameter><type><name>A</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(mchunkptr)((A) + align_offset(chunk2mem(A)))</cpp:value></cpp:define>

<comment type="block">/* Bounds on request (not chunk) sizes. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_REQUEST</name></cpp:macro>		<cpp:value>((~MIN_CHUNK_SIZE+1) &lt;&lt; 2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN_REQUEST</name></cpp:macro>		<cpp:value>(MIN_CHUNK_SIZE - CHUNK_OVERHEAD - SIZE_T_ONE)</cpp:value></cpp:define>

<comment type="block">/* pad request bytes into a usable size */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pad_request</name><parameter_list>(<parameter><type><name>req</name></type></parameter>)</parameter_list></cpp:macro> \
   <cpp:value>(((req) + CHUNK_OVERHEAD + CHUNK_ALIGN_MASK) &amp; ~CHUNK_ALIGN_MASK)</cpp:value></cpp:define>

<comment type="block">/* pad request, checking for minimum (but not maximum) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>request2size</name><parameter_list>(<parameter><type><name>req</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>(((req) &lt; MIN_REQUEST)? MIN_CHUNK_SIZE : pad_request(req))</cpp:value></cpp:define>

<comment type="block">/* ------------------ Operations on head and foot fields ----------------- */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PINUSE_BIT</name></cpp:macro>		<cpp:value>(SIZE_T_ONE)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CINUSE_BIT</name></cpp:macro>		<cpp:value>(SIZE_T_TWO)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INUSE_BITS</name></cpp:macro>		<cpp:value>(PINUSE_BIT|CINUSE_BIT)</cpp:value></cpp:define>

<comment type="block">/* Head value for fenceposts */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FENCEPOST_HEAD</name></cpp:macro>		<cpp:value>(INUSE_BITS|SIZE_T_SIZE)</cpp:value></cpp:define>

<comment type="block">/* extraction of fields from head words */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>cinuse</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>((p)-&gt;head &amp; CINUSE_BIT)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pinuse</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>((p)-&gt;head &amp; PINUSE_BIT)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>chunksize</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>((p)-&gt;head &amp; ~(INUSE_BITS))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>clear_pinuse</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>((p)-&gt;head &amp;= ~PINUSE_BIT)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>clear_cinuse</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>((p)-&gt;head &amp;= ~CINUSE_BIT)</cpp:value></cpp:define>

<comment type="block">/* Treat space at ptr +/- offset as a chunk */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>chunk_plus_offset</name><parameter_list>(<parameter><type><name>p</name></type></parameter>, <parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>((mchunkptr)(((char *)(p)) + (s)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>chunk_minus_offset</name><parameter_list>(<parameter><type><name>p</name></type></parameter>, <parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((mchunkptr)(((char *)(p)) - (s)))</cpp:value></cpp:define>

<comment type="block">/* Ptr to next or previous physical malloc_chunk. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>next_chunk</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((mchunkptr)(((char *)(p)) + ((p)-&gt;head &amp; ~INUSE_BITS)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>prev_chunk</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((mchunkptr)(((char *)(p)) - ((p)-&gt;prev_foot) ))</cpp:value></cpp:define>

<comment type="block">/* extract next chunk's pinuse bit */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>next_pinuse</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((next_chunk(p)-&gt;head) &amp; PINUSE_BIT)</cpp:value></cpp:define>

<comment type="block">/* Get/set size at footer */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>get_foot</name><parameter_list>(<parameter><type><name>p</name></type></parameter>, <parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(((mchunkptr)((char *)(p) + (s)))-&gt;prev_foot)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>set_foot</name><parameter_list>(<parameter><type><name>p</name></type></parameter>, <parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(((mchunkptr)((char *)(p) + (s)))-&gt;prev_foot = (s))</cpp:value></cpp:define>

<comment type="block">/* Set size, pinuse bit, and foot */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>set_size_and_pinuse_of_free_chunk</name><parameter_list>(<parameter><type><name>p</name></type></parameter>, <parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro>\
  <cpp:value>((p)-&gt;head = (s|PINUSE_BIT), set_foot(p, s))</cpp:value></cpp:define>

<comment type="block">/* Set size, pinuse bit, foot, and clear next pinuse */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>set_free_with_pinuse</name><parameter_list>(<parameter><type><name>p</name></type></parameter>, <parameter><type><name>s</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro>\
  <cpp:value>(clear_pinuse(n), set_size_and_pinuse_of_free_chunk(p, s))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>is_direct</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro>\
  <cpp:value>(!((p)-&gt;head &amp; PINUSE_BIT) &amp;&amp; ((p)-&gt;prev_foot &amp; IS_DIRECT_BIT))</cpp:value></cpp:define>

<comment type="block">/* Get the internal overhead associated with chunk p */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>overhead_for</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro>\
 <cpp:value>(is_direct(p)? DIRECT_CHUNK_OVERHEAD : CHUNK_OVERHEAD)</cpp:value></cpp:define>

<comment type="block">/* ---------------------- Overlaid data structures ----------------------- */</comment>

<struct>struct <name>malloc_tree_chunk</name> <block>{
  <comment type="block">/* The first four fields must be compatible with malloc_chunk */</comment>
  <decl_stmt><decl><type><name>size_t</name></type>                    <name>prev_foot</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type>                    <name>head</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>malloc_tree_chunk</name></name> <modifier>*</modifier></type><name>fd</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>malloc_tree_chunk</name></name> <modifier>*</modifier></type><name>bk</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name><name>struct</name> <name>malloc_tree_chunk</name></name> <modifier>*</modifier></type><name><name>child</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>malloc_tree_chunk</name></name> <modifier>*</modifier></type><name>parent</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bindex_t</name></type>                  <name>index</name></decl>;</decl_stmt>
}</block>;</struct>

<typedef>typedef <type><name><name>struct</name> <name>malloc_tree_chunk</name></name></type>  <name>tchunk</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>malloc_tree_chunk</name></name> <modifier>*</modifier></type><name>tchunkptr</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>malloc_tree_chunk</name></name> <modifier>*</modifier></type><name>tbinptr</name>;</typedef> <comment type="block">/* The type of bins of trees */</comment>

<comment type="block">/* A little helper macro for trees */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>leftmost_child</name><parameter_list>(<parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((t)-&gt;child[0] != 0? (t)-&gt;child[0] : (t)-&gt;child[1])</cpp:value></cpp:define>

<comment type="block">/* ----------------------------- Segments -------------------------------- */</comment>

<struct>struct <name>malloc_segment</name> <block>{
  <decl_stmt><decl><type><name>char</name>        <modifier>*</modifier></type><name>base</name></decl>;</decl_stmt>             <comment type="block">/* base address */</comment>
  <decl_stmt><decl><type><name>size_t</name></type>       <name>size</name></decl>;</decl_stmt>             <comment type="block">/* allocated size */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>malloc_segment</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>   <comment type="block">/* ptr to next segment */</comment>
}</block>;</struct>

<typedef>typedef <type><name><name>struct</name> <name>malloc_segment</name></name></type>  <name>msegment</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>malloc_segment</name></name> <modifier>*</modifier></type><name>msegmentptr</name>;</typedef>

<comment type="block">/* ---------------------------- malloc_state ----------------------------- */</comment>

<comment type="block">/* Bin types, widths and sizes */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NSMALLBINS</name></cpp:macro>		<cpp:value>(32U)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NTREEBINS</name></cpp:macro>		<cpp:value>(32U)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SMALLBIN_SHIFT</name></cpp:macro>		<cpp:value>(3U)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SMALLBIN_WIDTH</name></cpp:macro>		<cpp:value>(SIZE_T_ONE &lt;&lt; SMALLBIN_SHIFT)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TREEBIN_SHIFT</name></cpp:macro>		<cpp:value>(8U)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN_LARGE_SIZE</name></cpp:macro>		<cpp:value>(SIZE_T_ONE &lt;&lt; TREEBIN_SHIFT)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_SMALL_SIZE</name></cpp:macro>		<cpp:value>(MIN_LARGE_SIZE - SIZE_T_ONE)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_SMALL_REQUEST</name></cpp:macro>  <cpp:value>(MAX_SMALL_SIZE - CHUNK_ALIGN_MASK - CHUNK_OVERHEAD)</cpp:value></cpp:define>

<struct>struct <name>malloc_state</name> <block>{
  <decl_stmt><decl><type><name>binmap_t</name></type>   <name>smallmap</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>binmap_t</name></type>   <name>treemap</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type>     <name>dvsize</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type>     <name>topsize</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>mchunkptr</name></type>  <name>dv</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>mchunkptr</name></type>  <name>top</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type>     <name>trim_check</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type>     <name>release_checks</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>mchunkptr</name></type>  <name><name>smallbins</name><index>[<expr><operator>(</operator><name>NSMALLBINS</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>tbinptr</name></type>    <name><name>treebins</name><index>[<expr><name>NTREEBINS</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>msegment</name></type>   <name>seg</name></decl>;</decl_stmt>
}</block>;</struct>

<typedef>typedef <type><name><name>struct</name> <name>malloc_state</name></name> <modifier>*</modifier></type><name>mstate</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>is_initialized</name><parameter_list>(<parameter><type><name>M</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((M)-&gt;top != 0)</cpp:value></cpp:define>

<comment type="block">/* -------------------------- system alloc setup ------------------------- */</comment>

<comment type="block">/* page-align a size */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>page_align</name><parameter_list>(<parameter><type><name>S</name></type></parameter>)</parameter_list></cpp:macro>\
 <cpp:value>(((S) + (LJ_PAGESIZE - SIZE_T_ONE)) &amp; ~(LJ_PAGESIZE - SIZE_T_ONE))</cpp:value></cpp:define>

<comment type="block">/* granularity-align a size */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>granularity_align</name><parameter_list>(<parameter><type><name>S</name></type></parameter>)</parameter_list></cpp:macro>\
  <cpp:value>(((S) + (DEFAULT_GRANULARITY - SIZE_T_ONE))\
   &amp; ~(DEFAULT_GRANULARITY - SIZE_T_ONE))</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_WINDOWS</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>mmap_align</name><parameter_list>(<parameter><type><name>S</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>granularity_align(S)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>mmap_align</name><parameter_list>(<parameter><type><name>S</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>page_align(S)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*  True if segment S holds address A */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>segment_holds</name><parameter_list>(<parameter><type><name>S</name></type></parameter>, <parameter><type><name>A</name></type></parameter>)</parameter_list></cpp:macro>\
  <cpp:value>((char *)(A) &gt;= S-&gt;base &amp;&amp; (char *)(A) &lt; S-&gt;base + S-&gt;size)</cpp:value></cpp:define>

<comment type="block">/* Return segment holding given address */</comment>
<function><type><specifier>static</specifier> <name>msegmentptr</name></type> <name>segment_holding</name><parameter_list>(<parameter><decl><type><name>mstate</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>addr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>msegmentptr</name></type> <name>sp</name> <init>= <expr><operator>&amp;</operator><name><name>m</name><operator>-&gt;</operator><name>seg</name></name></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>addr</name> <operator>&gt;=</operator> <name><name>sp</name><operator>-&gt;</operator><name>base</name></name> <operator>&amp;&amp;</operator> <name>addr</name> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>base</name></name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>sp</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>sp</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>next</name></name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* Return true if segment contains a segment link */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>has_segment_link</name><parameter_list>(<parameter><decl><type><name>mstate</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>msegmentptr</name></type> <name>ss</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>msegmentptr</name></type> <name>sp</name> <init>= <expr><operator>&amp;</operator><name><name>m</name><operator>-&gt;</operator><name>seg</name></name></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>sp</name> <operator>&gt;=</operator> <name><name>ss</name><operator>-&gt;</operator><name>base</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>sp</name> <operator>&lt;</operator> <name><name>ss</name><operator>-&gt;</operator><name>base</name></name> <operator>+</operator> <name><name>ss</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>sp</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>next</name></name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
  TOP_FOOT_SIZE is padding at the end of a segment, including space
  that may be needed to place segment records and fenceposts when new
  noncontiguous segments are added.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TOP_FOOT_SIZE</name></cpp:macro>\
  <cpp:value>(align_offset(chunk2mem(0))+pad_request(sizeof(struct malloc_segment))+MIN_CHUNK_SIZE)</cpp:value></cpp:define>

<comment type="block">/* ---------------------------- Indexing Bins ---------------------------- */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>is_small</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>(((s) &gt;&gt; SMALLBIN_SHIFT) &lt; NSMALLBINS)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>small_index</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>((s)  &gt;&gt; SMALLBIN_SHIFT)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>small_index2size</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((i)  &lt;&lt; SMALLBIN_SHIFT)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN_SMALL_INDEX</name></cpp:macro>		<cpp:value>(small_index(MIN_CHUNK_SIZE))</cpp:value></cpp:define>

<comment type="block">/* addressing by index. See above about smallbin repositioning */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>smallbin_at</name><parameter_list>(<parameter><type><name>M</name></type></parameter>, <parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((sbinptr)((char *)&amp;((M)-&gt;smallbins[(i)&lt;&lt;1])))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>treebin_at</name><parameter_list>(<parameter><type><name>M</name></type></parameter>,<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>(&amp;((M)-&gt;treebins[i]))</cpp:value></cpp:define>

<comment type="block">/* assign tree index for size S to variable I */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>compute_tree_index</name><parameter_list>(<parameter><type><name>S</name></type></parameter>, <parameter><type><name>I</name></type></parameter>)</parameter_list></cpp:macro>\
<cpp:value>{\
  unsigned int X = (unsigned int)(S &gt;&gt; TREEBIN_SHIFT);\
  if (X == 0) {\
    I = 0;\
  } else if (X &gt; 0xFFFF) {\
    I = NTREEBINS-1;\
  } else {\
    unsigned int K = lj_fls(X);\
    I =  (bindex_t)((K &lt;&lt; 1) + ((S &gt;&gt; (K + (TREEBIN_SHIFT-1)) &amp; 1)));\
  }\
}</cpp:value></cpp:define>

<comment type="block">/* Bit representing maximum resolved size in a treebin at i */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>bit_for_tree_index</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> \
   <cpp:value>(i == NTREEBINS-1)? (SIZE_T_BITSIZE-1) : (((i) &gt;&gt; 1) + TREEBIN_SHIFT - 2)</cpp:value></cpp:define>

<comment type="block">/* Shift placing maximum resolved bit in a treebin at i as sign bit */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>leftshift_for_tree_index</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> \
   <cpp:value>((i == NTREEBINS-1)? 0 : \
    ((SIZE_T_BITSIZE-SIZE_T_ONE) - (((i) &gt;&gt; 1) + TREEBIN_SHIFT - 2)))</cpp:value></cpp:define>

<comment type="block">/* The size of the smallest chunk held in bin with index i */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>minsize_for_tree_index</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> \
   <cpp:value>((SIZE_T_ONE &lt;&lt; (((i) &gt;&gt; 1) + TREEBIN_SHIFT)) |  \
   (((size_t)((i) &amp; SIZE_T_ONE)) &lt;&lt; (((i) &gt;&gt; 1) + TREEBIN_SHIFT - 1)))</cpp:value></cpp:define>

<comment type="block">/* ------------------------ Operations on bin maps ----------------------- */</comment>

<comment type="block">/* bit corresponding to given index */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>idx2bit</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>((binmap_t)(1) &lt;&lt; (i))</cpp:value></cpp:define>

<comment type="block">/* Mark/Clear bits with given index */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>mark_smallmap</name><parameter_list>(<parameter><type><name>M</name></type></parameter>,<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((M)-&gt;smallmap |=  idx2bit(i))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>clear_smallmap</name><parameter_list>(<parameter><type><name>M</name></type></parameter>,<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((M)-&gt;smallmap &amp;= ~idx2bit(i))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>smallmap_is_marked</name><parameter_list>(<parameter><type><name>M</name></type></parameter>,<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((M)-&gt;smallmap &amp;   idx2bit(i))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>mark_treemap</name><parameter_list>(<parameter><type><name>M</name></type></parameter>,<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((M)-&gt;treemap  |=  idx2bit(i))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>clear_treemap</name><parameter_list>(<parameter><type><name>M</name></type></parameter>,<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((M)-&gt;treemap  &amp;= ~idx2bit(i))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>treemap_is_marked</name><parameter_list>(<parameter><type><name>M</name></type></parameter>,<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((M)-&gt;treemap  &amp;   idx2bit(i))</cpp:value></cpp:define>

<comment type="block">/* mask with all bits to left of least bit of x on */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>left_bits</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>((x&lt;&lt;1) | (~(x&lt;&lt;1)+1))</cpp:value></cpp:define>

<comment type="block">/* Set cinuse bit and pinuse bit of next chunk */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>set_inuse</name><parameter_list>(<parameter><type><name>M</name></type></parameter>,<parameter><type><name>p</name></type></parameter>,<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro>\
  <cpp:value>((p)-&gt;head = (((p)-&gt;head &amp; PINUSE_BIT)|s|CINUSE_BIT),\
  ((mchunkptr)(((char *)(p)) + (s)))-&gt;head |= PINUSE_BIT)</cpp:value></cpp:define>

<comment type="block">/* Set cinuse and pinuse of this chunk and pinuse of next chunk */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>set_inuse_and_pinuse</name><parameter_list>(<parameter><type><name>M</name></type></parameter>,<parameter><type><name>p</name></type></parameter>,<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro>\
  <cpp:value>((p)-&gt;head = (s|PINUSE_BIT|CINUSE_BIT),\
  ((mchunkptr)(((char *)(p)) + (s)))-&gt;head |= PINUSE_BIT)</cpp:value></cpp:define>

<comment type="block">/* Set size, cinuse and pinuse bit of this chunk */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>set_size_and_pinuse_of_inuse_chunk</name><parameter_list>(<parameter><type><name>M</name></type></parameter>, <parameter><type><name>p</name></type></parameter>, <parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro>\
  <cpp:value>((p)-&gt;head = (s|PINUSE_BIT|CINUSE_BIT))</cpp:value></cpp:define>

<comment type="block">/* ----------------------- Operations on smallbins ----------------------- */</comment>

<comment type="block">/* Link a free chunk into a smallbin  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>insert_small_chunk</name><parameter_list>(<parameter><type><name>M</name></type></parameter>, <parameter><type><name>P</name></type></parameter>, <parameter><type><name>S</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{\
  bindex_t I = small_index(S);\
  mchunkptr B = smallbin_at(M, I);\
  mchunkptr F = B;\
  if (!smallmap_is_marked(M, I))\
    mark_smallmap(M, I);\
  else\
    F = B-&gt;fd;\
  B-&gt;fd = P;\
  F-&gt;bk = P;\
  P-&gt;fd = F;\
  P-&gt;bk = B;\
}</cpp:value></cpp:define>

<comment type="block">/* Unlink a chunk from a smallbin  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>unlink_small_chunk</name><parameter_list>(<parameter><type><name>M</name></type></parameter>, <parameter><type><name>P</name></type></parameter>, <parameter><type><name>S</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{\
  mchunkptr F = P-&gt;fd;\
  mchunkptr B = P-&gt;bk;\
  bindex_t I = small_index(S);\
  if (F == B) {\
    clear_smallmap(M, I);\
  } else {\
    F-&gt;bk = B;\
    B-&gt;fd = F;\
  }\
}</cpp:value></cpp:define>

<comment type="block">/* Unlink the first chunk from a smallbin */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>unlink_first_small_chunk</name><parameter_list>(<parameter><type><name>M</name></type></parameter>, <parameter><type><name>B</name></type></parameter>, <parameter><type><name>P</name></type></parameter>, <parameter><type><name>I</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{\
  mchunkptr F = P-&gt;fd;\
  if (B == F) {\
    clear_smallmap(M, I);\
  } else {\
    B-&gt;fd = F;\
    F-&gt;bk = B;\
  }\
}</cpp:value></cpp:define>

<comment type="block">/* Replace dv node, binning the old one */</comment>
<comment type="block">/* Used only when dvsize known to be small */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>replace_dv</name><parameter_list>(<parameter><type><name>M</name></type></parameter>, <parameter><type><name>P</name></type></parameter>, <parameter><type><name>S</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{\
  size_t DVS = M-&gt;dvsize;\
  if (DVS != 0) {\
    mchunkptr DV = M-&gt;dv;\
    insert_small_chunk(M, DV, DVS);\
  }\
  M-&gt;dvsize = S;\
  M-&gt;dv = P;\
}</cpp:value></cpp:define>

<comment type="block">/* ------------------------- Operations on trees ------------------------- */</comment>

<comment type="block">/* Insert chunk into tree */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>insert_large_chunk</name><parameter_list>(<parameter><type><name>M</name></type></parameter>, <parameter><type><name>X</name></type></parameter>, <parameter><type><name>S</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{\
  tbinptr *H;\
  bindex_t I;\
  compute_tree_index(S, I);\
  H = treebin_at(M, I);\
  X-&gt;index = I;\
  X-&gt;child[0] = X-&gt;child[1] = 0;\
  if (!treemap_is_marked(M, I)) {\
    mark_treemap(M, I);\
    *H = X;\
    X-&gt;parent = (tchunkptr)H;\
    X-&gt;fd = X-&gt;bk = X;\
  } else {\
    tchunkptr T = *H;\
    size_t K = S &lt;&lt; leftshift_for_tree_index(I);\
    for (;;) {\
      if (chunksize(T) != S) {\
	tchunkptr *C = &amp;(T-&gt;child[(K &gt;&gt; (SIZE_T_BITSIZE-SIZE_T_ONE)) &amp; 1]);\
	K &lt;&lt;= 1;\
	if (*C != 0) {\
	  T = *C;\
	} else {\
	  *C = X;\
	  X-&gt;parent = T;\
	  X-&gt;fd = X-&gt;bk = X;\
	  break;\
	}\
      } else {\
	tchunkptr F = T-&gt;fd;\
	T-&gt;fd = F-&gt;bk = X;\
	X-&gt;fd = F;\
	X-&gt;bk = T;\
	X-&gt;parent = 0;\
	break;\
      }\
    }\
  }\
}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>unlink_large_chunk</name><parameter_list>(<parameter><type><name>M</name></type></parameter>, <parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{\
  tchunkptr XP = X-&gt;parent;\
  tchunkptr R;\
  if (X-&gt;bk != X) {\
    tchunkptr F = X-&gt;fd;\
    R = X-&gt;bk;\
    F-&gt;bk = R;\
    R-&gt;fd = F;\
  } else {\
    tchunkptr *RP;\
    if (((R = *(RP = &amp;(X-&gt;child[1]))) != 0) ||\
	((R = *(RP = &amp;(X-&gt;child[0]))) != 0)) {\
      tchunkptr *CP;\
      while ((*(CP = &amp;(R-&gt;child[1])) != 0) ||\
	     (*(CP = &amp;(R-&gt;child[0])) != 0)) {\
	R = *(RP = CP);\
      }\
      *RP = 0;\
    }\
  }\
  if (XP != 0) {\
    tbinptr *H = treebin_at(M, X-&gt;index);\
    if (X == *H) {\
      if ((*H = R) == 0) \
	clear_treemap(M, X-&gt;index);\
    } else {\
      if (XP-&gt;child[0] == X) \
	XP-&gt;child[0] = R;\
      else \
	XP-&gt;child[1] = R;\
    }\
    if (R != 0) {\
      tchunkptr C0, C1;\
      R-&gt;parent = XP;\
      if ((C0 = X-&gt;child[0]) != 0) {\
	R-&gt;child[0] = C0;\
	C0-&gt;parent = R;\
      }\
      if ((C1 = X-&gt;child[1]) != 0) {\
	R-&gt;child[1] = C1;\
	C1-&gt;parent = R;\
      }\
    }\
  }\
}</cpp:value></cpp:define>

<comment type="block">/* Relays to large vs small bin operations */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>insert_chunk</name><parameter_list>(<parameter><type><name>M</name></type></parameter>, <parameter><type><name>P</name></type></parameter>, <parameter><type><name>S</name></type></parameter>)</parameter_list></cpp:macro>\
  <cpp:value>if (is_small(S)) { insert_small_chunk(M, P, S)\
  } else { tchunkptr TP = (tchunkptr)(P); insert_large_chunk(M, TP, S); }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>unlink_chunk</name><parameter_list>(<parameter><type><name>M</name></type></parameter>, <parameter><type><name>P</name></type></parameter>, <parameter><type><name>S</name></type></parameter>)</parameter_list></cpp:macro>\
  <cpp:value>if (is_small(S)) { unlink_small_chunk(M, P, S)\
  } else { tchunkptr TP = (tchunkptr)(P); unlink_large_chunk(M, TP); }</cpp:value></cpp:define>

<comment type="block">/* -----------------------  Direct-mmapping chunks ----------------------- */</comment>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>direct_alloc</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>nb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>size_t</name></type> <name>mmsize</name> <init>= <expr><call><name>mmap_align</name><argument_list>(<argument><expr><name>nb</name> <operator>+</operator> <name>SIX_SIZE_T_SIZES</name> <operator>+</operator> <name>CHUNK_ALIGN_MASK</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>LJ_LIKELY</name><argument_list>(<argument><expr><name>mmsize</name> <operator>&gt;</operator> <name>nb</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>     <comment type="block">/* Check for wrap around 0 */</comment>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>mm</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><call><name>DIRECT_MMAP</name><argument_list>(<argument><expr><name>mmsize</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>mm</name> <operator>!=</operator> <name>CMFAIL</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>size_t</name></type> <name>offset</name> <init>= <expr><call><name>align_offset</name><argument_list>(<argument><expr><call><name>chunk2mem</name><argument_list>(<argument><expr><name>mm</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>size_t</name></type> <name>psize</name> <init>= <expr><name>mmsize</name> <operator>-</operator> <name>offset</name> <operator>-</operator> <name>DIRECT_FOOT_PAD</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>mchunkptr</name></type> <name>p</name> <init>= <expr><operator>(</operator><name>mchunkptr</name><operator>)</operator><operator>(</operator><name>mm</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>prev_foot</name></name> <operator>=</operator> <name>offset</name> <operator>|</operator> <name>IS_DIRECT_BIT</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <name>psize</name><operator>|</operator><name>CINUSE_BIT</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>chunk_plus_offset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>psize</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>head</name> <operator>=</operator> <name>FENCEPOST_HEAD</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>chunk_plus_offset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>psize</name><operator>+</operator><name>SIZE_T_SIZE</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>head</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <return>return <expr><call><name>chunk2mem</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>mchunkptr</name></type> <name>direct_resize</name><parameter_list>(<parameter><decl><type><name>mchunkptr</name></type> <name>oldp</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>size_t</name></type> <name>oldsize</name> <init>= <expr><call><name>chunksize</name><argument_list>(<argument><expr><name>oldp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>is_small</name><argument_list>(<argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* Can't shrink direct regions below small size */</comment>
    <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
  <comment type="block">/* Keep old chunk if big enough but not too big */</comment>
  <if_stmt><if>if <condition>(<expr><name>oldsize</name> <operator>&gt;=</operator> <name>nb</name> <operator>+</operator> <name>SIZE_T_SIZE</name> <operator>&amp;&amp;</operator>
      <operator>(</operator><name>oldsize</name> <operator>-</operator> <name>nb</name><operator>)</operator> <operator>&lt;=</operator> <operator>(</operator><name>DEFAULT_GRANULARITY</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>oldp</name></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>offset</name> <init>= <expr><name><name>oldp</name><operator>-&gt;</operator><name>prev_foot</name></name> <operator>&amp;</operator> <operator>~</operator><name>IS_DIRECT_BIT</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>oldmmsize</name> <init>= <expr><name>oldsize</name> <operator>+</operator> <name>offset</name> <operator>+</operator> <name>DIRECT_FOOT_PAD</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>newmmsize</name> <init>= <expr><call><name>mmap_align</name><argument_list>(<argument><expr><name>nb</name> <operator>+</operator> <name>SIX_SIZE_T_SIZES</name> <operator>+</operator> <name>CHUNK_ALIGN_MASK</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cp</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>CALL_MREMAP</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>oldp</name> <operator>-</operator> <name>offset</name></expr></argument>,
				   <argument><expr><name>oldmmsize</name></expr></argument>, <argument><expr><name>newmmsize</name></expr></argument>, <argument><expr><name>CALL_MREMAP_MV</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>cp</name> <operator>!=</operator> <name>CMFAIL</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>mchunkptr</name></type> <name>newp</name> <init>= <expr><operator>(</operator><name>mchunkptr</name><operator>)</operator><operator>(</operator><name>cp</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>size_t</name></type> <name>psize</name> <init>= <expr><name>newmmsize</name> <operator>-</operator> <name>offset</name> <operator>-</operator> <name>DIRECT_FOOT_PAD</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>newp</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <name>psize</name><operator>|</operator><name>CINUSE_BIT</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>chunk_plus_offset</name><argument_list>(<argument><expr><name>newp</name></expr></argument>, <argument><expr><name>psize</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>head</name> <operator>=</operator> <name>FENCEPOST_HEAD</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>chunk_plus_offset</name><argument_list>(<argument><expr><name>newp</name></expr></argument>, <argument><expr><name>psize</name><operator>+</operator><name>SIZE_T_SIZE</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>head</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <return>return <expr><name>newp</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -------------------------- mspace management -------------------------- */</comment>

<comment type="block">/* Initialize top chunk and its size */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>init_top</name><parameter_list>(<parameter><decl><type><name>mstate</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>mchunkptr</name></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>psize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Ensure alignment */</comment>
  <decl_stmt><decl><type><name>size_t</name></type> <name>offset</name> <init>= <expr><call><name>align_offset</name><argument_list>(<argument><expr><call><name>chunk2mem</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>mchunkptr</name><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>p</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>psize</name> <operator>-=</operator> <name>offset</name></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>topsize</name></name> <operator>=</operator> <name>psize</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <name>psize</name> <operator>|</operator> <name>PINUSE_BIT</name></expr>;</expr_stmt>
  <comment type="block">/* set size of fake trailing chunk holding overhead space only once */</comment>
  <expr_stmt><expr><call><name>chunk_plus_offset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>psize</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>head</name> <operator>=</operator> <name>TOP_FOOT_SIZE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>trim_check</name></name> <operator>=</operator> <name>DEFAULT_TRIM_THRESHOLD</name></expr>;</expr_stmt> <comment type="block">/* reset on each update */</comment>
</block_content>}</block></function>

<comment type="block">/* Initialize bins for a new mstate that is otherwise zeroed out */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>init_bins</name><parameter_list>(<parameter><decl><type><name>mstate</name></type> <name>m</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Establish circular links for smallbins */</comment>
  <decl_stmt><decl><type><name>bindex_t</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NSMALLBINS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>sbinptr</name></type> <name>bin</name> <init>= <expr><call><name>smallbin_at</name><argument_list>(<argument><expr><name>m</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>fd</name></name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>bk</name></name> <operator>=</operator> <name>bin</name></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* Allocate chunk and prepend remainder with chunk in successor base. */</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>prepend_alloc</name><parameter_list>(<parameter><decl><type><name>mstate</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>newbase</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>oldbase</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>mchunkptr</name></type> <name>p</name> <init>= <expr><call><name>align_as_chunk</name><argument_list>(<argument><expr><name>newbase</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>mchunkptr</name></type> <name>oldfirst</name> <init>= <expr><call><name>align_as_chunk</name><argument_list>(<argument><expr><name>oldbase</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>psize</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>oldfirst</name> <operator>-</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>p</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>mchunkptr</name></type> <name>q</name> <init>= <expr><call><name>chunk_plus_offset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>qsize</name> <init>= <expr><name>psize</name> <operator>-</operator> <name>nb</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>set_size_and_pinuse_of_inuse_chunk</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* consolidate remainder with first chunk of old base */</comment>
  <if_stmt><if>if <condition>(<expr><name>oldfirst</name> <operator>==</operator> <name><name>m</name><operator>-&gt;</operator><name>top</name></name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>tsize</name> <init>= <expr><name><name>m</name><operator>-&gt;</operator><name>topsize</name></name> <operator>+=</operator> <name>qsize</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name>q</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>q</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <name>tsize</name> <operator>|</operator> <name>PINUSE_BIT</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>oldfirst</name> <operator>==</operator> <name><name>m</name><operator>-&gt;</operator><name>dv</name></name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>dsize</name> <init>= <expr><name><name>m</name><operator>-&gt;</operator><name>dvsize</name></name> <operator>+=</operator> <name>qsize</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>dv</name></name> <operator>=</operator> <name>q</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>set_size_and_pinuse_of_free_chunk</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>dsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cinuse</name><argument_list>(<argument><expr><name>oldfirst</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>size_t</name></type> <name>nsize</name> <init>= <expr><call><name>chunksize</name><argument_list>(<argument><expr><name>oldfirst</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>unlink_chunk</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>oldfirst</name></expr></argument>, <argument><expr><name>nsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>oldfirst</name> <operator>=</operator> <call><name>chunk_plus_offset</name><argument_list>(<argument><expr><name>oldfirst</name></expr></argument>, <argument><expr><name>nsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>qsize</name> <operator>+=</operator> <name>nsize</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>set_free_with_pinuse</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>qsize</name></expr></argument>, <argument><expr><name>oldfirst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>insert_chunk</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>q</name></expr></argument>, <argument><expr><name>qsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><call><name>chunk2mem</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Add a segment to hold a new noncontiguous region */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>add_segment</name><parameter_list>(<parameter><decl><type><name>mstate</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>tbase</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>tsize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Determine locations and sizes of segment, fenceposts, old top */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>old_top</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>m</name><operator>-&gt;</operator><name>top</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>msegmentptr</name></type> <name>oldsp</name> <init>= <expr><call><name>segment_holding</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>old_top</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>old_end</name> <init>= <expr><name><name>oldsp</name><operator>-&gt;</operator><name>base</name></name> <operator>+</operator> <name><name>oldsp</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>ssize</name> <init>= <expr><call><name>pad_request</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>malloc_segment</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>rawsp</name> <init>= <expr><name>old_end</name> <operator>-</operator> <operator>(</operator><name>ssize</name> <operator>+</operator> <name>FOUR_SIZE_T_SIZES</name> <operator>+</operator> <name>CHUNK_ALIGN_MASK</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>offset</name> <init>= <expr><call><name>align_offset</name><argument_list>(<argument><expr><call><name>chunk2mem</name><argument_list>(<argument><expr><name>rawsp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>asp</name> <init>= <expr><name>rawsp</name> <operator>+</operator> <name>offset</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>csp</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>asp</name> <operator>&lt;</operator> <operator>(</operator><name>old_top</name> <operator>+</operator> <name>MIN_CHUNK_SIZE</name><operator>)</operator><operator>)</operator></expr>?</condition><then> <expr><name>old_top</name></expr> </then><else>: <expr><name>asp</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>mchunkptr</name></type> <name>sp</name> <init>= <expr><operator>(</operator><name>mchunkptr</name><operator>)</operator><name>csp</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>msegmentptr</name></type> <name>ss</name> <init>= <expr><operator>(</operator><name>msegmentptr</name><operator>)</operator><operator>(</operator><call><name>chunk2mem</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>mchunkptr</name></type> <name>tnext</name> <init>= <expr><call><name>chunk_plus_offset</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><name>ssize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>mchunkptr</name></type> <name>p</name> <init>= <expr><name>tnext</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* reset top to new space */</comment>
  <expr_stmt><expr><call><name>init_top</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><operator>(</operator><name>mchunkptr</name><operator>)</operator><name>tbase</name></expr></argument>, <argument><expr><name>tsize</name> <operator>-</operator> <name>TOP_FOOT_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Set up segment record */</comment>
  <expr_stmt><expr><call><name>set_size_and_pinuse_of_inuse_chunk</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>ssize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>ss</name> <operator>=</operator> <name><name>m</name><operator>-&gt;</operator><name>seg</name></name></expr>;</expr_stmt> <comment type="block">/* Push current record */</comment>
  <expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>seg</name><operator>.</operator><name>base</name></name> <operator>=</operator> <name>tbase</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>seg</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name>tsize</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>seg</name><operator>.</operator><name>next</name></name> <operator>=</operator> <name>ss</name></expr>;</expr_stmt>

  <comment type="block">/* Insert trailing fenceposts */</comment>
  <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>mchunkptr</name></type> <name>nextp</name> <init>= <expr><call><name>chunk_plus_offset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SIZE_T_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <name>FENCEPOST_HEAD</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><operator>(</operator><name><name>nextp</name><operator>-&gt;</operator><name>head</name></name><operator>)</operator><operator>)</operator> <operator>&lt;</operator> <name>old_end</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <name>nextp</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <break>break;</break></block_content></block></else></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Insert the rest of old top into a bin as an ordinary free chunk */</comment>
  <if_stmt><if>if <condition>(<expr><name>csp</name> <operator>!=</operator> <name>old_top</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>mchunkptr</name></type> <name>q</name> <init>= <expr><operator>(</operator><name>mchunkptr</name><operator>)</operator><name>old_top</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>psize</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>csp</name> <operator>-</operator> <name>old_top</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mchunkptr</name></type> <name>tn</name> <init>= <expr><call><name>chunk_plus_offset</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>psize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>set_free_with_pinuse</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>psize</name></expr></argument>, <argument><expr><name>tn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>insert_chunk</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>q</name></expr></argument>, <argument><expr><name>psize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* -------------------------- System allocation -------------------------- */</comment>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>alloc_sys</name><parameter_list>(<parameter><decl><type><name>mstate</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tbase</name> <init>= <expr><name>CMFAIL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>tsize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Directly map large chunks */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>LJ_UNLIKELY</name><argument_list>(<argument><expr><name>nb</name> <operator>&gt;=</operator> <name>DEFAULT_MMAP_THRESHOLD</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>mem</name> <init>= <expr><call><name>direct_alloc</name><argument_list>(<argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>mem</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>mem</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>req</name> <init>= <expr><name>nb</name> <operator>+</operator> <name>TOP_FOOT_SIZE</name> <operator>+</operator> <name>SIZE_T_ONE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>rsize</name> <init>= <expr><call><name>granularity_align</name><argument_list>(<argument><expr><name>req</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>LJ_LIKELY</name><argument_list>(<argument><expr><name>rsize</name> <operator>&gt;</operator> <name>nb</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> <comment type="block">/* Fail if wraps around zero */</comment>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>mp</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><call><name>CALL_MMAP</name><argument_list>(<argument><expr><name>rsize</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>mp</name> <operator>!=</operator> <name>CMFAIL</name></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name>tbase</name> <operator>=</operator> <name>mp</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>tsize</name> <operator>=</operator> <name>rsize</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>

  <if_stmt><if>if <condition>(<expr><name>tbase</name> <operator>!=</operator> <name>CMFAIL</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>msegmentptr</name></type> <name>sp</name> <init>= <expr><operator>&amp;</operator><name><name>m</name><operator>-&gt;</operator><name>seg</name></name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* Try to merge with an existing segment */</comment>
    <while>while <condition>(<expr><name>sp</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>tbase</name> <operator>!=</operator> <name><name>sp</name><operator>-&gt;</operator><name>base</name></name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>sp</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></while>
    <if_stmt><if>if <condition>(<expr><name>sp</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>segment_holds</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>top</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> <comment type="block">/* append */</comment>
      <expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>size</name></name> <operator>+=</operator> <name>tsize</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>init_top</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>top</name></name></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>topsize</name></name> <operator>+</operator> <name>tsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>sp</name> <operator>=</operator> <operator>&amp;</operator><name><name>m</name><operator>-&gt;</operator><name>seg</name></name></expr>;</expr_stmt>
      <while>while <condition>(<expr><name>sp</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>sp</name><operator>-&gt;</operator><name>base</name></name> <operator>!=</operator> <name>tbase</name> <operator>+</operator> <name>tsize</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>sp</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></while>
      <if_stmt><if>if <condition>(<expr><name>sp</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>oldbase</name> <init>= <expr><name><name>sp</name><operator>-&gt;</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <name>tbase</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>size</name></name> <operator>+=</operator> <name>tsize</name></expr>;</expr_stmt>
	<return>return <expr><call><name>prepend_alloc</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>tbase</name></expr></argument>, <argument><expr><name>oldbase</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr>;</return>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<expr_stmt><expr><call><name>add_segment</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>tbase</name></expr></argument>, <argument><expr><name>tsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>nb</name> <operator>&lt;</operator> <name><name>m</name><operator>-&gt;</operator><name>topsize</name></name></expr>)</condition> <block>{<block_content> <comment type="block">/* Allocate from new or extended top space */</comment>
      <decl_stmt><decl><type><name>size_t</name></type> <name>rsize</name> <init>= <expr><name><name>m</name><operator>-&gt;</operator><name>topsize</name></name> <operator>-=</operator> <name>nb</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>mchunkptr</name></type> <name>p</name> <init>= <expr><name><name>m</name><operator>-&gt;</operator><name>top</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>mchunkptr</name></type> <name>r</name> <init>= <expr><name><name>m</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <call><name>chunk_plus_offset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <name>rsize</name> <operator>|</operator> <name>PINUSE_BIT</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>set_size_and_pinuse_of_inuse_chunk</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><call><name>chunk2mem</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -----------------------  system deallocation -------------------------- */</comment>

<comment type="block">/* Unmap and unlink any mmapped segments that don't contain used chunks */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>release_unused_segments</name><parameter_list>(<parameter><decl><type><name>mstate</name></type> <name>m</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>size_t</name></type> <name>released</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>nsegs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>msegmentptr</name></type> <name>pred</name> <init>= <expr><operator>&amp;</operator><name><name>m</name><operator>-&gt;</operator><name>seg</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>msegmentptr</name></type> <name>sp</name> <init>= <expr><name><name>pred</name><operator>-&gt;</operator><name>next</name></name></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><name>sp</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>base</name> <init>= <expr><name><name>sp</name><operator>-&gt;</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><name><name>sp</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>msegmentptr</name></type> <name>next</name> <init>= <expr><name><name>sp</name><operator>-&gt;</operator><name>next</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>nsegs</name><operator>++</operator></expr>;</expr_stmt>
    <block>{<block_content>
      <decl_stmt><decl><type><name>mchunkptr</name></type> <name>p</name> <init>= <expr><call><name>align_as_chunk</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>size_t</name></type> <name>psize</name> <init>= <expr><call><name>chunksize</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <comment type="block">/* Can unmap if first chunk holds entire segment and not pinned */</comment>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cinuse</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>p</name> <operator>+</operator> <name>psize</name> <operator>&gt;=</operator> <name>base</name> <operator>+</operator> <name>size</name> <operator>-</operator> <name>TOP_FOOT_SIZE</name></expr>)</condition> <block>{<block_content>
	<decl_stmt><decl><type><name>tchunkptr</name></type> <name>tp</name> <init>= <expr><operator>(</operator><name>tchunkptr</name><operator>)</operator><name>p</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name><name>m</name><operator>-&gt;</operator><name>dv</name></name></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>dv</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>dvsize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
	  <expr_stmt><expr><call><name>unlink_large_chunk</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>CALL_MUNMAP</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><name>released</name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>
	  <comment type="block">/* unlink obsoleted record */</comment>
	  <expr_stmt><expr><name>sp</name> <operator>=</operator> <name>pred</name></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content> <comment type="block">/* back out if cannot unmap */</comment>
	  <expr_stmt><expr><call><name>insert_large_chunk</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>tp</name></expr></argument>, <argument><expr><name>psize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><name>pred</name> <operator>=</operator> <name>sp</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>sp</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <comment type="block">/* Reset check counter */</comment>
  <expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>release_checks</name></name> <operator>=</operator> <ternary><condition><expr><name>nsegs</name> <operator>&gt;</operator> <name>MAX_RELEASE_CHECK_RATE</name></expr> ?</condition><then>
		      <expr><name>nsegs</name></expr> </then><else>: <expr><name>MAX_RELEASE_CHECK_RATE</name></expr></else></ternary></expr>;</expr_stmt>
  <return>return <expr><name>released</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>alloc_trim</name><parameter_list>(<parameter><decl><type><name>mstate</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>pad</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>size_t</name></type> <name>released</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>pad</name> <operator>&lt;</operator> <name>MAX_REQUEST</name> <operator>&amp;&amp;</operator> <call><name>is_initialized</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>pad</name> <operator>+=</operator> <name>TOP_FOOT_SIZE</name></expr>;</expr_stmt> <comment type="block">/* ensure enough room for segment overhead */</comment>

    <if_stmt><if>if <condition>(<expr><name><name>m</name><operator>-&gt;</operator><name>topsize</name></name> <operator>&gt;</operator> <name>pad</name></expr>)</condition> <block>{<block_content>
      <comment type="block">/* Shrink top space in granularity-size units, keeping at least one */</comment>
      <decl_stmt><decl><type><name>size_t</name></type> <name>unit</name> <init>= <expr><name>DEFAULT_GRANULARITY</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>size_t</name></type> <name>extra</name> <init>= <expr><operator>(</operator><operator>(</operator><name><name>m</name><operator>-&gt;</operator><name>topsize</name></name> <operator>-</operator> <name>pad</name> <operator>+</operator> <operator>(</operator><name>unit</name> <operator>-</operator> <name>SIZE_T_ONE</name><operator>)</operator><operator>)</operator> <operator>/</operator> <name>unit</name> <operator>-</operator>
		      <name>SIZE_T_ONE</name><operator>)</operator> <operator>*</operator> <name>unit</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>msegmentptr</name></type> <name>sp</name> <init>= <expr><call><name>segment_holding</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>m</name><operator>-&gt;</operator><name>top</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>size</name></name> <operator>&gt;=</operator> <name>extra</name> <operator>&amp;&amp;</operator>
	  <operator>!</operator><call><name>has_segment_link</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> <comment type="block">/* can't shrink if pinned */</comment>
	<decl_stmt><decl><type><name>size_t</name></type> <name>newsize</name> <init>= <expr><name><name>sp</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <name>extra</name></expr></init></decl>;</decl_stmt>
	<comment type="block">/* Prefer mremap, fall back to munmap */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>CALL_MREMAP</name><argument_list>(<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>base</name></name></expr></argument>, <argument><expr><name><name>sp</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name>newsize</name></expr></argument>, <argument><expr><name>CALL_MREMAP_NOMOVE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>MFAIL</name><operator>)</operator> <operator>||</operator>
	    <operator>(</operator><call><name>CALL_MUNMAP</name><argument_list>(<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>base</name></name> <operator>+</operator> <name>newsize</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><name>released</name> <operator>=</operator> <name>extra</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>

      <if_stmt><if>if <condition>(<expr><name>released</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>size</name></name> <operator>-=</operator> <name>released</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>init_top</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>top</name></name></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>topsize</name></name> <operator>-</operator> <name>released</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Unmap any unused mmapped segments */</comment>
    <expr_stmt><expr><name>released</name> <operator>+=</operator> <call><name>release_unused_segments</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* On failure, disable autotrim to avoid repeated failed future calls */</comment>
    <if_stmt><if>if <condition>(<expr><name>released</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>m</name><operator>-&gt;</operator><name>topsize</name></name> <operator>&gt;</operator> <name><name>m</name><operator>-&gt;</operator><name>trim_check</name></name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>trim_check</name></name> <operator>=</operator> <name>MAX_SIZE_T</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><ternary><condition><expr><operator>(</operator><name>released</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ---------------------------- malloc support --------------------------- */</comment>

<comment type="block">/* allocate a large request from the best fitting chunk in a treebin */</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>tmalloc_large</name><parameter_list>(<parameter><decl><type><name>mstate</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>tchunkptr</name></type> <name>v</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>rsize</name> <init>= <expr><operator>~</operator><name>nb</name><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Unsigned negation */</comment>
  <decl_stmt><decl><type><name>tchunkptr</name></type> <name>t</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bindex_t</name></type> <name>idx</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>compute_tree_index</name><argument_list>(<argument><expr><name>nb</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>t</name> <operator>=</operator> <operator>*</operator><call><name>treebin_at</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <comment type="block">/* Traverse tree for this bin looking for node with size == nb */</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>sizebits</name> <init>= <expr><name>nb</name> <operator>&lt;&lt;</operator> <call><name>leftshift_for_tree_index</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>tchunkptr</name></type> <name>rst</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* The deepest untaken right subtree */</comment>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
      <decl_stmt><decl><type><name>tchunkptr</name></type> <name>rt</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>size_t</name></type> <name>trem</name> <init>= <expr><call><name>chunksize</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>nb</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>trem</name> <operator>&lt;</operator> <name>rsize</name></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name>v</name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>rsize</name> <operator>=</operator> <name>trem</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	  <break>break;</break></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>rt</name> <operator>=</operator> <name><name>t</name><operator>-&gt;</operator><name>child</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>t</name> <operator>=</operator> <name><name>t</name><operator>-&gt;</operator><name>child</name><index>[<expr><operator>(</operator><name>sizebits</name> <operator>&gt;&gt;</operator> <operator>(</operator><name>SIZE_T_BITSIZE</name><operator>-</operator><name>SIZE_T_ONE</name><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>rt</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>rt</name> <operator>!=</operator> <name>t</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>rst</name> <operator>=</operator> <name>rt</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>t</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name>t</name> <operator>=</operator> <name>rst</name></expr>;</expr_stmt> <comment type="block">/* set t to least subtree holding sizes &gt; nb */</comment>
	<break>break;</break>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>sizebits</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>t</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>v</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> <comment type="block">/* set t to root of next non-empty treebin */</comment>
    <decl_stmt><decl><type><name>binmap_t</name></type> <name>leftbits</name> <init>= <expr><call><name>left_bits</name><argument_list>(<argument><expr><call><name>idx2bit</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name><name>m</name><operator>-&gt;</operator><name>treemap</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>leftbits</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>t</name> <operator>=</operator> <operator>*</operator><call><name>treebin_at</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><call><name>lj_ffs</name><argument_list>(<argument><expr><name>leftbits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <while>while <condition>(<expr><name>t</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> <comment type="block">/* find smallest of tree or subtree */</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>trem</name> <init>= <expr><call><name>chunksize</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>nb</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>trem</name> <operator>&lt;</operator> <name>rsize</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>rsize</name> <operator>=</operator> <name>trem</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>v</name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>leftmost_child</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>

  <comment type="block">/*  If dv is a better fit, return NULL so malloc will use it */</comment>
  <if_stmt><if>if <condition>(<expr><name>v</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>rsize</name> <operator>&lt;</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name><name>m</name><operator>-&gt;</operator><name>dvsize</name></name> <operator>-</operator> <name>nb</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>mchunkptr</name></type> <name>r</name> <init>= <expr><call><name>chunk_plus_offset</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>unlink_large_chunk</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>rsize</name> <operator>&lt;</operator> <name>MIN_CHUNK_SIZE</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>set_inuse_and_pinuse</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><operator>(</operator><name>rsize</name> <operator>+</operator> <name>nb</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>set_size_and_pinuse_of_inuse_chunk</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>set_size_and_pinuse_of_free_chunk</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>rsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>insert_chunk</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>rsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><call><name>chunk2mem</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* allocate a small request from the best fitting chunk in a treebin */</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>tmalloc_small</name><parameter_list>(<parameter><decl><type><name>mstate</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>tchunkptr</name></type> <name>t</name></decl>, <decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>mchunkptr</name></type> <name>r</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>rsize</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bindex_t</name></type> <name>i</name> <init>= <expr><call><name>lj_ffs</name><argument_list>(<argument><expr><name><name>m</name><operator>-&gt;</operator><name>treemap</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>v</name> <operator>=</operator> <name>t</name> <operator>=</operator> <operator>*</operator><call><name>treebin_at</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rsize</name> <operator>=</operator> <call><name>chunksize</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>nb</name></expr>;</expr_stmt>

  <while>while <condition>(<expr><operator>(</operator><name>t</name> <operator>=</operator> <call><name>leftmost_child</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>trem</name> <init>= <expr><call><name>chunksize</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>nb</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>trem</name> <operator>&lt;</operator> <name>rsize</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>rsize</name> <operator>=</operator> <name>trem</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>v</name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>

  <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>chunk_plus_offset</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>unlink_large_chunk</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>rsize</name> <operator>&lt;</operator> <name>MIN_CHUNK_SIZE</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>set_inuse_and_pinuse</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><operator>(</operator><name>rsize</name> <operator>+</operator> <name>nb</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>set_size_and_pinuse_of_inuse_chunk</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>set_size_and_pinuse_of_free_chunk</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>rsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>replace_dv</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>rsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><call><name>chunk2mem</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------------- */</comment>

<function><type><name>void</name> <modifier>*</modifier></type><name>lj_alloc_create</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>size_t</name></type> <name>tsize</name> <init>= <expr><name>DEFAULT_GRANULARITY</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tbase</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>INIT_MMAP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>tbase</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><call><name>CALL_MMAP</name><argument_list>(<argument><expr><name>tsize</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>tbase</name> <operator>!=</operator> <name>CMFAIL</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>msize</name> <init>= <expr><call><name>pad_request</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>malloc_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mchunkptr</name></type> <name>mn</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mchunkptr</name></type> <name>msp</name> <init>= <expr><call><name>align_as_chunk</name><argument_list>(<argument><expr><name>tbase</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mstate</name></type> <name>m</name> <init>= <expr><operator>(</operator><name>mstate</name><operator>)</operator><operator>(</operator><call><name>chunk2mem</name><argument_list>(<argument><expr><name>msp</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>msize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>msp</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <operator>(</operator><name>msize</name><operator>|</operator><name>PINUSE_BIT</name><operator>|</operator><name>CINUSE_BIT</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>seg</name><operator>.</operator><name>base</name></name> <operator>=</operator> <name>tbase</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>seg</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name>tsize</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>release_checks</name></name> <operator>=</operator> <name>MAX_RELEASE_CHECK_RATE</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_bins</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mn</name> <operator>=</operator> <call><name>next_chunk</name><argument_list>(<argument><expr><call><name>mem2chunk</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>init_top</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>mn</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><operator>(</operator><name>tbase</name> <operator>+</operator> <name>tsize</name><operator>)</operator> <operator>-</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>mn</name><operator>)</operator> <operator>-</operator> <name>TOP_FOOT_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>m</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>lj_alloc_destroy</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>msp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>mstate</name></type> <name>ms</name> <init>= <expr><operator>(</operator><name>mstate</name><operator>)</operator><name>msp</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>msegmentptr</name></type> <name>sp</name> <init>= <expr><operator>&amp;</operator><name><name>ms</name><operator>-&gt;</operator><name>seg</name></name></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><name>sp</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>base</name> <init>= <expr><name><name>sp</name><operator>-&gt;</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><name><name>sp</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>sp</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CALL_MUNMAP</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>LJ_NOINLINE</name> <name>void</name> <modifier>*</modifier></type><name>lj_alloc_malloc</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>msp</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nsize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>mstate</name></type> <name>ms</name> <init>= <expr><operator>(</operator><name>mstate</name><operator>)</operator><name>msp</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>mem</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>nb</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>nsize</name> <operator>&lt;=</operator> <name>MAX_SMALL_REQUEST</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>bindex_t</name></type> <name>idx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>binmap_t</name></type> <name>smallbits</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>nb</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>nsize</name> <operator>&lt;</operator> <name>MIN_REQUEST</name><operator>)</operator></expr>?</condition><then> <expr><name>MIN_CHUNK_SIZE</name></expr> </then><else>: <expr><call><name>pad_request</name><argument_list>(<argument><expr><name>nsize</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>small_index</name><argument_list>(<argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>smallbits</name> <operator>=</operator> <name><name>ms</name><operator>-&gt;</operator><name>smallmap</name></name> <operator>&gt;&gt;</operator> <name>idx</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>smallbits</name> <operator>&amp;</operator> <literal type="number">0x3U</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> <comment type="block">/* Remainderless fit to a smallbin. */</comment>
      <decl_stmt><decl><type><name>mchunkptr</name></type> <name>b</name></decl>, <decl><type ref="prev"/><name>p</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>idx</name> <operator>+=</operator> <operator>~</operator><name>smallbits</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>;</expr_stmt>       <comment type="block">/* Uses next bin if idx empty */</comment>
      <expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>smallbin_at</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>b</name><operator>-&gt;</operator><name>fd</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>unlink_first_small_chunk</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>set_inuse_and_pinuse</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>small_index2size</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>mem</name> <operator>=</operator> <call><name>chunk2mem</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>mem</name></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>nb</name> <operator>&gt;</operator> <name><name>ms</name><operator>-&gt;</operator><name>dvsize</name></name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>smallbits</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> <comment type="block">/* Use chunk in next nonempty smallbin */</comment>
	<decl_stmt><decl><type><name>mchunkptr</name></type> <name>b</name></decl>, <decl><type ref="prev"/><name>p</name></decl>, <decl><type ref="prev"/><name>r</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>rsize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>binmap_t</name></type> <name>leftbits</name> <init>= <expr><operator>(</operator><name>smallbits</name> <operator>&lt;&lt;</operator> <name>idx</name><operator>)</operator> <operator>&amp;</operator> <call><name>left_bits</name><argument_list>(<argument><expr><call><name>idx2bit</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bindex_t</name></type> <name>i</name> <init>= <expr><call><name>lj_ffs</name><argument_list>(<argument><expr><name>leftbits</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>smallbin_at</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>b</name><operator>-&gt;</operator><name>fd</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>unlink_first_small_chunk</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rsize</name> <operator>=</operator> <call><name>small_index2size</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>nb</name></expr>;</expr_stmt>
	<comment type="block">/* Fit here cannot be remainderless if 4byte sizes */</comment>
	<if_stmt><if>if <condition>(<expr><name>SIZE_T_SIZE</name> <operator>!=</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <name>rsize</name> <operator>&lt;</operator> <name>MIN_CHUNK_SIZE</name></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><call><name>set_inuse_and_pinuse</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>small_index2size</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
	  <expr_stmt><expr><call><name>set_size_and_pinuse_of_inuse_chunk</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>chunk_plus_offset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><call><name>set_size_and_pinuse_of_free_chunk</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>rsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><call><name>replace_dv</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>rsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name>mem</name> <operator>=</operator> <call><name>chunk2mem</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>mem</name></expr>;</return>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>ms</name><operator>-&gt;</operator><name>treemap</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>mem</name> <operator>=</operator> <call><name>tmalloc_small</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
	<return>return <expr><name>mem</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>nsize</name> <operator>&gt;=</operator> <name>MAX_REQUEST</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>nb</name> <operator>=</operator> <name>MAX_SIZE_T</name></expr>;</expr_stmt> <comment type="block">/* Too big to allocate. Force failure (in sys alloc) */</comment>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name>nb</name> <operator>=</operator> <call><name>pad_request</name><argument_list>(<argument><expr><name>nsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>ms</name><operator>-&gt;</operator><name>treemap</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>mem</name> <operator>=</operator> <call><name>tmalloc_large</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>mem</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>nb</name> <operator>&lt;=</operator> <name><name>ms</name><operator>-&gt;</operator><name>dvsize</name></name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>rsize</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>dvsize</name></name> <operator>-</operator> <name>nb</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mchunkptr</name></type> <name>p</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>dv</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>rsize</name> <operator>&gt;=</operator> <name>MIN_CHUNK_SIZE</name></expr>)</condition> <block>{<block_content> <comment type="block">/* split dv */</comment>
      <decl_stmt><decl><type><name>mchunkptr</name></type> <name>r</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>dv</name></name> <operator>=</operator> <call><name>chunk_plus_offset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>dvsize</name></name> <operator>=</operator> <name>rsize</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>set_size_and_pinuse_of_free_chunk</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>rsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>set_size_and_pinuse_of_inuse_chunk</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content> <comment type="block">/* exhaust dv */</comment>
      <decl_stmt><decl><type><name>size_t</name></type> <name>dvs</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>dvsize</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>dvsize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>dv</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>set_inuse_and_pinuse</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>dvs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>mem</name> <operator>=</operator> <call><name>chunk2mem</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>mem</name></expr>;</return>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>nb</name> <operator>&lt;</operator> <name><name>ms</name><operator>-&gt;</operator><name>topsize</name></name></expr>)</condition> <block>{<block_content> <comment type="block">/* Split top */</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>rsize</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>topsize</name></name> <operator>-=</operator> <name>nb</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mchunkptr</name></type> <name>p</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>top</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mchunkptr</name></type> <name>r</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <call><name>chunk_plus_offset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <name>rsize</name> <operator>|</operator> <name>PINUSE_BIT</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>set_size_and_pinuse_of_inuse_chunk</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mem</name> <operator>=</operator> <call><name>chunk2mem</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>mem</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>alloc_sys</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>LJ_NOINLINE</name> <name>void</name> <modifier>*</modifier></type><name>lj_alloc_free</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>msp</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>mchunkptr</name></type> <name>p</name> <init>= <expr><call><name>mem2chunk</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mstate</name></type> <name>fm</name> <init>= <expr><operator>(</operator><name>mstate</name><operator>)</operator><name>msp</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>psize</name> <init>= <expr><call><name>chunksize</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mchunkptr</name></type> <name>next</name> <init>= <expr><call><name>chunk_plus_offset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>psize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pinuse</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>size_t</name></type> <name>prevsize</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>prev_foot</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>prevsize</name> <operator>&amp;</operator> <name>IS_DIRECT_BIT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name>prevsize</name> <operator>&amp;=</operator> <operator>~</operator><name>IS_DIRECT_BIT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>psize</name> <operator>+=</operator> <name>prevsize</name> <operator>+</operator> <name>DIRECT_FOOT_PAD</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CALL_MUNMAP</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>p</name> <operator>-</operator> <name>prevsize</name></expr></argument>, <argument><expr><name>psize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<decl_stmt><decl><type><name>mchunkptr</name></type> <name>prev</name> <init>= <expr><call><name>chunk_minus_offset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>prevsize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>psize</name> <operator>+=</operator> <name>prevsize</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>p</name> <operator>=</operator> <name>prev</name></expr>;</expr_stmt>
	<comment type="block">/* consolidate backward */</comment>
	<if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <name><name>fm</name><operator>-&gt;</operator><name>dv</name></name></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><call><name>unlink_chunk</name><argument_list>(<argument><expr><name>fm</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>prevsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>next</name><operator>-&gt;</operator><name>head</name></name> <operator>&amp;</operator> <name>INUSE_BITS</name><operator>)</operator> <operator>==</operator> <name>INUSE_BITS</name></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><name><name>fm</name><operator>-&gt;</operator><name>dvsize</name></name> <operator>=</operator> <name>psize</name></expr>;</expr_stmt>
	  <expr_stmt><expr><call><name>set_free_with_pinuse</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>psize</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cinuse</name><argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* consolidate forward */</comment>
      <if_stmt><if>if <condition>(<expr><name>next</name> <operator>==</operator> <name><name>fm</name><operator>-&gt;</operator><name>top</name></name></expr>)</condition> <block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>tsize</name> <init>= <expr><name><name>fm</name><operator>-&gt;</operator><name>topsize</name></name> <operator>+=</operator> <name>psize</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>fm</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <name>tsize</name> <operator>|</operator> <name>PINUSE_BIT</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name><name>fm</name><operator>-&gt;</operator><name>dv</name></name></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><name><name>fm</name><operator>-&gt;</operator><name>dv</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>fm</name><operator>-&gt;</operator><name>dvsize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>tsize</name> <operator>&gt;</operator> <name><name>fm</name><operator>-&gt;</operator><name>trim_check</name></name></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><call><name>alloc_trim</name><argument_list>(<argument><expr><name>fm</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>next</name> <operator>==</operator> <name><name>fm</name><operator>-&gt;</operator><name>dv</name></name></expr>)</condition> <block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>dsize</name> <init>= <expr><name><name>fm</name><operator>-&gt;</operator><name>dvsize</name></name> <operator>+=</operator> <name>psize</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>fm</name><operator>-&gt;</operator><name>dv</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_size_and_pinuse_of_free_chunk</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>dsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
      </block_content>}</block></if> <else>else <block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>nsize</name> <init>= <expr><call><name>chunksize</name><argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>psize</name> <operator>+=</operator> <name>nsize</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>unlink_chunk</name><argument_list>(<argument><expr><name>fm</name></expr></argument>, <argument><expr><name>next</name></expr></argument>, <argument><expr><name>nsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_size_and_pinuse_of_free_chunk</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>psize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name><name>fm</name><operator>-&gt;</operator><name>dv</name></name></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><name><name>fm</name><operator>-&gt;</operator><name>dvsize</name></name> <operator>=</operator> <name>psize</name></expr>;</expr_stmt>
	  <return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>set_free_with_pinuse</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>psize</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>is_small</name><argument_list>(<argument><expr><name>psize</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>insert_small_chunk</name><argument_list>(<argument><expr><name>fm</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>psize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <decl_stmt><decl><type><name>tchunkptr</name></type> <name>tp</name> <init>= <expr><operator>(</operator><name>tchunkptr</name><operator>)</operator><name>p</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>insert_large_chunk</name><argument_list>(<argument><expr><name>fm</name></expr></argument>, <argument><expr><name>tp</name></expr></argument>, <argument><expr><name>psize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>--</operator><name><name>fm</name><operator>-&gt;</operator><name>release_checks</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>release_unused_segments</name><argument_list>(<argument><expr><name>fm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>LJ_NOINLINE</name> <name>void</name> <modifier>*</modifier></type><name>lj_alloc_realloc</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>msp</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nsize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>nsize</name> <operator>&gt;=</operator> <name>MAX_REQUEST</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>mstate</name></type> <name>m</name> <init>= <expr><operator>(</operator><name>mstate</name><operator>)</operator><name>msp</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mchunkptr</name></type> <name>oldp</name> <init>= <expr><call><name>mem2chunk</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>oldsize</name> <init>= <expr><call><name>chunksize</name><argument_list>(<argument><expr><name>oldp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mchunkptr</name></type> <name>next</name> <init>= <expr><call><name>chunk_plus_offset</name><argument_list>(<argument><expr><name>oldp</name></expr></argument>, <argument><expr><name>oldsize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mchunkptr</name></type> <name>newp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>nb</name> <init>= <expr><call><name>request2size</name><argument_list>(<argument><expr><name>nsize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Try to either shrink or extend into top. Else malloc-copy-free */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>is_direct</name><argument_list>(<argument><expr><name>oldp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>newp</name> <operator>=</operator> <call><name>direct_resize</name><argument_list>(<argument><expr><name>oldp</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* this may return NULL. */</comment>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>oldsize</name> <operator>&gt;=</operator> <name>nb</name></expr>)</condition> <block>{<block_content> <comment type="block">/* already big enough */</comment>
      <decl_stmt><decl><type><name>size_t</name></type> <name>rsize</name> <init>= <expr><name>oldsize</name> <operator>-</operator> <name>nb</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>newp</name> <operator>=</operator> <name>oldp</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>rsize</name> <operator>&gt;=</operator> <name>MIN_CHUNK_SIZE</name></expr>)</condition> <block>{<block_content>
	<decl_stmt><decl><type><name>mchunkptr</name></type> <name>rem</name> <init>= <expr><call><name>chunk_plus_offset</name><argument_list>(<argument><expr><name>newp</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>set_inuse</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>newp</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_inuse</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>rem</name></expr></argument>, <argument><expr><name>rsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lj_alloc_free</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><call><name>chunk2mem</name><argument_list>(<argument><expr><name>rem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>next</name> <operator>==</operator> <name><name>m</name><operator>-&gt;</operator><name>top</name></name> <operator>&amp;&amp;</operator> <name>oldsize</name> <operator>+</operator> <name><name>m</name><operator>-&gt;</operator><name>topsize</name></name> <operator>&gt;</operator> <name>nb</name></expr>)</condition> <block>{<block_content>
      <comment type="block">/* Expand into top */</comment>
      <decl_stmt><decl><type><name>size_t</name></type> <name>newsize</name> <init>= <expr><name>oldsize</name> <operator>+</operator> <name><name>m</name><operator>-&gt;</operator><name>topsize</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>size_t</name></type> <name>newtopsize</name> <init>= <expr><name>newsize</name> <operator>-</operator> <name>nb</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>mchunkptr</name></type> <name>newtop</name> <init>= <expr><call><name>chunk_plus_offset</name><argument_list>(<argument><expr><name>oldp</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>set_inuse</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>oldp</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>newtop</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <name>newtopsize</name> <operator>|</operator><name>PINUSE_BIT</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name>newtop</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>topsize</name></name> <operator>=</operator> <name>newtopsize</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>newp</name> <operator>=</operator> <name>oldp</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>newp</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <return>return <expr><call><name>chunk2mem</name><argument_list>(<argument><expr><name>newp</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>newmem</name> <init>= <expr><call><name>lj_alloc_malloc</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>nsize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>newmem</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>oc</name> <init>= <expr><name>oldsize</name> <operator>-</operator> <call><name>overhead_for</name><argument_list>(<argument><expr><name>oldp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newmem</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><ternary><condition><expr><name>oc</name> <operator>&lt;</operator> <name>nsize</name></expr> ?</condition><then> <expr><name>oc</name></expr> </then><else>: <expr><name>nsize</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lj_alloc_free</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><name>newmem</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type><name>lj_alloc_f</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>msp</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>osize</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nsize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>osize</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>nsize</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>lj_alloc_free</name><argument_list>(<argument><expr><name>msp</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>ptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>lj_alloc_malloc</name><argument_list>(<argument><expr><name>msp</name></expr></argument>, <argument><expr><name>nsize</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <return>return <expr><call><name>lj_alloc_realloc</name><argument_list>(<argument><expr><name>msp</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>nsize</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
