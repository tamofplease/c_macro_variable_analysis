<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/sysbench/third_party/luajit/luajit/src/lj_snap.c"><comment type="block">/*
** Snapshot handling.
** Copyright (C) 2005-2020 Mike Pall. See Copyright Notice in luajit.h
*/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lj_snap_c</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUA_CORE</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_obj.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASJIT</name></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_gc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_tab.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_state.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_frame.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_bc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_ir.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_jit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_iropt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_trace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_snap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_target.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_ctype.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lj_cdata.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Pass IR on to next optimization in chain (FOLD). */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>emitir</name><parameter_list>(<parameter><type><name>ot</name></type></parameter>, <parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(lj_ir_set(J, (ot), (a), (b)), lj_opt_fold(J))</cpp:value></cpp:define>

<comment type="block">/* Emit raw IR without passing through optimizations. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>emitir_raw</name><parameter_list>(<parameter><type><name>ot</name></type></parameter>, <parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(lj_ir_set(J, (ot), (a), (b)), lj_ir_emit(J))</cpp:value></cpp:define>

<comment type="block">/* -- Snapshot buffer allocation ------------------------------------------ */</comment>

<comment type="block">/* Grow snapshot buffer. */</comment>
<function><type><name>void</name></type> <name>lj_snap_grow_buf_</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>MSize</name></type> <name>need</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>MSize</name></type> <name>maxsnap</name> <init>= <expr><operator>(</operator><name>MSize</name><operator>)</operator><name><name>J</name><operator>-&gt;</operator><name>param</name><index>[<expr><name>JIT_P_maxsnap</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>need</name> <operator>&gt;</operator> <name>maxsnap</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lj_trace_err</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>LJ_TRERR_SNAPOV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>lj_mem_growvec</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>snapbuf</name></name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>sizesnap</name></name></expr></argument>, <argument><expr><name>maxsnap</name></expr></argument>, <argument><expr><name>SnapShot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>snap</name></name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>snapbuf</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Grow snapshot map buffer. */</comment>
<function><type><name>void</name></type> <name>lj_snap_grow_map_</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>MSize</name></type> <name>need</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>need</name> <operator>&lt;</operator> <literal type="number">2</literal><operator>*</operator><name><name>J</name><operator>-&gt;</operator><name>sizesnapmap</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>need</name> <operator>=</operator> <literal type="number">2</literal><operator>*</operator><name><name>J</name><operator>-&gt;</operator><name>sizesnapmap</name></name></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><name>need</name> <operator>&lt;</operator> <literal type="number">64</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>need</name> <operator>=</operator> <literal type="number">64</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>snapmapbuf</name></name> <operator>=</operator> <operator>(</operator><name>SnapEntry</name> <operator>*</operator><operator>)</operator><call><name>lj_mem_realloc</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>snapmapbuf</name></name></expr></argument>,
		    <argument><expr><name><name>J</name><operator>-&gt;</operator><name>sizesnapmap</name></name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>SnapEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>need</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>SnapEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>snapmap</name></name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>snapmapbuf</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>sizesnapmap</name></name> <operator>=</operator> <name>need</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* -- Snapshot generation ------------------------------------------------- */</comment>

<comment type="block">/* Add all modified slots to the snapshot. */</comment>
<function><type><specifier>static</specifier> <name>MSize</name></type> <name>snapshot_slots</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>SnapEntry</name> <modifier>*</modifier></type><name>map</name></decl></parameter>, <parameter><decl><type><name>BCReg</name></type> <name>nslots</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>IRRef</name></type> <name>retf</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>chain</name><index>[<expr><name>IR_RETF</name></expr>]</index></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* Limits SLOAD restore elimination. */</comment>
  <decl_stmt><decl><type><name>BCReg</name></type> <name>s</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MSize</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>s</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>s</name> <operator>&lt;</operator> <name>nslots</name></expr>;</condition> <incr><expr><name>s</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>slot</name><index>[<expr><name>s</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IRRef</name></type> <name>ref</name> <init>= <expr><call><name>tref_ref</name><argument_list>(<argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_FR2</name></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* Ignore slot 1 in LJ_FR2 mode, except if tailcalled. */</comment>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>tr</name> <operator>&amp;</operator> <name>TREF_FRAME</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name><name>map</name><index>[<expr><name>n</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>SNAP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>SNAP_FRAME</name> <operator>|</operator> <name>SNAP_NORESTORE</name></expr></argument>, <argument><expr><name>REF_NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>tr</name> <operator>&amp;</operator> <operator>(</operator><name>TREF_FRAME</name> <operator>|</operator> <name>TREF_CONT</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name>ref</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>base</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>-</operator> <name><name>J</name><operator>-&gt;</operator><name>baseslot</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>tr</name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>slot</name><index>[<expr><name>s</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>tr</name> <operator>&amp;</operator> <literal type="number">0xff0000</literal><operator>)</operator> <operator>|</operator> <call><name>lj_ir_k64</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>IR_KNUM</name></expr></argument>, <argument><expr><name><name>base</name><index>[<expr><name>s</name></expr>]</index></name><operator>.</operator><name>u64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>ref</name> <operator>=</operator> <call><name>tref_ref</name><argument_list>(<argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if <condition>(<expr><name>ref</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>SnapEntry</name></type> <name>sn</name> <init>= <expr><call><name>SNAP_TR</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name> <init>= <expr><operator>&amp;</operator><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>ir</name><index>[<expr><name>ref</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>LJ_FR2</name> <operator>||</operator> <operator>!</operator><operator>(</operator><name>sn</name> <operator>&amp;</operator> <operator>(</operator><name>SNAP_CONT</name><operator>|</operator><name>SNAP_FRAME</name><operator>)</operator><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
	  <name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_SLOAD</name> <operator>&amp;&amp;</operator> <name><name>ir</name><operator>-&gt;</operator><name>op1</name></name> <operator>==</operator> <name>s</name> <operator>&amp;&amp;</operator> <name>ref</name> <operator>&gt;</operator> <name>retf</name></expr>)</condition> <block>{<block_content>
	<comment type="block">/* No need to snapshot unmodified non-inherited slots. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name> <operator>&amp;</operator> <name>IRSLOAD_INHERIT</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	  <continue>continue;</continue></block_content></block></if></if_stmt>
	<comment type="block">/* No need to restore readonly slots and unmodified non-parent slots. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>LJ_DUALNUM</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name> <operator>&amp;</operator> <name>IRSLOAD_CONVERT</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
	    <operator>(</operator><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name> <operator>&amp;</operator> <operator>(</operator><name>IRSLOAD_READONLY</name><operator>|</operator><name>IRSLOAD_PARENT</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <name>IRSLOAD_PARENT</name></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><name>sn</name> <operator>|=</operator> <name>SNAP_NORESTORE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>LJ_SOFTFP32</name> <operator>&amp;&amp;</operator> <call><name>irt_isnum</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>sn</name> <operator>|=</operator> <name>SNAP_SOFTFPNUM</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>map</name><index>[<expr><name>n</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>sn</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Add frame links at the end of the snapshot. */</comment>
<function><type><specifier>static</specifier> <name>MSize</name></type> <name>snapshot_framelinks</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>SnapEntry</name> <modifier>*</modifier></type><name>map</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>topslot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>frame</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>lim</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>-</operator> <name><name>J</name><operator>-&gt;</operator><name>baseslot</name></name> <operator>+</operator> <name>LJ_FR2</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GCfunc</name> <modifier>*</modifier></type><name>fn</name> <init>= <expr><call><name>frame_func</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>cTValue</name> <modifier>*</modifier></type><name>ftop</name> <init>= <expr><ternary><condition><expr><call><name>isluafunc</name><argument_list>(<argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><operator>(</operator><name>frame</name><operator>+</operator><call><name>funcproto</name><argument_list>(<argument><expr><name>fn</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>framesize</name><operator>)</operator></expr> </then><else>: <expr><name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_FR2</name></expr></cpp:if>
  <decl_stmt><decl><type><name>uint64_t</name></type> <name>pcbase</name> <init>= <expr><operator>(</operator><call><name>u64ptr</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>pc</name></name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name><name>J</name><operator>-&gt;</operator><name>baseslot</name></name> <operator>-</operator> <literal type="number">2</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><literal type="number">2</literal> <operator>&lt;=</operator> <name><name>J</name><operator>-&gt;</operator><name>baseslot</name></name> <operator>&amp;&amp;</operator> <name><name>J</name><operator>-&gt;</operator><name>baseslot</name></name> <operator>&lt;=</operator> <literal type="number">257</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>map</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pcbase</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><name>MSize</name></type> <name>f</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>map</name><index>[<expr><name>f</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>SNAP_MKPC</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>pc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* The current PC is always the first entry. */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <while>while <condition>(<expr><name>frame</name> <operator>&gt;</operator> <name>lim</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* Backwards traversal of all frames above base. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>frame_islua</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>LJ_FR2</name></expr></cpp:if>
      <expr_stmt><expr><name><name>map</name><index>[<expr><name>f</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>SNAP_MKPC</name><argument_list>(<argument><expr><call><name>frame_pc</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><name>frame</name> <operator>=</operator> <call><name>frame_prevl</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>frame_iscont</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>LJ_FR2</name></expr></cpp:if>
      <expr_stmt><expr><name><name>map</name><index>[<expr><name>f</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>SNAP_MKFTSZ</name><argument_list>(<argument><expr><call><name>frame_ftsz</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>map</name><index>[<expr><name>f</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>SNAP_MKPC</name><argument_list>(<argument><expr><call><name>frame_contpc</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><name>frame</name> <operator>=</operator> <call><name>frame_prevd</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>frame_isc</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>LJ_FR2</name></expr></cpp:if>
      <expr_stmt><expr><name><name>map</name><index>[<expr><name>f</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>SNAP_MKFTSZ</name><argument_list>(<argument><expr><call><name>frame_ftsz</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><name>frame</name> <operator>=</operator> <call><name>frame_prevd</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>frame</name> <operator>+</operator> <call><name>funcproto</name><argument_list>(<argument><expr><call><name>frame_func</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>framesize</name> <operator>&gt;</operator> <name>ftop</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>ftop</name> <operator>=</operator> <name>frame</name> <operator>+</operator> <call><name>funcproto</name><argument_list>(<argument><expr><call><name>frame_func</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>framesize</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><operator>*</operator><name>topslot</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><name>ftop</name> <operator>-</operator> <name>lim</name><operator>)</operator></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_FR2</name></expr></cpp:if>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SnapEntry</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">2</literal> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">2</literal></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>f</name> <operator>==</operator> <operator>(</operator><name>MSize</name><operator>)</operator><operator>(</operator><literal type="number">1</literal> <operator>+</operator> <name><name>J</name><operator>-&gt;</operator><name>framedepth</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>f</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/* Take a snapshot of the current stack. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>snapshot_stack</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>SnapShot</name> <modifier>*</modifier></type><name>snap</name></decl></parameter>, <parameter><decl><type><name>MSize</name></type> <name>nsnapmap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>BCReg</name></type> <name>nslots</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>baseslot</name></name> <operator>+</operator> <name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MSize</name></type> <name>nent</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SnapEntry</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <comment type="block">/* Conservative estimate. */</comment>
  <expr_stmt><expr><call><name>lj_snap_grow_map</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>nsnapmap</name> <operator>+</operator> <name>nslots</name> <operator>+</operator> <operator>(</operator><name>MSize</name><operator>)</operator><operator>(</operator><ternary><condition><expr><name>LJ_FR2</name></expr>?</condition><then><expr><literal type="number">2</literal></expr></then><else>:<expr><name><name>J</name><operator>-&gt;</operator><name>framedepth</name></name><operator>+</operator><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>&amp;</operator><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>snapmap</name><index>[<expr><name>nsnapmap</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nent</name> <operator>=</operator> <call><name>snapshot_slots</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>nslots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>snap</name><operator>-&gt;</operator><name>nent</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name>nent</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nent</name> <operator>+=</operator> <call><name>snapshot_framelinks</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <name>nent</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>snap</name><operator>-&gt;</operator><name>topslot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>snap</name><operator>-&gt;</operator><name>mapofs</name></name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>nsnapmap</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>snap</name><operator>-&gt;</operator><name>ref</name></name> <operator>=</operator> <operator>(</operator><name>IRRef1</name><operator>)</operator><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nins</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>snap</name><operator>-&gt;</operator><name>nslots</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name>nslots</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>snap</name><operator>-&gt;</operator><name>count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nsnapmap</name></name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>nsnapmap</name> <operator>+</operator> <name>nent</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Add or merge a snapshot. */</comment>
<function><type><name>void</name></type> <name>lj_snap_add</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>MSize</name></type> <name>nsnap</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nsnap</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MSize</name></type> <name>nsnapmap</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nsnapmap</name></name></expr></init></decl>;</decl_stmt>
  <comment type="block">/* Merge if no ins. inbetween or if requested and no guard inbetween. */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>nsnap</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>snap</name><index>[<expr><name>nsnap</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>ref</name> <operator>==</operator> <name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nins</name></name><operator>)</operator> <operator>||</operator>
      <operator>(</operator><name><name>J</name><operator>-&gt;</operator><name>mergesnap</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>irt_isguard</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>guardemit</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>nsnap</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* But preserve snap #0 PC. */</comment>
      <expr_stmt><expr><call><name>emitir_raw</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_NOP</name></expr></argument>, <argument><expr><name>IRT_NIL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>nomerge</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>nsnapmap</name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>snap</name><index>[<expr><operator>--</operator><name>nsnap</name></expr>]</index></name><operator>.</operator><name>mapofs</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
  <label><name>nomerge</name>:</label>
    <expr_stmt><expr><call><name>lj_snap_grow_buf</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>nsnap</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nsnap</name></name> <operator>=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><operator>(</operator><name>nsnap</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>mergesnap</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>guardemit</name><operator>.</operator><name>irt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>snapshot_stack</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>snap</name><index>[<expr><name>nsnap</name></expr>]</index></name></expr></argument>, <argument><expr><name>nsnapmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* -- Snapshot modification ----------------------------------------------- */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SNAP_USEDEF_SLOTS</name></cpp:macro>	<cpp:value>(LJ_MAX_JSLOTS+LJ_STACK_EXTRA)</cpp:value></cpp:define>

<comment type="block">/* Find unused slots with reaching-definitions bytecode data-flow analysis. */</comment>
<function><type><specifier>static</specifier> <name>BCReg</name></type> <name>snap_usedef</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>udf</name></decl></parameter>,
			 <parameter><decl><type><specifier>const</specifier> <name>BCIns</name> <modifier>*</modifier></type><name>pc</name></decl></parameter>, <parameter><decl><type><name>BCReg</name></type> <name>maxslot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>BCReg</name></type> <name>s</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GCobj</name> <modifier>*</modifier></type><name>o</name></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>maxslot</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LUAJIT_USE_VALGRIND</name></cpp:ifdef>
  <comment type="block">/* Avoid errors for harmless reads beyond maxslot. */</comment>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>udf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>SNAP_USEDEF_SLOTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>udf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>maxslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Treat open upvalues as used. */</comment>
  <expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>gcref</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>openupval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while <condition>(<expr><name>o</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>uvval</name><argument_list>(<argument><expr><call><name>gco2uv</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>base</name></name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>udf</name><index>[<expr><call><name>uvval</name><argument_list>(<argument><expr><call><name>gco2uv</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>-</operator> <name><name>J</name><operator>-&gt;</operator><name>L</name><operator>-&gt;</operator><name>base</name></name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>gcref</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>nextgc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_SLOT</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>udf[(s)] &amp;= ~1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEF_SLOT</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>udf[(s)] *= 3</cpp:value></cpp:define>

  <comment type="block">/* Scan through following bytecode and check for uses/defs. */</comment>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>pc</name> <operator>&gt;=</operator> <call><name>proto_bc</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>pt</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>pc</name> <operator>&lt;</operator> <call><name>proto_bc</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>pt</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>J</name><operator>-&gt;</operator><name>pt</name><operator>-&gt;</operator><name>sizebc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>BCIns</name></type> <name>ins</name> <init>= <expr><operator>*</operator><name>pc</name><operator>++</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BCOp</name></type> <name>op</name> <init>= <expr><call><name>bc_op</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <switch>switch <condition>(<expr><call><name>bcmode_b</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>BCMvar</name></expr>:</case> <expr_stmt><expr><call><name>USE_SLOT</name><argument_list>(<argument><expr><call><name>bc_b</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    <default>default:</default> <break>break;</break>
    </block_content>}</block></switch>
    <switch>switch <condition>(<expr><call><name>bcmode_c</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>BCMvar</name></expr>:</case> <expr_stmt><expr><call><name>USE_SLOT</name><argument_list>(<argument><expr><call><name>bc_c</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>BCMrbase</name></expr>:</case>
      <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>op</name> <operator>==</operator> <name>BC_CAT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for <control>(<init><expr><name>s</name> <operator>=</operator> <call><name>bc_b</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>s</name> <operator>&lt;=</operator> <call><name>bc_c</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>s</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>USE_SLOT</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
      <for>for <control>(<init>;</init> <condition><expr><name>s</name> <operator>&lt;</operator> <name>maxslot</name></expr>;</condition> <incr><expr><name>s</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>DEF_SLOT</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
      <break>break;</break>
    <case>case <expr><name>BCMjump</name></expr>:</case>
    <label><name>handle_jump</name>:</label> <block>{<block_content>
      <decl_stmt><decl><type><name>BCReg</name></type> <name>minslot</name> <init>= <expr><call><name>bc_a</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>op</name> <operator>&gt;=</operator> <name>BC_FORI</name> <operator>&amp;&amp;</operator> <name>op</name> <operator>&lt;=</operator> <name>BC_JFORL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>minslot</name> <operator>+=</operator> <name>FORL_EXT</name></expr>;</expr_stmt></block_content></block></if>
      <if type="elseif">else if <condition>(<expr><name>op</name> <operator>&gt;=</operator> <name>BC_ITERL</name> <operator>&amp;&amp;</operator> <name>op</name> <operator>&lt;=</operator> <name>BC_JITERL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>minslot</name> <operator>+=</operator> <call><name>bc_b</name><argument_list>(<argument><expr><name><name>pc</name><index>[<expr><operator>-</operator><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
      <if type="elseif">else if <condition>(<expr><name>op</name> <operator>==</operator> <name>BC_UCLO</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>pc</name> <operator>+=</operator> <call><name>bc_j</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break> </block_content>}</block></if></if_stmt>
      <for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name>minslot</name></expr>;</init> <condition><expr><name>s</name> <operator>&lt;</operator> <name>maxslot</name></expr>;</condition> <incr><expr><name>s</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>DEF_SLOT</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
      <return>return <expr><ternary><condition><expr><name>minslot</name> <operator>&lt;</operator> <name>maxslot</name></expr> ?</condition><then> <expr><name>minslot</name></expr> </then><else>: <expr><name>maxslot</name></expr></else></ternary></expr>;</return>
      </block_content>}</block>
    <case>case <expr><name>BCMlit</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>BC_JFORL</name> <operator>||</operator> <name>op</name> <operator>==</operator> <name>BC_JITERL</name> <operator>||</operator> <name>op</name> <operator>==</operator> <name>BC_JLOOP</name></expr>)</condition> <block>{<block_content>
	<goto>goto <name>handle_jump</name>;</goto>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>bc_isret</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<decl_stmt><decl><type><name>BCReg</name></type> <name>top</name> <init>= <expr><ternary><condition><expr><name>op</name> <operator>==</operator> <name>BC_RETM</name></expr> ?</condition><then> <expr><name>maxslot</name></expr> </then><else>: <expr><operator>(</operator><call><name>bc_a</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>bc_d</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<for>for <control>(<init><expr><name>s</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>s</name> <operator>&lt;</operator> <call><name>bc_a</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>s</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>DEF_SLOT</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<for>for <control>(<init>;</init> <condition><expr><name>s</name> <operator>&lt;</operator> <name>top</name></expr>;</condition> <incr><expr><name>s</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>USE_SLOT</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<for>for <control>(<init>;</init> <condition><expr><name>s</name> <operator>&lt;</operator> <name>maxslot</name></expr>;</condition> <incr><expr><name>s</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>DEF_SLOT</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    <case>case <expr><name>BCMfunc</name></expr>:</case> <return>return <expr><name>maxslot</name></expr>;</return>  <comment type="block">/* NYI: will abort, anyway. */</comment>
    <default>default:</default> <break>break;</break>
    </block_content>}</block></switch>
    <switch>switch <condition>(<expr><call><name>bcmode_a</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>BCMvar</name></expr>:</case> <expr_stmt><expr><call><name>USE_SLOT</name><argument_list>(<argument><expr><call><name>bc_a</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>BCMdst</name></expr>:</case>
       <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>op</name> <operator>==</operator> <name>BC_ISTC</name> <operator>||</operator> <name>op</name> <operator>==</operator> <name>BC_ISFC</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>DEF_SLOT</name><argument_list>(<argument><expr><call><name>bc_a</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
       <break>break;</break>
    <case>case <expr><name>BCMbase</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>op</name> <operator>&gt;=</operator> <name>BC_CALLM</name> <operator>&amp;&amp;</operator> <name>op</name> <operator>&lt;=</operator> <name>BC_VARG</name></expr>)</condition> <block>{<block_content>
	<decl_stmt><decl><type><name>BCReg</name></type> <name>top</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>op</name> <operator>==</operator> <name>BC_CALLM</name> <operator>||</operator> <name>op</name> <operator>==</operator> <name>BC_CALLMT</name> <operator>||</operator> <call><name>bc_c</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then>
		    <expr><name>maxslot</name></expr> </then><else>: <expr><operator>(</operator><call><name>bc_a</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>bc_c</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call><operator>+</operator><name>LJ_FR2</name><operator>)</operator></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>LJ_FR2</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>DEF_SLOT</name><argument_list>(<argument><expr><call><name>bc_a</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>bc_a</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call> <operator>-</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>op</name> <operator>==</operator> <name>BC_ITERC</name> <operator>||</operator> <name>op</name> <operator>==</operator> <name>BC_ITERN</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">3</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
	<for>for <control>(<init>;</init> <condition><expr><name>s</name> <operator>&lt;</operator> <name>top</name></expr>;</condition> <incr><expr><name>s</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>USE_SLOT</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<for>for <control>(<init>;</init> <condition><expr><name>s</name> <operator>&lt;</operator> <name>maxslot</name></expr>;</condition> <incr><expr><name>s</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>DEF_SLOT</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>BC_CALLT</name> <operator>||</operator> <name>op</name> <operator>==</operator> <name>BC_CALLMT</name></expr>)</condition> <block>{<block_content>
	  <for>for <control>(<init><expr><name>s</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>s</name> <operator>&lt;</operator> <call><name>bc_a</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>s</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>DEF_SLOT</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	  <return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>op</name> <operator>==</operator> <name>BC_KNIL</name></expr>)</condition> <block>{<block_content>
	<for>for <control>(<init><expr><name>s</name> <operator>=</operator> <call><name>bc_a</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>s</name> <operator>&lt;=</operator> <call><name>bc_d</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>s</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>DEF_SLOT</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>op</name> <operator>==</operator> <name>BC_TSETM</name></expr>)</condition> <block>{<block_content>
	<for>for <control>(<init><expr><name>s</name> <operator>=</operator> <call><name>bc_a</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>s</name> <operator>&lt;</operator> <name>maxslot</name></expr>;</condition> <incr><expr><name>s</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>USE_SLOT</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    <default>default:</default> <break>break;</break>
    </block_content>}</block></switch>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>pc</name> <operator>&gt;=</operator> <call><name>proto_bc</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>pt</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>pc</name> <operator>&lt;</operator> <call><name>proto_bc</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>pt</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>J</name><operator>-&gt;</operator><name>pt</name><operator>-&gt;</operator><name>sizebc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>USE_SLOT</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>DEF_SLOT</name></cpp:undef>

  <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* unreachable */</comment>
</block_content>}</block></function>

<comment type="block">/* Purge dead slots before the next snapshot. */</comment>
<function><type><name>void</name></type> <name>lj_snap_purge</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name><name>udf</name><index>[<expr><name>SNAP_USEDEF_SLOTS</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCReg</name></type> <name>maxslot</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCReg</name></type> <name>s</name> <init>= <expr><call><name>snap_usedef</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>udf</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>pc</name></name></expr></argument>, <argument><expr><name>maxslot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init>;</init> <condition><expr><name>s</name> <operator>&lt;</operator> <name>maxslot</name></expr>;</condition> <incr><expr><name>s</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <if_stmt><if>if <condition>(<expr><name><name>udf</name><index>[<expr><name>s</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name><index>[<expr><name>s</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>  <comment type="block">/* Purge dead slots. */</comment>
</block_content>}</block></function>

<comment type="block">/* Shrink last snapshot. */</comment>
<function><type><name>void</name></type> <name>lj_snap_shrink</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>SnapShot</name> <modifier>*</modifier></type><name>snap</name> <init>= <expr><operator>&amp;</operator><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>snap</name><index>[<expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nsnap</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SnapEntry</name> <modifier>*</modifier></type><name>map</name> <init>= <expr><operator>&amp;</operator><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>snapmap</name><index>[<expr><name><name>snap</name><operator>-&gt;</operator><name>mapofs</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MSize</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>m</name></decl>, <decl><type ref="prev"/><name>nlim</name></decl>, <decl><type ref="prev"/><name>nent</name> <init>= <expr><name><name>snap</name><operator>-&gt;</operator><name>nent</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name><name>udf</name><index>[<expr><name>SNAP_USEDEF_SLOTS</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCReg</name></type> <name>maxslot</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCReg</name></type> <name>baseslot</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>baseslot</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCReg</name></type> <name>minslot</name> <init>= <expr><call><name>snap_usedef</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>udf</name></expr></argument>, <argument><expr><call><name>snap_pc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>map</name><index>[<expr><name>nent</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>maxslot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>maxslot</name> <operator>+=</operator> <name>baseslot</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>minslot</name> <operator>+=</operator> <name>baseslot</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>snap</name><operator>-&gt;</operator><name>nslots</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name>maxslot</name></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>n</name> <operator>=</operator> <name>m</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name>nent</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>  <comment type="block">/* Remove unused slots from snapshot. */</comment>
    <decl_stmt><decl><type><name>BCReg</name></type> <name>s</name> <init>= <expr><call><name>snap_slot</name><argument_list>(<argument><expr><name><name>map</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>s</name> <operator>&lt;</operator> <name>minslot</name> <operator>||</operator> <operator>(</operator><name>s</name> <operator>&lt;</operator> <name>maxslot</name> <operator>&amp;&amp;</operator> <name><name>udf</name><index>[<expr><name>s</name><operator>-</operator><name>baseslot</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>map</name><index>[<expr><name>m</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>map</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Only copy used slots. */</comment>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>snap</name><operator>-&gt;</operator><name>nent</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name>m</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nlim</name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nsnapmap</name></name> <operator>-</operator> <name><name>snap</name><operator>-&gt;</operator><name>mapofs</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <while>while <condition>(<expr><name>n</name> <operator>&lt;=</operator> <name>nlim</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>map</name><index>[<expr><name>m</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>map</name><index>[<expr><name>n</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt></block_content></block></while>  <comment type="block">/* Move PC + frame links down. */</comment>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>nsnapmap</name></name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name><name>snap</name><operator>-&gt;</operator><name>mapofs</name></name> <operator>+</operator> <name>m</name><operator>)</operator></expr>;</expr_stmt>  <comment type="block">/* Free up space in map. */</comment>
</block_content>}</block></function>

<comment type="block">/* -- Snapshot access ----------------------------------------------------- */</comment>

<comment type="block">/* Initialize a Bloom Filter with all renamed refs.
** There are very few renames (often none), so the filter has
** very few bits set. This makes it suitable for negative filtering.
*/</comment>
<function><type><specifier>static</specifier> <name>BloomFilter</name></type> <name>snap_renamefilter</name><parameter_list>(<parameter><decl><type><name>GCtrace</name> <modifier>*</modifier></type><name>T</name></decl></parameter>, <parameter><decl><type><name>SnapNo</name></type> <name>lim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>BloomFilter</name></type> <name>rfilt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>ir</name> <operator>=</operator> <operator>&amp;</operator><name><name>T</name><operator>-&gt;</operator><name>ir</name><index>[<expr><name><name>T</name><operator>-&gt;</operator><name>nins</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</init> <condition><expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_RENAME</name></expr>;</condition> <incr><expr><name>ir</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <if_stmt><if>if <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name> <operator>&lt;=</operator> <name>lim</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>bloomset</name><argument_list>(<argument><expr><name>rfilt</name></expr></argument>, <argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
  <return>return <expr><name>rfilt</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Process matching renames to find the original RegSP. */</comment>
<function><type><specifier>static</specifier> <name>RegSP</name></type> <name>snap_renameref</name><parameter_list>(<parameter><decl><type><name>GCtrace</name> <modifier>*</modifier></type><name>T</name></decl></parameter>, <parameter><decl><type><name>SnapNo</name></type> <name>lim</name></decl></parameter>, <parameter><decl><type><name>IRRef</name></type> <name>ref</name></decl></parameter>, <parameter><decl><type><name>RegSP</name></type> <name>rs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>ir</name> <operator>=</operator> <operator>&amp;</operator><name><name>T</name><operator>-&gt;</operator><name>ir</name><index>[<expr><name><name>T</name><operator>-&gt;</operator><name>nins</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</init> <condition><expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_RENAME</name></expr>;</condition> <incr><expr><name>ir</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <if_stmt><if>if <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name> <operator>==</operator> <name>ref</name> <operator>&amp;&amp;</operator> <name><name>ir</name><operator>-&gt;</operator><name>op2</name></name> <operator>&lt;=</operator> <name>lim</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>rs</name> <operator>=</operator> <name><name>ir</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
  <return>return <expr><name>rs</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Copy RegSP from parent snapshot to the parent links of the IR. */</comment>
<function><type><name>IRIns</name> <modifier>*</modifier></type><name>lj_snap_regspmap</name><parameter_list>(<parameter><decl><type><name>GCtrace</name> <modifier>*</modifier></type><name>T</name></decl></parameter>, <parameter><decl><type><name>SnapNo</name></type> <name>snapno</name></decl></parameter>, <parameter><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>SnapShot</name> <modifier>*</modifier></type><name>snap</name> <init>= <expr><operator>&amp;</operator><name><name>T</name><operator>-&gt;</operator><name>snap</name><index>[<expr><name>snapno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SnapEntry</name> <modifier>*</modifier></type><name>map</name> <init>= <expr><operator>&amp;</operator><name><name>T</name><operator>-&gt;</operator><name>snapmap</name><index>[<expr><name><name>snap</name><operator>-&gt;</operator><name>mapofs</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BloomFilter</name></type> <name>rfilt</name> <init>= <expr><call><name>snap_renamefilter</name><argument_list>(<argument><expr><name>T</name></expr></argument>, <argument><expr><name>snapno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MSize</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IRRef</name></type> <name>ref</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <for>for <control>( <init>;</init> <condition>;</condition> <incr><expr><name>ir</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>rs</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_SLOAD</name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name> <operator>&amp;</operator> <name>IRSLOAD_PARENT</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <for>for <control>( <init>;</init> <condition>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
	<expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>n</name> <operator>&lt;</operator> <name><name>snap</name><operator>-&gt;</operator><name>nent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>snap_slot</name><argument_list>(<argument><expr><name><name>map</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><name>ref</name> <operator>=</operator> <call><name>snap_ref</name><argument_list>(<argument><expr><name><name>map</name><index>[<expr><name>n</name><operator>++</operator></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <break>break;</break>
	</block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>LJ_SOFTFP32</name> <operator>&amp;&amp;</operator> <name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_HIOP</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>ref</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_PVAL</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>ref</name> <operator>=</operator> <name><name>ir</name><operator>-&gt;</operator><name>op1</name></name> <operator>+</operator> <name>REF_BIAS</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <break>break;</break>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>rs</name> <operator>=</operator> <name><name>T</name><operator>-&gt;</operator><name>ir</name><index>[<expr><name>ref</name></expr>]</index></name><operator>.</operator><name>prev</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>bloomtest</name><argument_list>(<argument><expr><name>rfilt</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>rs</name> <operator>=</operator> <call><name>snap_renameref</name><argument_list>(<argument><expr><name>T</name></expr></argument>, <argument><expr><name>snapno</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>, <argument><expr><name>rs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><name>rs</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>regsp_used</name><argument_list>(<argument><expr><name>rs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>ir</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -- Snapshot replay ----------------------------------------------------- */</comment>

<comment type="block">/* Replay constant from parent trace. */</comment>
<function><type><specifier>static</specifier> <name>TRef</name></type> <name>snap_replay_const</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Only have to deal with constants that can occur in stack slots. */</comment>
  <switch>switch <condition>(<expr><operator>(</operator><name>IROp</name><operator>)</operator><name><name>ir</name><operator>-&gt;</operator><name>o</name></name></expr>)</condition> <block>{<block_content>
  <case>case <expr><name>IR_KPRI</name></expr>:</case> <return>return <expr><call><name>TREF_PRI</name><argument_list>(<argument><expr><call><name>irt_type</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
  <case>case <expr><name>IR_KINT</name></expr>:</case> <return>return <expr><call><name>lj_ir_kint</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>ir</name><operator>-&gt;</operator><name>i</name></name></expr></argument>)</argument_list></call></expr>;</return>
  <case>case <expr><name>IR_KGC</name></expr>:</case> <return>return <expr><call><name>lj_ir_kgc</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>ir_kgc</name><argument_list>(<argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>irt_t</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
  <case>case <expr><name>IR_KNUM</name></expr>:</case> <case>case <expr><name>IR_KINT64</name></expr>:</case>
    <return>return <expr><call><name>lj_ir_k64</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>(</operator><name>IROp</name><operator>)</operator><name><name>ir</name><operator>-&gt;</operator><name>o</name></name></expr></argument>, <argument><expr><call><name>ir_k64</name><argument_list>(<argument><expr><name>ir</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>u64</name></expr></argument>)</argument_list></call></expr>;</return>
  <case>case <expr><name>IR_KPTR</name></expr>:</case> <return>return <expr><call><name>lj_ir_kptr</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>ir_kptr</name><argument_list>(<argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>  <comment type="block">/* Continuation. */</comment>
  <default>default:</default> <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>TREF_NIL</name></expr>;</return> <break>break;</break>
  </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/* De-duplicate parent reference. */</comment>
<function><type><specifier>static</specifier> <name>TRef</name></type> <name>snap_dedup</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>SnapEntry</name> <modifier>*</modifier></type><name>map</name></decl></parameter>, <parameter><decl><type><name>MSize</name></type> <name>nmax</name></decl></parameter>, <parameter><decl><type><name>IRRef</name></type> <name>ref</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>MSize</name></type> <name>j</name></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nmax</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <if_stmt><if>if <condition>(<expr><call><name>snap_ref</name><argument_list>(<argument><expr><name><name>map</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>ref</name></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name><name>J</name><operator>-&gt;</operator><name>slot</name><index>[<expr><call><name>snap_slot</name><argument_list>(<argument><expr><name><name>map</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>SNAP_CONT</name><operator>|</operator><name>SNAP_FRAME</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Emit parent reference with de-duplication. */</comment>
<function><type><specifier>static</specifier> <name>TRef</name></type> <name>snap_pref</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>GCtrace</name> <modifier>*</modifier></type><name>T</name></decl></parameter>, <parameter><decl><type><name>SnapEntry</name> <modifier>*</modifier></type><name>map</name></decl></parameter>, <parameter><decl><type><name>MSize</name></type> <name>nmax</name></decl></parameter>,
		      <parameter><decl><type><name>BloomFilter</name></type> <name>seen</name></decl></parameter>, <parameter><decl><type><name>IRRef</name></type> <name>ref</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name> <init>= <expr><operator>&amp;</operator><name><name>T</name><operator>-&gt;</operator><name>ir</name><index>[<expr><name>ref</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>irref_isk</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>snap_replay_const</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>regsp_used</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>tr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>bloomtest</name><argument_list>(<argument><expr><name>seen</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name>tr</name> <operator>=</operator> <call><name>snap_dedup</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>map</name></expr></argument>, <argument><expr><name>nmax</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_PVAL</name></expr></argument>, <argument><expr><call><name>irt_type</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ref</name> <operator>-</operator> <name>REF_BIAS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>tr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Check whether a sunk store corresponds to an allocation. Slow path. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>snap_sunk_store2</name><parameter_list>(<parameter><decl><type><name>GCtrace</name> <modifier>*</modifier></type><name>T</name></decl></parameter>, <parameter><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ira</name></decl></parameter>, <parameter><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>irs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>irs</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_ASTORE</name> <operator>||</operator> <name><name>irs</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_HSTORE</name> <operator>||</operator>
      <name><name>irs</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_FSTORE</name> <operator>||</operator> <name><name>irs</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_XSTORE</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>irk</name> <init>= <expr><operator>&amp;</operator><name><name>T</name><operator>-&gt;</operator><name>ir</name><index>[<expr><name><name>irs</name><operator>-&gt;</operator><name>op1</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>irk</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_AREF</name> <operator>||</operator> <name><name>irk</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_HREFK</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>irk</name> <operator>=</operator> <operator>&amp;</operator><name><name>T</name><operator>-&gt;</operator><name>ir</name><index>[<expr><name><name>irk</name><operator>-&gt;</operator><name>op1</name></name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><operator>(</operator><operator>&amp;</operator><name><name>T</name><operator>-&gt;</operator><name>ir</name><index>[<expr><name><name>irk</name><operator>-&gt;</operator><name>op1</name></name></expr>]</index></name> <operator>==</operator> <name>ira</name><operator>)</operator></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Check whether a sunk store corresponds to an allocation. Fast path. */</comment>
<function><type><specifier>static</specifier> <name>LJ_AINLINE</name> <name>int</name></type> <name>snap_sunk_store</name><parameter_list>(<parameter><decl><type><name>GCtrace</name> <modifier>*</modifier></type><name>T</name></decl></parameter>, <parameter><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ira</name></decl></parameter>, <parameter><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>irs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>irs</name><operator>-&gt;</operator><name>s</name></name> <operator>!=</operator> <literal type="number">255</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><operator>(</operator><name>ira</name> <operator>+</operator> <name><name>irs</name><operator>-&gt;</operator><name>s</name></name> <operator>==</operator> <name>irs</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* Fast check. */</comment>
  <return>return <expr><call><name>snap_sunk_store2</name><argument_list>(<argument><expr><name>T</name></expr></argument>, <argument><expr><name>ira</name></expr></argument>, <argument><expr><name>irs</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Replay snapshot state to setup side trace. */</comment>
<function><type><name>void</name></type> <name>lj_snap_replay</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>GCtrace</name> <modifier>*</modifier></type><name>T</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>SnapShot</name> <modifier>*</modifier></type><name>snap</name> <init>= <expr><operator>&amp;</operator><name><name>T</name><operator>-&gt;</operator><name>snap</name><index>[<expr><name><name>J</name><operator>-&gt;</operator><name>exitno</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SnapEntry</name> <modifier>*</modifier></type><name>map</name> <init>= <expr><operator>&amp;</operator><name><name>T</name><operator>-&gt;</operator><name>snapmap</name><index>[<expr><name><name>snap</name><operator>-&gt;</operator><name>mapofs</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MSize</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>nent</name> <init>= <expr><name><name>snap</name><operator>-&gt;</operator><name>nent</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BloomFilter</name></type> <name>seen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>pass23</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>framedepth</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <comment type="block">/* Emit IR for slots inherited from parent snapshot. */</comment>
  <for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name>nent</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>SnapEntry</name></type> <name>sn</name> <init>= <expr><name><name>map</name><index>[<expr><name>n</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BCReg</name></type> <name>s</name> <init>= <expr><call><name>snap_slot</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IRRef</name></type> <name>ref</name> <init>= <expr><call><name>snap_ref</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name> <init>= <expr><operator>&amp;</operator><name><name>T</name><operator>-&gt;</operator><name>ir</name><index>[<expr><name>ref</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name></decl>;</decl_stmt>
    <comment type="block">/* The bloom filter avoids O(nent^2) overhead for de-duping slots. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>bloomtest</name><argument_list>(<argument><expr><name>seen</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>tr</name> <operator>=</operator> <call><name>snap_dedup</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>map</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <goto>goto <name>setslot</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>bloomset</name><argument_list>(<argument><expr><name>seen</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>irref_isk</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <comment type="block">/* See special treatment of LJ_FR2 slot 1 in snapshot_slots() above. */</comment>
      <if_stmt><if>if <condition>(<expr><name>LJ_FR2</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>sn</name> <operator>==</operator> <call><name>SNAP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>SNAP_FRAME</name> <operator>|</operator> <name>SNAP_NORESTORE</name></expr></argument>, <argument><expr><name>REF_NIL</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>tr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
      <else>else<block type="pseudo"><block_content>
	<expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>snap_replay_const</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>regsp_used</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>pass23</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>s</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>tr</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <decl_stmt><decl><type><name>IRType</name></type> <name>t</name> <init>= <expr><call><name>irt_type</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>mode</name> <init>= <expr><name>IRSLOAD_INHERIT</name><operator>|</operator><name>IRSLOAD_PARENT</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>LJ_SOFTFP32</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>sn</name> <operator>&amp;</operator> <name>SNAP_SOFTFPNUM</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>t</name> <operator>=</operator> <name>IRT_NUM</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_SLOAD</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>mode</name> <operator>|=</operator> <operator>(</operator><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name> <operator>&amp;</operator> <name>IRSLOAD_READONLY</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>emitir_raw</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_SLOAD</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  <label><name>setslot</name>:</label>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>slot</name><index>[<expr><name>s</name></expr>]</index></name> <operator>=</operator> <name>tr</name> <operator>|</operator> <operator>(</operator><name>sn</name><operator>&amp;</operator><operator>(</operator><name>SNAP_CONT</name><operator>|</operator><name>SNAP_FRAME</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>  <comment type="block">/* Same as TREF_* flags. */</comment>
    <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>framedepth</name></name> <operator>+=</operator> <operator>(</operator><operator>(</operator><name>sn</name> <operator>&amp;</operator> <operator>(</operator><name>SNAP_CONT</name><operator>|</operator><name>SNAP_FRAME</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>s</name> <operator>!=</operator> <name>LJ_FR2</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>sn</name> <operator>&amp;</operator> <name>SNAP_FRAME</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>baseslot</name></name> <operator>=</operator> <name>s</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if <condition>(<expr><name>pass23</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>irlast</name> <init>= <expr><operator>&amp;</operator><name><name>T</name><operator>-&gt;</operator><name>ir</name><index>[<expr><name><name>snap</name><operator>-&gt;</operator><name>ref</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>pass23</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <comment type="block">/* Emit dependent PVALs. */</comment>
    <for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name>nent</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <decl_stmt><decl><type><name>SnapEntry</name></type> <name>sn</name> <init>= <expr><name><name>map</name><index>[<expr><name>n</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>IRRef</name></type> <name>refp</name> <init>= <expr><call><name>snap_ref</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name> <init>= <expr><operator>&amp;</operator><name><name>T</name><operator>-&gt;</operator><name>ir</name><index>[<expr><name>refp</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>regsp_reg</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>r</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RID_SUNK</name></expr>)</condition> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>slot</name><index>[<expr><call><name>snap_slot</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>!=</operator> <call><name>snap_slot</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>pass23</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_TNEW</name> <operator>||</operator> <name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_TDUP</name> <operator>||</operator>
		   <name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_CNEW</name> <operator>||</operator> <name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_CNEWI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name> <operator>&gt;=</operator> <name><name>T</name><operator>-&gt;</operator><name>nk</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>snap_pref</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>map</name></expr></argument>, <argument><expr><name>nent</name></expr></argument>, <argument><expr><name>seen</name></expr></argument>, <argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name> <operator>&gt;=</operator> <name><name>T</name><operator>-&gt;</operator><name>nk</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>snap_pref</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>map</name></expr></argument>, <argument><expr><name>nent</name></expr></argument>, <argument><expr><name>seen</name></expr></argument>, <argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>LJ_HASFFI</name> <operator>&amp;&amp;</operator> <name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_CNEWI</name></expr>)</condition> <block>{<block_content>
	  <if_stmt><if>if <condition>(<expr><name>LJ_32</name> <operator>&amp;&amp;</operator> <name>refp</name><operator>+</operator><literal type="number">1</literal> <operator>&lt;</operator> <name><name>T</name><operator>-&gt;</operator><name>nins</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>ir</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>-&gt;</operator><name>o</name> <operator>==</operator> <name>IR_HIOP</name></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><call><name>snap_pref</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>map</name></expr></argument>, <argument><expr><name>nent</name></expr></argument>, <argument><expr><name>seen</name></expr></argument>, <argument><expr><operator>(</operator><name>ir</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>-&gt;</operator><name>op2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
	  <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>irs</name></decl>;</decl_stmt>
	  <for>for <control>(<init><expr><name>irs</name> <operator>=</operator> <name>ir</name><operator>+</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>irs</name> <operator>&lt;</operator> <name>irlast</name></expr>;</condition> <incr><expr><name>irs</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
	    <if_stmt><if>if <condition>(<expr><name><name>irs</name><operator>-&gt;</operator><name>r</name></name> <operator>==</operator> <name>RID_SINK</name> <operator>&amp;&amp;</operator> <call><name>snap_sunk_store</name><argument_list>(<argument><expr><name>T</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><name>irs</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	      <if_stmt><if>if <condition>(<expr><call><name>snap_pref</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>map</name></expr></argument>, <argument><expr><name>nent</name></expr></argument>, <argument><expr><name>seen</name></expr></argument>, <argument><expr><name><name>irs</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snap_pref</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>map</name></expr></argument>, <argument><expr><name>nent</name></expr></argument>, <argument><expr><name>seen</name></expr></argument>, <argument><expr><name><name>T</name><operator>-&gt;</operator><name>ir</name><index>[<expr><name><name>irs</name><operator>-&gt;</operator><name>op2</name></name></expr>]</index></name><operator>.</operator><name>op1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	      <if type="elseif">else if <condition>(<expr><operator>(</operator><name>LJ_SOFTFP32</name> <operator>||</operator> <operator>(</operator><name>LJ_32</name> <operator>&amp;&amp;</operator> <name>LJ_HASFFI</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
		       <name>irs</name><operator>+</operator><literal type="number">1</literal> <operator>&lt;</operator> <name>irlast</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>irs</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>-&gt;</operator><name>o</name> <operator>==</operator> <name>IR_HIOP</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snap_pref</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>map</name></expr></argument>, <argument><expr><name>nent</name></expr></argument>, <argument><expr><name>seen</name></expr></argument>, <argument><expr><operator>(</operator><name>irs</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>-&gt;</operator><name>op2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	    </block_content>}</block></if></if_stmt></block_content></block></for>
	</block_content>}</block></else></if_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>irref_isk</name><argument_list>(<argument><expr><name>refp</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>regsp_used</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_CONV</name> <operator>&amp;&amp;</operator> <name><name>ir</name><operator>-&gt;</operator><name>op2</name></name> <operator>==</operator> <name>IRCONV_NUM_INT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>slot</name><index>[<expr><call><name>snap_slot</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>snap_pref</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>map</name></expr></argument>, <argument><expr><name>nent</name></expr></argument>, <argument><expr><name>seen</name></expr></argument>, <argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <comment type="block">/* Replay sunk instructions. */</comment>
    <for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>pass23</name> <operator>&amp;&amp;</operator> <name>n</name> <operator>&lt;</operator> <name>nent</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <decl_stmt><decl><type><name>SnapEntry</name></type> <name>sn</name> <init>= <expr><name><name>map</name><index>[<expr><name>n</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>IRRef</name></type> <name>refp</name> <init>= <expr><call><name>snap_ref</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name> <init>= <expr><operator>&amp;</operator><name><name>T</name><operator>-&gt;</operator><name>ir</name><index>[<expr><name>refp</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>regsp_reg</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>r</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RID_SUNK</name></expr>)</condition> <block>{<block_content>
	<decl_stmt><decl><type><name>TRef</name></type> <name>op1</name></decl>, <decl><type ref="prev"/><name>op2</name></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>J</name><operator>-&gt;</operator><name>slot</name><index>[<expr><call><name>snap_slot</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>!=</operator> <call><name>snap_slot</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* De-dup allocs. */</comment>
	  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>slot</name><index>[<expr><call><name>snap_slot</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>slot</name><index>[<expr><name><name>J</name><operator>-&gt;</operator><name>slot</name><index>[<expr><call><name>snap_slot</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt>
	  <continue>continue;</continue>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>op1</name> <operator>=</operator> <name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>op1</name> <operator>&gt;=</operator> <name><name>T</name><operator>-&gt;</operator><name>nk</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>op1</name> <operator>=</operator> <call><name>snap_pref</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>map</name></expr></argument>, <argument><expr><name>nent</name></expr></argument>, <argument><expr><name>seen</name></expr></argument>, <argument><expr><name>op1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>op2</name> <operator>=</operator> <name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>op2</name> <operator>&gt;=</operator> <name><name>T</name><operator>-&gt;</operator><name>nk</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>op2</name> <operator>=</operator> <call><name>snap_pref</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>map</name></expr></argument>, <argument><expr><name>nent</name></expr></argument>, <argument><expr><name>seen</name></expr></argument>, <argument><expr><name>op2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>LJ_HASFFI</name> <operator>&amp;&amp;</operator> <name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_CNEWI</name></expr>)</condition> <block>{<block_content>
	  <if_stmt><if>if <condition>(<expr><name>LJ_32</name> <operator>&amp;&amp;</operator> <name>refp</name><operator>+</operator><literal type="number">1</literal> <operator>&lt;</operator> <name><name>T</name><operator>-&gt;</operator><name>nins</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>ir</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>-&gt;</operator><name>o</name> <operator>==</operator> <name>IR_HIOP</name></expr>)</condition> <block>{<block_content>
	    <expr_stmt><expr><call><name>lj_needsplit</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Emit joining HIOP. */</comment>
	    <expr_stmt><expr><name>op2</name> <operator>=</operator> <call><name>emitir_raw</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_HIOP</name></expr></argument>, <argument><expr><name>IRT_I64</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>op2</name></expr></argument>,
			     <argument><expr><call><name>snap_pref</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>map</name></expr></argument>, <argument><expr><name>nent</name></expr></argument>, <argument><expr><name>seen</name></expr></argument>, <argument><expr><operator>(</operator><name>ir</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>-&gt;</operator><name>op2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  </block_content>}</block></if></if_stmt>
	  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>slot</name><index>[<expr><call><name>snap_slot</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>ot</name></name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>IRT_MARK</name><operator>|</operator><name>IRT_ISPHI</name><operator>)</operator></expr></argument>, <argument><expr><name>op1</name></expr></argument>, <argument><expr><name>op2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
	  <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>irs</name></decl>;</decl_stmt>
	  <decl_stmt><decl><type><name>TRef</name></type> <name>tr</name> <init>= <expr><call><name>emitir</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>ot</name></name></expr></argument>, <argument><expr><name>op1</name></expr></argument>, <argument><expr><name>op2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>slot</name><index>[<expr><call><name>snap_slot</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>tr</name></expr>;</expr_stmt>
	  <for>for <control>(<init><expr><name>irs</name> <operator>=</operator> <name>ir</name><operator>+</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>irs</name> <operator>&lt;</operator> <name>irlast</name></expr>;</condition> <incr><expr><name>irs</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
	    <if_stmt><if>if <condition>(<expr><name><name>irs</name><operator>-&gt;</operator><name>r</name></name> <operator>==</operator> <name>RID_SINK</name> <operator>&amp;&amp;</operator> <call><name>snap_sunk_store</name><argument_list>(<argument><expr><name>T</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><name>irs</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	      <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>irr</name> <init>= <expr><operator>&amp;</operator><name><name>T</name><operator>-&gt;</operator><name>ir</name><index>[<expr><name><name>irs</name><operator>-&gt;</operator><name>op1</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	      <decl_stmt><decl><type><name>TRef</name></type> <name>val</name></decl>, <decl><type ref="prev"/><name>key</name> <init>= <expr><name><name>irr</name><operator>-&gt;</operator><name>op2</name></name></expr></init></decl>, <decl><type ref="prev"/><name>tmp</name> <init>= <expr><name>tr</name></expr></init></decl>;</decl_stmt>
	      <if_stmt><if>if <condition>(<expr><name><name>irr</name><operator>-&gt;</operator><name>o</name></name> <operator>!=</operator> <name>IR_FREF</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>irk</name> <init>= <expr><operator>&amp;</operator><name><name>T</name><operator>-&gt;</operator><name>ir</name><index>[<expr><name>key</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>irr</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_HREFK</name></expr>)</condition><block type="pseudo"><block_content>
		  <expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>lj_ir_kslot</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><call><name>snap_replay_const</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>T</name><operator>-&gt;</operator><name>ir</name><index>[<expr><name><name>irk</name><operator>-&gt;</operator><name>op1</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
				    <argument><expr><name><name>irk</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
		  <expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>snap_replay_const</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>irk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>irr</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_HREFK</name> <operator>||</operator> <name><name>irr</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_AREF</name></expr>)</condition> <block>{<block_content>
		  <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>irf</name> <init>= <expr><operator>&amp;</operator><name><name>T</name><operator>-&gt;</operator><name>ir</name><index>[<expr><name><name>irr</name><operator>-&gt;</operator><name>op1</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		  <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><name><name>irf</name><operator>-&gt;</operator><name>ot</name></name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name><name>irf</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	      </block_content>}</block></if></if_stmt>
	      <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><name><name>irr</name><operator>-&gt;</operator><name>ot</name></name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>snap_pref</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>map</name></expr></argument>, <argument><expr><name>nent</name></expr></argument>, <argument><expr><name>seen</name></expr></argument>, <argument><expr><name><name>irs</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <if_stmt><if>if <condition>(<expr><name>val</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>irc</name> <init>= <expr><operator>&amp;</operator><name><name>T</name><operator>-&gt;</operator><name>ir</name><index>[<expr><name><name>irs</name><operator>-&gt;</operator><name>op2</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>irc</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_CONV</name> <operator>&amp;&amp;</operator> <name><name>irc</name><operator>-&gt;</operator><name>op2</name></name> <operator>==</operator> <name>IRCONV_NUM_INT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>snap_pref</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>map</name></expr></argument>, <argument><expr><name>nent</name></expr></argument>, <argument><expr><name>seen</name></expr></argument>, <argument><expr><name><name>irc</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRTN</name><argument_list>(<argument><expr><name>IR_CONV</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>IRCONV_NUM_INT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>LJ_SOFTFP32</name> <operator>||</operator> <operator>(</operator><name>LJ_32</name> <operator>&amp;&amp;</operator> <name>LJ_HASFFI</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
			 <name>irs</name><operator>+</operator><literal type="number">1</literal> <operator>&lt;</operator> <name>irlast</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>irs</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>-&gt;</operator><name>o</name> <operator>==</operator> <name>IR_HIOP</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>IRType</name></type> <name>t</name> <init>= <expr><name>IRT_I64</name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>LJ_SOFTFP32</name> <operator>&amp;&amp;</operator> <call><name>irt_type</name><argument_list>(<argument><expr><operator>(</operator><name>irs</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>-&gt;</operator><name>t</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>IRT_SOFTFP</name></expr>)</condition><block type="pseudo"><block_content>
		  <expr_stmt><expr><name>t</name> <operator>=</operator> <name>IRT_NUM</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>lj_needsplit</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>irref_isk</name><argument_list>(<argument><expr><name><name>irs</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>irref_isk</name><argument_list>(<argument><expr><operator>(</operator><name>irs</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>-&gt;</operator><name>op2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		  <decl_stmt><decl><type><name>uint64_t</name></type> <name>k</name> <init>= <expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>T</name><operator>-&gt;</operator><name>ir</name><index>[<expr><name><name>irs</name><operator>-&gt;</operator><name>op2</name></name></expr>]</index></name><operator>.</operator><name>i</name> <operator>+</operator>
			       <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>T</name><operator>-&gt;</operator><name>ir</name><index>[<expr><operator>(</operator><name>irs</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>-&gt;</operator><name>op2</name></expr>]</index></name><operator>.</operator><name>i</name> <operator>&lt;&lt;</operator> <literal type="number">32</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
		  <expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>lj_ir_k64</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><ternary><condition><expr><name>t</name> <operator>==</operator> <name>IRT_I64</name></expr> ?</condition><then> <expr><name>IR_KINT64</name></expr> </then><else>: <expr><name>IR_KNUM</name></expr></else></ternary></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
		  <expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>emitir_raw</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_HIOP</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>val</name></expr></argument>,
			  <argument><expr><call><name>snap_pref</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>map</name></expr></argument>, <argument><expr><name>nent</name></expr></argument>, <argument><expr><name>seen</name></expr></argument>, <argument><expr><operator>(</operator><name>irs</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>-&gt;</operator><name>op2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name><name>irs</name><operator>-&gt;</operator><name>o</name></name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<continue>continue;</continue>
	      </block_content>}</block></if></if_stmt>
	      <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>emitir</name><argument_list>(<argument><expr><name><name>irs</name><operator>-&gt;</operator><name>ot</name></name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>LJ_HASFFI</name> <operator>&amp;&amp;</operator> <name><name>irs</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_XBAR</name> <operator>&amp;&amp;</operator> <name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_CNEW</name></expr>)</condition> <block>{<block_content>
	      <expr_stmt><expr><call><name>emitir</name><argument_list>(<argument><expr><call><name>IRT</name><argument_list>(<argument><expr><name>IR_XBAR</name></expr></argument>, <argument><expr><name>IRT_NIL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    </block_content>}</block></if></if_stmt></block_content></block></for>
	</block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <name><name>J</name><operator>-&gt;</operator><name>slot</name></name> <operator>+</operator> <name><name>J</name><operator>-&gt;</operator><name>baseslot</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>J</name><operator>-&gt;</operator><name>maxslot</name></name> <operator>=</operator> <name><name>snap</name><operator>-&gt;</operator><name>nslots</name></name> <operator>-</operator> <name><name>J</name><operator>-&gt;</operator><name>baseslot</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lj_snap_add</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>pass23</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* Need explicit GC step _after_ initial snapshot. */</comment>
    <expr_stmt><expr><call><name>emitir_raw</name><argument_list>(<argument><expr><call><name>IRTG</name><argument_list>(<argument><expr><name>IR_GCSTEP</name></expr></argument>, <argument><expr><name>IRT_NIL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* -- Snapshot restore ---------------------------------------------------- */</comment>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>snap_unsink</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>GCtrace</name> <modifier>*</modifier></type><name>T</name></decl></parameter>, <parameter><decl><type><name>ExitState</name> <modifier>*</modifier></type><name>ex</name></decl></parameter>,
			<parameter><decl><type><name>SnapNo</name></type> <name>snapno</name></decl></parameter>, <parameter><decl><type><name>BloomFilter</name></type> <name>rfilt</name></decl></parameter>,
			<parameter><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name></decl></parameter>, <parameter><decl><type><name>TValue</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Restore a value from the trace exit state. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>snap_restoreval</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>GCtrace</name> <modifier>*</modifier></type><name>T</name></decl></parameter>, <parameter><decl><type><name>ExitState</name> <modifier>*</modifier></type><name>ex</name></decl></parameter>,
			    <parameter><decl><type><name>SnapNo</name></type> <name>snapno</name></decl></parameter>, <parameter><decl><type><name>BloomFilter</name></type> <name>rfilt</name></decl></parameter>,
			    <parameter><decl><type><name>IRRef</name></type> <name>ref</name></decl></parameter>, <parameter><decl><type><name>TValue</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name> <init>= <expr><operator>&amp;</operator><name><name>T</name><operator>-&gt;</operator><name>ir</name><index>[<expr><name>ref</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IRType1</name></type> <name>t</name> <init>= <expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RegSP</name></type> <name>rs</name> <init>= <expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>irref_isk</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Restore constant slot. */</comment>
    <expr_stmt><expr><call><name>lj_ir_kvalue</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>LJ_UNLIKELY</name><argument_list>(<argument><expr><call><name>bloomtest</name><argument_list>(<argument><expr><name>rfilt</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>rs</name> <operator>=</operator> <call><name>snap_renameref</name><argument_list>(<argument><expr><name>T</name></expr></argument>, <argument><expr><name>snapno</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>, <argument><expr><name>rs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>ra_hasspill</name><argument_list>(<argument><expr><call><name>regsp_spill</name><argument_list>(<argument><expr><name>rs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* Restore from spill slot. */</comment>
    <decl_stmt><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>sps</name> <init>= <expr><operator>&amp;</operator><name><name>ex</name><operator>-&gt;</operator><name>spill</name><index>[<expr><call><name>regsp_spill</name><argument_list>(<argument><expr><name>rs</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>irt_isinteger</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>setintV</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><operator>*</operator><name>sps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>LJ_SOFTFP32</name></expr></cpp:if>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>irt_isnum</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>u64</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator><name>sps</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_64</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>LJ_GC64</name></expr></cpp:if>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>irt_islightud</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <comment type="block">/* 64 bit lightuserdata which may escape already has the tag bits. */</comment>
      <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>u64</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator><name>sps</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>irt_ispri</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* PRI refs never have a spill slot. */</comment>
      <expr_stmt><expr><call><name>setgcV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><operator>(</operator><name>GCobj</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><operator>*</operator><operator>(</operator><name>GCSize</name> <operator>*</operator><operator>)</operator><name>sps</name></expr></argument>, <argument><expr><call><name>irt_toitype</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* Restore from register. */</comment>
    <decl_stmt><decl><type><name>Reg</name></type> <name>r</name> <init>= <expr><call><name>regsp_reg</name><argument_list>(<argument><expr><name>rs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ra_noreg</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_CONV</name> <operator>&amp;&amp;</operator> <name><name>ir</name><operator>-&gt;</operator><name>op2</name></name> <operator>==</operator> <name>IRCONV_NUM_INT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>snap_restoreval</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>ex</name></expr></argument>, <argument><expr><name>snapno</name></expr></argument>, <argument><expr><name>rfilt</name></expr></argument>, <argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>LJ_DUALNUM</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>setnumV</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><operator>(</operator><name>lua_Number</name><operator>)</operator><call><name>intV</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <return>return;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>irt_isinteger</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>setintV</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><name><name>ex</name><operator>-&gt;</operator><name>gpr</name><index>[<expr><name>r</name><operator>-</operator><name>RID_MIN_GPR</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>LJ_SOFTFP</name></expr></cpp:if>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>irt_isnum</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>setnumV</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><name><name>ex</name><operator>-&gt;</operator><name>fpr</name><index>[<expr><name>r</name><operator>-</operator><name>RID_MIN_FPR</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LJ_64</name></expr></cpp:elif>  <comment type="block">/* &amp;&amp; LJ_SOFTFP */</comment>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>irt_isnum</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>u64</name></name> <operator>=</operator> <name><name>ex</name><operator>-&gt;</operator><name>gpr</name><index>[<expr><name>r</name><operator>-</operator><name>RID_MIN_GPR</name></expr>]</index></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_64</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>LJ_GC64</name></expr></cpp:if>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>irt_is64</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <comment type="block">/* 64 bit values that already have the tag bits. */</comment>
      <expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>u64</name></name> <operator>=</operator> <name><name>ex</name><operator>-&gt;</operator><name>gpr</name><index>[<expr><name>r</name><operator>-</operator><name>RID_MIN_GPR</name></expr>]</index></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>irt_ispri</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>setpriV</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><call><name>irt_toitype</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>setgcV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><operator>(</operator><name>GCobj</name> <operator>*</operator><operator>)</operator><name><name>ex</name><operator>-&gt;</operator><name>gpr</name><index>[<expr><name>r</name><operator>-</operator><name>RID_MIN_GPR</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>irt_toitype</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>
<comment type="block">/* Restore raw data from the trace exit state. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>snap_restoredata</name><parameter_list>(<parameter><decl><type><name>GCtrace</name> <modifier>*</modifier></type><name>T</name></decl></parameter>, <parameter><decl><type><name>ExitState</name> <modifier>*</modifier></type><name>ex</name></decl></parameter>,
			     <parameter><decl><type><name>SnapNo</name></type> <name>snapno</name></decl></parameter>, <parameter><decl><type><name>BloomFilter</name></type> <name>rfilt</name></decl></parameter>,
			     <parameter><decl><type><name>IRRef</name></type> <name>ref</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><name>CTSize</name></type> <name>sz</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name> <init>= <expr><operator>&amp;</operator><name><name>T</name><operator>-&gt;</operator><name>ir</name><index>[<expr><name>ref</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RegSP</name></type> <name>rs</name> <init>= <expr><name><name>ir</name><operator>-&gt;</operator><name>prev</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>src</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint64_t</name></type> <name>tmp</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>irref_isk</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>ir_isk64</name><argument_list>(<argument><expr><name>ir</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>src</name> <operator>=</operator> <operator>(</operator><name>int32_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>ir</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>sz</name> <operator>==</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>tmp</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>ir</name><operator>-&gt;</operator><name>i</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>src</name> <operator>=</operator> <operator>(</operator><name>int32_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>tmp</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>src</name> <operator>=</operator> <operator>&amp;</operator><name><name>ir</name><operator>-&gt;</operator><name>i</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>LJ_UNLIKELY</name><argument_list>(<argument><expr><call><name>bloomtest</name><argument_list>(<argument><expr><name>rfilt</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>rs</name> <operator>=</operator> <call><name>snap_renameref</name><argument_list>(<argument><expr><name>T</name></expr></argument>, <argument><expr><name>snapno</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>, <argument><expr><name>rs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ra_hasspill</name><argument_list>(<argument><expr><call><name>regsp_spill</name><argument_list>(<argument><expr><name>rs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>src</name> <operator>=</operator> <operator>&amp;</operator><name><name>ex</name><operator>-&gt;</operator><name>spill</name><index>[<expr><call><name>regsp_spill</name><argument_list>(<argument><expr><name>rs</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>sz</name> <operator>==</operator> <literal type="number">8</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>irt_is64</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name>tmp</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>*</operator><name>src</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>src</name> <operator>=</operator> <operator>(</operator><name>int32_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>tmp</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <decl_stmt><decl><type><name>Reg</name></type> <name>r</name> <init>= <expr><call><name>regsp_reg</name><argument_list>(<argument><expr><name>rs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>ra_noreg</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<comment type="block">/* Note: this assumes CNEWI is never used for SOFTFP split numbers. */</comment>
	<expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>sz</name> <operator>==</operator> <literal type="number">8</literal> <operator>&amp;&amp;</operator> <name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_CONV</name> <operator>&amp;&amp;</operator> <name><name>ir</name><operator>-&gt;</operator><name>op2</name></name> <operator>==</operator> <name>IRCONV_NUM_INT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>snap_restoredata</name><argument_list>(<argument><expr><name>T</name></expr></argument>, <argument><expr><name>ex</name></expr></argument>, <argument><expr><name>snapno</name></expr></argument>, <argument><expr><name>rfilt</name></expr></argument>, <argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><operator>(</operator><name>lua_Number</name> <operator>*</operator><operator>)</operator><name>dst</name> <operator>=</operator> <operator>(</operator><name>lua_Number</name><operator>)</operator><operator>*</operator><operator>(</operator><name>int32_t</name> <operator>*</operator><operator>)</operator><name>dst</name></expr>;</expr_stmt>
	<return>return;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>src</name> <operator>=</operator> <operator>(</operator><name>int32_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>ex</name><operator>-&gt;</operator><name>gpr</name><index>[<expr><name>r</name><operator>-</operator><name>RID_MIN_GPR</name></expr>]</index></name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>LJ_SOFTFP</name></expr></cpp:if>
      <if_stmt><if>if <condition>(<expr><name>r</name> <operator>&gt;=</operator> <name>RID_MAX_GPR</name></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name>src</name> <operator>=</operator> <operator>(</operator><name>int32_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>ex</name><operator>-&gt;</operator><name>fpr</name><index>[<expr><name>r</name><operator>-</operator><name>RID_MIN_FPR</name></expr>]</index></name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_TARGET_PPC</name></expr></cpp:if>
	<if_stmt><if>if <condition>(<expr><name>sz</name> <operator>==</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* PPC FPRs are always doubles. */</comment>
	  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>float</name> <operator>*</operator><operator>)</operator><name>dst</name> <operator>=</operator> <operator>(</operator><name>float</name><operator>)</operator><operator>*</operator><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator><name>src</name></expr>;</expr_stmt>
	  <return>return;</return>
	</block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<if_stmt><if>if <condition>(<expr><name>LJ_BE</name> <operator>&amp;&amp;</operator> <name>sz</name> <operator>==</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>src</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      </block_content>}</block></if> <if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      if <condition>(<expr><name>LJ_64</name> <operator>&amp;&amp;</operator> <name>LJ_BE</name> <operator>&amp;&amp;</operator> <name>sz</name> <operator>==</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>src</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>sz</name> <operator>==</operator> <literal type="number">1</literal> <operator>||</operator> <name>sz</name> <operator>==</operator> <literal type="number">2</literal> <operator>||</operator> <name>sz</name> <operator>==</operator> <literal type="number">4</literal> <operator>||</operator> <name>sz</name> <operator>==</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>sz</name> <operator>==</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><operator>(</operator><name>int32_t</name> <operator>*</operator><operator>)</operator><name>dst</name> <operator>=</operator> <operator>*</operator><name>src</name></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><name>sz</name> <operator>==</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator><name>dst</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator><name>src</name></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><name>sz</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><operator>(</operator><name>int8_t</name> <operator>*</operator><operator>)</operator><name>dst</name> <operator>=</operator> <operator>(</operator><name>int8_t</name><operator>)</operator><operator>*</operator><name>src</name></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><operator>(</operator><name>int16_t</name> <operator>*</operator><operator>)</operator><name>dst</name> <operator>=</operator> <operator>(</operator><name>int16_t</name><operator>)</operator><operator>*</operator><name>src</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Unsink allocation from the trace exit state. Unsink sunk stores. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>snap_unsink</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>GCtrace</name> <modifier>*</modifier></type><name>T</name></decl></parameter>, <parameter><decl><type><name>ExitState</name> <modifier>*</modifier></type><name>ex</name></decl></parameter>,
			<parameter><decl><type><name>SnapNo</name></type> <name>snapno</name></decl></parameter>, <parameter><decl><type><name>BloomFilter</name></type> <name>rfilt</name></decl></parameter>,
			<parameter><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name></decl></parameter>, <parameter><decl><type><name>TValue</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_TNEW</name> <operator>||</operator> <name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_TDUP</name> <operator>||</operator>
	     <name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_CNEW</name> <operator>||</operator> <name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_CNEWI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_HASFFI</name></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_CNEW</name> <operator>||</operator> <name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_CNEWI</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>CTState</name> <modifier>*</modifier></type><name>cts</name> <init>= <expr><call><name>ctype_cts</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CTypeID</name></type> <name>id</name> <init>= <expr><operator>(</operator><name>CTypeID</name><operator>)</operator><name><name>T</name><operator>-&gt;</operator><name>ir</name><index>[<expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr>]</index></name><operator>.</operator><name>i</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CTSize</name></type> <name>sz</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CTInfo</name></type> <name>info</name> <init>= <expr><call><name>lj_ctype_info</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GCcdata</name> <modifier>*</modifier></type><name>cd</name> <init>= <expr><call><name>lj_cdata_newx</name><argument_list>(<argument><expr><name>cts</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>setcdataV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_CNEWI</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><call><name>cdataptr</name><argument_list>(<argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>sz</name> <operator>==</operator> <literal type="number">4</literal> <operator>||</operator> <name>sz</name> <operator>==</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>LJ_32</name> <operator>&amp;&amp;</operator> <name>sz</name> <operator>==</operator> <literal type="number">8</literal> <operator>&amp;&amp;</operator> <name>ir</name><operator>+</operator><literal type="number">1</literal> <operator>&lt;</operator> <name><name>T</name><operator>-&gt;</operator><name>ir</name></name> <operator>+</operator> <name><name>T</name><operator>-&gt;</operator><name>nins</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>ir</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>-&gt;</operator><name>o</name> <operator>==</operator> <name>IR_HIOP</name></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>snap_restoredata</name><argument_list>(<argument><expr><name>T</name></expr></argument>, <argument><expr><name>ex</name></expr></argument>, <argument><expr><name>snapno</name></expr></argument>, <argument><expr><name>rfilt</name></expr></argument>, <argument><expr><operator>(</operator><name>ir</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>-&gt;</operator><name>op2</name></expr></argument>, <argument><expr><ternary><condition><expr><name>LJ_LE</name></expr>?</condition><then><expr><name>p</name><operator>+</operator><literal type="number">4</literal></expr></then><else>:<expr><name>p</name></expr></else></ternary></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>LJ_BE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>sz</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>snap_restoredata</name><argument_list>(<argument><expr><name>T</name></expr></argument>, <argument><expr><name>ex</name></expr></argument>, <argument><expr><name>snapno</name></expr></argument>, <argument><expr><name>rfilt</name></expr></argument>, <argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>irs</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>irlast</name> <init>= <expr><operator>&amp;</operator><name><name>T</name><operator>-&gt;</operator><name>ir</name><index>[<expr><name><name>T</name><operator>-&gt;</operator><name>snap</name><index>[<expr><name>snapno</name></expr>]</index></name><operator>.</operator><name>ref</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <for>for <control>(<init><expr><name>irs</name> <operator>=</operator> <name>ir</name><operator>+</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>irs</name> <operator>&lt;</operator> <name>irlast</name></expr>;</condition> <incr><expr><name>irs</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
	<if_stmt><if>if <condition>(<expr><name><name>irs</name><operator>-&gt;</operator><name>r</name></name> <operator>==</operator> <name>RID_SINK</name> <operator>&amp;&amp;</operator> <call><name>snap_sunk_store</name><argument_list>(<argument><expr><name>T</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><name>irs</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	  <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>iro</name> <init>= <expr><operator>&amp;</operator><name><name>T</name><operator>-&gt;</operator><name>ir</name><index>[<expr><name><name>T</name><operator>-&gt;</operator><name>ir</name><index>[<expr><name><name>irs</name><operator>-&gt;</operator><name>op1</name></name></expr>]</index></name><operator>.</operator><name>op2</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	  <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>cd</name></expr></init></decl>;</decl_stmt>
	  <decl_stmt><decl><type><name>CTSize</name></type> <name>szs</name></decl>;</decl_stmt>
	  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>irs</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_XSTORE</name> <operator>&amp;&amp;</operator> <name><name>T</name><operator>-&gt;</operator><name>ir</name><index>[<expr><name><name>irs</name><operator>-&gt;</operator><name>op1</name></name></expr>]</index></name><operator>.</operator><name>o</name> <operator>==</operator> <name>IR_ADD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>iro</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_KINT</name> <operator>||</operator> <name><name>iro</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_KINT64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <if_stmt><if>if <condition>(<expr><call><name>irt_is64</name><argument_list>(<argument><expr><name><name>irs</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>szs</name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt></block_content></block></if>
	  <if type="elseif">else if <condition>(<expr><call><name>irt_isi8</name><argument_list>(<argument><expr><name><name>irs</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>irt_isu8</name><argument_list>(<argument><expr><name><name>irs</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>szs</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
	  <if type="elseif">else if <condition>(<expr><call><name>irt_isi16</name><argument_list>(<argument><expr><name><name>irs</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>irt_isu16</name><argument_list>(<argument><expr><name><name>irs</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>szs</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
	  <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>szs</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	  <if_stmt><if>if <condition>(<expr><name>LJ_64</name> <operator>&amp;&amp;</operator> <name><name>iro</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_KINT64</name></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><name>p</name> <operator>+=</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><call><name>ir_k64</name><argument_list>(<argument><expr><name>iro</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>u64</name></expr>;</expr_stmt></block_content></block></if>
	  <else>else<block type="pseudo"><block_content>
	    <expr_stmt><expr><name>p</name> <operator>+=</operator> <name><name>iro</name><operator>-&gt;</operator><name>i</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>p</name> <operator>&gt;=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><call><name>cdataptr</name><argument_list>(<argument><expr><name>cd</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		     <name>p</name> <operator>+</operator> <name>szs</name> <operator>&lt;=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><call><name>cdataptr</name><argument_list>(<argument><expr><name>cd</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <if_stmt><if>if <condition>(<expr><name>LJ_32</name> <operator>&amp;&amp;</operator> <name>irs</name><operator>+</operator><literal type="number">1</literal> <operator>&lt;</operator> <name><name>T</name><operator>-&gt;</operator><name>ir</name></name> <operator>+</operator> <name><name>T</name><operator>-&gt;</operator><name>nins</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>irs</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>-&gt;</operator><name>o</name> <operator>==</operator> <name>IR_HIOP</name></expr>)</condition> <block>{<block_content>
	    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>szs</name> <operator>==</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>snap_restoredata</name><argument_list>(<argument><expr><name>T</name></expr></argument>, <argument><expr><name>ex</name></expr></argument>, <argument><expr><name>snapno</name></expr></argument>, <argument><expr><name>rfilt</name></expr></argument>, <argument><expr><operator>(</operator><name>irs</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>-&gt;</operator><name>op2</name></expr></argument>, <argument><expr><ternary><condition><expr><name>LJ_LE</name></expr>?</condition><then><expr><name>p</name><operator>+</operator><literal type="number">4</literal></expr></then><else>:<expr><name>p</name></expr></else></ternary></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if_stmt><if>if <condition>(<expr><name>LJ_BE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	  </block_content>}</block></if></if_stmt>
	  <expr_stmt><expr><call><name>snap_restoredata</name><argument_list>(<argument><expr><name>T</name></expr></argument>, <argument><expr><name>ex</name></expr></argument>, <argument><expr><name>snapno</name></expr></argument>, <argument><expr><name>rfilt</name></expr></argument>, <argument><expr><name><name>irs</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>szs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt></block_content></block></for>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <block>{<block_content>
    <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>irs</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>irlast</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GCtab</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><ternary><condition><expr><name><name>ir</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_TNEW</name></expr> ?</condition><then> <expr><call><name>lj_tab_new</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr></argument>, <argument><expr><name><name>ir</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>)</argument_list></call></expr> </then><else>:
				  <expr><call><name>lj_tab_dup</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><call><name>ir_ktab</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>T</name><operator>-&gt;</operator><name>ir</name><index>[<expr><name><name>ir</name><operator>-&gt;</operator><name>op1</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>settabV</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>irlast</name> <operator>=</operator> <operator>&amp;</operator><name><name>T</name><operator>-&gt;</operator><name>ir</name><index>[<expr><name><name>T</name><operator>-&gt;</operator><name>snap</name><index>[<expr><name>snapno</name></expr>]</index></name><operator>.</operator><name>ref</name></expr>]</index></name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>irs</name> <operator>=</operator> <name>ir</name><operator>+</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>irs</name> <operator>&lt;</operator> <name>irlast</name></expr>;</condition> <incr><expr><name>irs</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
      <if_stmt><if>if <condition>(<expr><name><name>irs</name><operator>-&gt;</operator><name>r</name></name> <operator>==</operator> <name>RID_SINK</name> <operator>&amp;&amp;</operator> <call><name>snap_sunk_store</name><argument_list>(<argument><expr><name>T</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><name>irs</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>irk</name> <init>= <expr><operator>&amp;</operator><name><name>T</name><operator>-&gt;</operator><name>ir</name><index>[<expr><name><name>irs</name><operator>-&gt;</operator><name>op1</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TValue</name></type> <name>tmp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>irs</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_ASTORE</name> <operator>||</operator> <name><name>irs</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_HSTORE</name> <operator>||</operator>
		   <name><name>irs</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_FSTORE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>irk</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_FREF</name></expr>)</condition> <block>{<block_content>
	  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>irk</name><operator>-&gt;</operator><name>op2</name></name> <operator>==</operator> <name>IRFL_TAB_META</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><call><name>snap_restoreval</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>ex</name></expr></argument>, <argument><expr><name>snapno</name></expr></argument>, <argument><expr><name>rfilt</name></expr></argument>, <argument><expr><name><name>irs</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <comment type="block">/* NOBARRIER: The table is new (marked white). */</comment>
	  <expr_stmt><expr><call><name>setgcref</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>metatable</name></name></expr></argument>, <argument><expr><call><name>obj2gco</name><argument_list>(<argument><expr><call><name>tabV</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
	  <expr_stmt><expr><name>irk</name> <operator>=</operator> <operator>&amp;</operator><name><name>T</name><operator>-&gt;</operator><name>ir</name><index>[<expr><name><name>irk</name><operator>-&gt;</operator><name>op2</name></name></expr>]</index></name></expr>;</expr_stmt>
	  <if_stmt><if>if <condition>(<expr><name><name>irk</name><operator>-&gt;</operator><name>o</name></name> <operator>==</operator> <name>IR_KSLOT</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>irk</name> <operator>=</operator> <operator>&amp;</operator><name><name>T</name><operator>-&gt;</operator><name>ir</name><index>[<expr><name><name>irk</name><operator>-&gt;</operator><name>op1</name></name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	  <expr_stmt><expr><call><name>lj_ir_kvalue</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><name>irk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>lj_tab_set</name><argument_list>(<argument><expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <comment type="block">/* NOBARRIER: The table is new (marked white). */</comment>
	  <expr_stmt><expr><call><name>snap_restoreval</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>ex</name></expr></argument>, <argument><expr><name>snapno</name></expr></argument>, <argument><expr><name>rfilt</name></expr></argument>, <argument><expr><name><name>irs</name><operator>-&gt;</operator><name>op2</name></name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <if_stmt><if>if <condition>(<expr><name>LJ_SOFTFP32</name> <operator>&amp;&amp;</operator> <name>irs</name><operator>+</operator><literal type="number">1</literal> <operator>&lt;</operator> <name><name>T</name><operator>-&gt;</operator><name>ir</name></name> <operator>+</operator> <name><name>T</name><operator>-&gt;</operator><name>nins</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>irs</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>-&gt;</operator><name>o</name> <operator>==</operator> <name>IR_HIOP</name></expr>)</condition> <block>{<block_content>
	    <expr_stmt><expr><call><name>snap_restoreval</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>ex</name></expr></argument>, <argument><expr><name>snapno</name></expr></argument>, <argument><expr><name>rfilt</name></expr></argument>, <argument><expr><operator>(</operator><name>irs</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>-&gt;</operator><name>op2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>u32</name><operator>.</operator><name>hi</name></name> <operator>=</operator> <name><name>tmp</name><operator>.</operator><name>u32</name><operator>.</operator><name>lo</name></name></expr>;</expr_stmt>
	  </block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt></block_content></block></for>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Restore interpreter state from exit state with the help of a snapshot. */</comment>
<function><type><specifier>const</specifier> <name>BCIns</name> <modifier>*</modifier></type><name>lj_snap_restore</name><parameter_list>(<parameter><decl><type><name>jit_State</name> <modifier>*</modifier></type><name>J</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>exptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>ExitState</name> <modifier>*</modifier></type><name>ex</name> <init>= <expr><operator>(</operator><name>ExitState</name> <operator>*</operator><operator>)</operator><name>exptr</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SnapNo</name></type> <name>snapno</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>exitno</name></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* For now, snapno == exitno. */</comment>
  <decl_stmt><decl><type><name>GCtrace</name> <modifier>*</modifier></type><name>T</name> <init>= <expr><call><name>traceref</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name><name>J</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SnapShot</name> <modifier>*</modifier></type><name>snap</name> <init>= <expr><operator>&amp;</operator><name><name>T</name><operator>-&gt;</operator><name>snap</name><index>[<expr><name>snapno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MSize</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>nent</name> <init>= <expr><name><name>snap</name><operator>-&gt;</operator><name>nent</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SnapEntry</name> <modifier>*</modifier></type><name>map</name> <init>= <expr><operator>&amp;</operator><name><name>T</name><operator>-&gt;</operator><name>snapmap</name><index>[<expr><name><name>snap</name><operator>-&gt;</operator><name>mapofs</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>LJ_FR2</name> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>LUA_USE_ASSERT</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <decl_stmt><decl><type><name>SnapEntry</name> <modifier>*</modifier></type><name>flinks</name> <init>= <expr><operator>&amp;</operator><name><name>T</name><operator>-&gt;</operator><name>snapmap</name><index>[<expr><call><name>snap_nextofs</name><argument_list>(<argument><expr><name>T</name></expr></argument>, <argument><expr><name>snap</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal><operator>-</operator><name>LJ_FR2</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>LJ_FR2</name></expr></cpp:if>
  <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>ftsz0</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>frame</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BloomFilter</name></type> <name>rfilt</name> <init>= <expr><call><name>snap_renamefilter</name><argument_list>(<argument><expr><name>T</name></expr></argument>, <argument><expr><name>snapno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>BCIns</name> <modifier>*</modifier></type><name>pc</name> <init>= <expr><call><name>snap_pc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>map</name><index>[<expr><name>nent</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name> <init>= <expr><name><name>J</name><operator>-&gt;</operator><name>L</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Set interpreter PC to the next PC to get correct error messages. */</comment>
  <expr_stmt><expr><call><name>setcframe_pc</name><argument_list>(<argument><expr><call><name>cframe_raw</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>cframe</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pc</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Make sure the stack is big enough for the slots from the snapshot. */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>LJ_UNLIKELY</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>+</operator> <name><name>snap</name><operator>-&gt;</operator><name>topslot</name></name> <operator>&gt;=</operator> <call><name>tvref</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>maxstack</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <call><name>curr_topL</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lj_state_growstack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>snap</name><operator>-&gt;</operator><name>topslot</name></name> <operator>-</operator> <call><name>curr_proto</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>framesize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Fill stack slots with data from the registers and spill slots. */</comment>
  <expr_stmt><expr><name>frame</name> <operator>=</operator> <name><name>L</name><operator>-&gt;</operator><name>base</name></name><operator>-</operator><literal type="number">1</literal><operator>-</operator><name>LJ_FR2</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>LJ_FR2</name></expr></cpp:if>
  <expr_stmt><expr><name>ftsz0</name> <operator>=</operator> <call><name>frame_ftsz</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Preserve link to previous frame in slot #0. */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name>nent</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>SnapEntry</name></type> <name>sn</name> <init>= <expr><name><name>map</name><index>[<expr><name>n</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>sn</name> <operator>&amp;</operator> <name>SNAP_NORESTORE</name><operator>)</operator></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><operator>&amp;</operator><name><name>frame</name><index>[<expr><call><name>snap_slot</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>IRRef</name></type> <name>ref</name> <init>= <expr><call><name>snap_ref</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>IRIns</name> <modifier>*</modifier></type><name>ir</name> <init>= <expr><operator>&amp;</operator><name><name>T</name><operator>-&gt;</operator><name>ir</name><index>[<expr><name>ref</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>ir</name><operator>-&gt;</operator><name>r</name></name> <operator>==</operator> <name>RID_SUNK</name></expr>)</condition> <block>{<block_content>
	<decl_stmt><decl><type><name>MSize</name></type> <name>j</name></decl>;</decl_stmt>
	<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
	  <if_stmt><if>if <condition>(<expr><call><name>snap_ref</name><argument_list>(<argument><expr><name><name>map</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>ref</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* De-duplicate sunk allocations. */</comment>
	    <expr_stmt><expr><call><name>copyTV</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>frame</name><index>[<expr><call><name>snap_slot</name><argument_list>(<argument><expr><name><name>map</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <goto>goto <name>dupslot</name>;</goto>
	  </block_content>}</block></if></if_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>snap_unsink</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>ex</name></expr></argument>, <argument><expr><name>snapno</name></expr></argument>, <argument><expr><name>rfilt</name></expr></argument>, <argument><expr><name>ir</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <label><name>dupslot</name>:</label>
	<continue>continue;</continue>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>snap_restoreval</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>ex</name></expr></argument>, <argument><expr><name>snapno</name></expr></argument>, <argument><expr><name>rfilt</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>LJ_SOFTFP32</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>sn</name> <operator>&amp;</operator> <name>SNAP_SOFTFPNUM</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>tvisint</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<decl_stmt><decl><type><name>TValue</name></type> <name>tmp</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>snap_restoreval</name><argument_list>(<argument><expr><name>J</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>ex</name></expr></argument>, <argument><expr><name>snapno</name></expr></argument>, <argument><expr><name>rfilt</name></expr></argument>, <argument><expr><name>ref</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>u32</name><operator>.</operator><name>hi</name></name> <operator>=</operator> <name><name>tmp</name><operator>.</operator><name>u32</name><operator>.</operator><name>lo</name></name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>LJ_FR2</name></expr></cpp:if>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>sn</name> <operator>&amp;</operator> <operator>(</operator><name>SNAP_CONT</name><operator>|</operator><name>SNAP_FRAME</name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
	<comment type="block">/* Overwrite tag with frame link. */</comment>
	<expr_stmt><expr><call><name>setframe_ftsz</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><ternary><condition><expr><call><name>snap_slot</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><operator>(</operator><name>int32_t</name><operator>)</operator><operator>*</operator><name>flinks</name><operator>--</operator></expr> </then><else>: <expr><name>ftsz0</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <name>o</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LJ_FR2</name></expr></cpp:if>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>base</name></name> <operator>+=</operator> <operator>(</operator><name><name>map</name><index>[<expr><name>nent</name><operator>+</operator><name>LJ_BE</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>map</name> <operator>+</operator> <name>nent</name> <operator>==</operator> <name>flinks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Compute current stack top. */</comment>
  <switch>switch <condition>(<expr><call><name>bc_op</name><argument_list>(<argument><expr><operator>*</operator><name>pc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
  <default>default:</default>
    <if_stmt><if>if <condition>(<expr><call><name>bc_op</name><argument_list>(<argument><expr><operator>*</operator><name>pc</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>BC_FUNCF</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <call><name>curr_topL</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* fallthrough */</comment>
  <case>case <expr><name>BC_CALLM</name></expr>:</case> <case>case <expr><name>BC_CALLMT</name></expr>:</case> <case>case <expr><name>BC_RETM</name></expr>:</case> <case>case <expr><name>BC_TSETM</name></expr>:</case>
    <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name>frame</name> <operator>+</operator> <name><name>snap</name><operator>-&gt;</operator><name>nslots</name></name></expr>;</expr_stmt>
    <break>break;</break>
  </block_content>}</block></switch>
  <return>return <expr><name>pc</name></expr>;</return>
</block_content>}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>emitir_raw</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>emitir</name></cpp:undef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
