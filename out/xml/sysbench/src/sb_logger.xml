<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/sysbench/src/sb_logger.c"><comment type="block">/* Copyright (C) 2004 MySQL AB
   Copyright (C) 2004-2018 Alexey Kopytov &lt;akopytov@gmail.com&gt;

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
*/</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_CONFIG_H</name></cpp:ifdef>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>STDC_HEADERS</name></cpp:ifdef>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_ERRNO_H</name></cpp:ifdef>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_MATH_H</name></cpp:ifdef>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sysbench.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sb_list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sb_logger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sb_histogram.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ck_cc.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TEXT_BUFFER_SIZE</name></cpp:macro> <cpp:value>4096</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ERROR_BUFFER_SIZE</name></cpp:macro> <cpp:value>256</cpp:value></cpp:define>

<comment type="block">/*
   Use 1024-element array for latency histogram tracking values between 0.001
   milliseconds and 100 seconds.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPER_LOG_GRANULARITY</name></cpp:macro> <cpp:value>1024</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPER_LOG_MIN_VALUE</name></cpp:macro>   <cpp:value>1e-3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPER_LOG_MAX_VALUE</name></cpp:macro>   <cpp:value>1E5</cpp:value></cpp:define>

<comment type="block">/* Array of message handlers (one chain per message type) */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>sb_list_t</name></type> <name><name>handlers</name><index>[<expr><name>LOG_MSG_TYPE_MAX</name></expr>]</index></name></decl>;</decl_stmt>

<comment type="block">/* set after logger initialization */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>char</name></type> <name>initialized</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><specifier>static</specifier> <name>pthread_mutex_t</name></type> <name>text_mutex</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type>    <name>text_cnt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type>            <name><name>text_buf</name><index>[<expr><name>TEXT_BUFFER_SIZE</name></expr>]</index></name></decl>;</decl_stmt>


<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>text_handler_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>text_handler_process</name><parameter_list>(<parameter><decl><type><name>log_msg_t</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>oper_handler_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>oper_handler_done</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Built-in log handlers */</comment>

<comment type="block">/* Text messages handler */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>sb_arg_t</name></type> <name><name>text_handler_args</name><index>[]</index></name> <init>=
<expr><block>{
  <expr><call><name>SB_OPT</name><argument_list>(<argument><expr><literal type="string">"verbosity"</literal></expr></argument>, <argument><expr><literal type="string">"verbosity level {5 - debug, 0 - only critical messages}"</literal></expr></argument>,
         <argument><expr><literal type="string">"3"</literal></expr></argument>, <argument><expr><name>INT</name></expr></argument>)</argument_list></call></expr>,

  <expr><name>SB_OPT_END</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>log_handler_t</name></type> <name>text_handler</name> <init>= <expr><block>{
  <expr><block>{
    <expr><operator>&amp;</operator><name>text_handler_init</name></expr>,
    <expr><operator>&amp;</operator><name>text_handler_process</name></expr>,
    <expr><name>NULL</name></expr>,
  }</block></expr>,
  <expr><name>text_handler_args</name></expr>,
  <expr><block>{<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Operation start/stop messages handler */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>sb_arg_t</name></type> <name><name>oper_handler_args</name><index>[]</index></name> <init>=
<expr><block>{
  <expr><call><name>SB_OPT</name><argument_list>(<argument><expr><literal type="string">"percentile"</literal></expr></argument>, <argument><expr><literal type="string">"percentile to calculate in latency statistics (1-100). "</literal>
         <literal type="string">"Use the special value of 0 to disable percentile calculations"</literal></expr></argument>,
         <argument><expr><literal type="string">"95"</literal></expr></argument>, <argument><expr><name>INT</name></expr></argument>)</argument_list></call></expr>,
  <expr><call><name>SB_OPT</name><argument_list>(<argument><expr><literal type="string">"histogram"</literal></expr></argument>, <argument><expr><literal type="string">"print latency histogram in report"</literal></expr></argument>, <argument><expr><literal type="string">"off"</literal></expr></argument>, <argument><expr><name>BOOL</name></expr></argument>)</argument_list></call></expr>,

  <expr><name>SB_OPT_END</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>log_handler_t</name></type> <name>oper_handler</name> <init>= <expr><block>{
  <expr><block>{
    <expr><name>oper_handler_init</name></expr>,
    <expr><name>NULL</name></expr>,
    <expr><name>oper_handler_done</name></expr>,
  }</block></expr>,
  <expr><name>oper_handler_args</name></expr>,
  <expr><block>{<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>


<comment type="block">/* Register logger and all handlers */</comment>


<function><type><name>int</name></type> <name>log_register</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>LOG_MSG_TYPE_MAX</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>SB_LIST_INIT</name><argument_list>(<argument><expr><name>handlers</name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

  <expr_stmt><expr><call><name>log_add_handler</name><argument_list>(<argument><expr><name>LOG_MSG_TYPE_TEXT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>text_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>log_add_handler</name><argument_list>(<argument><expr><name>LOG_MSG_TYPE_OPER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oper_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Display command line options for registered log handlers */</comment>


<function><type><name>void</name></type> <name>log_print_help</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type>    <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sb_list_item_t</name>  <modifier>*</modifier></type><name>pos</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>log_handler_t</name>   <modifier>*</modifier></type><name>handler</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Log options:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>LOG_MSG_TYPE_MAX</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
  <block>{<block_content>
    <macro><name>SB_LIST_FOR_EACH</name><argument_list>(<argument>pos</argument>, <argument>handlers + i</argument>)</argument_list></macro>
    <block>{<block_content>
      <expr_stmt><expr><name>handler</name> <operator>=</operator> <call><name>SB_LIST_ENTRY</name><argument_list>(<argument><expr><name>pos</name></expr></argument>, <argument><expr><name>log_handler_t</name></expr></argument>, <argument><expr><name>listitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>handler</name><operator>-&gt;</operator><name>args</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>sb_print_options</name><argument_list>(<argument><expr><name><name>handler</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block>
  </block_content>}</block></for>
</block_content>}</block></function>


<comment type="block">/* Initialize logger and all handlers */</comment>


<function><type><name>int</name></type> <name>log_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type>    <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sb_list_item_t</name>  <modifier>*</modifier></type><name>pos</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>log_handler_t</name>   <modifier>*</modifier></type><name>handler</name></decl>;</decl_stmt>

  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>LOG_MSG_TYPE_MAX</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
  <block>{<block_content>
    <macro><name>SB_LIST_FOR_EACH</name><argument_list>(<argument>pos</argument>, <argument>handlers + i</argument>)</argument_list></macro>
    <block>{<block_content>
      <expr_stmt><expr><name>handler</name> <operator>=</operator> <call><name>SB_LIST_ENTRY</name><argument_list>(<argument><expr><name>pos</name></expr></argument>, <argument><expr><name>log_handler_t</name></expr></argument>, <argument><expr><name>listitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>handler</name><operator>-&gt;</operator><name>ops</name><operator>.</operator><name>init</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name><name>handler</name><operator>-&gt;</operator><name>ops</name><operator>.</operator><name>init</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block>
  </block_content>}</block></for>

  <comment type="block">/* required to let log_text() pass messages to handlers */</comment>
  <expr_stmt><expr><name>initialized</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> 
  
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Uninitialize logger and all handlers */</comment>


<function><type><name>void</name></type> <name>log_done</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type>    <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sb_list_item_t</name>  <modifier>*</modifier></type><name>pos</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>log_handler_t</name>   <modifier>*</modifier></type><name>handler</name></decl>;</decl_stmt>

  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>LOG_MSG_TYPE_MAX</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
  <block>{<block_content>
    <macro><name>SB_LIST_FOR_EACH</name><argument_list>(<argument>pos</argument>, <argument>handlers + i</argument>)</argument_list></macro>
    <block>{<block_content>
      <expr_stmt><expr><name>handler</name> <operator>=</operator> <call><name>SB_LIST_ENTRY</name><argument_list>(<argument><expr><name>pos</name></expr></argument>, <argument><expr><name>log_handler_t</name></expr></argument>, <argument><expr><name>listitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>handler</name><operator>-&gt;</operator><name>ops</name><operator>.</operator><name>done</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name><name>handler</name><operator>-&gt;</operator><name>ops</name><operator>.</operator><name>done</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block>
  </block_content>}</block></for>

  <expr_stmt><expr><name>initialized</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>  


<comment type="block">/* Add handler for a specified type of messages */</comment>


<function><type><name>int</name></type> <name>log_add_handler</name><parameter_list>(<parameter><decl><type><name>log_msg_type_t</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>log_handler_t</name> <modifier>*</modifier></type><name>handler</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>type</name> <operator>&lt;=</operator> <name>LOG_MSG_TYPE_MIN</name> <operator>||</operator> <name>type</name> <operator>&gt;=</operator> <name>LOG_MSG_TYPE_MAX</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>handler</name><operator>-&gt;</operator><name>args</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>sb_register_arg_set</name><argument_list>(<argument><expr><name><name>handler</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  
  <expr_stmt><expr><call><name>SB_LIST_ADD_TAIL</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>handler</name><operator>-&gt;</operator><name>listitem</name></name></expr></argument>, <argument><expr><name>handlers</name> <operator>+</operator> <name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Main function to dispatch log messages */</comment>


<function><type><name>void</name></type> <name>log_msg</name><parameter_list>(<parameter><decl><type><name>log_msg_t</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>sb_list_item_t</name>  <modifier>*</modifier></type><name>pos</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>log_handler_t</name>   <modifier>*</modifier></type><name>handler</name></decl>;</decl_stmt>
  
  <macro><name>SB_LIST_FOR_EACH</name><argument_list>(<argument>pos</argument>, <argument>handlers + msg-&gt;type</argument>)</argument_list></macro>
  <block>{<block_content>
    <expr_stmt><expr><name>handler</name> <operator>=</operator> <call><name>SB_LIST_ENTRY</name><argument_list>(<argument><expr><name>pos</name></expr></argument>, <argument><expr><name>log_handler_t</name></expr></argument>, <argument><expr><name>listitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>handler</name><operator>-&gt;</operator><name>ops</name><operator>.</operator><name>process</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name><name>handler</name><operator>-&gt;</operator><name>ops</name><operator>.</operator><name>process</name></name><argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>get_msg_prefix</name><parameter_list>(<parameter><decl><type><name>log_msg_priority_t</name></type> <name>priority</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>prefix</name></decl>;</decl_stmt>

  <switch>switch <condition>(<expr><name>priority</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>LOG_FATAL</name></expr>:</case>
      <expr_stmt><expr><name>prefix</name> <operator>=</operator> <literal type="string">"FATAL: "</literal></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>LOG_ALERT</name></expr>:</case>
      <expr_stmt><expr><name>prefix</name> <operator>=</operator> <literal type="string">"ALERT: "</literal></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>LOG_WARNING</name></expr>:</case>
      <expr_stmt><expr><name>prefix</name> <operator>=</operator> <literal type="string">"WARNING: "</literal></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>LOG_DEBUG</name></expr>:</case>
      <expr_stmt><expr><name>prefix</name> <operator>=</operator> <literal type="string">"DEBUG: "</literal></expr>;</expr_stmt>
      <break>break;</break>
    <default>default:</default>
      <expr_stmt><expr><name>prefix</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
      <break>break;</break>
  </block_content>}</block></switch>

  <return>return <expr><name>prefix</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* printf-like wrapper to log text messages */</comment>


<function><type><name>void</name></type> <name>log_text</name><parameter_list>(<parameter><decl><type><name>log_msg_priority_t</name></type> <name>priority</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>log_msg_t</name></type>      <name>msg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>log_msg_text_t</name></type> <name>text_msg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type>           <name><name>buf</name><index>[<expr><name>TEXT_BUFFER_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>va_list</name></type>        <name>ap</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type>            <name>n</name></decl>, <decl><type ref="prev"/><name>clen</name></decl>, <decl><type ref="prev"/><name>maxlen</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>maxlen</name> <operator>=</operator> <name>TEXT_BUFFER_SIZE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>clen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>vsnprintf</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>clen</name></expr></argument>, <argument><expr><name>maxlen</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>n</name> <operator>&gt;=</operator> <name>maxlen</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <name>maxlen</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>clen</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>maxlen</name> <operator>-=</operator> <name>n</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>clen</name></expr></argument>, <argument><expr><name>maxlen</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/*
    No race condition here because log_init() is supposed to be called
    in a single-threaded stage
  */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>initialized</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><call><name>get_msg_prefix</name><argument_list>(<argument><expr><name>priority</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>LOG_MSG_TYPE_TEXT</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>data</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>text_msg</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>text_msg</name><operator>.</operator><name>priority</name></name> <operator>=</operator> <name>priority</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>text_msg</name><operator>.</operator><name>text</name></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>text_msg</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>log_msg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
  variant of log_text() which prepends log lines with the elapsed time of a
  specified timer.
*/</comment>


<function><type><name>void</name></type> <name>log_timestamp</name><parameter_list>(<parameter><decl><type><name>log_msg_priority_t</name></type> <name>priority</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>seconds</name></decl></parameter>,
                   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>log_msg_t</name></type>      <name>msg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>log_msg_text_t</name></type> <name>text_msg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type>           <name><name>buf</name><index>[<expr><name>TEXT_BUFFER_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>va_list</name></type>        <name>ap</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type>            <name>n</name></decl>, <decl><type ref="prev"/><name>clen</name></decl>, <decl><type ref="prev"/><name>maxlen</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>maxlen</name> <operator>=</operator> <name>TEXT_BUFFER_SIZE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>clen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>maxlen</name></expr></argument>, <argument><expr><literal type="string">"[ %.0fs ] "</literal></expr></argument>, <argument><expr><name>seconds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>clen</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>maxlen</name> <operator>-=</operator> <name>n</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>vsnprintf</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>clen</name></expr></argument>, <argument><expr><name>maxlen</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>n</name> <operator>&gt;=</operator> <name>maxlen</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <name>maxlen</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>clen</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>maxlen</name> <operator>-=</operator> <name>n</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>clen</name></expr></argument>, <argument><expr><name>maxlen</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/*
    No race condition here because log_init() is supposed to be called
    in a single-threaded stage
  */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>initialized</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><call><name>get_msg_prefix</name><argument_list>(<argument><expr><name>priority</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>LOG_MSG_TYPE_TEXT</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>data</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>text_msg</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>text_msg</name><operator>.</operator><name>priority</name></name> <operator>=</operator> <name>priority</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>text_msg</name><operator>.</operator><name>text</name></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
  <comment type="block">/* Skip duplicate checks */</comment>
  <expr_stmt><expr><name><name>text_msg</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <name>LOG_MSG_TEXT_ALLOW_DUPLICATES</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>log_msg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* printf-like wrapper to log system error messages */</comment>


<function><type><name>void</name></type> <name>log_errno</name><parameter_list>(<parameter><decl><type><name>log_msg_priority_t</name></type> <name>priority</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>char</name></type>           <name><name>buf</name><index>[<expr><name>TEXT_BUFFER_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type>           <name><name>errbuf</name><index>[<expr><name>ERROR_BUFFER_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>va_list</name></type>        <name>ap</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type>            <name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type>            <name>old_errno</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name>           <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>old_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_STRERROR_R</name></cpp:ifdef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>STRERROR_R_CHAR_P</name></cpp:ifdef>
  <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>strerror_r</name><argument_list>(<argument><expr><name>old_errno</name></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>strerror_r</name><argument_list>(<argument><expr><name>old_errno</name></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>tmp</name> <operator>=</operator> <name>errbuf</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* STRERROR_R_CHAR_P */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* !HAVE_STRERROR_P */</comment>
  <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>old_errno</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>tmp</name> <operator>=</operator> <name>errbuf</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_STRERROR_P */</comment>

  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>vsnprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>TEXT_BUFFER_SIZE</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>n</name> <operator>==</operator> <name>TEXT_BUFFER_SIZE</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>n</name></expr></argument>, <argument><expr><name>TEXT_BUFFER_SIZE</name> <operator>-</operator> <name>n</name></expr></argument>, <argument><expr><literal type="string">" errno = %d (%s)"</literal></expr></argument>, <argument><expr><name>old_errno</name></expr></argument>,
           <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>priority</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<comment type="block">/* Initialize text handler */</comment>


<function><type><name>int</name></type> <name>text_handler_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SETVBUF</name></cpp:ifdef>
  <comment type="block">/* Set stdout to unbuffered mode */</comment>
  <expr_stmt><expr><call><name>setvbuf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>_IONBF</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  
  <expr_stmt><expr><name><name>sb_globals</name><operator>.</operator><name>verbosity</name></name> <operator>=</operator> <call><name>sb_get_value_int</name><argument_list>(<argument><expr><literal type="string">"verbosity"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>sb_globals</name><operator>.</operator><name>verbosity</name></name> <operator>&gt;</operator> <name>LOG_DEBUG</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Invalid value for verbosity: %d\n"</literal></expr></argument>, <argument><expr><name><name>sb_globals</name><operator>.</operator><name>verbosity</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>pthread_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>text_mutex</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>text_cnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>text_buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
  
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Print text message to the log */</comment>


<function><type><name>int</name></type> <name>text_handler_process</name><parameter_list>(<parameter><decl><type><name>log_msg_t</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>log_msg_text_t</name> <modifier>*</modifier></type><name>text_msg</name> <init>= <expr><operator>(</operator><name>log_msg_text_t</name> <operator>*</operator><operator>)</operator><name><name>msg</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>text_msg</name><operator>-&gt;</operator><name>priority</name></name> <operator>&gt;</operator> <name><name>sb_globals</name><operator>.</operator><name>verbosity</name></name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>text_msg</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>LOG_MSG_TEXT_ALLOW_DUPLICATES</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>text_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>text_buf</name></expr></argument>, <argument><expr><name><name>text_msg</name><operator>-&gt;</operator><name>text</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name>text_cnt</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>text_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>text_cnt</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"(last message repeated %u times)\n"</literal></expr></argument>, <argument><expr><name>text_cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

      <expr_stmt><expr><name>text_cnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>text_buf</name></expr></argument>, <argument><expr><name><name>text_msg</name><operator>-&gt;</operator><name>text</name></name></expr></argument>, <argument><expr><name>TEXT_BUFFER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>text_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><call><name>get_msg_prefix</name><argument_list>(<argument><expr><name><name>text_msg</name><operator>-&gt;</operator><name>priority</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>text_msg</name><operator>-&gt;</operator><name>text</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Initialize operation messages handler */</comment>


<function><type><name>int</name></type> <name>oper_handler_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type>          <name>tmp</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>sb_get_value_int</name><argument_list>(<argument><expr><literal type="string">"percentile"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>tmp</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>tmp</name></expr></argument> &gt;</argument_list></name> <literal type="number">100</literal></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_FATAL</name></expr></argument>, <argument><expr><literal type="string">"Invalid value for --percentile: %d"</literal></expr></argument>,
             <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>sb_globals</name><operator>.</operator><name>percentile</name></name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>sb_globals</name><operator>.</operator><name>histogram</name></name> <operator>=</operator> <call><name>sb_get_value_flag</name><argument_list>(<argument><expr><literal type="string">"histogram"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>sb_globals</name><operator>.</operator><name>percentile</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>sb_globals</name><operator>.</operator><name>histogram</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_FATAL</name></expr></argument>, <argument><expr><literal type="string">"--histogram cannot be used with --percentile=0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>sb_histogram_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb_latency_histogram</name></expr></argument>, <argument><expr><name>OPER_LOG_GRANULARITY</name></expr></argument>,
                        <argument><expr><name>OPER_LOG_MIN_VALUE</name></expr></argument>, <argument><expr><name>OPER_LOG_MAX_VALUE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Uninitialize operations messages handler */</comment>

<function><type><name>int</name></type> <name>oper_handler_done</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>sb_histogram_done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb_latency_histogram</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
</unit>
