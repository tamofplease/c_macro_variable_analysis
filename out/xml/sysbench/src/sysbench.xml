<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/sysbench/src/sysbench.c"><comment type="block">/* Copyright (C) 2004 MySQL AB
   Copyright (C) 2004-2018 Alexey Kopytov &lt;akopytov@gmail.com&gt;

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
*/</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_CONFIG_H</name></cpp:ifdef>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>STDC_HEADERS</name></cpp:ifdef>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_STRING_H</name></cpp:ifdef>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_STRINGS_H</name></cpp:ifdef>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;strings.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_UNISTD_H</name></cpp:ifdef> 
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_STAT_H</name></cpp:ifdef>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_ERRNO_H</name></cpp:ifdef>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_FCNTL_H</name></cpp:ifdef>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_PTHREAD_H</name></cpp:ifdef>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;pthread.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_THREAD_H</name></cpp:ifdef>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;thread.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_MATH_H</name></cpp:ifdef>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SCHED_H</name></cpp:ifdef>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;sched.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SIGNAL_H</name></cpp:ifdef>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LIMITS_H</name></cpp:ifdef>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;luajit.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sysbench.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sb_options.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sb_lua.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"db_driver.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sb_rand.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sb_thread.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sb_barrier.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ck_cc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ck_ring.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VERSION_STRING</name></cpp:macro> <cpp:value>PACKAGE" "PACKAGE_VERSION SB_GIT_SHA</cpp:value></cpp:define>

<comment type="block">/* Maximum queue length for the tx-rate mode. Must be a power of 2 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_QUEUE_LEN</name></cpp:macro> <cpp:value>131072</cpp:value></cpp:define>

<comment type="block">/*
  Extra thread ID assigned to background threads. This may be used as an index
  into per-thread arrays (see comment in sb_alloc_per_thread_array().
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SB_BACKGROUND_THREAD_ID</name></cpp:macro> <cpp:value>sb_globals.threads</cpp:value></cpp:define>

<comment type="block">/* General options */</comment>
<decl_stmt><decl><type><name>sb_arg_t</name></type> <name><name>general_args</name><index>[]</index></name> <init>=
<expr><block>{
  <expr><call><name>SB_OPT</name><argument_list>(<argument><expr><literal type="string">"threads"</literal></expr></argument>, <argument><expr><literal type="string">"number of threads to use"</literal></expr></argument>, <argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>INT</name></expr></argument>)</argument_list></call></expr>,
  <expr><call><name>SB_OPT</name><argument_list>(<argument><expr><literal type="string">"events"</literal></expr></argument>, <argument><expr><literal type="string">"limit for total number of events"</literal></expr></argument>, <argument><expr><literal type="string">"0"</literal></expr></argument>, <argument><expr><name>INT</name></expr></argument>)</argument_list></call></expr>,
  <expr><call><name>SB_OPT</name><argument_list>(<argument><expr><literal type="string">"time"</literal></expr></argument>, <argument><expr><literal type="string">"limit for total execution time in seconds"</literal></expr></argument>, <argument><expr><literal type="string">"10"</literal></expr></argument>, <argument><expr><name>INT</name></expr></argument>)</argument_list></call></expr>,
  <expr><call><name>SB_OPT</name><argument_list>(<argument><expr><literal type="string">"warmup-time"</literal></expr></argument>, <argument><expr><literal type="string">"execute events for this many seconds with statistics "</literal>
         <literal type="string">"disabled before the actual benchmark run with statistics enabled"</literal></expr></argument>,
         <argument><expr><literal type="string">"0"</literal></expr></argument>, <argument><expr><name>INT</name></expr></argument>)</argument_list></call></expr>,
  <expr><call><name>SB_OPT</name><argument_list>(<argument><expr><literal type="string">"forced-shutdown"</literal></expr></argument>,
         <argument><expr><literal type="string">"number of seconds to wait after the --time limit before forcing "</literal>
         <literal type="string">"shutdown, or 'off' to disable"</literal></expr></argument>, <argument><expr><literal type="string">"off"</literal></expr></argument>, <argument><expr><name>STRING</name></expr></argument>)</argument_list></call></expr>,
  <expr><call><name>SB_OPT</name><argument_list>(<argument><expr><literal type="string">"thread-stack-size"</literal></expr></argument>, <argument><expr><literal type="string">"size of stack per thread"</literal></expr></argument>, <argument><expr><literal type="string">"64K"</literal></expr></argument>, <argument><expr><name>SIZE</name></expr></argument>)</argument_list></call></expr>,
  <expr><call><name>SB_OPT</name><argument_list>(<argument><expr><literal type="string">"thread-init-timeout"</literal></expr></argument>, <argument><expr><literal type="string">"wait time in seconds for worker threads to initialize"</literal></expr></argument>, <argument><expr><literal type="string">"30"</literal></expr></argument>, <argument><expr><name>INT</name></expr></argument>)</argument_list></call></expr>,
  <expr><call><name>SB_OPT</name><argument_list>(<argument><expr><literal type="string">"rate"</literal></expr></argument>, <argument><expr><literal type="string">"average transactions rate. 0 for unlimited rate"</literal></expr></argument>, <argument><expr><literal type="string">"0"</literal></expr></argument>, <argument><expr><name>INT</name></expr></argument>)</argument_list></call></expr>,
  <expr><call><name>SB_OPT</name><argument_list>(<argument><expr><literal type="string">"report-interval"</literal></expr></argument>, <argument><expr><literal type="string">"periodically report intermediate statistics with "</literal>
         <literal type="string">"a specified interval in seconds. 0 disables intermediate reports"</literal></expr></argument>,
         <argument><expr><literal type="string">"0"</literal></expr></argument>, <argument><expr><name>INT</name></expr></argument>)</argument_list></call></expr>,
  <expr><call><name>SB_OPT</name><argument_list>(<argument><expr><literal type="string">"report-checkpoints"</literal></expr></argument>, <argument><expr><literal type="string">"dump full statistics and reset all counters at "</literal>
         <literal type="string">"specified points in time. The argument is a list of comma-separated "</literal>
         <literal type="string">"values representing the amount of time in seconds elapsed from start "</literal>
         <literal type="string">"of test when report checkpoint(s) must be performed. Report "</literal>
         <literal type="string">"checkpoints are off by default."</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>LIST</name></expr></argument>)</argument_list></call></expr>,
  <expr><call><name>SB_OPT</name><argument_list>(<argument><expr><literal type="string">"debug"</literal></expr></argument>, <argument><expr><literal type="string">"print more debugging info"</literal></expr></argument>, <argument><expr><literal type="string">"off"</literal></expr></argument>, <argument><expr><name>BOOL</name></expr></argument>)</argument_list></call></expr>,
  <expr><call><name>SB_OPT</name><argument_list>(<argument><expr><literal type="string">"validate"</literal></expr></argument>, <argument><expr><literal type="string">"perform validation checks where possible"</literal></expr></argument>, <argument><expr><literal type="string">"off"</literal></expr></argument>, <argument><expr><name>BOOL</name></expr></argument>)</argument_list></call></expr>,
  <expr><call><name>SB_OPT</name><argument_list>(<argument><expr><literal type="string">"help"</literal></expr></argument>, <argument><expr><literal type="string">"print help and exit"</literal></expr></argument>, <argument><expr><literal type="string">"off"</literal></expr></argument>, <argument><expr><name>BOOL</name></expr></argument>)</argument_list></call></expr>,
  <expr><call><name>SB_OPT</name><argument_list>(<argument><expr><literal type="string">"version"</literal></expr></argument>, <argument><expr><literal type="string">"print version and exit"</literal></expr></argument>, <argument><expr><literal type="string">"off"</literal></expr></argument>, <argument><expr><name>BOOL</name></expr></argument>)</argument_list></call></expr>,
  <expr><call><name>SB_OPT</name><argument_list>(<argument><expr><literal type="string">"config-file"</literal></expr></argument>, <argument><expr><literal type="string">"File containing command line options"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>FILE</name></expr></argument>)</argument_list></call></expr>,
  <expr><call><name>SB_OPT</name><argument_list>(<argument><expr><literal type="string">"luajit-cmd"</literal></expr></argument>, <argument><expr><literal type="string">"perform LuaJIT control command. This option is "</literal>
         <literal type="string">"equivalent to 'luajit -j'. See LuaJIT documentation for more "</literal>
         <literal type="string">"information"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>STRING</name></expr></argument>)</argument_list></call></expr>,

  <expr><name>SB_OPT_END</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* List of available tests */</comment>
<decl_stmt><decl><type><name>sb_list_t</name></type>        <name>tests</name></decl>;</decl_stmt>

<comment type="block">/* Global variables */</comment>
<decl_stmt><decl><type><name>sb_globals_t</name></type>     <name>sb_globals</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sb_test_t</name>        <modifier>*</modifier></type><name>current_test</name></decl>;</decl_stmt>

<comment type="block">/* Barrier to ensure we start the benchmark run when all workers are ready */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>sb_barrier_t</name></type> <name>worker_barrier</name></decl>;</decl_stmt>

<comment type="block">/* Wait at most this number of seconds for worker threads to initialize */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>thread_init_timeout</name></decl>;</decl_stmt>

<comment type="block">/* Barrier to signal reporting threads */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>sb_barrier_t</name></type> <name>report_barrier</name></decl>;</decl_stmt>

<comment type="block">/* structures to handle queue of events, needed for tx_rate mode */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>pthread_mutex_t</name></type>    <name>queue_mutex</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>pthread_cond_t</name></type>     <name>queue_cond</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint64_t</name>           <name><name>queue_array</name><index>[<expr><name>MAX_QUEUE_LEN</name></expr>]</index></name></type> <name>CK_CC_CACHELINE</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ck_ring_buffer_t</name>   <name><name>queue_ring_buffer</name><index>[<expr><name>MAX_QUEUE_LEN</name></expr>]</index></name></type> <name>CK_CC_CACHELINE</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ck_ring_t</name>          <name>queue_ring</name></type> <name>CK_CC_CACHELINE</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name> <name>report_thread_created</name></type> <name>CK_CC_CACHELINE</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>checkpoints_thread_created</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>eventgen_thread_created</name></decl>;</decl_stmt>

<comment type="block">/* per-thread timers for response time stats */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>sb_timer_t</name> <modifier>*</modifier></type><name>timers</name></decl>;</decl_stmt>

<comment type="block">/* Temporary copy of timers for checkpoint reports */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>sb_timer_t</name> <modifier>*</modifier></type><name>timers_copy</name></decl>;</decl_stmt>

<comment type="block">/* Global execution timer */</comment>
<decl_stmt><decl><type><name>sb_timer_t</name>      <name>sb_exec_timer</name></type> <name>CK_CC_CACHELINE</name></decl>;</decl_stmt>

<comment type="block">/* timers for intermediate/checkpoint reports */</comment>
<decl_stmt><decl><type><name>sb_timer_t</name> <name>sb_intermediate_timer</name></type> <name>CK_CC_CACHELINE</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sb_timer_t</name> <name>sb_checkpoint_timer</name></type>   <name>CK_CC_CACHELINE</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>TLS</name> <name>int</name></type> <name>sb_tls_thread_id</name></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>print_header</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>print_help</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>print_run_mode</name><parameter_list>(<parameter><decl><type><name>sb_test_t</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_ALARM</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sigalrm_thread_init_timeout_handler</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sig</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>sig</name> <operator>!=</operator> <name>SIGALRM</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_FATAL</name></expr></argument>,
           <argument><expr><literal type="string">"Worker threads failed to initialize within %u seconds!"</literal></expr></argument>,
           <argument><expr><name>thread_init_timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Default intermediate reports handler */</comment>

<function><type><name>void</name></type> <name>sb_report_intermediate</name><parameter_list>(<parameter><decl><type><name>sb_stat_t</name> <modifier>*</modifier></type><name>stat</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>log_timestamp</name><argument_list>(<argument><expr><name>LOG_NOTICE</name></expr></argument>, <argument><expr><name><name>stat</name><operator>-&gt;</operator><name>time_total</name></name></expr></argument>,
                <argument><expr><literal type="string">"thds: %"</literal> <name>PRIu32</name> <literal type="string">" eps: %4.2f lat (ms,%u%%): %4.2f"</literal></expr></argument>,
                <argument><expr><name><name>stat</name><operator>-&gt;</operator><name>threads_running</name></name></expr></argument>,
                <argument><expr><name><name>stat</name><operator>-&gt;</operator><name>events</name></name> <operator>/</operator> <name><name>stat</name><operator>-&gt;</operator><name>time_interval</name></name></expr></argument>,
                <argument><expr><name><name>sb_globals</name><operator>.</operator><name>percentile</name></name></expr></argument>,
                <argument><expr><call><name>SEC2MS</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>latency_pct</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>sb_globals</name><operator>.</operator><name>tx_rate</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>log_timestamp</name><argument_list>(<argument><expr><name>LOG_NOTICE</name></expr></argument>, <argument><expr><name><name>stat</name><operator>-&gt;</operator><name>time_total</name></name></expr></argument>,
                  <argument><expr><literal type="string">"queue length: %"</literal> <name>PRIu64</name> <literal type="string">" concurrency: %"</literal> <name>PRIu64</name></expr></argument>,
                  <argument><expr><name><name>stat</name><operator>-&gt;</operator><name>queue_length</name></name></expr></argument>, <argument><expr><name><name>stat</name><operator>-&gt;</operator><name>concurrency</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>report_get_common_stat</name><parameter_list>(<parameter><decl><type><name>sb_stat_t</name> <modifier>*</modifier></type><name>stat</name></decl></parameter>, <parameter><decl><type><name>sb_counters_t</name></type> <name>cnt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>stat</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sb_stat_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>threads_running</name></name> <operator>=</operator> <name><name>sb_globals</name><operator>.</operator><name>threads_running</name></name></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>events</name></name> <operator>=</operator>        <name><name>cnt</name><index>[<expr><name>SB_CNT_EVENT</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>reads</name></name> <operator>=</operator>         <name><name>cnt</name><index>[<expr><name>SB_CNT_READ</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>writes</name></name> <operator>=</operator>        <name><name>cnt</name><index>[<expr><name>SB_CNT_WRITE</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>other</name></name> <operator>=</operator>         <name><name>cnt</name><index>[<expr><name>SB_CNT_OTHER</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>errors</name></name> <operator>=</operator>        <name><name>cnt</name><index>[<expr><name>SB_CNT_ERROR</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>reconnects</name></name> <operator>=</operator>    <name><name>cnt</name><index>[<expr><name>SB_CNT_RECONNECT</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>bytes_read</name></name> <operator>=</operator>    <name><name>cnt</name><index>[<expr><name>SB_CNT_BYTES_READ</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>bytes_written</name></name> <operator>=</operator> <name><name>cnt</name><index>[<expr><name>SB_CNT_BYTES_WRITTEN</name></expr>]</index></name></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>time_total</name></name> <operator>=</operator> <call><name>NS2SEC</name><argument_list>(<argument><expr><call><name>sb_timer_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb_exec_timer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>-</operator>
    <name><name>sb_globals</name><operator>.</operator><name>warmup_time</name></name></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>report_intermediate</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>sb_stat_t</name></type> <name>stat</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sb_counters_t</name></type> <name>cnt</name></decl>;</decl_stmt>

  <comment type="block">/*
    sb_globals.report_interval may be set to 0 by the master thread to
    silence intermediate reports at the end of the test
  */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>ck_pr_load_uint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sb_globals</name><operator>.</operator><name>report_interval</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>sb_counters_agg_intermediate</name><argument_list>(<argument><expr><name>cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>report_get_common_stat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>stat</name></expr></argument>, <argument><expr><name>cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>stat</name><operator>.</operator><name>latency_pct</name></name> <operator>=</operator>
    <call><name>MS2SEC</name><argument_list>(<argument><expr><call><name>sb_histogram_get_pct_intermediate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb_latency_histogram</name></expr></argument>,
                                             <argument><expr><name><name>sb_globals</name><operator>.</operator><name>percentile</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>stat</name><operator>.</operator><name>time_interval</name></name> <operator>=</operator> <call><name>NS2SEC</name><argument_list>(<argument><expr><call><name>sb_timer_current</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb_intermediate_timer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>sb_globals</name><operator>.</operator><name>tx_rate</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>stat</name><operator>.</operator><name>queue_length</name></name> <operator>=</operator> <call><name>ck_ring_size</name><argument_list>(<argument><expr><operator>&amp;</operator><name>queue_ring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stat</name><operator>.</operator><name>concurrency</name></name> <operator>=</operator> <call><name>ck_pr_load_int</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sb_globals</name><operator>.</operator><name>concurrency</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>current_test</name> <operator>&amp;&amp;</operator> <name><name>current_test</name><operator>-&gt;</operator><name>ops</name><operator>.</operator><name>report_intermediate</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name><name>current_test</name><operator>-&gt;</operator><name>ops</name><operator>.</operator><name>report_intermediate</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>stat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>sb_report_intermediate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>stat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Default cumulative reports handler */</comment>

<function><type><name>void</name></type> <name>sb_report_cumulative</name><parameter_list>(<parameter><decl><type><name>sb_stat_t</name> <modifier>*</modifier></type><name>stat</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>nthreads</name> <init>= <expr><name><name>sb_globals</name><operator>.</operator><name>threads</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>sb_globals</name><operator>.</operator><name>forced_shutdown_in_progress</name></name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/*
      In case we print statistics on forced shutdown, there may be (potentially
      long running or hung) transactions which are still in progress.

      We still want to reflect them in statistics, so stop running timers to
      consider long transactions as done at the forced shutdown time, and print
      a counter of still running transactions.
    */</comment>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>unfinished</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nthreads</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>sb_timer_running</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>timers_copy</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><name>unfinished</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sb_timer_stop</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>timers_copy</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt><empty_stmt>;</empty_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>unfinished</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_NOTICE</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_NOTICE</name></expr></argument>, <argument><expr><literal type="string">"Number of unfinished transactions on "</literal>
               <literal type="string">"forced shutdown: %u"</literal></expr></argument>, <argument><expr><name>unfinished</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_NOTICE</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_NOTICE</name></expr></argument>, <argument><expr><literal type="string">"Throughput:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_NOTICE</name></expr></argument>, <argument><expr><literal type="string">"    events/s (eps):                      %.4f"</literal></expr></argument>,
           <argument><expr><name><name>stat</name><operator>-&gt;</operator><name>events</name></name> <operator>/</operator> <name><name>stat</name><operator>-&gt;</operator><name>time_interval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_NOTICE</name></expr></argument>, <argument><expr><literal type="string">"    time elapsed:                        %.4fs"</literal></expr></argument>,
           <argument><expr><name><name>stat</name><operator>-&gt;</operator><name>time_total</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_NOTICE</name></expr></argument>, <argument><expr><literal type="string">"    total number of events:              %"</literal> <name>PRIu64</name></expr></argument>,
           <argument><expr><name><name>stat</name><operator>-&gt;</operator><name>events</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_NOTICE</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_NOTICE</name></expr></argument>, <argument><expr><literal type="string">"Latency (ms):"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_NOTICE</name></expr></argument>, <argument><expr><literal type="string">"         min: %39.2f"</literal></expr></argument>,
           <argument><expr><call><name>SEC2MS</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>latency_min</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_NOTICE</name></expr></argument>, <argument><expr><literal type="string">"         avg: %39.2f"</literal></expr></argument>,
           <argument><expr><call><name>SEC2MS</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>latency_avg</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_NOTICE</name></expr></argument>, <argument><expr><literal type="string">"         max: %39.2f"</literal></expr></argument>,
           <argument><expr><call><name>SEC2MS</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>latency_max</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>sb_globals</name><operator>.</operator><name>percentile</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_NOTICE</name></expr></argument>, <argument><expr><literal type="string">"        %3dth percentile: %27.2f"</literal></expr></argument>,
             <argument><expr><name><name>sb_globals</name><operator>.</operator><name>percentile</name></name></expr></argument>, <argument><expr><call><name>SEC2MS</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>latency_pct</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_NOTICE</name></expr></argument>, <argument><expr><literal type="string">"         percentile stats:               disabled"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

  <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_NOTICE</name></expr></argument>, <argument><expr><literal type="string">"         sum: %39.2f"</literal></expr></argument>,
           <argument><expr><call><name>SEC2MS</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>latency_sum</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_NOTICE</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Aggregate temporary timers copy */</comment>
  <decl_stmt><decl><type><name>sb_timer_t</name></type> <name>t</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sb_timer_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nthreads</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>sb_timer_merge</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>timers_copy</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

  <comment type="block">/* Calculate and print events distribution by threads */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>double</name></type> <name>events_avg</name> <init>= <expr><operator>(</operator><name>double</name><operator>)</operator> <name><name>t</name><operator>.</operator><name>events</name></name> <operator>/</operator> <name>nthreads</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>double</name></type> <name>time_avg</name> <init>= <expr><name><name>stat</name><operator>-&gt;</operator><name>latency_sum</name></name> <operator>/</operator> <name>nthreads</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>double</name></type> <name>events_stddev</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>double</name></type> <name>time_stddev</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <for>for<control>(<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nthreads</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
  <block>{<block_content>
    <decl_stmt><decl><type><name>double</name></type> <name>diff</name> <init>= <expr><call><name>fabs</name><argument_list>(<argument><expr><name>events_avg</name> <operator>-</operator> <name><name>timers_copy</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>events</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>events_stddev</name> <operator>+=</operator> <name>diff</name> <operator>*</operator> <name>diff</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>diff</name> <operator>=</operator> <call><name>fabs</name><argument_list>(<argument><expr><name>time_avg</name> <operator>-</operator> <call><name>NS2SEC</name><argument_list>(<argument><expr><call><name>sb_timer_sum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>timers_copy</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>time_stddev</name> <operator>+=</operator> <name>diff</name> <operator>*</operator> <name>diff</name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name>events_stddev</name> <operator>=</operator> <call><name>sqrt</name><argument_list>(<argument><expr><name>events_stddev</name> <operator>/</operator> <name>nthreads</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>time_stddev</name> <operator>=</operator> <call><name>sqrt</name><argument_list>(<argument><expr><name>time_stddev</name> <operator>/</operator> <name>nthreads</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_NOTICE</name></expr></argument>, <argument><expr><literal type="string">"Threads fairness:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_NOTICE</name></expr></argument>, <argument><expr><literal type="string">"    events (avg/stddev):           %.4f/%3.2f"</literal></expr></argument>,
           <argument><expr><name>events_avg</name></expr></argument>, <argument><expr><name>events_stddev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_NOTICE</name></expr></argument>, <argument><expr><literal type="string">"    execution time (avg/stddev):   %.4f/%3.2f"</literal></expr></argument>,
           <argument><expr><name>time_avg</name></expr></argument>, <argument><expr><name>time_stddev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_NOTICE</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>sb_globals</name><operator>.</operator><name>debug</name></name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"Verbose per-thread statistics:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nthreads</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
      <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"    thread #%3d: min: %.4fs  avg: %.4fs  max: %.4fs  "</literal>
               <literal type="string">"events: %"</literal> <name>PRIu64</name></expr></argument>,
               <argument><expr><name>i</name></expr></argument>,
               <argument><expr><call><name>NS2SEC</name><argument_list>(<argument><expr><call><name>sb_timer_min</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>timers_copy</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
               <argument><expr><call><name>NS2SEC</name><argument_list>(<argument><expr><call><name>sb_timer_avg</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>timers_copy</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
               <argument><expr><call><name>NS2SEC</name><argument_list>(<argument><expr><call><name>sb_timer_max</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>timers_copy</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
               <argument><expr><name><name>timers_copy</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>events</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"                 "</literal>
               <literal type="string">"total time taken by event execution: %.4fs"</literal></expr></argument>,
               <argument><expr><call><name>NS2SEC</name><argument_list>(<argument><expr><call><name>sb_timer_sum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>timers_copy</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_NOTICE</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Do a checkpoint, i.e. aggregate and reset collected statistics */</comment>

<function><type><specifier>static</specifier> <name>void</name></type> <name>checkpoint</name><parameter_list>(<parameter><decl><type><name>sb_stat_t</name> <modifier>*</modifier></type><name>stat</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>sb_counters_t</name></type> <name>cnt</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>sb_counters_agg_cumulative</name><argument_list>(<argument><expr><name>cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>report_get_common_stat</name><argument_list>(<argument><expr><name>stat</name></expr></argument>, <argument><expr><name>cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>time_interval</name></name> <operator>=</operator> <call><name>NS2SEC</name><argument_list>(<argument><expr><call><name>sb_timer_current</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb_checkpoint_timer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>latency_pct</name></name> <operator>=</operator>
    <call><name>MS2SEC</name><argument_list>(<argument><expr><call><name>sb_histogram_get_pct_checkpoint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb_latency_histogram</name></expr></argument>,
                                           <argument><expr><name><name>sb_globals</name><operator>.</operator><name>percentile</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Atomically reset each timer after copying it into its timers_copy slot */</comment>
  <for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sb_globals</name><operator>.</operator><name>threads</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>sb_timer_checkpoint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>timers</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>timers_copy</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>report_cumulative</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>sb_stat_t</name></type>  <name>stat</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sb_timer_t</name></type> <name>t</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>checkpoint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>stat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>sb_timer_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Aggregate temporary timers copy populated by checkpoint() */</comment>
  <for>for<control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sb_globals</name><operator>.</operator><name>threads</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>sb_timer_merge</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>timers_copy</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

  <comment type="block">/* Calculate aggregate latency values */</comment>
  <expr_stmt><expr><name><name>stat</name><operator>.</operator><name>latency_min</name></name> <operator>=</operator> <call><name>NS2SEC</name><argument_list>(<argument><expr><call><name>sb_timer_min</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>stat</name><operator>.</operator><name>latency_max</name></name> <operator>=</operator> <call><name>NS2SEC</name><argument_list>(<argument><expr><call><name>sb_timer_max</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>stat</name><operator>.</operator><name>latency_avg</name></name> <operator>=</operator> <call><name>NS2SEC</name><argument_list>(<argument><expr><call><name>sb_timer_avg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>stat</name><operator>.</operator><name>latency_sum</name></name> <operator>=</operator> <call><name>NS2SEC</name><argument_list>(<argument><expr><call><name>sb_timer_sum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>current_test</name> <operator>&amp;&amp;</operator> <name><name>current_test</name><operator>-&gt;</operator><name>ops</name><operator>.</operator><name>report_cumulative</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name><name>current_test</name><operator>-&gt;</operator><name>ops</name><operator>.</operator><name>report_cumulative</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>stat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>sb_report_cumulative</name><argument_list>(<argument><expr><operator>&amp;</operator><name>stat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>sigalrm_forced_shutdown_handler</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sig</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>sig</name> <operator>!=</operator> <name>SIGALRM</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name><name>sb_globals</name><operator>.</operator><name>forced_shutdown_in_progress</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>sb_timer_stop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb_exec_timer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sb_timer_stop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb_intermediate_timer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sb_timer_stop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb_checkpoint_timer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_FATAL</name></expr></argument>,
           <argument><expr><literal type="string">"The --max-time limit has expired, forcing shutdown..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>report_cumulative</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>log_done</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<function><type><specifier>static</specifier> <name>int</name></type> <name>register_tests</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>SB_LIST_INIT</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tests</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Register tests */</comment>
  <return>return <expr><call><name>register_test_fileio</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tests</name></expr></argument>)</argument_list></call>
    <operator>+</operator> <call><name>register_test_cpu</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tests</name></expr></argument>)</argument_list></call>
    <operator>+</operator> <call><name>register_test_memory</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tests</name></expr></argument>)</argument_list></call>
    <operator>+</operator> <call><name>register_test_threads</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tests</name></expr></argument>)</argument_list></call>
    <operator>+</operator> <call><name>register_test_mutex</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tests</name></expr></argument>)</argument_list></call>
    <operator>+</operator> <call><name>db_register</name><argument_list>()</argument_list></call>
    <operator>+</operator> <call><name>sb_rand_register</name><argument_list>()</argument_list></call></expr>
    ;</return>
</block_content>}</block></function>


<comment type="block">/* Print program header */</comment>


<function><type><name>void</name></type> <name>print_header</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_NOTICE</name></expr></argument>,
           <argument><expr><literal type="string">"%s (using %s %s)\n"</literal></expr></argument>,
           <argument><expr><name>VERSION_STRING</name></expr></argument>, <argument><expr><name>SB_WITH_LUAJIT</name></expr></argument>, <argument><expr><name>LUAJIT_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* Print program usage */</comment>


<function><type><name>void</name></type> <name>print_help</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>sb_list_item_t</name> <modifier>*</modifier></type><name>pos</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sb_test_t</name>      <modifier>*</modifier></type><name>test</name></decl>;</decl_stmt>
  
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Usage:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  sysbench [options]... [testname] [command]\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Commands implemented by most tests: prepare run cleanup help\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"General options:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sb_print_options</name><argument_list>(<argument><expr><name>general_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>sb_rand_print_help</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>log_print_help</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>db_print_help</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Compiled-in tests:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <macro><name>SB_LIST_FOR_EACH</name><argument_list>(<argument>pos</argument>, <argument>&amp;tests</argument>)</argument_list></macro>
  <block>{<block_content>
    <expr_stmt><expr><name>test</name> <operator>=</operator> <call><name>SB_LIST_ENTRY</name><argument_list>(<argument><expr><name>pos</name></expr></argument>, <argument><expr><name>sb_test_t</name></expr></argument>, <argument><expr><name>listitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  %s - %s\n"</literal></expr></argument>, <argument><expr><name><name>test</name><operator>-&gt;</operator><name>sname</name></name></expr></argument>, <argument><expr><name><name>test</name><operator>-&gt;</operator><name>lname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"See 'sysbench &lt;testname&gt; help' for a list of options for "</literal>
         <literal type="string">"each test.\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
  Set an option value if a default value has been previously set with
  sb_register_arg_set(), i.e. if it's a 'known' option, or ignore_unknown is
  'true'. In which case return 0, otherwise return 1.
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_option</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ignore_unknown</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>        <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name>              <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>option_t</name>          <modifier>*</modifier></type><name>opt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type>              <name>ctmp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type>               <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>tmp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>ctmp</name> <operator>=</operator> <operator>*</operator><name>tmp</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>tmp</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>value</name> <operator>=</operator> <name>tmp</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <expr_stmt><expr><name>value</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><name>opt</name> <operator>=</operator> <call><name>sb_find_option</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>opt</name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <name>ignore_unknown</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>set_option</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>,
                    <argument><expr><ternary><condition><expr><name>opt</name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><name><name>opt</name><operator>-&gt;</operator><name>type</name></name></expr> </then><else>: <expr><name>SB_ARG_TYPE_STRING</name></expr></else></ternary></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator>  <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>tmp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><operator>*</operator><name>tmp</name> <operator>=</operator> <name>ctmp</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
  Parse general command line arguments. Test-specific argument are parsed by
  parse_test_arguments() at a later stage when a builtin test or a Lua script is
  known.
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_general_arguments</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>      <name>testname</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>      <name>cmdname</name></decl>;</decl_stmt>

  <comment type="block">/* Set default values for general options */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>sb_register_arg_set</name><argument_list>(<argument><expr><name>general_args</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Parse command line arguments */</comment>
  <expr_stmt><expr><name>testname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>cmdname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

  <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>testname</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><name>testname</name> <operator>=</operator> <name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>

      <if_stmt><if>if <condition>(<expr><name>cmdname</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><name>cmdname</name> <operator>=</operator> <name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Unrecognized command line argument: %s\n"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>parse_option</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name><operator>+</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* An option from general_args. Exclude it from future processing */</comment>
      <expr_stmt><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><name><name>sb_globals</name><operator>.</operator><name>testname</name></name> <operator>=</operator> <name>testname</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sb_globals</name><operator>.</operator><name>cmdname</name></name> <operator>=</operator> <name>cmdname</name></expr>;</expr_stmt>

  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Parse test-specific arguments */</comment>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_test_arguments</name><parameter_list>(<parameter><decl><type><name>sb_test_t</name> <modifier>*</modifier></type><name>test</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Set default values */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>test</name><operator>-&gt;</operator><name>args</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>sb_register_arg_set</name><argument_list>(<argument><expr><name><name>test</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

  <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
  <block>{<block_content>
    <comment type="block">/* Skip already parsed and non-option arguments */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>strncmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <continue>continue;</continue></block_content></block></if></if_stmt>

    <comment type="block">/* At this stage an unrecognized option must throw a error. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>parse_option</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name><operator>+</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"invalid option: %s\n"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>print_run_mode</name><parameter_list>(<parameter><decl><type><name>sb_test_t</name> <modifier>*</modifier></type><name>test</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_NOTICE</name></expr></argument>, <argument><expr><literal type="string">"Running the test with following options:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_NOTICE</name></expr></argument>, <argument><expr><literal type="string">"Number of threads: %d"</literal></expr></argument>, <argument><expr><name><name>sb_globals</name><operator>.</operator><name>threads</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>sb_globals</name><operator>.</operator><name>warmup_time</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_NOTICE</name></expr></argument>, <argument><expr><literal type="string">"Warmup time: %ds"</literal></expr></argument>, <argument><expr><name><name>sb_globals</name><operator>.</operator><name>warmup_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>sb_globals</name><operator>.</operator><name>tx_rate</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_NOTICE</name></expr></argument>,
            <argument><expr><literal type="string">"Target transaction rate: %d/sec"</literal></expr></argument>, <argument><expr><name><name>sb_globals</name><operator>.</operator><name>tx_rate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>sb_globals</name><operator>.</operator><name>report_interval</name></name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_NOTICE</name></expr></argument>, <argument><expr><literal type="string">"Report intermediate results every %d second(s)"</literal></expr></argument>,
             <argument><expr><name><name>sb_globals</name><operator>.</operator><name>report_interval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>sb_globals</name><operator>.</operator><name>n_checkpoints</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type>         <name><name>list_str</name><index>[<expr><name>MAX_CHECKPOINTS</name> <operator>*</operator> <literal type="number">12</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>         <modifier>*</modifier></type><name>tmp</name> <init>= <expr><name>list_str</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>          <name>n</name></decl>, <decl><type ref="prev"/><name>size</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>list_str</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sb_globals</name><operator>.</operator><name>n_checkpoints</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
      <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><literal type="string">"%u, "</literal></expr></argument>, <argument><expr><name><name>sb_globals</name><operator>.</operator><name>checkpoints</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;=</operator> <name>size</name></expr>)</condition><block type="pseudo"><block_content>
        <break>break;</break></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>tmp</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>size</name> <operator>-=</operator> <name>n</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name><name>sb_globals</name><operator>.</operator><name>n_checkpoints</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><name><name>sb_globals</name><operator>.</operator><name>checkpoints</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_NOTICE</name></expr></argument>, <argument><expr><literal type="string">"Report checkpoint(s) at %s seconds"</literal></expr></argument>,
             <argument><expr><name>list_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>sb_globals</name><operator>.</operator><name>debug</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_NOTICE</name></expr></argument>, <argument><expr><literal type="string">"Debug mode enabled.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  
  <if_stmt><if>if <condition>(<expr><name><name>sb_globals</name><operator>.</operator><name>validate</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_NOTICE</name></expr></argument>, <argument><expr><literal type="string">"Validation checks: on.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>sb_rand_seed</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_NOTICE</name></expr></argument>,
             <argument><expr><literal type="string">"Initializing random number generator from seed (%d).\n"</literal></expr></argument>,
             <argument><expr><name>sb_rand_seed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>srandom</name><argument_list>(<argument><expr><name>sb_rand_seed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_NOTICE</name></expr></argument>,
             <argument><expr><literal type="string">"Initializing random number generator from current time\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>srandom</name><argument_list>(<argument><expr><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>sb_globals</name><operator>.</operator><name>force_shutdown</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_NOTICE</name></expr></argument>, <argument><expr><literal type="string">"Forcing shutdown in %u seconds"</literal></expr></argument>,
             <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator> <call><name>NS2SEC</name><argument_list>(<argument><expr><name><name>sb_globals</name><operator>.</operator><name>max_time_ns</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>sb_globals</name><operator>.</operator><name>timeout</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  
  <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_NOTICE</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>test</name><operator>-&gt;</operator><name>ops</name><operator>.</operator><name>print_mode</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name><name>test</name><operator>-&gt;</operator><name>ops</name><operator>.</operator><name>print_mode</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>sb_more_events</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>thread_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>thread_id</name></expr>;</expr_stmt> <comment type="block">/* unused */</comment>

  <if_stmt><if>if <condition>(<expr><name><name>sb_globals</name><operator>.</operator><name>error</name></name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Check if we have a time limit */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>sb_globals</name><operator>.</operator><name>max_time_ns</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
      <call><name>SB_UNLIKELY</name><argument_list>(<argument><expr><call><name>sb_timer_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb_exec_timer</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name><name>sb_globals</name><operator>.</operator><name>max_time_ns</name></name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_INFO</name></expr></argument>, <argument><expr><literal type="string">"Time limit exceeded, exiting..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Check if we have a limit on the number of events */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>uint64_t</name></type> <name>max_events</name> <init>= <expr><call><name>ck_pr_load_64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sb_globals</name><operator>.</operator><name>max_events</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>max_events</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
      <call><name>SB_UNLIKELY</name><argument_list>(<argument><expr><call><name>ck_pr_faa_64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sb_globals</name><operator>.</operator><name>nevents</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>max_events</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_INFO</name></expr></argument>, <argument><expr><literal type="string">"Event limit exceeded, exiting..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If we are in tx_rate mode, we take events from queue */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>sb_globals</name><operator>.</operator><name>tx_rate</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr><operator>!</operator><call><name>ck_ring_dequeue_spmc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>queue_ring</name></expr></argument>, <argument><expr><name>queue_ring_buffer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
           <operator>!</operator><name><name>sb_globals</name><operator>.</operator><name>error</name></name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>queue_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>pthread_cond_wait</name><argument_list>(<argument><expr><operator>&amp;</operator><name>queue_cond</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>queue_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>queue_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Re-check for global error and time limit after waiting */</comment>

      <if_stmt><if>if <condition>(<expr><name><name>sb_globals</name><operator>.</operator><name>error</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

      <if_stmt><if>if <condition>(<expr><name><name>sb_globals</name><operator>.</operator><name>max_time_ns</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
          <call><name>SB_UNLIKELY</name><argument_list>(<argument><expr><call><name>sb_timer_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb_exec_timer</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name><name>sb_globals</name><operator>.</operator><name>max_time_ns</name></name></expr></argument>)</argument_list></call></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_INFO</name></expr></argument>, <argument><expr><literal type="string">"Time limit exceeded, exiting..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>ck_pr_inc_int</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sb_globals</name><operator>.</operator><name>concurrency</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>timers</name><index>[<expr><name>thread_id</name></expr>]</index></name><operator>.</operator><name>queue_time</name> <operator>=</operator> <call><name>sb_timer_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb_exec_timer</name></expr></argument>)</argument_list></call> <operator>-</operator>
      <operator>(</operator><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator> <name>ptr</name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>sb_event_start</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>thread_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>sb_timer_start</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>timers</name><index>[<expr><name>thread_id</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>sb_event_stop</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>thread_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>sb_timer_t</name>     <modifier>*</modifier></type><name>timer</name> <init>= <expr><operator>&amp;</operator><name><name>timers</name><index>[<expr><name>thread_id</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>long</name> <name>long</name></type>      <name>value</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>sb_timer_stop</name><argument_list>(<argument><expr><name>timer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>sb_globals</name><operator>.</operator><name>percentile</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>sb_histogram_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb_latency_histogram</name></expr></argument>, <argument><expr><call><name>NS2MS</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>sb_counter_inc</name><argument_list>(<argument><expr><name>thread_id</name></expr></argument>, <argument><expr><name>SB_CNT_EVENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>sb_globals</name><operator>.</operator><name>tx_rate</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>ck_pr_dec_int</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sb_globals</name><operator>.</operator><name>concurrency</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/* Main event loop -- the default thread_run implementation */</comment>


<function><type><specifier>static</specifier> <name>int</name></type> <name>thread_run</name><parameter_list>(<parameter><decl><type><name>sb_test_t</name> <modifier>*</modifier></type><name>test</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>thread_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>sb_event_t</name></type>        <name>event</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type>               <name>rc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <while>while <condition>(<expr><call><name>sb_more_events</name><argument_list>(<argument><expr><name>thread_id</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>rc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>event</name> <operator>=</operator> <call><name><name>test</name><operator>-&gt;</operator><name>ops</name><operator>.</operator><name>next_event</name></name><argument_list>(<argument><expr><name>thread_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>event</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>SB_REQ_TYPE_NULL</name></expr>)</condition><block type="pseudo"><block_content>
      <break>break;</break></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>sb_event_start</name><argument_list>(<argument><expr><name>thread_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>test</name><operator>-&gt;</operator><name>ops</name><operator>.</operator><name>execute_event</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>event</name></expr></argument>, <argument><expr><name>thread_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>sb_event_stop</name><argument_list>(<argument><expr><name>thread_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Main worker thread */</comment>


<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>worker_thread</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>sb_thread_ctxt_t</name>   <modifier>*</modifier></type><name>ctxt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type>       <name>thread_id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type>                <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>ctxt</name> <operator>=</operator> <operator>(</operator><name>sb_thread_ctxt_t</name> <operator>*</operator><operator>)</operator><name>arg</name></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>sb_test_t</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>test</name> <init>= <expr><name>current_test</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>sb_tls_thread_id</name> <operator>=</operator> <name>thread_id</name> <operator>=</operator> <name><name>ctxt</name><operator>-&gt;</operator><name>id</name></name></expr>;</expr_stmt>

  <comment type="block">/* Initialize thread-local RNG state */</comment>
  <expr_stmt><expr><call><name>sb_rand_thread_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"Worker thread (#%d) started"</literal></expr></argument>, <argument><expr><name>thread_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>test</name><operator>-&gt;</operator><name>ops</name><operator>.</operator><name>thread_init</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name><name>test</name><operator>-&gt;</operator><name>ops</name><operator>.</operator><name>thread_init</name></name><argument_list>(<argument><expr><name>thread_id</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"Worker thread (#%d) failed to initialize!"</literal></expr></argument>, <argument><expr><name>thread_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sb_globals</name><operator>.</operator><name>error</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <comment type="block">/* Avoid blocking the main thread */</comment>
    <expr_stmt><expr><call><name>sb_barrier_wait</name><argument_list>(<argument><expr><operator>&amp;</operator><name>worker_barrier</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"Worker thread (#%d) initialized"</literal></expr></argument>, <argument><expr><name>thread_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Wait for other threads to initialize */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>sb_barrier_wait</name><argument_list>(<argument><expr><operator>&amp;</operator><name>worker_barrier</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>test</name><operator>-&gt;</operator><name>ops</name><operator>.</operator><name>thread_run</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Use benchmark-provided thread_run implementation */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>test</name><operator>-&gt;</operator><name>ops</name><operator>.</operator><name>thread_run</name></name><argument_list>(<argument><expr><name>thread_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Use default thread_run implementation */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>thread_run</name><argument_list>(<argument><expr><name>test</name></expr></argument>, <argument><expr><name>thread_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>sb_globals</name><operator>.</operator><name>error</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><name><name>test</name><operator>-&gt;</operator><name>ops</name><operator>.</operator><name>thread_done</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name><name>test</name><operator>-&gt;</operator><name>ops</name><operator>.</operator><name>thread_done</name></name><argument_list>(<argument><expr><name>thread_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Generate exponentially distributed number with a given Lambda */</comment>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>double</name></type> <name>sb_rand_exp</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>lambda</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><operator>-</operator><name>lambda</name> <operator>*</operator> <call><name>log</name><argument_list>(<argument><expr><literal type="number">1</literal> <operator>-</operator> <call><name>sb_rand_uniform_double</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>eventgen_thread_proc</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>arg</name></expr>;</expr_stmt> <comment type="block">/* unused */</comment>

  <expr_stmt><expr><name>sb_tls_thread_id</name> <operator>=</operator> <name>SB_BACKGROUND_THREAD_ID</name></expr>;</expr_stmt>

  <comment type="block">/* Initialize thread-local RNG state */</comment>
  <expr_stmt><expr><call><name>sb_rand_thread_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>ck_ring_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>queue_ring</name></expr></argument>, <argument><expr><name>MAX_QUEUE_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>pthread_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>queue_mutex</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>||</operator>
      <call><name>pthread_cond_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>queue_cond</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>sb_barrier_wait</name><argument_list>(<argument><expr><operator>&amp;</operator><name>worker_barrier</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"Event generating thread started"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Wait for the worker threads to initialize */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>sb_barrier_wait</name><argument_list>(<argument><expr><operator>&amp;</operator><name>worker_barrier</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>eventgen_thread_created</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

  <comment type="block">/*
    Get exponentially distributed time intervals in nanoseconds with Lambda =
    tx_rate. Alternatively, we can use Lambda = tx_rate / 1e9
  */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>double</name></type> <name>lambda</name> <init>= <expr><literal type="number">1e9</literal> <operator>/</operator> <name><name>sb_globals</name><operator>.</operator><name>tx_rate</name></name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>uint64_t</name></type> <name>curr_ns</name> <init>= <expr><call><name>sb_timer_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb_exec_timer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint64_t</name></type> <name>intr_ns</name> <init>= <expr><call><name>sb_rand_exp</name><argument_list>(<argument><expr><name>lambda</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint64_t</name></type> <name>next_ns</name> <init>= <expr><name>curr_ns</name> <operator>+</operator> <name>intr_ns</name></expr></init></decl>;</decl_stmt>

  <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition>;</condition> <incr><expr><name>i</name> <operator>=</operator> <operator>(</operator><name>i</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name>MAX_QUEUE_LEN</name></expr></incr>)</control>
  <block>{<block_content>
    <expr_stmt><expr><name>curr_ns</name> <operator>=</operator> <call><name>sb_timer_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb_exec_timer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>intr_ns</name> <operator>=</operator> <call><name>sb_rand_exp</name><argument_list>(<argument><expr><name>lambda</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>next_ns</name> <operator>+=</operator> <name>intr_ns</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>sb_globals</name><operator>.</operator><name>max_time_ns</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
        <call><name>SB_UNLIKELY</name><argument_list>(<argument><expr><name>curr_ns</name> <operator>&gt;=</operator> <name><name>sb_globals</name><operator>.</operator><name>max_time_ns</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Wake all waiting threads */</comment>
      <expr_stmt><expr><call><name>pthread_cond_broadcast</name><argument_list>(<argument><expr><operator>&amp;</operator><name>queue_cond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>next_ns</name> <operator>&gt;</operator> <name>curr_ns</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>sb_nanosleep</name><argument_list>(<argument><expr><name>next_ns</name> <operator>-</operator> <name>curr_ns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Enqueue a new event */</comment>
    <expr_stmt><expr><name><name>queue_array</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>sb_timer_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb_exec_timer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ck_ring_enqueue_spmc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>queue_ring</name></expr></argument>, <argument><expr><name>queue_ring_buffer</name></expr></argument>,
                             <argument><expr><operator>&amp;</operator><name><name>queue_array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>false</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>sb_globals</name><operator>.</operator><name>error</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_FATAL</name></expr></argument>,
               <argument><expr><literal type="string">"The event queue is full. This means the worker threads are "</literal>
               <literal type="string">"unable to keep up with the specified event generation rate"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>pthread_cond_broadcast</name><argument_list>(<argument><expr><operator>&amp;</operator><name>queue_cond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Wake up one waiting thread, if there are any */</comment>
    <expr_stmt><expr><call><name>pthread_cond_signal</name><argument_list>(<argument><expr><operator>&amp;</operator><name>queue_cond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Intermediate reports thread */</comment>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>report_thread_proc</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type>       <name>pause_ns</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type>       <name>prev_ns</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type>       <name>next_ns</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type>       <name>curr_ns</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>long</name> <name>long</name></type> <name>interval_ns</name> <init>= <expr><call><name>SEC2NS</name><argument_list>(<argument><expr><name><name>sb_globals</name><operator>.</operator><name>report_interval</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>arg</name></expr>;</expr_stmt> <comment type="block">/* unused */</comment>

  <expr_stmt><expr><name>sb_tls_thread_id</name> <operator>=</operator> <name>SB_BACKGROUND_THREAD_ID</name></expr>;</expr_stmt>

  <comment type="block">/* Initialize thread-local RNG state */</comment>
  <expr_stmt><expr><call><name>sb_rand_thread_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>sb_lua_loaded</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>sb_lua_report_thread_init</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>pthread_cleanup_push</name><argument_list>(<argument><expr><name>sb_lua_report_thread_done</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"Reporting thread started"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Wait for the signal from the main thread to start reporting */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>sb_barrier_wait</name><argument_list>(<argument><expr><operator>&amp;</operator><name>report_barrier</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>report_thread_created</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

  <expr_stmt><expr><name>pause_ns</name> <operator>=</operator> <name>interval_ns</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>prev_ns</name> <operator>=</operator> <call><name>sb_timer_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb_exec_timer</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>interval_ns</name></expr>;</expr_stmt>

  <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
  <block>{<block_content>
    <expr_stmt><expr><call><name>sb_nanosleep</name><argument_list>(<argument><expr><name>pause_ns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>report_intermediate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>curr_ns</name> <operator>=</operator> <call><name>sb_timer_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb_exec_timer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <do>do
    <block>{<block_content>
      <expr_stmt><expr><name>next_ns</name> <operator>=</operator> <name>prev_ns</name> <operator>+</operator> <name>interval_ns</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>prev_ns</name> <operator>=</operator> <name>next_ns</name></expr>;</expr_stmt>
    </block_content>}</block> while <condition>(<expr><name>curr_ns</name> <operator>&gt;=</operator> <name>next_ns</name></expr>)</condition>;</do>
    <expr_stmt><expr><name>pause_ns</name> <operator>=</operator> <name>next_ns</name> <operator>-</operator> <name>curr_ns</name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><call><name>pthread_cleanup_pop</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Checkpoints reports thread */</comment>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>checkpoints_thread_proc</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type>       <name>next_ns</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type>       <name>curr_ns</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type>             <name>i</name></decl>;</decl_stmt>

  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>arg</name></expr>;</expr_stmt> <comment type="block">/* unused */</comment>

  <expr_stmt><expr><name>sb_tls_thread_id</name> <operator>=</operator> <name>SB_BACKGROUND_THREAD_ID</name></expr>;</expr_stmt>

  <comment type="block">/* Initialize thread-local RNG state */</comment>
  <expr_stmt><expr><call><name>sb_rand_thread_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>sb_lua_loaded</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>sb_lua_report_thread_init</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>pthread_cleanup_push</name><argument_list>(<argument><expr><name>sb_lua_report_thread_done</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"Checkpoints report thread started"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Wait for the signal from the main thread to start reporting */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>sb_barrier_wait</name><argument_list>(<argument><expr><operator>&amp;</operator><name>report_barrier</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>checkpoints_thread_created</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sb_globals</name><operator>.</operator><name>n_checkpoints</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
  <block>{<block_content>
    <expr_stmt><expr><name>next_ns</name> <operator>=</operator> <call><name>SEC2NS</name><argument_list>(<argument><expr><name><name>sb_globals</name><operator>.</operator><name>checkpoints</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>curr_ns</name> <operator>=</operator> <call><name>sb_timer_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb_exec_timer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>next_ns</name> <operator>&lt;=</operator> <name>curr_ns</name></expr>)</condition><block type="pseudo"><block_content>
      <continue>continue;</continue></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>sb_nanosleep</name><argument_list>(<argument><expr><name>next_ns</name> <operator>-</operator> <name>curr_ns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>log_timestamp</name><argument_list>(<argument><expr><name>LOG_NOTICE</name></expr></argument>, <argument><expr><call><name>NS2SEC</name><argument_list>(<argument><expr><call><name>sb_timer_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb_exec_timer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                  <argument><expr><literal type="string">"Checkpoint report:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>report_cumulative</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><call><name>pthread_cleanup_pop</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Callback to start timers when all threads are ready */</comment>

<function><type><specifier>static</specifier> <name>int</name></type> <name>threads_started_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>arg</name></expr>;</expr_stmt> <comment type="block">/* unused */</comment>

  <comment type="block">/* Report initialization errors to the main thread */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>sb_globals</name><operator>.</operator><name>error</name></name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name><name>sb_globals</name><operator>.</operator><name>threads_running</name></name> <operator>=</operator> <name><name>sb_globals</name><operator>.</operator><name>threads</name></name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>sb_timer_start</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb_exec_timer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sb_timer_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb_intermediate_timer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sb_exec_timer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sb_timer_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb_checkpoint_timer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sb_exec_timer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_NOTICE</name></expr></argument>, <argument><expr><literal type="string">"Threads started!\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
  Main test function: start threads, wait for them to finish and measure time.
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type> <name>run_test</name><parameter_list>(<parameter><decl><type><name>sb_test_t</name> <modifier>*</modifier></type><name>test</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type>          <name>err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>pthread_t</name></type>    <name>report_thread</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>pthread_t</name></type>    <name>checkpoints_thread</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>pthread_t</name></type>    <name>eventgen_thread</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>barrier_threads</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint64_t</name></type>     <name>old_max_events</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* initialize test */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>test</name><operator>-&gt;</operator><name>ops</name><operator>.</operator><name>init</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name><name>test</name><operator>-&gt;</operator><name>ops</name><operator>.</operator><name>init</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  
  <comment type="block">/* print test mode */</comment>
  <expr_stmt><expr><call><name>print_run_mode</name><argument_list>(<argument><expr><name>test</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* initialize timers */</comment>
  <expr_stmt><expr><call><name>sb_timer_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb_exec_timer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sb_timer_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb_intermediate_timer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sb_timer_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb_checkpoint_timer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* prepare test */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>test</name><operator>-&gt;</operator><name>ops</name><operator>.</operator><name>prepare</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name><name>test</name><operator>-&gt;</operator><name>ops</name><operator>.</operator><name>prepare</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>pthread_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sb_globals</name><operator>.</operator><name>exec_mutex</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>sb_globals</name><operator>.</operator><name>threads_running</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <comment type="block">/* Calculate the required number of threads for the worker start barrier */</comment>
  <expr_stmt><expr><name>barrier_threads</name> <operator>=</operator> <literal type="number">1</literal> <comment type="block">/* main thread */</comment> <operator>+</operator> <name><name>sb_globals</name><operator>.</operator><name>threads</name></name> <operator>+</operator>
    <operator>(</operator><name><name>sb_globals</name><operator>.</operator><name>tx_rate</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> <comment type="block">/* event generation thread */</comment>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>sb_barrier_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>worker_barrier</name></expr></argument>, <argument><expr><name>barrier_threads</name></expr></argument>,
                      <argument><expr><name>threads_started_callback</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>log_errno</name><argument_list>(<argument><expr><name>LOG_FATAL</name></expr></argument>, <argument><expr><literal type="string">"sb_barrier_init() failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Calculate the required number of threads for the report start barrier */</comment>
  <expr_stmt><expr><name>barrier_threads</name> <operator>=</operator> <literal type="number">1</literal> <comment type="block">/* main thread */</comment> <operator>+</operator>
    <operator>(</operator><name><name>sb_globals</name><operator>.</operator><name>report_interval</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <comment type="block">/* intermediate reports thread */</comment> <operator>+</operator>
    <operator>(</operator><name><name>sb_globals</name><operator>.</operator><name>n_checkpoints</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> <comment type="block">/* checkpoint reports thread */</comment>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>sb_barrier_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>report_barrier</name></expr></argument>, <argument><expr><name>barrier_threads</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>log_errno</name><argument_list>(<argument><expr><name>LOG_FATAL</name></expr></argument>, <argument><expr><literal type="string">"sb_barrier_init() failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>


  <if_stmt><if>if <condition>(<expr><name><name>sb_globals</name><operator>.</operator><name>report_interval</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Create a thread for intermediate statistic reports */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>err</name> <operator>=</operator> <call><name>sb_thread_create</name><argument_list>(<argument><expr><operator>&amp;</operator><name>report_thread</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sb_thread_attr</name></expr></argument>,
                                <argument><expr><operator>&amp;</operator><name>report_thread_proc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>log_errno</name><argument_list>(<argument><expr><name>LOG_FATAL</name></expr></argument>,
                <argument><expr><literal type="string">"sb_thread_create() for the reporting thread failed."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>sb_globals</name><operator>.</operator><name>tx_rate</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>err</name> <operator>=</operator> <call><name>sb_thread_create</name><argument_list>(<argument><expr><operator>&amp;</operator><name>eventgen_thread</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sb_thread_attr</name></expr></argument>,
                                <argument><expr><operator>&amp;</operator><name>eventgen_thread_proc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>log_errno</name><argument_list>(<argument><expr><name>LOG_FATAL</name></expr></argument>,
                <argument><expr><literal type="string">"sb_thread_create() for the reporting thread failed."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>sb_globals</name><operator>.</operator><name>n_checkpoints</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Create a thread for checkpoint statistic reports */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>err</name> <operator>=</operator> <call><name>sb_thread_create</name><argument_list>(<argument><expr><operator>&amp;</operator><name>checkpoints_thread</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sb_thread_attr</name></expr></argument>,
                                <argument><expr><operator>&amp;</operator><name>checkpoints_thread_proc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>log_errno</name><argument_list>(<argument><expr><name>LOG_FATAL</name></expr></argument>,
                <argument><expr><literal type="string">"sb_thread_create() for the checkpoint thread failed."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>err</name> <operator>=</operator> <call><name>sb_thread_create_workers</name><argument_list>(<argument><expr><operator>&amp;</operator><name>worker_thread</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>err</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_ALARM</name></cpp:ifdef>
  <comment type="block">/* Exit with an error if thread initialization timeout expires */</comment>
  <expr_stmt><expr><call><name>signal</name><argument_list>(<argument><expr><name>SIGALRM</name></expr></argument>, <argument><expr><name>sigalrm_thread_init_timeout_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>alarm</name><argument_list>(<argument><expr><name>thread_init_timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if_stmt><if>if <condition>(<expr><name><name>sb_globals</name><operator>.</operator><name>warmup_time</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Disable the max_events limit for the warmup stage */</comment>
    <expr_stmt><expr><name>old_max_events</name> <operator>=</operator> <name><name>sb_globals</name><operator>.</operator><name>max_events</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sb_globals</name><operator>.</operator><name>max_events</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>sb_barrier_wait</name><argument_list>(<argument><expr><operator>&amp;</operator><name>worker_barrier</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_FATAL</name></expr></argument>, <argument><expr><literal type="string">"Threads initialization failed!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_ALARM</name></cpp:ifdef>
  <expr_stmt><expr><call><name>alarm</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>sb_globals</name><operator>.</operator><name>force_shutdown</name></name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Set the alarm to force shutdown */</comment>
    <expr_stmt><expr><call><name>signal</name><argument_list>(<argument><expr><name>SIGALRM</name></expr></argument>, <argument><expr><name>sigalrm_forced_shutdown_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>alarm</name><argument_list>(<argument><expr><call><name>NS2SEC</name><argument_list>(<argument><expr><name><name>sb_globals</name><operator>.</operator><name>max_time_ns</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>sb_globals</name><operator>.</operator><name>timeout</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if_stmt><if>if <condition>(<expr><name><name>sb_globals</name><operator>.</operator><name>warmup_time</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_NOTICE</name></expr></argument>, <argument><expr><literal type="string">"Warming up for %d seconds...\n"</literal></expr></argument>,
             <argument><expr><name><name>sb_globals</name><operator>.</operator><name>warmup_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>usleep</name><argument_list>(<argument><expr><name><name>sb_globals</name><operator>.</operator><name>warmup_time</name></name> <operator>*</operator> <literal type="number">1000000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Re-enable the max_events limit, if it was set */</comment>
    <expr_stmt><expr><call><name>ck_pr_store_64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sb_globals</name><operator>.</operator><name>max_events</name></name></expr></argument>, <argument><expr><name>old_max_events</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Perform a checkpoint to reset previously collected stats */</comment>
    <decl_stmt><decl><type><name>sb_stat_t</name></type> <name>stat</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>checkpoint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>stat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Signal the report threads to start reporting */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>sb_barrier_wait</name><argument_list>(<argument><expr><operator>&amp;</operator><name>report_barrier</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_FATAL</name></expr></argument>, <argument><expr><literal type="string">"Failed to signal reporting threads"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>err</name> <operator>=</operator> <call><name>sb_thread_join_workers</name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>err</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>sb_timer_stop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb_exec_timer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sb_timer_stop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb_intermediate_timer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sb_timer_stop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb_checkpoint_timer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Silence periodic reports if they were on */</comment>
  <expr_stmt><expr><call><name>ck_pr_store_uint</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sb_globals</name><operator>.</operator><name>report_interval</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_ALARM</name></cpp:ifdef>
  <expr_stmt><expr><call><name>alarm</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_INFO</name></expr></argument>, <argument><expr><literal type="string">"Done.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* cleanup test */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>test</name><operator>-&gt;</operator><name>ops</name><operator>.</operator><name>cleanup</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name><name>test</name><operator>-&gt;</operator><name>ops</name><operator>.</operator><name>cleanup</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>report_thread_created</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>sb_thread_cancel</name><argument_list>(<argument><expr><name>report_thread</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>sb_thread_join</name><argument_list>(<argument><expr><name>report_thread</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>log_errno</name><argument_list>(<argument><expr><name>LOG_FATAL</name></expr></argument>, <argument><expr><literal type="string">"Terminating the reporting thread failed."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>eventgen_thread_created</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/*
      When a time limit is used, the event generation thread may terminate
      itself.
    */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>sb_thread_cancel</name><argument_list>(<argument><expr><name>eventgen_thread</name></expr></argument>)</argument_list></call> <operator>||</operator>
         <call><name>sb_thread_join</name><argument_list>(<argument><expr><name>eventgen_thread</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>sb_globals</name><operator>.</operator><name>max_time_ns</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_FATAL</name></expr></argument>, <argument><expr><literal type="string">"Terminating the event generator thread failed."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>checkpoints_thread_created</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>sb_thread_cancel</name><argument_list>(<argument><expr><name>checkpoints_thread</name></expr></argument>)</argument_list></call> <operator>||</operator>
        <call><name>sb_thread_join</name><argument_list>(<argument><expr><name>checkpoints_thread</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>log_errno</name><argument_list>(<argument><expr><name>LOG_FATAL</name></expr></argument>, <argument><expr><literal type="string">"Terminating the checkpoint thread failed."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* print test-specific stats */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>sb_globals</name><operator>.</operator><name>error</name></name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>sb_globals</name><operator>.</operator><name>histogram</name></name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_NOTICE</name></expr></argument>, <argument><expr><literal type="string">"Latency histogram (values are in milliseconds)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sb_histogram_print</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb_latency_histogram</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_NOTICE</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>report_cumulative</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>pthread_mutex_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sb_globals</name><operator>.</operator><name>exec_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* finalize test */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>test</name><operator>-&gt;</operator><name>ops</name><operator>.</operator><name>done</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><operator>(</operator><name><name>test</name><operator>-&gt;</operator><name>ops</name><operator>.</operator><name>done</name></name><operator>)</operator><operator>)</operator><operator>(</operator><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <return>return <expr><name><name>sb_globals</name><operator>.</operator><name>error</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>sb_test_t</name> <modifier>*</modifier></type><name>find_test</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>sb_list_item_t</name> <modifier>*</modifier></type><name>pos</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sb_test_t</name>      <modifier>*</modifier></type><name>test</name></decl>;</decl_stmt>

  <macro><name>SB_LIST_FOR_EACH</name><argument_list>(<argument>pos</argument>, <argument>&amp;tests</argument>)</argument_list></macro>
  <block>{<block_content>
    <expr_stmt><expr><name>test</name> <operator>=</operator> <call><name>SB_LIST_ENTRY</name><argument_list>(<argument><expr><name>pos</name></expr></argument>, <argument><expr><name>sb_test_t</name></expr></argument>, <argument><expr><name>listitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>test</name><operator>-&gt;</operator><name>sname</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>test</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block>

  <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>checkpoint_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a_ptr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b_ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>a</name> <init>= <expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>int</name> <operator>*</operator><operator>)</operator> <name>a_ptr</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>b</name> <init>= <expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>int</name> <operator>*</operator><operator>)</operator> <name>b_ptr</name></expr></init></decl>;</decl_stmt>

  <return>return <expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>a</name> <operator>-</operator> <name>b</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>option_t</name> <modifier>*</modifier></type><name>opt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name>     <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sb_list_t</name>         <modifier>*</modifier></type><name>checkpoints_list</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sb_list_item_t</name>    <modifier>*</modifier></type><name>pos_val</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>value_t</name>           <modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>sb_globals</name><operator>.</operator><name>threads</name></name> <operator>=</operator> <call><name>sb_get_value_int</name><argument_list>(<argument><expr><literal type="string">"threads"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>thread_init_timeout</name> <operator>=</operator> <call><name>sb_get_value_int</name><argument_list>(<argument><expr><literal type="string">"thread-init-timeout"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <if_stmt><if>if <condition>(<expr><name><name>sb_globals</name><operator>.</operator><name>threads</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_FATAL</name></expr></argument>, <argument><expr><literal type="string">"Invalid value for --threads: %d.\n"</literal></expr></argument>,
             <argument><expr><name><name>sb_globals</name><operator>.</operator><name>threads</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>sb_globals</name><operator>.</operator><name>max_events</name></name> <operator>=</operator> <call><name>sb_get_value_int</name><argument_list>(<argument><expr><literal type="string">"events"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>sb_globals</name><operator>.</operator><name>warmup_time</name></name> <operator>=</operator> <call><name>sb_get_value_int</name><argument_list>(<argument><expr><literal type="string">"warmup-time"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>sb_globals</name><operator>.</operator><name>warmup_time</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_FATAL</name></expr></argument>, <argument><expr><literal type="string">"Invalid value for --warmup-time: %d.\n"</literal></expr></argument>,
             <argument><expr><name><name>sb_globals</name><operator>.</operator><name>warmup_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>max_time</name> <init>= <expr><call><name>sb_get_value_int</name><argument_list>(<argument><expr><literal type="string">"time"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>sb_globals</name><operator>.</operator><name>max_time_ns</name></name> <operator>=</operator> <call><name>SEC2NS</name><argument_list>(<argument><expr><name>max_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>sb_globals</name><operator>.</operator><name>max_events</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>sb_globals</name><operator>.</operator><name>max_time_ns</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_WARNING</name></expr></argument>, <argument><expr><literal type="string">"Both event and time limits are disabled, "</literal>
             <literal type="string">"running an endless test"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>sb_globals</name><operator>.</operator><name>max_time_ns</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Adjust the time limit if warmup time has been requested */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>sb_globals</name><operator>.</operator><name>warmup_time</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>sb_globals</name><operator>.</operator><name>max_time_ns</name></name> <operator>+=</operator> <call><name>SEC2NS</name><argument_list>(<argument><expr><name><name>sb_globals</name><operator>.</operator><name>warmup_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Parse the --forced-shutdown value */</comment>
    <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>sb_get_value_string</name><argument_list>(<argument><expr><literal type="string">"forced-shutdown"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>tmp</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>sb_globals</name><operator>.</operator><name>force_shutdown</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sb_globals</name><operator>.</operator><name>timeout</name></name> <operator>=</operator> <call><name>NS2SEC</name><argument_list>(<argument><expr><name><name>sb_globals</name><operator>.</operator><name>max_time_ns</name></name></expr></argument>)</argument_list></call> <operator>/</operator> <literal type="number">20</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><literal type="string">"off"</literal></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>
    
      <expr_stmt><expr><name><name>sb_globals</name><operator>.</operator><name>force_shutdown</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sb_globals</name><operator>.</operator><name>timeout</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>*</operator><name>endptr</name> <operator>==</operator> <literal type="char">'%'</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>sb_globals</name><operator>.</operator><name>timeout</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator> <operator>(</operator><name><name>sb_globals</name><operator>.</operator><name>timeout</name></name> <operator>*</operator>
                                         <call><name>NS2SEC</name><argument_list>(<argument><expr><name><name>sb_globals</name><operator>.</operator><name>max_time_ns</name></name></expr></argument>)</argument_list></call> <operator>/</operator> <literal type="number">100</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
      <if type="elseif">else if <condition>(<expr><operator>*</operator><name>tmp</name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>||</operator> <operator>*</operator><name>endptr</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_FATAL</name></expr></argument>, <argument><expr><literal type="string">"Invalid value for --forced-shutdown: '%s'"</literal></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>sb_globals</name><operator>.</operator><name>force_shutdown</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>err</name> <operator>=</operator> <call><name>sb_thread_init</name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>err</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name><name>sb_globals</name><operator>.</operator><name>debug</name></name> <operator>=</operator> <call><name>sb_get_value_flag</name><argument_list>(<argument><expr><literal type="string">"debug"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Automatically set logger verbosity to 'debug' */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>sb_globals</name><operator>.</operator><name>debug</name></name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>opt</name> <operator>=</operator> <call><name>sb_find_option</name><argument_list>(<argument><expr><literal type="string">"verbosity"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>opt</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>set_option</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"5"</literal></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  
  <expr_stmt><expr><name><name>sb_globals</name><operator>.</operator><name>validate</name></name> <operator>=</operator> <call><name>sb_get_value_flag</name><argument_list>(<argument><expr><literal type="string">"validate"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>sb_rand_init</name><argument_list>()</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>sb_globals</name><operator>.</operator><name>tx_rate</name></name> <operator>=</operator> <call><name>sb_get_value_int</name><argument_list>(<argument><expr><literal type="string">"rate"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>sb_globals</name><operator>.</operator><name>report_interval</name></name> <operator>=</operator> <call><name>sb_get_value_int</name><argument_list>(<argument><expr><literal type="string">"report-interval"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>sb_globals</name><operator>.</operator><name>n_checkpoints</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>checkpoints_list</name> <operator>=</operator> <call><name>sb_get_value_list</name><argument_list>(<argument><expr><literal type="string">"report-checkpoints"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <macro><name>SB_LIST_FOR_EACH</name><argument_list>(<argument>pos_val</argument>, <argument>checkpoints_list</argument>)</argument_list></macro>
  <block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type> <name>res</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>SB_LIST_ENTRY</name><argument_list>(<argument><expr><name>pos_val</name></expr></argument>, <argument><expr><name>value_t</name></expr></argument>, <argument><expr><name>listitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name><name>val</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>endptr</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>||</operator> <name><name>res</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>res</name></expr></argument> &gt;</argument_list></name> <name>INT_MAX</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_FATAL</name></expr></argument>, <argument><expr><literal type="string">"Invalid value for --report-checkpoints: '%s'"</literal></expr></argument>,
               <argument><expr><name><name>val</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>++</operator><name><name>sb_globals</name><operator>.</operator><name>n_checkpoints</name></name> <operator>&gt;</operator> <name>MAX_CHECKPOINTS</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_FATAL</name></expr></argument>, <argument><expr><literal type="string">"Too many checkpoints in --report-checkpoints "</literal>
               <literal type="string">"(up to %d can be defined)"</literal></expr></argument>, <argument><expr><name>MAX_CHECKPOINTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>sb_globals</name><operator>.</operator><name>checkpoints</name><index>[<expr><name><name>sb_globals</name><operator>.</operator><name>n_checkpoints</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name>res</name></expr>;</expr_stmt>
  </block_content>}</block>

  <if_stmt><if>if <condition>(<expr><name><name>sb_globals</name><operator>.</operator><name>n_checkpoints</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name><name>sb_globals</name><operator>.</operator><name>checkpoints</name></name></expr></argument>, <argument><expr><name><name>sb_globals</name><operator>.</operator><name>n_checkpoints</name></name></expr></argument>,
          <argument><expr>sizeof<operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator></expr></argument>, <argument><expr><name>checkpoint_cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Initialize timers */</comment>
  <expr_stmt><expr><name>timers</name> <operator>=</operator> <call><name>sb_alloc_per_thread_array</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sb_timer_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>timers_copy</name> <operator>=</operator> <call><name>sb_alloc_per_thread_array</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sb_timer_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>timers</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>timers_copy</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_FATAL</name></expr></argument>, <argument><expr><literal type="string">"Memory allocation failure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <for>for <control>(<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sb_globals</name><operator>.</operator><name>threads</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>sb_timer_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>timers</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

  <comment type="block">/* LuaJIT commands */</comment>
  <expr_stmt><expr><name><name>sb_globals</name><operator>.</operator><name>luajit_cmd</name></name> <operator>=</operator> <call><name>sb_get_value_string</name><argument_list>(<argument><expr><literal type="string">"luajit-cmd"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type> <name>main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>sb_test_t</name> <modifier>*</modifier></type><name>test</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>sb_globals</name><operator>.</operator><name>argc</name></name> <operator>=</operator> <name>argc</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sb_globals</name><operator>.</operator><name>argv</name></name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>argc</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>sb_globals</name><operator>.</operator><name>argv</name></name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>argc</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Initialize options library */</comment>
  <expr_stmt><expr><call><name>sb_options_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* First register the logger */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>log_register</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>EXIT_FAILURE</name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Register available tests */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>register_tests</name><argument_list>()</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Failed to register tests.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>EXIT_FAILURE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Parse command line arguments */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>parse_general_arguments</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>EXIT_FAILURE</name></expr>;</return></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>sb_get_value_flag</name><argument_list>(<argument><expr><literal type="string">"help"</literal></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>print_help</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>EXIT_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>sb_get_value_flag</name><argument_list>(<argument><expr><literal type="string">"version"</literal></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>VERSION_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>EXIT_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Initialize global variables and logger */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>init</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>log_init</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>sb_counters_init</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>EXIT_FAILURE</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>print_header</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>sb_globals</name><operator>.</operator><name>testname</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>sb_globals</name><operator>.</operator><name>testname</name></name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Is it a built-in test name? */</comment>
    <expr_stmt><expr><name>test</name> <operator>=</operator> <call><name>find_test</name><argument_list>(<argument><expr><name><name>sb_globals</name><operator>.</operator><name>testname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>test</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>sb_globals</name><operator>.</operator><name>cmdname</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Command is a mandatory argument for built-in tests */</comment>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"The '%s' test requires a command argument. "</literal>
              <literal type="string">"See 'sysbench %s help'\n"</literal></expr></argument>, <argument><expr><name><name>test</name><operator>-&gt;</operator><name>sname</name></name></expr></argument>, <argument><expr><name><name>test</name><operator>-&gt;</operator><name>sname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>EXIT_FAILURE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>test</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>test</name> <operator>=</operator> <call><name>sb_load_lua</name><argument_list>(<argument><expr><name><name>sb_globals</name><operator>.</operator><name>testname</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>EXIT_FAILURE</name></expr>;</return></block_content></block></if></if_stmt>

      <if_stmt><if>if <condition>(<expr><name><name>sb_globals</name><operator>.</operator><name>cmdname</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* No command specified, there's nothing more todo */</comment>
        <return>return <expr><ternary><condition><expr><name>test</name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>EXIT_SUCCESS</name></expr></then><else>: <expr><name>EXIT_FAILURE</name></expr></else></ternary></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <expr_stmt><expr><name><name>sb_globals</name><operator>.</operator><name>testname</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>SB_ISATTY</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>log_text</name><argument_list>(<argument><expr><name>LOG_NOTICE</name></expr></argument>, <argument><expr><literal type="string">"Reading the script from the standard input:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>test</name> <operator>=</operator> <call><name>sb_load_lua</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><ternary><condition><expr><name>test</name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>EXIT_SUCCESS</name></expr> </then><else>: <expr><name>EXIT_FAILURE</name></expr></else></ternary></expr>;</return>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><name>current_test</name> <operator>=</operator> <name>test</name></expr>;</expr_stmt>

  <comment type="block">/* Load and parse test-specific options */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>parse_test_arguments</name><argument_list>(<argument><expr><name>test</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>EXIT_FAILURE</name></expr>;</return></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>sb_lua_loaded</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>sb_lua_custom_command_defined</name><argument_list>(<argument><expr><name><name>sb_globals</name><operator>.</operator><name>cmdname</name></name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator>  <call><name>sb_lua_call_custom_command</name><argument_list>(<argument><expr><name><name>sb_globals</name><operator>.</operator><name>cmdname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>sb_globals</name><operator>.</operator><name>cmdname</name></name></expr></argument>, <argument><expr><literal type="string">"help"</literal></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>test</name><operator>-&gt;</operator><name>builtin_cmds</name><operator>.</operator><name>help</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name><name>test</name><operator>-&gt;</operator><name>builtin_cmds</name><operator>.</operator><name>help</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>EXIT_SUCCESS</name></expr>;</expr_stmt>
      <goto>goto <name>end</name>;</goto>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>test</name><operator>-&gt;</operator><name>args</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s options:\n"</literal></expr></argument>, <argument><expr><name><name>test</name><operator>-&gt;</operator><name>sname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sb_print_test_options</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>EXIT_SUCCESS</name></expr>;</expr_stmt>
      <goto>goto <name>end</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* We don't know want to print as help text, let the user know */</comment>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"'%s' test does not implement the 'help' command.\n"</literal></expr></argument>,
            <argument><expr><name><name>test</name><operator>-&gt;</operator><name>sname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>EXIT_FAILURE</name></expr>;</return>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>sb_globals</name><operator>.</operator><name>cmdname</name></name></expr></argument>, <argument><expr><literal type="string">"prepare"</literal></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>test</name><operator>-&gt;</operator><name>builtin_cmds</name><operator>.</operator><name>prepare</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"'%s' test does not implement the 'prepare' command.\n"</literal></expr></argument>,
              <argument><expr><name><name>test</name><operator>-&gt;</operator><name>sname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>EXIT_FAILURE</name></expr>;</expr_stmt>
      <goto>goto <name>end</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>test</name><operator>-&gt;</operator><name>builtin_cmds</name><operator>.</operator><name>prepare</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>sb_globals</name><operator>.</operator><name>cmdname</name></name></expr></argument>, <argument><expr><literal type="string">"cleanup"</literal></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>test</name><operator>-&gt;</operator><name>builtin_cmds</name><operator>.</operator><name>cleanup</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"'%s' test does not implement the 'cleanup' command.\n"</literal></expr></argument>,
              <argument><expr><name><name>test</name><operator>-&gt;</operator><name>sname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>EXIT_FAILURE</name></expr>;</expr_stmt>
      <goto>goto <name>end</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>test</name><operator>-&gt;</operator><name>builtin_cmds</name><operator>.</operator><name>cleanup</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>sb_globals</name><operator>.</operator><name>cmdname</name></name></expr></argument>, <argument><expr><literal type="string">"run"</literal></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <ternary><condition><expr><call><name>run_test</name><argument_list>(<argument><expr><name>test</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>EXIT_FAILURE</name></expr> </then><else>: <expr><name>EXIT_SUCCESS</name></expr></else></ternary></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Unknown command: %s\n"</literal></expr></argument>, <argument><expr><name><name>sb_globals</name><operator>.</operator><name>cmdname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>EXIT_FAILURE</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

<label><name>end</name>:</label>
  <if_stmt><if>if <condition>(<expr><call><name>sb_lua_loaded</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>sb_lua_done</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>db_done</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>sb_counters_done</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>log_done</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>sb_options_done</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>sb_rand_done</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>sb_thread_done</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>timers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>timers_copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>sb_globals</name><operator>.</operator><name>argv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Print a description of available command line options for the current test */</comment>

<function><type><name>void</name></type> <name>sb_print_test_options</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>current_test</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>sb_print_options</name><argument_list>(<argument><expr><name><name>current_test</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
  Allocate an array of objects of the specified size for all threads, both
  worker and background ones.
*/</comment>

<function><type><name>void</name> <modifier>*</modifier></type><name>sb_alloc_per_thread_array</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/*
    We want to exclude queries executed by background threads from statistics
    generated for worker threads.

    To simplify code, we allocate all timers and counters for all worker threads
    + possible background threads created by sysbench for statistic reports,
    etc. When executing requests from background threads, extra array slots will
    be used (it depends on the assigned ID for each thread). When aggregating
    counters and timers, we only consider slots in the range [0,
    sb_globals.threads - 1], i.e. ignore statistics generated by background
    threads. Currently we assign the same single thread ID for all background
    threads, so they also share the same single slot in each allocated array.
  */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>bsize</name> <init>= <expr><operator>(</operator><name><name>sb_globals</name><operator>.</operator><name>threads</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>size</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>sb_memalign</name><argument_list>(<argument><expr><name>bsize</name></expr></argument>, <argument><expr><name>CK_MD_CACHELINE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>bsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>ptr</name></expr>;</return>
</block_content>}</block></function>
</unit>
