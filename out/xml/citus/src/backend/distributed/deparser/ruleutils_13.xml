<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/builded_projects/citus/src/backend/distributed/deparser/ruleutils_13.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * ruleutils_13.c
 *	  Functions to convert stored expressions/querytrees back to
 *	  source text
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/distributed/deparser/ruleutils_13.c
 *
 * This needs to be closely in sync with the core code.
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_version_constants.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_config.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <name>PG_VERSION_13</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <name>PG_VERSION_14</name><operator>)</operator></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/amapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_aggregate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_authid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_constraint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_depend.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_extension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_foreign_data_wrapper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_language.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_opclass.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_operator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_partitioned_table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_statistic_ext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/extension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/keywords.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_nodefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_ruleutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/spi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"foreign/foreign.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pathnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_node.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_agg.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_func.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_node.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_oper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parser.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteHandler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteManip.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteSupport.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/hsearch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ruleutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/varlena.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/xml.h"</cpp:file></cpp:include>


<comment type="block">/* ----------
 * Pretty formatting constants
 * ----------
 */</comment>

<comment type="block">/* Indent counts */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRETTYINDENT_STD</name></cpp:macro>		<cpp:value>8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRETTYINDENT_JOIN</name></cpp:macro>		<cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRETTYINDENT_VAR</name></cpp:macro>		<cpp:value>4</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRETTYINDENT_LIMIT</name></cpp:macro>		<cpp:value>40</cpp:value></cpp:define>	<comment type="block">/* wrap limit */</comment>

<comment type="block">/* Pretty flags */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRETTYFLAG_PAREN</name></cpp:macro>		<cpp:value>0x0001</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRETTYFLAG_INDENT</name></cpp:macro>		<cpp:value>0x0002</cpp:value></cpp:define>

<comment type="block">/* Default line length for pretty-print wrapping: 0 means wrap always */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRAP_COLUMN_DEFAULT</name></cpp:macro>		<cpp:value>0</cpp:value></cpp:define>

<comment type="block">/* macros to test if pretty action needed */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRETTY_PAREN</name><parameter_list>(<parameter><type><name>context</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((context)-&gt;prettyFlags &amp; PRETTYFLAG_PAREN)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRETTY_INDENT</name><parameter_list>(<parameter><type><name>context</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((context)-&gt;prettyFlags &amp; PRETTYFLAG_INDENT)</cpp:value></cpp:define>


<comment type="block">/* ----------
 * Local data types
 * ----------
 */</comment>

<comment type="block">/* Context info needed for invoking a recursive querytree display routine */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name></decl>;</decl_stmt>			<comment type="block">/* output buffer to append to */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>namespaces</name></decl>;</decl_stmt>		<comment type="block">/* List of deparse_namespace nodes */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>windowClause</name></decl>;</decl_stmt>	<comment type="block">/* Current query level's WINDOW clause */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>windowTList</name></decl>;</decl_stmt>	<comment type="block">/* targetlist for resolving WINDOW clause */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>prettyFlags</name></decl>;</decl_stmt>	<comment type="block">/* enabling of pretty-print functions */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>wrapColumn</name></decl>;</decl_stmt>		<comment type="block">/* max line length, or -1 for no limit */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>indentLevel</name></decl>;</decl_stmt>	<comment type="block">/* current indent level for prettyprint */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>varprefix</name></decl>;</decl_stmt>		<comment type="block">/* true to print prefixes on Vars */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>distrelid</name></decl>;</decl_stmt>		<comment type="block">/* the distributed table being modified, if valid */</comment>
	<decl_stmt><decl><type><name>int64</name></type>		<name>shardid</name></decl>;</decl_stmt>		<comment type="block">/* a distributed table's shardid, if positive */</comment>
	<decl_stmt><decl><type><name>ParseExprKind</name></type> <name>special_exprkind</name></decl>;</decl_stmt> <comment type="block">/* set only for exprkinds needing special
									 * handling */</comment>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>appendparents</name></decl>;</decl_stmt>	<comment type="block">/* if not null, map child Vars of these relids
								 * back to the parent rel */</comment>
}</block></struct></type> <name>deparse_context</name>;</typedef>

<comment type="block">/*
 * Each level of query context around a subtree needs a level of Var namespace.
 * A Var having varlevelsup=N refers to the N'th item (counting from 0) in
 * the current context's namespaces list.
 *
 * The rangetable is the list of actual RTEs from the query tree, and the
 * cte list is the list of actual CTEs.
 *
 * rtable_names holds the alias name to be used for each RTE (either a C
 * string, or NULL for nameless RTEs such as unnamed joins).
 * rtable_columns holds the column alias names to be used for each RTE.
 *
 * In some cases we need to make names of merged JOIN USING columns unique
 * across the whole query, not only per-RTE.  If so, unique_using is true
 * and using_names is a list of C strings representing names already assigned
 * to USING columns.
 *
 * When deparsing plan trees, there is always just a single item in the
 * deparse_namespace list (since a plan tree never contains Vars with
 * varlevelsup &gt; 0).  We store the PlanState node that is the immediate
 * parent of the expression to be deparsed, as well as a list of that
 * PlanState's ancestors.  In addition, we store its outer and inner subplan
 * state nodes, as well as their plan nodes' targetlists, and the index tlist
 * if the current plan node might contain INDEX_VAR Vars.  (These fields could
 * be derived on-the-fly from the current PlanState, but it seems notationally
 * clearer to set them up as separate fields.)
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rtable</name></decl>;</decl_stmt>			<comment type="block">/* List of RangeTblEntry nodes */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rtable_names</name></decl>;</decl_stmt>	<comment type="block">/* Parallel list of names for RTEs */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rtable_columns</name></decl>;</decl_stmt> <comment type="block">/* Parallel list of deparse_columns structs */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>subplans</name></decl>;</decl_stmt>		<comment type="block">/* List of Plan trees for SubPlans */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>ctes</name></decl>;</decl_stmt>			<comment type="block">/* List of CommonTableExpr nodes */</comment>
	<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>appendrels</name></decl>;</decl_stmt> <comment type="block">/* Array of AppendRelInfo nodes, or NULL */</comment>
	<comment type="block">/* Workspace for column alias assignment: */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>unique_using</name></decl>;</decl_stmt>	<comment type="block">/* Are we making USING names globally unique */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>using_names</name></decl>;</decl_stmt>	<comment type="block">/* List of assigned names for USING columns */</comment>
	<comment type="block">/* Remaining fields are used only when deparsing a Plan tree: */</comment>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>			<comment type="block">/* immediate parent of current expression */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>ancestors</name></decl>;</decl_stmt>		<comment type="block">/* ancestors of planstate */</comment>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>outer_plan</name></decl>;</decl_stmt>		<comment type="block">/* outer subnode, or NULL if none */</comment>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>inner_plan</name></decl>;</decl_stmt>		<comment type="block">/* inner subnode, or NULL if none */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>outer_tlist</name></decl>;</decl_stmt>	<comment type="block">/* referent for OUTER_VAR Vars */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>inner_tlist</name></decl>;</decl_stmt>	<comment type="block">/* referent for INNER_VAR Vars */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>index_tlist</name></decl>;</decl_stmt>	<comment type="block">/* referent for INDEX_VAR Vars */</comment>
}</block></struct></type> <name>deparse_namespace</name>;</typedef>

<comment type="block">/* Callback signature for resolve_special_varno() */</comment>
<typedef>typedef <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>rsv_callback</name>) <parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
							  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>callback_arg</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<comment type="block">/*
 * Per-relation data about column alias names.
 *
 * Selecting aliases is unreasonably complicated because of the need to dump
 * rules/views whose underlying tables may have had columns added, deleted, or
 * renamed since the query was parsed.  We must nonetheless print the rule/view
 * in a form that can be reloaded and will produce the same results as before.
 *
 * For each RTE used in the query, we must assign column aliases that are
 * unique within that RTE.  SQL does not require this of the original query,
 * but due to factors such as *-expansion we need to be able to uniquely
 * reference every column in a decompiled query.  As long as we qualify all
 * column references, per-RTE uniqueness is sufficient for that.
 *
 * However, we can't ensure per-column name uniqueness for unnamed join RTEs,
 * since they just inherit column names from their input RTEs, and we can't
 * rename the columns at the join level.  Most of the time this isn't an issue
 * because we don't need to reference the join's output columns as such; we
 * can reference the input columns instead.  That approach can fail for merged
 * JOIN USING columns, however, so when we have one of those in an unnamed
 * join, we have to make that column's alias globally unique across the whole
 * query to ensure it can be referenced unambiguously.
 *
 * Another problem is that a JOIN USING clause requires the columns to be
 * merged to have the same aliases in both input RTEs, and that no other
 * columns in those RTEs or their children conflict with the USING names.
 * To handle that, we do USING-column alias assignment in a recursive
 * traversal of the query's jointree.  When descending through a JOIN with
 * USING, we preassign the USING column names to the child columns, overriding
 * other rules for column alias assignment.  We also mark each RTE with a list
 * of all USING column names selected for joins containing that RTE, so that
 * when we assign other columns' aliases later, we can avoid conflicts.
 *
 * Another problem is that if a JOIN's input tables have had columns added or
 * deleted since the query was parsed, we must generate a column alias list
 * for the join that matches the current set of input columns --- otherwise, a
 * change in the number of columns in the left input would throw off matching
 * of aliases to columns of the right input.  Thus, positions in the printable
 * column alias list are not necessarily one-for-one with varattnos of the
 * JOIN, so we need a separate new_colnames[] array for printing purposes.
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<comment type="block">/*
	 * colnames is an array containing column aliases to use for columns that
	 * existed when the query was parsed.  Dropped columns have NULL entries.
	 * This array can be directly indexed by varattno to get a Var's name.
	 *
	 * Non-NULL entries are guaranteed unique within the RTE, *except* when
	 * this is for an unnamed JOIN RTE.  In that case we merely copy up names
	 * from the two input RTEs.
	 *
	 * During the recursive descent in set_using_names(), forcible assignment
	 * of a child RTE's column name is represented by pre-setting that element
	 * of the child's colnames array.  So at that stage, NULL entries in this
	 * array just mean that no name has been preassigned, not necessarily that
	 * the column is dropped.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_cols</name></decl>;</decl_stmt>		<comment type="block">/* length of colnames[] array */</comment>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>colnames</name></decl>;</decl_stmt>		<comment type="block">/* array of C strings and NULLs */</comment>

	<comment type="block">/*
	 * new_colnames is an array containing column aliases to use for columns
	 * that would exist if the query was re-parsed against the current
	 * definitions of its base tables.  This is what to print as the column
	 * alias list for the RTE.  This array does not include dropped columns,
	 * but it will include columns added since original parsing.  Indexes in
	 * it therefore have little to do with current varattno values.  As above,
	 * entries are unique unless this is for an unnamed JOIN RTE.  (In such an
	 * RTE, we never actually print this array, but we must compute it anyway
	 * for possible use in computing column names of upper joins.) The
	 * parallel array is_new_col marks which of these columns are new since
	 * original parsing.  Entries with is_new_col false must match the
	 * non-NULL colnames entries one-for-one.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_new_cols</name></decl>;</decl_stmt>	<comment type="block">/* length of new_colnames[] array */</comment>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>new_colnames</name></decl>;</decl_stmt>	<comment type="block">/* array of C strings */</comment>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>is_new_col</name></decl>;</decl_stmt>		<comment type="block">/* array of bool flags */</comment>

	<comment type="block">/* This flag tells whether we should actually print a column alias list */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>printaliases</name></decl>;</decl_stmt>

	<comment type="block">/* This list has all names used as USING names in joins above this RTE */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>parentUsing</name></decl>;</decl_stmt>	<comment type="block">/* names assigned to parent merged columns */</comment>

	<comment type="block">/*
	 * If this struct is for a JOIN RTE, we fill these fields during the
	 * set_using_names() pass to describe its relationship to its child RTEs.
	 *
	 * leftattnos and rightattnos are arrays with one entry per existing
	 * output column of the join (hence, indexable by join varattno).  For a
	 * simple reference to a column of the left child, leftattnos[i] is the
	 * child RTE's attno and rightattnos[i] is zero; and conversely for a
	 * column of the right child.  But for merged columns produced by JOIN
	 * USING/NATURAL JOIN, both leftattnos[i] and rightattnos[i] are nonzero.
	 * Also, if the column has been dropped, both are zero.
	 *
	 * If it's a JOIN USING, usingNames holds the alias names selected for the
	 * merged columns (these might be different from the original USING list,
	 * if we had to modify names to achieve uniqueness).
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>leftrti</name></decl>;</decl_stmt>		<comment type="block">/* rangetable index of left child */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>rightrti</name></decl>;</decl_stmt>		<comment type="block">/* rangetable index of right child */</comment>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>leftattnos</name></decl>;</decl_stmt>		<comment type="block">/* left-child varattnos of join cols, or 0 */</comment>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>rightattnos</name></decl>;</decl_stmt>	<comment type="block">/* right-child varattnos of join cols, or 0 */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>usingNames</name></decl>;</decl_stmt>		<comment type="block">/* names assigned to merged columns */</comment>
}</block></struct></type> <name>deparse_columns</name>;</typedef>

<comment type="block">/* This macro is analogous to rt_fetch(), but for deparse_columns structs */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>deparse_columns_fetch</name><parameter_list>(<parameter><type><name>rangetable_index</name></type></parameter>, <parameter><type><name>dpns</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>((deparse_columns *) list_nth((dpns)-&gt;rtable_columns, (rangetable_index)-1))</cpp:value></cpp:define>

<comment type="block">/*
 * Entry in set_rtable_names' hash table
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>char</name></type>		<name><name>name</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* Hash key --- must be first */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>counter</name></decl>;</decl_stmt>		<comment type="block">/* Largest addition used so far for name */</comment>
}</block></struct></type> <name>NameHashEntry</name>;</typedef>


<comment type="block">/* ----------
 * Local functions
 *
 * Most of these functions used to use fixed-size buffers to build their
 * results.  Now, they take an (already initialized) StringInfo object
 * as a parameter, and append their text output to its contents.
 * ----------
 */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_rtable_names</name><parameter_list>(<parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>parent_namespaces</name></decl></parameter>,
				 <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>rels_used</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_deparse_for_query</name><parameter_list>(<parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>parent_namespaces</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>has_dangerous_join_using</name><parameter_list>(<parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>jtnode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_using_names</name><parameter_list>(<parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>jtnode</name></decl></parameter>,
				<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>parentUsing</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_relation_column_names</name><parameter_list>(<parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl></parameter>,
						  <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>,
						  <parameter><decl><type><name>deparse_columns</name> <modifier>*</modifier></type><name>colinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_join_column_names</name><parameter_list>(<parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>,
					  <parameter><decl><type><name>deparse_columns</name> <modifier>*</modifier></type><name>colinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>colname_is_unique</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colname</name></decl></parameter>, <parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl></parameter>,
				  <parameter><decl><type><name>deparse_columns</name> <modifier>*</modifier></type><name>colinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>make_colname_unique</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>colname</name></decl></parameter>, <parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl></parameter>,
					<parameter><decl><type><name>deparse_columns</name> <modifier>*</modifier></type><name>colinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>expand_colnames_array_to</name><parameter_list>(<parameter><decl><type><name>deparse_columns</name> <modifier>*</modifier></type><name>colinfo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>identify_join_columns</name><parameter_list>(<parameter><decl><type><name>JoinExpr</name> <modifier>*</modifier></type><name>j</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>jrte</name></decl></parameter>,
					  <parameter><decl><type><name>deparse_columns</name> <modifier>*</modifier></type><name>colinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>get_rtable_name</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>rtindex</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_deparse_plan</name><parameter_list>(<parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>push_child_plan</name><parameter_list>(<parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>,
				<parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>save_dpns</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pop_child_plan</name><parameter_list>(<parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl></parameter>,
			   <parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>save_dpns</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>push_ancestor_plan</name><parameter_list>(<parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl></parameter>, <parameter><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>ancestor_cell</name></decl></parameter>,
				   <parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>save_dpns</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pop_ancestor_plan</name><parameter_list>(<parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl></parameter>,
				  <parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>save_dpns</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_query_def</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>parentnamespace</name></decl></parameter>,
			  <parameter><decl><type><name>TupleDesc</name></type> <name>resultDesc</name></decl></parameter>,
			  <parameter><decl><type><name>int</name></type> <name>prettyFlags</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>wrapColumn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startIndent</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_query_def_extended</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>,
				<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>parentnamespace</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>distrelid</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>shardid</name></decl></parameter>,
				<parameter><decl><type><name>TupleDesc</name></type> <name>resultDesc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>prettyFlags</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>wrapColumn</name></decl></parameter>,
				<parameter><decl><type><name>int</name></type> <name>startIndent</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_values_def</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>values_lists</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_with_clause</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_select_query_def</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
					 <parameter><decl><type><name>TupleDesc</name></type> <name>resultDesc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_insert_query_def</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_update_query_def</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_update_query_targetlist_def</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>,
								<parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
								<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_delete_query_def</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_utility_query_def</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_basic_select_query</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
					   <parameter><decl><type><name>TupleDesc</name></type> <name>resultDesc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_target_list</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
				<parameter><decl><type><name>TupleDesc</name></type> <name>resultDesc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_setop_query</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>setOp</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
				<parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
				<parameter><decl><type><name>TupleDesc</name></type> <name>resultDesc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>get_rule_sortgroupclause</name><parameter_list>(<parameter><decl><type><name>Index</name></type> <name>ref</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>force_colno</name></decl></parameter>,
						 <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_rule_groupingset</name><parameter_list>(<parameter><decl><type><name>GroupingSet</name> <modifier>*</modifier></type><name>gset</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetlist</name></decl></parameter>,
					 <parameter><decl><type><name>bool</name></type> <name>omit_parens</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_rule_orderby</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>orderList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name></type> <name>force_colno</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_rule_windowclause</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_rule_windowspec</name><parameter_list>(<parameter><decl><type><name>WindowClause</name> <modifier>*</modifier></type><name>wc</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>,
					<parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>get_variable</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>levelsup</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>istoplevel</name></decl></parameter>,
			 <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_special_variable</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
					 <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>callback_arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>resolve_special_varno</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
					<parameter><decl><type><name>rsv_callback</name></type> <name>callback</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>callback_arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>find_param_referent</name><parameter_list>(<parameter><decl><type><name>Param</name> <modifier>*</modifier></type><name>param</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
					<parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier><modifier>*</modifier></type><name>dpns_p</name></decl></parameter>, <parameter><decl><type><name>ListCell</name> <modifier>*</modifier><modifier>*</modifier></type><name>ancestor_cell_p</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_parameter</name><parameter_list>(<parameter><decl><type><name>Param</name> <modifier>*</modifier></type><name>param</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>get_simple_binary_op_name</name><parameter_list>(<parameter><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>isSimpleNode</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parentNode</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>prettyFlags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>appendContextKeyword</name><parameter_list>(<parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>,
					 <parameter><decl><type><name>int</name></type> <name>indentBefore</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>indentAfter</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>indentPlus</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>removeStringInfoSpaces</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_rule_expr</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
			  <parameter><decl><type><name>bool</name></type> <name>showimplicit</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_rule_expr_toplevel</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>showimplicit</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_rule_expr_funccall</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>showimplicit</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>looks_like_function</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_oper_expr</name><parameter_list>(<parameter><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_func_expr</name><parameter_list>(<parameter><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
			  <parameter><decl><type><name>bool</name></type> <name>showimplicit</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_agg_expr</name><parameter_list>(<parameter><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>aggref</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
			 <parameter><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>original_aggref</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_agg_combine_expr</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
					 <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>callback_arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_windowfunc_expr</name><parameter_list>(<parameter><decl><type><name>WindowFunc</name> <modifier>*</modifier></type><name>wfunc</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_coercion_expr</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
				  <parameter><decl><type><name>Oid</name></type> <name>resulttype</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>resulttypmod</name></decl></parameter>,
				  <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parentNode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_const_expr</name><parameter_list>(<parameter><decl><type><name>Const</name> <modifier>*</modifier></type><name>constval</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
			   <parameter><decl><type><name>int</name></type> <name>showtype</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_const_collation</name><parameter_list>(<parameter><decl><type><name>Const</name> <modifier>*</modifier></type><name>constval</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>simple_quote_literal</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_sublink_expr</name><parameter_list>(<parameter><decl><type><name>SubLink</name> <modifier>*</modifier></type><name>sublink</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_tablefunc</name><parameter_list>(<parameter><decl><type><name>TableFunc</name> <modifier>*</modifier></type><name>tf</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
			  <parameter><decl><type><name>bool</name></type> <name>showimplicit</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_from_clause</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>,
				<parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_from_clause_item</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>jtnode</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
					 <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_column_alias_list</name><parameter_list>(<parameter><decl><type><name>deparse_columns</name> <modifier>*</modifier></type><name>colinfo</name></decl></parameter>,
					  <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_from_clause_coldeflist</name><parameter_list>(<parameter><decl><type><name>RangeTblFunction</name> <modifier>*</modifier></type><name>rtfunc</name></decl></parameter>,
						   <parameter><decl><type><name>deparse_columns</name> <modifier>*</modifier></type><name>colinfo</name></decl></parameter>,
						   <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_tablesample_def</name><parameter_list>(<parameter><decl><type><name>TableSampleClause</name> <modifier>*</modifier></type><name>tablesample</name></decl></parameter>,
					<parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_opclass_name</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opclass</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>actual_datatype</name></decl></parameter>,
				 <parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>processIndirection</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>printSubscripts</name><parameter_list>(<parameter><decl><type><name>SubscriptingRef</name> <modifier>*</modifier></type><name>aref</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>get_relation_name</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>generate_relation_or_shard_name</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>distrelid</name></decl></parameter>,
				<parameter><decl><type><name>int64</name></type> <name>shardid</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>namespaces</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>generate_rte_shard_name</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>generate_fragment_name</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>schemaName</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>tableName</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>generate_function_name</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>argnames</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>argtypes</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>has_variadic</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>use_variadic_p</name></decl></parameter>,
					   <parameter><decl><type><name>ParseExprKind</name></type> <name>special_exprkind</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>only_marker</name><parameter_list>(<parameter><type><name>rte</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>((rte)-&gt;inh ? "" : "ONLY ")</cpp:value></cpp:define>



<comment type="block">/*
 * pg_get_query_def parses back one query tree, and outputs the resulting query
 * string into given buffer.
 */</comment>
<function><type><name>void</name></type>
<name>pg_get_query_def</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>get_query_def</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>WRAP_COLUMN_DEFAULT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_merged_argument_list merges both IN and OUT arguments lists into one and also
 * eliminates the INOUT duplicates(present in both the lists).
 */</comment>
<function><type><name>bool</name></type>
<name>get_merged_argument_list</name><parameter_list>(<parameter><decl><type><name>CallStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>mergedNamedArgList</name></decl></parameter>,
					   <parameter><decl><type><name>Oid</name> <modifier>*</modifier><modifier>*</modifier></type><name>mergedNamedArgTypes</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>mergedArgumentList</name></decl></parameter>,
					   <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>totalArguments</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* No OUT argument support in Postgres 13 */</comment>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pg_get_rule_expr deparses an expression and returns the result as a string.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>pg_get_rule_expr</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expression</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>showImplicitCasts</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>deparse_context</name></type> <name>context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OverrideSearchPath</name> <modifier>*</modifier></type><name>overridePath</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>buffer</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Set search_path to NIL so that all objects outside of pg_catalog will be
	 * schema-prefixed. pg_catalog will be added automatically when we call
	 * PushOverrideSearchPath(), since we set addCatalog to true;
	 */</comment>
	<expr_stmt><expr><name>overridePath</name> <operator>=</operator> <call><name>GetOverrideSearchPath</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>overridePath</name><operator>-&gt;</operator><name>schemas</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>overridePath</name><operator>-&gt;</operator><name>addCatalog</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PushOverrideSearchPath</name><argument_list>(<argument><expr><name>overridePath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>buf</name></name> <operator>=</operator> <name>buffer</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>namespaces</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>windowClause</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>windowTList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>varprefix</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>prettyFlags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>wrapColumn</name></name> <operator>=</operator> <name>WRAP_COLUMN_DEFAULT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>indentLevel</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>special_exprkind</name></name> <operator>=</operator> <name>EXPR_KIND_NONE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>distrelid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>shardid</name></name> <operator>=</operator> <name>INVALID_SHARD_ID</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name>expression</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>, <argument><expr><name>showImplicitCasts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* revert back to original search_path */</comment>
	<expr_stmt><expr><call><name>PopOverrideSearchPath</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>buffer</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * set_rtable_names: select RTE aliases to be used in printing a query
 *
 * We fill in dpns-&gt;rtable_names with a list of names that is one-for-one with
 * the already-filled dpns-&gt;rtable list.  Each RTE name is unique among those
 * in the new namespace plus any ancestor namespaces listed in
 * parent_namespaces.
 *
 * If rels_used isn't NULL, only RTE indexes listed in it are given aliases.
 *
 * Note that this function is only concerned with relation names, not column
 * names.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_rtable_names</name><parameter_list>(<parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>parent_namespaces</name></decl></parameter>,
				 <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>rels_used</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>hash_ctl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HTAB</name>	   <modifier>*</modifier></type><name>names_hash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NameHashEntry</name> <modifier>*</modifier></type><name>hentry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rtindex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>rtable_names</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<comment type="block">/* nothing more to do if empty rtable */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dpns</name><operator>-&gt;</operator><name>rtable</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We use a hash table to hold known names, so that this process is O(N)
	 * not O(N^2) for N names.
	 */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hash_ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <name>NAMEDATALEN</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>NameHashEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>names_hash</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"set_rtable_names names"</literal></expr></argument>,
							 <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>,
							 <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Preload the hash table with names appearing in parent_namespaces */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>parent_namespaces</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>olddpns</name> <init>= <expr><operator>(</operator><name>deparse_namespace</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>olddpns-&gt;rtable_names</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oldname</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>oldname</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>hentry</name> <operator>=</operator> <operator>(</operator><name>NameHashEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>names_hash</name></expr></argument>,
												   <argument><expr><name>oldname</name></expr></argument>,
												   <argument><expr><name>HASH_ENTER</name></expr></argument>,
												   <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* we do not complain about duplicate names in parent namespaces */</comment>
			<expr_stmt><expr><name><name>hentry</name><operator>-&gt;</operator><name>counter</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block>

	<comment type="block">/* Now we can scan the rtable */</comment>
	<expr_stmt><expr><name>rtindex</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>dpns-&gt;rtable</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>refname</name></decl>;</decl_stmt>

		<comment type="block">/* Just in case this takes an unreasonable amount of time ... */</comment>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>rels_used</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name>rtindex</name></expr></argument>, <argument><expr><name>rels_used</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Ignore unreferenced RTE */</comment>
			<expr_stmt><expr><name>refname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>alias</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* If RTE has a user-defined alias, prefer that */</comment>
			<expr_stmt><expr><name>refname</name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>alias</name><operator>-&gt;</operator><name>aliasname</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Use the current actual name of the relation */</comment>
			<expr_stmt><expr><name>refname</name> <operator>=</operator> <call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_JOIN</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Unnamed join has no refname */</comment>
			<expr_stmt><expr><name>refname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Otherwise use whatever the parser assigned */</comment>
			<expr_stmt><expr><name>refname</name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * If the selected name isn't unique, append digits to make it so, and
		 * make a new hash entry for it once we've got a unique name.  For a
		 * very long input name, we might have to truncate to stay within
		 * NAMEDATALEN.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>refname</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>hentry</name> <operator>=</operator> <operator>(</operator><name>NameHashEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>names_hash</name></expr></argument>,
												   <argument><expr><name>refname</name></expr></argument>,
												   <argument><expr><name>HASH_ENTER</name></expr></argument>,
												   <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Name already in use, must choose a new one */</comment>
				<decl_stmt><decl><type><name>int</name></type>			<name>refnamelen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>refname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>modname</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>refnamelen</name> <operator>+</operator> <literal type="number">16</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>NameHashEntry</name> <modifier>*</modifier></type><name>hentry2</name></decl>;</decl_stmt>

				<do>do
				<block>{<block_content>
					<expr_stmt><expr><name><name>hentry</name><operator>-&gt;</operator><name>counter</name></name><operator>++</operator></expr>;</expr_stmt>
					<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
					<block>{<block_content>
						<comment type="block">/*
						 * We avoid using %.*s here because it can misbehave
						 * if the data is not valid in what libc thinks is the
						 * prevailing encoding.
						 */</comment>
						<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>modname</name></expr></argument>, <argument><expr><name>refname</name></expr></argument>, <argument><expr><name>refnamelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>modname</name> <operator>+</operator> <name>refnamelen</name></expr></argument>, <argument><expr><literal type="string">"_%d"</literal></expr></argument>, <argument><expr><name><name>hentry</name><operator>-&gt;</operator><name>counter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>modname</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>NAMEDATALEN</name></expr>)</condition><block type="pseudo"><block_content>
							<break>break;</break></block_content></block></if></if_stmt>
						<comment type="block">/* drop chars from refname to keep all the digits */</comment>
						<expr_stmt><expr><name>refnamelen</name> <operator>=</operator> <call><name>pg_mbcliplen</name><argument_list>(<argument><expr><name>refname</name></expr></argument>, <argument><expr><name>refnamelen</name></expr></argument>,
												  <argument><expr><name>refnamelen</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></for>
					<expr_stmt><expr><name>hentry2</name> <operator>=</operator> <operator>(</operator><name>NameHashEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>names_hash</name></expr></argument>,
															<argument><expr><name>modname</name></expr></argument>,
															<argument><expr><name>HASH_ENTER</name></expr></argument>,
															<argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block> while <condition>(<expr><name>found</name></expr>)</condition>;</do>
				<expr_stmt><expr><name><name>hentry2</name><operator>-&gt;</operator><name>counter</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>	<comment type="block">/* init new hash entry */</comment>
				<expr_stmt><expr><name>refname</name> <operator>=</operator> <name>modname</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Name not previously used, need only initialize hentry */</comment>
				<expr_stmt><expr><name><name>hentry</name><operator>-&gt;</operator><name>counter</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>rtable_names</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>rtable_names</name></name></expr></argument>, <argument><expr><name>refname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rtindex</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name>names_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * set_deparse_for_query: set up deparse_namespace for deparsing a Query tree
 *
 * For convenience, this is defined to initialize the deparse_namespace struct
 * from scratch.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_deparse_for_query</name><parameter_list>(<parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>parent_namespaces</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

	<comment type="block">/* Initialize *dpns and fill rtable/ctes links */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>deparse_namespace</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>subplans</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>ctes</name></name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>cteList</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>appendrels</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* Assign a unique relation alias to each RTE */</comment>
	<expr_stmt><expr><call><name>set_rtable_names</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><name>parent_namespaces</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize dpns-&gt;rtable_columns to contain zeroed structs */</comment>
	<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>rtable_columns</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>rtable_columns</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>rtable_columns</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>rtable_columns</name></name></expr></argument>,
									   <argument><expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>deparse_columns</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

	<comment type="block">/* If it's a utility query, it won't have a jointree */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>jointree</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Detect whether global uniqueness of USING names is needed */</comment>
		<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>unique_using</name></name> <operator>=</operator>
			<call><name>has_dangerous_join_using</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Select names for columns merged by USING, via a recursive pass over
		 * the query jointree.
		 */</comment>
		<expr_stmt><expr><call><name>set_using_names</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Now assign remaining column aliases for each RTE.  We do this in a
	 * linear scan of the rtable, so as to process RTEs whether or not they
	 * are in the jointree (we mustn't miss NEW.*, INSERT target relations,
	 * etc).  JOIN RTEs must be processed after their children, but this is
	 * okay because they appear later in the rtable list than their children
	 * (cf Asserts in identify_join_columns()).
	 */</comment>
	<macro><name>forboth</name><argument_list>(<argument>lc</argument>, <argument>dpns-&gt;rtable</argument>, <argument>lc2</argument>, <argument>dpns-&gt;rtable_columns</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>deparse_columns</name> <modifier>*</modifier></type><name>colinfo</name> <init>= <expr><operator>(</operator><name>deparse_columns</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_JOIN</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>set_join_column_names</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>colinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>set_relation_column_names</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>colinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * has_dangerous_join_using: search jointree for unnamed JOIN USING
 *
 * Merged columns of a JOIN USING may act differently from either of the input
 * columns, either because they are merged with COALESCE (in a FULL JOIN) or
 * because an implicit coercion of the underlying input column is required.
 * In such a case the column must be referenced as a column of the JOIN not as
 * a column of either input.  And this is problematic if the join is unnamed
 * (alias-less): we cannot qualify the column's name with an RTE name, since
 * there is none.  (Forcibly assigning an alias to the join is not a solution,
 * since that will prevent legal references to tables below the join.)
 * To ensure that every column in the query is unambiguously referenceable,
 * we must assign such merged columns names that are globally unique across
 * the whole query, aliasing other columns out of the way as necessary.
 *
 * Because the ensuing re-aliasing is fairly damaging to the readability of
 * the query, we don't do this unless we have to.  So, we must pre-scan
 * the join tree to see if we have to, before starting set_using_names().
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>has_dangerous_join_using</name><parameter_list>(<parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>jtnode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* nothing to do here */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>FromExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FromExpr</name>   <modifier>*</modifier></type><name>f</name> <init>= <expr><operator>(</operator><name>FromExpr</name> <operator>*</operator><operator>)</operator> <name>jtnode</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>f-&gt;fromlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>has_dangerous_join_using</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JoinExpr</name>   <modifier>*</modifier></type><name>j</name> <init>= <expr><operator>(</operator><name>JoinExpr</name> <operator>*</operator><operator>)</operator> <name>jtnode</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Is it an unnamed JOIN with USING? */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>j</name><operator>-&gt;</operator><name>alias</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>j</name><operator>-&gt;</operator><name>usingClause</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Yes, so check each join alias var to see if any of them are not
			 * simple references to underlying columns.  If so, we have a
			 * dangerous situation and must pick unique aliases.
			 */</comment>
			<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>jrte</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>, <argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* We need only examine the merged columns */</comment>
			<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>jrte</name><operator>-&gt;</operator><name>joinmergedcols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>aliasvar</name> <init>= <expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>jrte</name><operator>-&gt;</operator><name>joinaliasvars</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>aliasvar</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Nope, but inspect children */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>has_dangerous_join_using</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><name><name>j</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>has_dangerous_join_using</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * set_using_names: select column aliases to be used for merged USING columns
 *
 * We do this during a recursive descent of the query jointree.
 * dpns-&gt;unique_using must already be set to determine the global strategy.
 *
 * Column alias info is saved in the dpns-&gt;rtable_columns list, which is
 * assumed to be filled with pre-zeroed deparse_columns structs.
 *
 * parentUsing is a list of all USING aliases assigned in parent joins of
 * the current jointree node.  (The passed-in list must not be modified.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_using_names</name><parameter_list>(<parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>jtnode</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>parentUsing</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* nothing to do now */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>FromExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FromExpr</name>   <modifier>*</modifier></type><name>f</name> <init>= <expr><operator>(</operator><name>FromExpr</name> <operator>*</operator><operator>)</operator> <name>jtnode</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>f-&gt;fromlist</argument>)</argument_list></macro>
			<expr_stmt><expr><call><name>set_using_names</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>parentUsing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JoinExpr</name>   <modifier>*</modifier></type><name>j</name> <init>= <expr><operator>(</operator><name>JoinExpr</name> <operator>*</operator><operator>)</operator> <name>jtnode</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>, <argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>deparse_columns</name> <modifier>*</modifier></type><name>colinfo</name> <init>= <expr><call><name>deparse_columns_fetch</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>, <argument><expr><name>dpns</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>leftattnos</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>rightattnos</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>deparse_columns</name> <modifier>*</modifier></type><name>leftcolinfo</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>deparse_columns</name> <modifier>*</modifier></type><name>rightcolinfo</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<comment type="block">/* Get info about the shape of the join */</comment>
		<expr_stmt><expr><call><name>identify_join_columns</name><argument_list>(<argument><expr><name>j</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>colinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>leftattnos</name> <operator>=</operator> <name><name>colinfo</name><operator>-&gt;</operator><name>leftattnos</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>rightattnos</name> <operator>=</operator> <name><name>colinfo</name><operator>-&gt;</operator><name>rightattnos</name></name></expr>;</expr_stmt>

		<comment type="block">/* Look up the not-yet-filled-in child deparse_columns structs */</comment>
		<expr_stmt><expr><name>leftcolinfo</name> <operator>=</operator> <call><name>deparse_columns_fetch</name><argument_list>(<argument><expr><name><name>colinfo</name><operator>-&gt;</operator><name>leftrti</name></name></expr></argument>, <argument><expr><name>dpns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rightcolinfo</name> <operator>=</operator> <call><name>deparse_columns_fetch</name><argument_list>(<argument><expr><name><name>colinfo</name><operator>-&gt;</operator><name>rightrti</name></name></expr></argument>, <argument><expr><name>dpns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If this join is unnamed, then we cannot substitute new aliases at
		 * this level, so any name requirements pushed down to here must be
		 * pushed down again to the children.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>alias</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>colinfo</name><operator>-&gt;</operator><name>num_cols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>colname</name> <init>= <expr><name><name>colinfo</name><operator>-&gt;</operator><name>colnames</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>colname</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<comment type="block">/* Push down to left column, unless it's a system column */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>leftattnos</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>expand_colnames_array_to</name><argument_list>(<argument><expr><name>leftcolinfo</name></expr></argument>, <argument><expr><name><name>leftattnos</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>leftcolinfo</name><operator>-&gt;</operator><name>colnames</name><index>[<expr><name><name>leftattnos</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>colname</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* Same on the righthand side */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>rightattnos</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>expand_colnames_array_to</name><argument_list>(<argument><expr><name>rightcolinfo</name></expr></argument>, <argument><expr><name><name>rightattnos</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>rightcolinfo</name><operator>-&gt;</operator><name>colnames</name><index>[<expr><name><name>rightattnos</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>colname</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If there's a USING clause, select the USING column names and push
		 * those names down to the children.  We have two strategies:
		 *
		 * If dpns-&gt;unique_using is true, we force all USING names to be
		 * unique across the whole query level.  In principle we'd only need
		 * the names of dangerous USING columns to be globally unique, but to
		 * safely assign all USING names in a single pass, we have to enforce
		 * the same uniqueness rule for all of them.  However, if a USING
		 * column's name has been pushed down from the parent, we should use
		 * it as-is rather than making a uniqueness adjustment.  This is
		 * necessary when we're at an unnamed join, and it creates no risk of
		 * ambiguity.  Also, if there's a user-written output alias for a
		 * merged column, we prefer to use that rather than the input name;
		 * this simplifies the logic and seems likely to lead to less aliasing
		 * overall.
		 *
		 * If dpns-&gt;unique_using is false, we only need USING names to be
		 * unique within their own join RTE.  We still need to honor
		 * pushed-down names, though.
		 *
		 * Though significantly different in results, these two strategies are
		 * implemented by the same code, with only the difference of whether
		 * to put assigned names into dpns-&gt;using_names.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>j</name><operator>-&gt;</operator><name>usingClause</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Copy the input parentUsing list so we don't modify it */</comment>
			<expr_stmt><expr><name>parentUsing</name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name>parentUsing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* USING names must correspond to the first join output columns */</comment>
			<expr_stmt><expr><call><name>expand_colnames_array_to</name><argument_list>(<argument><expr><name>colinfo</name></expr></argument>, <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>usingClause</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>j-&gt;usingClause</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>colname</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/* Assert it's a merged column */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>leftattnos</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>rightattnos</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Adopt passed-down name if any, else select unique name */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>colinfo</name><operator>-&gt;</operator><name>colnames</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>colname</name> <operator>=</operator> <name><name>colinfo</name><operator>-&gt;</operator><name>colnames</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* Prefer user-written output alias if any */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>alias</name></name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>alias</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>colname</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>alias</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<comment type="block">/* Make it appropriately unique */</comment>
					<expr_stmt><expr><name>colname</name> <operator>=</operator> <call><name>make_colname_unique</name><argument_list>(<argument><expr><name>colname</name></expr></argument>, <argument><expr><name>dpns</name></expr></argument>, <argument><expr><name>colinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>dpns</name><operator>-&gt;</operator><name>unique_using</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>using_names</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>using_names</name></name></expr></argument>,
													<argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<comment type="block">/* Save it as output column name, too */</comment>
					<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>colnames</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>colname</name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<comment type="block">/* Remember selected names for use later */</comment>
				<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>usingNames</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>colinfo</name><operator>-&gt;</operator><name>usingNames</name></name></expr></argument>, <argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>parentUsing</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>parentUsing</name></expr></argument>, <argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Push down to left column, unless it's a system column */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>leftattnos</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>expand_colnames_array_to</name><argument_list>(<argument><expr><name>leftcolinfo</name></expr></argument>, <argument><expr><name><name>leftattnos</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>leftcolinfo</name><operator>-&gt;</operator><name>colnames</name><index>[<expr><name><name>leftattnos</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>colname</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* Same on the righthand side */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>rightattnos</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>expand_colnames_array_to</name><argument_list>(<argument><expr><name>rightcolinfo</name></expr></argument>, <argument><expr><name><name>rightattnos</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>rightcolinfo</name><operator>-&gt;</operator><name>colnames</name><index>[<expr><name><name>rightattnos</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>colname</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Mark child deparse_columns structs with correct parentUsing info */</comment>
		<expr_stmt><expr><name><name>leftcolinfo</name><operator>-&gt;</operator><name>parentUsing</name></name> <operator>=</operator> <name>parentUsing</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rightcolinfo</name><operator>-&gt;</operator><name>parentUsing</name></name> <operator>=</operator> <name>parentUsing</name></expr>;</expr_stmt>

		<comment type="block">/* Now recursively assign USING column names in children */</comment>
		<expr_stmt><expr><call><name>set_using_names</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><name><name>j</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>, <argument><expr><name>parentUsing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>set_using_names</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>, <argument><expr><name>parentUsing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * set_relation_column_names: select column aliases for a non-join RTE
 *
 * Column alias info is saved in *colinfo, which is assumed to be pre-zeroed.
 * If any colnames entries are already filled in, those override local
 * choices.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_relation_column_names</name><parameter_list>(<parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>,
						  <parameter><decl><type><name>deparse_columns</name> <modifier>*</modifier></type><name>colinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>ncolumns</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>real_colnames</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>changed_any</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> 		<name>has_anonymous</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>noldcolumns</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Extract the RTE's "real" column names.  This is comparable to
	 * get_rte_attribute_name, except that it's important to disregard dropped
	 * columns.  We put NULL into the array for a dropped column.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name> <operator>||</operator>
        <call><name>GetRangeTblKind</name><argument_list>(<argument><expr><name>rte</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CITUS_RTE_SHARD</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Relation --- look to the system catalogs for up-to-date info */</comment>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>ncolumns</name> <operator>=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>real_colnames</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>ncolumns</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ncolumns</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>real_colnames</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>real_colnames</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Otherwise use the column names from eref */</comment>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>ncolumns</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>real_colnames</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>ncolumns</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rte-&gt;eref-&gt;colnames</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/*
			 * If the column name shown in eref is an empty string, then it's
			 * a column that was dropped at the time of parsing the query, so
			 * treat it as dropped.
			 */</comment>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cname</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>cname</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>cname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>real_colnames</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>cname</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Ensure colinfo-&gt;colnames has a slot for each column.  (It could be long
	 * enough already, if we pushed down a name for the last column.)  Note:
	 * it's possible that there are now more columns than there were when the
	 * query was parsed, ie colnames could be longer than rte-&gt;eref-&gt;colnames.
	 * We must assign unique aliases to the new columns too, else there could
	 * be unresolved conflicts when the view/rule is reloaded.
	 */</comment>
	<expr_stmt><expr><call><name>expand_colnames_array_to</name><argument_list>(<argument><expr><name>colinfo</name></expr></argument>, <argument><expr><name>ncolumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>colinfo</name><operator>-&gt;</operator><name>num_cols</name></name> <operator>==</operator> <name>ncolumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make sufficiently large new_colnames and is_new_col arrays, too.
	 *
	 * Note: because we leave colinfo-&gt;num_new_cols zero until after the loop,
	 * colname_is_unique will not consult that array, which is fine because it
	 * would only be duplicate effort.
	 */</comment>
	<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>new_colnames</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>ncolumns</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>is_new_col</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>ncolumns</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Scan the columns, select a unique alias for each one, and store it in
	 * colinfo-&gt;colnames and colinfo-&gt;new_colnames.  The former array has NULL
	 * entries for dropped columns, the latter omits them.  Also mark
	 * new_colnames entries as to whether they are new since parse time; this
	 * is the case for entries beyond the length of rte-&gt;eref-&gt;colnames.
	 */</comment>
	<expr_stmt><expr><name>noldcolumns</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>changed_any</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>has_anonymous</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ncolumns</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>real_colname</name> <init>= <expr><name><name>real_colnames</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>colname</name> <init>= <expr><name><name>colinfo</name><operator>-&gt;</operator><name>colnames</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Skip dropped columns */</comment>
		<if_stmt><if>if <condition>(<expr><name>real_colname</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>colname</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* colnames[i] is already NULL */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* If alias already assigned, that's what to use */</comment>
		<if_stmt><if>if <condition>(<expr><name>colname</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* If user wrote an alias, prefer that over real column name */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>alias</name></name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>alias</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>colname</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>alias</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>colname</name> <operator>=</operator> <name>real_colname</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/* Unique-ify and insert into colinfo */</comment>
			<expr_stmt><expr><name>colname</name> <operator>=</operator> <call><name>make_colname_unique</name><argument_list>(<argument><expr><name>colname</name></expr></argument>, <argument><expr><name>dpns</name></expr></argument>, <argument><expr><name>colinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>colnames</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>colname</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Put names of non-dropped columns in new_colnames[] too */</comment>
		<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>new_colnames</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>colname</name></expr>;</expr_stmt>
		<comment type="block">/* And mark them as new or not */</comment>
		<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>is_new_col</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>i</name> <operator>&gt;=</operator> <name>noldcolumns</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/* Remember if any assigned aliases differ from "real" name */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>changed_any</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>colname</name></expr></argument>, <argument><expr><name>real_colname</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>changed_any</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Remember if there is a reference to an anonymous column as named by
		 * char * FigureColname(Node *node)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>has_anonymous</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>real_colname</name></expr></argument>, <argument><expr><literal type="string">"?column?"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>has_anonymous</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Set correct length for new_colnames[] array.  (Note: if columns have
	 * been added, colinfo-&gt;num_cols includes them, which is not really quite
	 * right but is harmless, since any new columns must be at the end where
	 * they won't affect varattnos of pre-existing columns.)
	 */</comment>
	<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>num_new_cols</name></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * For a relation RTE, we need only print the alias column names if any
	 * are different from the underlying "real" names.  For a function RTE,
	 * always emit a complete column alias list; this is to protect against
	 * possible instability of the default column names (eg, from altering
	 * parameter names).  For tablefunc RTEs, we never print aliases, because
	 * the column names are part of the clause itself.  For other RTE types,
	 * print if we changed anything OR if there were user-written column
	 * aliases (since the latter would be part of the underlying "reality").
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>printaliases</name></name> <operator>=</operator> <name>changed_any</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_FUNCTION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>printaliases</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_TABLEFUNC</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>printaliases</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>alias</name></name> <operator>&amp;&amp;</operator> <name><name>rte</name><operator>-&gt;</operator><name>alias</name><operator>-&gt;</operator><name>colnames</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>printaliases</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>printaliases</name></name> <operator>=</operator> <name>changed_any</name> <operator>||</operator> <name>has_anonymous</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * set_join_column_names: select column aliases for a join RTE
 *
 * Column alias info is saved in *colinfo, which is assumed to be pre-zeroed.
 * If any colnames entries are already filled in, those override local
 * choices.  Also, names for USING columns were already chosen by
 * set_using_names().  We further expect that column alias selection has been
 * completed for both input RTEs.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_join_column_names</name><parameter_list>(<parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>,
					  <parameter><decl><type><name>deparse_columns</name> <modifier>*</modifier></type><name>colinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>deparse_columns</name> <modifier>*</modifier></type><name>leftcolinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>deparse_columns</name> <modifier>*</modifier></type><name>rightcolinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>changed_any</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>noldcolumns</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nnewcolumns</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>leftmerged</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>rightmerged</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ic</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>jc</name></decl>;</decl_stmt>

	<comment type="block">/* Look up the previously-filled-in child deparse_columns structs */</comment>
	<expr_stmt><expr><name>leftcolinfo</name> <operator>=</operator> <call><name>deparse_columns_fetch</name><argument_list>(<argument><expr><name><name>colinfo</name><operator>-&gt;</operator><name>leftrti</name></name></expr></argument>, <argument><expr><name>dpns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rightcolinfo</name> <operator>=</operator> <call><name>deparse_columns_fetch</name><argument_list>(<argument><expr><name><name>colinfo</name><operator>-&gt;</operator><name>rightrti</name></name></expr></argument>, <argument><expr><name>dpns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Ensure colinfo-&gt;colnames has a slot for each column.  (It could be long
	 * enough already, if we pushed down a name for the last column.)  Note:
	 * it's possible that one or both inputs now have more columns than there
	 * were when the query was parsed, but we'll deal with that below.  We
	 * only need entries in colnames for pre-existing columns.
	 */</comment>
	<expr_stmt><expr><name>noldcolumns</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>expand_colnames_array_to</name><argument_list>(<argument><expr><name>colinfo</name></expr></argument>, <argument><expr><name>noldcolumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>colinfo</name><operator>-&gt;</operator><name>num_cols</name></name> <operator>==</operator> <name>noldcolumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Scan the join output columns, select an alias for each one, and store
	 * it in colinfo-&gt;colnames.  If there are USING columns, set_using_names()
	 * already selected their names, so we can start the loop at the first
	 * non-merged column.
	 */</comment>
	<expr_stmt><expr><name>changed_any</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>colinfo</name><operator>-&gt;</operator><name>usingNames</name></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>noldcolumns</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>colname</name> <init>= <expr><name><name>colinfo</name><operator>-&gt;</operator><name>colnames</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>real_colname</name></decl>;</decl_stmt>

		<comment type="block">/* Join column must refer to at least one input column */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>colinfo</name><operator>-&gt;</operator><name>leftattnos</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>colinfo</name><operator>-&gt;</operator><name>rightattnos</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Get the child column name */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>colinfo</name><operator>-&gt;</operator><name>leftattnos</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>real_colname</name> <operator>=</operator> <name><name>leftcolinfo</name><operator>-&gt;</operator><name>colnames</name><index>[<expr><name><name>colinfo</name><operator>-&gt;</operator><name>leftattnos</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>colinfo</name><operator>-&gt;</operator><name>rightattnos</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>real_colname</name> <operator>=</operator> <name><name>rightcolinfo</name><operator>-&gt;</operator><name>colnames</name><index>[<expr><name><name>colinfo</name><operator>-&gt;</operator><name>rightattnos</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* We're joining system columns --- use eref name */</comment>
			<expr_stmt><expr><name>real_colname</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
			<comment type="block">/* If child col has been dropped, no need to assign a join colname */</comment>
		<if_stmt><if>if <condition>(<expr><name>real_colname</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>colnames</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* In an unnamed join, just report child column names as-is */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>alias</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>colnames</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>real_colname</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* If alias already assigned, that's what to use */</comment>
		<if_stmt><if>if <condition>(<expr><name>colname</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* If user wrote an alias, prefer that over real column name */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>alias</name></name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>alias</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>colname</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>alias</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>colname</name> <operator>=</operator> <name>real_colname</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/* Unique-ify and insert into colinfo */</comment>
			<expr_stmt><expr><name>colname</name> <operator>=</operator> <call><name>make_colname_unique</name><argument_list>(<argument><expr><name>colname</name></expr></argument>, <argument><expr><name>dpns</name></expr></argument>, <argument><expr><name>colinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>colnames</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>colname</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Remember if any assigned aliases differ from "real" name */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>changed_any</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>colname</name></expr></argument>, <argument><expr><name>real_colname</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>changed_any</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Calculate number of columns the join would have if it were re-parsed
	 * now, and create storage for the new_colnames and is_new_col arrays.
	 *
	 * Note: colname_is_unique will be consulting new_colnames[] during the
	 * loops below, so its not-yet-filled entries must be zeroes.
	 */</comment>
	<expr_stmt><expr><name>nnewcolumns</name> <operator>=</operator> <name><name>leftcolinfo</name><operator>-&gt;</operator><name>num_new_cols</name></name> <operator>+</operator> <name><name>rightcolinfo</name><operator>-&gt;</operator><name>num_new_cols</name></name> <operator>-</operator>
		<call><name>list_length</name><argument_list>(<argument><expr><name><name>colinfo</name><operator>-&gt;</operator><name>usingNames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>num_new_cols</name></name> <operator>=</operator> <name>nnewcolumns</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>new_colnames</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>nnewcolumns</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>is_new_col</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>nnewcolumns</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Generating the new_colnames array is a bit tricky since any new columns
	 * added since parse time must be inserted in the right places.  This code
	 * must match the parser, which will order a join's columns as merged
	 * columns first (in USING-clause order), then non-merged columns from the
	 * left input (in attnum order), then non-merged columns from the right
	 * input (ditto).  If one of the inputs is itself a join, its columns will
	 * be ordered according to the same rule, which means newly-added columns
	 * might not be at the end.  We can figure out what's what by consulting
	 * the leftattnos and rightattnos arrays plus the input is_new_col arrays.
	 *
	 * In these loops, i indexes leftattnos/rightattnos (so it's join varattno
	 * less one), j indexes new_colnames/is_new_col, and ic/jc have similar
	 * meanings for the current child RTE.
	 */</comment>

	<comment type="block">/* Handle merged columns; they are first and can't be new */</comment>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>noldcolumns</name> <operator>&amp;&amp;</operator>
		   <name><name>colinfo</name><operator>-&gt;</operator><name>leftattnos</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		   <name><name>colinfo</name><operator>-&gt;</operator><name>rightattnos</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* column name is already determined and known unique */</comment>
		<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>new_colnames</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>colinfo</name><operator>-&gt;</operator><name>colnames</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>is_new_col</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/* build bitmapsets of child attnums of merged columns */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>colinfo</name><operator>-&gt;</operator><name>leftattnos</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>leftmerged</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>leftmerged</name></expr></argument>, <argument><expr><name><name>colinfo</name><operator>-&gt;</operator><name>leftattnos</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>colinfo</name><operator>-&gt;</operator><name>rightattnos</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>rightmerged</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>rightmerged</name></expr></argument>, <argument><expr><name><name>colinfo</name><operator>-&gt;</operator><name>rightattnos</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Handle non-merged left-child columns */</comment>
	<expr_stmt><expr><name>ic</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>jc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>jc</name> <operator>&lt;</operator> <name><name>leftcolinfo</name><operator>-&gt;</operator><name>num_new_cols</name></name></expr>;</condition> <incr><expr><name>jc</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>child_colname</name> <init>= <expr><name><name>leftcolinfo</name><operator>-&gt;</operator><name>new_colnames</name><index>[<expr><name>jc</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>leftcolinfo</name><operator>-&gt;</operator><name>is_new_col</name><index>[<expr><name>jc</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Advance ic to next non-dropped old column of left child */</comment>
			<while>while <condition>(<expr><name>ic</name> <operator>&lt;</operator> <name><name>leftcolinfo</name><operator>-&gt;</operator><name>num_cols</name></name> <operator>&amp;&amp;</operator>
				   <name><name>leftcolinfo</name><operator>-&gt;</operator><name>colnames</name><index>[<expr><name>ic</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>ic</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ic</name> <operator>&lt;</operator> <name><name>leftcolinfo</name><operator>-&gt;</operator><name>num_cols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ic</name><operator>++</operator></expr>;</expr_stmt>
			<comment type="block">/* If it is a merged column, we already processed it */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>ic</name></expr></argument>, <argument><expr><name>leftmerged</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<comment type="block">/* Else, advance i to the corresponding existing join column */</comment>
			<while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name><name>colinfo</name><operator>-&gt;</operator><name>num_cols</name></name> <operator>&amp;&amp;</operator>
				   <name><name>colinfo</name><operator>-&gt;</operator><name>colnames</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>i</name> <operator>&lt;</operator> <name><name>colinfo</name><operator>-&gt;</operator><name>num_cols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ic</name> <operator>==</operator> <name><name>colinfo</name><operator>-&gt;</operator><name>leftattnos</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Use the already-assigned name of this column */</comment>
			<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>new_colnames</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>colinfo</name><operator>-&gt;</operator><name>colnames</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Unique-ify the new child column name and assign, unless we're
			 * in an unnamed join, in which case just copy
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>alias</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>new_colnames</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator>
					<call><name>make_colname_unique</name><argument_list>(<argument><expr><name>child_colname</name></expr></argument>, <argument><expr><name>dpns</name></expr></argument>, <argument><expr><name>colinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>changed_any</name> <operator>&amp;&amp;</operator>
					<call><name>strcmp</name><argument_list>(<argument><expr><name><name>colinfo</name><operator>-&gt;</operator><name>new_colnames</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>child_colname</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>changed_any</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>new_colnames</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>child_colname</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>is_new_col</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>leftcolinfo</name><operator>-&gt;</operator><name>is_new_col</name><index>[<expr><name>jc</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Handle non-merged right-child columns in exactly the same way */</comment>
	<expr_stmt><expr><name>ic</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>jc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>jc</name> <operator>&lt;</operator> <name><name>rightcolinfo</name><operator>-&gt;</operator><name>num_new_cols</name></name></expr>;</condition> <incr><expr><name>jc</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>child_colname</name> <init>= <expr><name><name>rightcolinfo</name><operator>-&gt;</operator><name>new_colnames</name><index>[<expr><name>jc</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rightcolinfo</name><operator>-&gt;</operator><name>is_new_col</name><index>[<expr><name>jc</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Advance ic to next non-dropped old column of right child */</comment>
			<while>while <condition>(<expr><name>ic</name> <operator>&lt;</operator> <name><name>rightcolinfo</name><operator>-&gt;</operator><name>num_cols</name></name> <operator>&amp;&amp;</operator>
				   <name><name>rightcolinfo</name><operator>-&gt;</operator><name>colnames</name><index>[<expr><name>ic</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>ic</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ic</name> <operator>&lt;</operator> <name><name>rightcolinfo</name><operator>-&gt;</operator><name>num_cols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ic</name><operator>++</operator></expr>;</expr_stmt>
			<comment type="block">/* If it is a merged column, we already processed it */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>ic</name></expr></argument>, <argument><expr><name>rightmerged</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<comment type="block">/* Else, advance i to the corresponding existing join column */</comment>
			<while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name><name>colinfo</name><operator>-&gt;</operator><name>num_cols</name></name> <operator>&amp;&amp;</operator>
				   <name><name>colinfo</name><operator>-&gt;</operator><name>colnames</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>i</name> <operator>&lt;</operator> <name><name>colinfo</name><operator>-&gt;</operator><name>num_cols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ic</name> <operator>==</operator> <name><name>colinfo</name><operator>-&gt;</operator><name>rightattnos</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Use the already-assigned name of this column */</comment>
			<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>new_colnames</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>colinfo</name><operator>-&gt;</operator><name>colnames</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Unique-ify the new child column name and assign, unless we're
			 * in an unnamed join, in which case just copy
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>alias</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>new_colnames</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator>
					<call><name>make_colname_unique</name><argument_list>(<argument><expr><name>child_colname</name></expr></argument>, <argument><expr><name>dpns</name></expr></argument>, <argument><expr><name>colinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>changed_any</name> <operator>&amp;&amp;</operator>
					<call><name>strcmp</name><argument_list>(<argument><expr><name><name>colinfo</name><operator>-&gt;</operator><name>new_colnames</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>child_colname</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>changed_any</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>new_colnames</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>child_colname</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>is_new_col</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>rightcolinfo</name><operator>-&gt;</operator><name>is_new_col</name><index>[<expr><name>jc</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Assert we processed the right number of columns */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name><name>colinfo</name><operator>-&gt;</operator><name>num_cols</name></name> <operator>&amp;&amp;</operator> <name><name>colinfo</name><operator>-&gt;</operator><name>colnames</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>i</name> <operator>==</operator> <name><name>colinfo</name><operator>-&gt;</operator><name>num_cols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>j</name> <operator>==</operator> <name>nnewcolumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * For a named join, print column aliases if we changed any from the child
	 * names.  Unnamed joins cannot print aliases.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>alias</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>printaliases</name></name> <operator>=</operator> <name>changed_any</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>printaliases</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * colname_is_unique: is colname distinct from already-chosen column names?
 *
 * dpns is query-wide info, colinfo is for the column's RTE
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>colname_is_unique</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colname</name></decl></parameter>, <parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl></parameter>,
				  <parameter><decl><type><name>deparse_columns</name> <modifier>*</modifier></type><name>colinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* Check against already-assigned column aliases within RTE */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>colinfo</name><operator>-&gt;</operator><name>num_cols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oldname</name> <init>= <expr><name><name>colinfo</name><operator>-&gt;</operator><name>colnames</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>oldname</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>oldname</name></expr></argument>, <argument><expr><name>colname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * If we're building a new_colnames array, check that too (this will be
	 * partially but not completely redundant with the previous checks)
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>colinfo</name><operator>-&gt;</operator><name>num_new_cols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oldname</name> <init>= <expr><name><name>colinfo</name><operator>-&gt;</operator><name>new_colnames</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>oldname</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>oldname</name></expr></argument>, <argument><expr><name>colname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Also check against USING-column names that must be globally unique */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>dpns-&gt;using_names</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oldname</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>oldname</name></expr></argument>, <argument><expr><name>colname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* Also check against names already assigned for parent-join USING cols */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>colinfo-&gt;parentUsing</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oldname</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>oldname</name></expr></argument>, <argument><expr><name>colname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * make_colname_unique: modify colname if necessary to make it unique
 *
 * dpns is query-wide info, colinfo is for the column's RTE
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>make_colname_unique</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>colname</name></decl></parameter>, <parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl></parameter>,
					<parameter><decl><type><name>deparse_columns</name> <modifier>*</modifier></type><name>colinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If the selected name isn't unique, append digits to make it so.  For a
	 * very long input name, we might have to truncate to stay within
	 * NAMEDATALEN.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>colname_is_unique</name><argument_list>(<argument><expr><name>colname</name></expr></argument>, <argument><expr><name>dpns</name></expr></argument>, <argument><expr><name>colinfo</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>colnamelen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>modname</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>colnamelen</name> <operator>+</operator> <literal type="number">16</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<do>do
		<block>{<block_content>
			<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
			<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
			<block>{<block_content>
				<comment type="block">/*
				 * We avoid using %.*s here because it can misbehave if the
				 * data is not valid in what libc thinks is the prevailing
				 * encoding.
				 */</comment>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>modname</name></expr></argument>, <argument><expr><name>colname</name></expr></argument>, <argument><expr><name>colnamelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>modname</name> <operator>+</operator> <name>colnamelen</name></expr></argument>, <argument><expr><literal type="string">"_%d"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>modname</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>NAMEDATALEN</name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
				<comment type="block">/* drop chars from colname to keep all the digits */</comment>
				<expr_stmt><expr><name>colnamelen</name> <operator>=</operator> <call><name>pg_mbcliplen</name><argument_list>(<argument><expr><name>colname</name></expr></argument>, <argument><expr><name>colnamelen</name></expr></argument>,
										  <argument><expr><name>colnamelen</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block> while <condition>(<expr><operator>!</operator><call><name>colname_is_unique</name><argument_list>(<argument><expr><name>modname</name></expr></argument>, <argument><expr><name>dpns</name></expr></argument>, <argument><expr><name>colinfo</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
		<expr_stmt><expr><name>colname</name> <operator>=</operator> <name>modname</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>colname</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * expand_colnames_array_to: make colinfo-&gt;colnames at least n items long
 *
 * Any added array entries are initialized to zero.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>expand_colnames_array_to</name><parameter_list>(<parameter><decl><type><name>deparse_columns</name> <modifier>*</modifier></type><name>colinfo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <name><name>colinfo</name><operator>-&gt;</operator><name>num_cols</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>colinfo</name><operator>-&gt;</operator><name>colnames</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>colnames</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>n</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>colnames</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name><name>colinfo</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>,
												   <argument><expr><name>n</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>colinfo</name><operator>-&gt;</operator><name>colnames</name></name> <operator>+</operator> <name><name>colinfo</name><operator>-&gt;</operator><name>num_cols</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
				   <argument><expr><operator>(</operator><name>n</name> <operator>-</operator> <name><name>colinfo</name><operator>-&gt;</operator><name>num_cols</name></name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>num_cols</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * identify_join_columns: figure out where columns of a join come from
 *
 * Fills the join-specific fields of the colinfo struct, except for
 * usingNames which is filled later.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>identify_join_columns</name><parameter_list>(<parameter><decl><type><name>JoinExpr</name> <modifier>*</modifier></type><name>j</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>jrte</name></decl></parameter>,
					  <parameter><decl><type><name>deparse_columns</name> <modifier>*</modifier></type><name>colinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>numjoincols</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>jcolno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rcolno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* Extract left/right child RT indexes */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>leftrti</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <name><name>j</name><operator>-&gt;</operator><name>larg</name></name><operator>)</operator><operator>-&gt;</operator><name>rtindex</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>, <argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>leftrti</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>JoinExpr</name> <operator>*</operator><operator>)</operator> <name><name>j</name><operator>-&gt;</operator><name>larg</name></name><operator>)</operator><operator>-&gt;</operator><name>rtindex</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type in jointree: %d"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>rightrti</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <name><name>j</name><operator>-&gt;</operator><name>rarg</name></name><operator>)</operator><operator>-&gt;</operator><name>rtindex</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>, <argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>rightrti</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>JoinExpr</name> <operator>*</operator><operator>)</operator> <name><name>j</name><operator>-&gt;</operator><name>rarg</name></name><operator>)</operator><operator>-&gt;</operator><name>rtindex</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type in jointree: %d"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Assert children will be processed earlier than join in second pass */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>colinfo</name><operator>-&gt;</operator><name>leftrti</name></name> <operator>&lt;</operator> <name><name>j</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>colinfo</name><operator>-&gt;</operator><name>rightrti</name></name> <operator>&lt;</operator> <name><name>j</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize result arrays with zeroes */</comment>
	<expr_stmt><expr><name>numjoincols</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>jrte</name><operator>-&gt;</operator><name>joinaliasvars</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numjoincols</name> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>jrte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>leftattnos</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>numjoincols</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>rightattnos</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>numjoincols</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Deconstruct RTE's joinleftcols/joinrightcols into desired format.
	 * Recall that the column(s) merged due to USING are the first column(s)
	 * of the join output.  We need not do anything special while scanning
	 * joinleftcols, but while scanning joinrightcols we must distinguish
	 * merged from unmerged columns.
	 */</comment>
	<expr_stmt><expr><name>jcolno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>jrte-&gt;joinleftcols</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>leftattno</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>leftattnos</name><index>[<expr><name>jcolno</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>leftattno</name></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><name>rcolno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>jrte-&gt;joinrightcols</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>rightattno</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>rcolno</name> <operator>&lt;</operator> <name><name>jrte</name><operator>-&gt;</operator><name>joinmergedcols</name></name></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* merged column? */</comment>
			<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>rightattnos</name><index>[<expr><name>rcolno</name></expr>]</index></name> <operator>=</operator> <name>rightattno</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>rightattnos</name><index>[<expr><name>jcolno</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>rightattno</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name>rcolno</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>jcolno</name> <operator>==</operator> <name>numjoincols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_rtable_name: convenience function to get a previously assigned RTE alias
 *
 * The RTE must belong to the topmost namespace level in "context".
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_rtable_name</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>rtindex</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name> <init>= <expr><operator>(</operator><name>deparse_namespace</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>namespaces</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rtindex</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>rtindex</name> <operator>&lt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>rtable_names</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>rtable_names</name></name></expr></argument>, <argument><expr><name>rtindex</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * set_deparse_plan: set up deparse_namespace to parse subexpressions
 * of a given Plan node
 *
 * This sets the plan, outer_planstate, inner_planstate, outer_tlist,
 * inner_tlist, and index_tlist fields.  Caller is responsible for adjusting
 * the ancestors list if necessary.  Note that the rtable and ctes fields do
 * not need to change when shifting attention to different plan nodes in a
 * single plan tree.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_deparse_plan</name><parameter_list>(<parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>plan</name></name> <operator>=</operator> <name>plan</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We special-case Append and MergeAppend to pretend that the first child
	 * plan is the OUTER referent; we have to interpret OUTER Vars in their
	 * tlists according to one of the children, and the first one is the most
	 * natural choice.  Likewise special-case ModifyTable to pretend that the
	 * first child plan is the OUTER referent; this is to support RETURNING
	 * lists containing references to non-target relations.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>Append</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>outer_plan</name></name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Append</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>appendplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>MergeAppend</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>outer_plan</name></name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>MergeAppend</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>mergeplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>ModifyTable</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>outer_plan</name></name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>ModifyTable</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>plans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>outer_plan</name></name> <operator>=</operator> <call><name>outerPlan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dpns</name><operator>-&gt;</operator><name>outer_plan</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>outer_tlist</name></name> <operator>=</operator> <name><name>dpns</name><operator>-&gt;</operator><name>outer_plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>outer_tlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * For a SubqueryScan, pretend the subplan is INNER referent.  (We don't
	 * use OUTER because that could someday conflict with the normal meaning.)
	 * Likewise, for a CteScan, pretend the subquery's plan is INNER referent.
	 * For ON CONFLICT .. UPDATE we just need the inner tlist to point to the
	 * excluded expression's tlist. (Similar to the SubqueryScan we don't want
	 * to reuse OUTER, it's used for RETURNING in some modify table cases,
	 * although not INSERT .. CONFLICT).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>SubqueryScan</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>inner_plan</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>SubqueryScan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>subplan</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>CteScan</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>inner_plan</name></name> <operator>=</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>subplans</name></name></expr></argument>,
									<argument><expr><operator>(</operator><operator>(</operator><name>CteScan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>ctePlanId</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>ModifyTable</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>inner_plan</name></name> <operator>=</operator> <name>plan</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>inner_plan</name></name> <operator>=</operator> <call><name>innerPlan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>ModifyTable</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>inner_tlist</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>ModifyTable</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>exclRelTlist</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>dpns</name><operator>-&gt;</operator><name>inner_plan</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>inner_tlist</name></name> <operator>=</operator> <name><name>dpns</name><operator>-&gt;</operator><name>inner_plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>inner_tlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Set up referent for INDEX_VAR Vars, if needed */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>IndexOnlyScan</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>index_tlist</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>IndexOnlyScan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>indextlist</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>ForeignScan</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>index_tlist</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>ForeignScan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>fdw_scan_tlist</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>CustomScan</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>index_tlist</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>CustomScan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>custom_scan_tlist</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>index_tlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * push_child_plan: temporarily transfer deparsing attention to a child plan
 *
 * When expanding an OUTER_VAR or INNER_VAR reference, we must adjust the
 * deparse context in case the referenced expression itself uses
 * OUTER_VAR/INNER_VAR.  We modify the top stack entry in-place to avoid
 * affecting levelsup issues (although in a Plan tree there really shouldn't
 * be any).
 *
 * Caller must provide a local deparse_namespace variable to save the
 * previous state for pop_child_plan.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>push_child_plan</name><parameter_list>(<parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>,
				<parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>save_dpns</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Save state for restoration later */</comment>
	<expr_stmt><expr><operator>*</operator><name>save_dpns</name> <operator>=</operator> <operator>*</operator><name>dpns</name></expr>;</expr_stmt>

	<comment type="block">/* Link current plan node into ancestors list */</comment>
	<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>ancestors</name></name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>ancestors</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set attention on selected child */</comment>
	<expr_stmt><expr><call><name>set_deparse_plan</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pop_child_plan: undo the effects of push_child_plan
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pop_child_plan</name><parameter_list>(<parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl></parameter>, <parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>save_dpns</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>ancestors</name></decl>;</decl_stmt>

	<comment type="block">/* Get rid of ancestors list cell added by push_child_plan */</comment>
	<expr_stmt><expr><name>ancestors</name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>ancestors</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Restore fields changed by push_child_plan */</comment>
	<expr_stmt><expr><operator>*</operator><name>dpns</name> <operator>=</operator> <operator>*</operator><name>save_dpns</name></expr>;</expr_stmt>

	<comment type="block">/* Make sure dpns-&gt;ancestors is right (may be unnecessary) */</comment>
	<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>ancestors</name></name> <operator>=</operator> <name>ancestors</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * push_ancestor_plan: temporarily transfer deparsing attention to an
 * ancestor plan
 *
 * When expanding a Param reference, we must adjust the deparse context
 * to match the plan node that contains the expression being printed;
 * otherwise we'd fail if that expression itself contains a Param or
 * OUTER_VAR/INNER_VAR/INDEX_VAR variable.
 *
 * The target ancestor is conveniently identified by the ListCell holding it
 * in dpns-&gt;ancestors.
 *
 * Caller must provide a local deparse_namespace variable to save the
 * previous state for pop_ancestor_plan.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>push_ancestor_plan</name><parameter_list>(<parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl></parameter>, <parameter><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>ancestor_cell</name></decl></parameter>,
				   <parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>save_dpns</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>ancestor_cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Save state for restoration later */</comment>
	<expr_stmt><expr><operator>*</operator><name>save_dpns</name> <operator>=</operator> <operator>*</operator><name>dpns</name></expr>;</expr_stmt>

	<comment type="block">/* Build a new ancestor list with just this node's ancestors */</comment>
	<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>ancestors</name></name> <operator>=</operator>
		<call><name>list_copy_tail</name><argument_list>(<argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>ancestors</name></name></expr></argument>,
					   <argument><expr><call><name>list_cell_number</name><argument_list>(<argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>ancestors</name></name></expr></argument>, <argument><expr><name>ancestor_cell</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set attention on selected ancestor */</comment>
	<expr_stmt><expr><call><name>set_deparse_plan</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pop_ancestor_plan: undo the effects of push_ancestor_plan
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pop_ancestor_plan</name><parameter_list>(<parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl></parameter>, <parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>save_dpns</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Free the ancestor list made in push_ancestor_plan */</comment>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>ancestors</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Restore fields changed by push_ancestor_plan */</comment>
	<expr_stmt><expr><operator>*</operator><name>dpns</name> <operator>=</operator> <operator>*</operator><name>save_dpns</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------
 * deparse_shard_query		- Parse back a query for execution on a shard
 *
 * Builds an SQL string to perform the provided query on a specific shard and
 * places this string into the provided buffer.
 * ----------
 */</comment>
<function><type><name>void</name></type>
<name>deparse_shard_query</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>distrelid</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>shardid</name></decl></parameter>,
					<parameter><decl><type><name>StringInfo</name></type> <name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>get_query_def_extended</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>distrelid</name></expr></argument>, <argument><expr><name>shardid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
						   <argument><expr><name>WRAP_COLUMN_DEFAULT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------
 * get_query_def			- Parse back one query parsetree
 *
 * If resultDesc is not NULL, then it is the output tuple descriptor for
 * the view represented by a SELECT query.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_query_def</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>parentnamespace</name></decl></parameter>,
			  <parameter><decl><type><name>TupleDesc</name></type> <name>resultDesc</name></decl></parameter>,
			  <parameter><decl><type><name>int</name></type> <name>prettyFlags</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>wrapColumn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startIndent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>get_query_def_extended</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>parentnamespace</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>resultDesc</name></expr></argument>,
						   <argument><expr><name>prettyFlags</name></expr></argument>, <argument><expr><name>wrapColumn</name></expr></argument>, <argument><expr><name>startIndent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------
 * get_query_def_extended		- Parse back one query parsetree, optionally
 * 								  with extension using a shard identifier.
 *
 * If distrelid is valid and shardid is positive, the provided shardid is added
 * any time the provided relid is deparsed, so that the query may be executed
 * on a placement for the given shard.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_query_def_extended</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>parentnamespace</name></decl></parameter>,
					   <parameter><decl><type><name>Oid</name></type> <name>distrelid</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>shardid</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>resultDesc</name></decl></parameter>,
					   <parameter><decl><type><name>int</name></type> <name>prettyFlags</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>wrapColumn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startIndent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>deparse_context</name></type> <name>context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>deparse_namespace</name></type> <name>dpns</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>OverrideSearchPath</name> <modifier>*</modifier></type><name>overridePath</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Guard against excessively long or deeply-nested queries */</comment>
	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Before we begin to examine the query, acquire locks on referenced
	 * relations, and fix up deleted columns in JOIN RTEs.  This ensures
	 * consistent results.  Note we assume it's OK to scribble on the passed
	 * querytree!
	 *
	 * We are only deparsing the query (we are not about to execute it), so we
	 * only need AccessShareLock on the relations it mentions.
	 */</comment>
	<expr_stmt><expr><call><name>AcquireRewriteLocks</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set search_path to NIL so that all objects outside of pg_catalog will be
	 * schema-prefixed. pg_catalog will be added automatically when we call
	 * PushOverrideSearchPath(), since we set addCatalog to true;
	 */</comment>
	<expr_stmt><expr><name>overridePath</name> <operator>=</operator> <call><name>GetOverrideSearchPath</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>overridePath</name><operator>-&gt;</operator><name>schemas</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>overridePath</name><operator>-&gt;</operator><name>addCatalog</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PushOverrideSearchPath</name><argument_list>(<argument><expr><name>overridePath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>buf</name></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>namespaces</name></name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dpns</name></expr></argument>, <argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><name>parentnamespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>windowClause</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>windowTList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>varprefix</name></name> <operator>=</operator> <operator>(</operator><name>parentnamespace</name> <operator>!=</operator> <name>NIL</name> <operator>||</operator>
						 <call><name>list_length</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>prettyFlags</name></name> <operator>=</operator> <name>prettyFlags</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>wrapColumn</name></name> <operator>=</operator> <name>wrapColumn</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>indentLevel</name></name> <operator>=</operator> <name>startIndent</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>special_exprkind</name></name> <operator>=</operator> <name>EXPR_KIND_NONE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>appendparents</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>distrelid</name></name> <operator>=</operator> <name>distrelid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>shardid</name></name> <operator>=</operator> <name>shardid</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>set_deparse_for_query</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dpns</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>parentnamespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>CMD_SELECT</name></expr>:</case>
			<expr_stmt><expr><call><name>get_select_query_def</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>, <argument><expr><name>resultDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>CMD_UPDATE</name></expr>:</case>
			<expr_stmt><expr><call><name>get_update_query_def</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>CMD_INSERT</name></expr>:</case>
			<expr_stmt><expr><call><name>get_insert_query_def</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>CMD_DELETE</name></expr>:</case>
			<expr_stmt><expr><call><name>get_delete_query_def</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>CMD_NOTHING</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"NOTHING"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>CMD_UTILITY</name></expr>:</case>
			<expr_stmt><expr><call><name>get_utility_query_def</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized query command type: %d"</literal></expr></argument>,
				 <argument><expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* revert back to original search_path */</comment>
	<expr_stmt><expr><call><name>PopOverrideSearchPath</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * get_values_def			- Parse back a VALUES list
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_values_def</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>values_lists</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>first_list</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>vtl</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"VALUES "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>vtl</argument>, <argument>values_lists</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>sublist</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>vtl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>first_col</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>first_list</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>first_list</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>sublist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>col</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>first_col</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>first_col</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/*
			 * Print the value.  Whole-row Vars need special treatment.
			 */</comment>
			<expr_stmt><expr><call><name>get_rule_expr_toplevel</name><argument_list>(<argument><expr><name>col</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/* ----------
 * get_with_clause			- Parse back a WITH clause
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_with_clause</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sep</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>cteList</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PRETTY_INDENT</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>indentLevel</name></name> <operator>+=</operator> <name>PRETTYINDENT_STD</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>hasRecursive</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">"WITH RECURSIVE "</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">"WITH "</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>query-&gt;cteList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CommonTableExpr</name> <modifier>*</modifier></type><name>cte</name> <init>= <expr><operator>(</operator><name>CommonTableExpr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name><name>cte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>cte</name><operator>-&gt;</operator><name>aliascolnames</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>col</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>col</argument>, <argument>cte-&gt;aliascolnames</argument>)</argument_list></macro>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>first</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,
									   <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>col</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" AS "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<switch>switch <condition>(<expr><name><name>cte</name><operator>-&gt;</operator><name>ctematerialized</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>CTEMaterializeDefault</name></expr>:</case>
				<break>break;</break>
			<case>case <expr><name>CTEMaterializeAlways</name></expr>:</case>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"MATERIALIZED "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>CTEMaterializeNever</name></expr>:</case>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"NOT MATERIALIZED "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PRETTY_INDENT</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>get_query_def</name><argument_list>(<argument><expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name><name>cte</name><operator>-&gt;</operator><name>ctequery</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>namespaces</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					  <argument><expr><name><name>context</name><operator>-&gt;</operator><name>prettyFlags</name></name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>wrapColumn</name></name></expr></argument>,
					  <argument><expr><name><name>context</name><operator>-&gt;</operator><name>indentLevel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PRETTY_INDENT</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><call><name>PRETTY_INDENT</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>indentLevel</name></name> <operator>-=</operator> <name>PRETTYINDENT_STD</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * get_select_query_def			- Parse back a SELECT parsetree
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_select_query_def</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
					 <parameter><decl><type><name>TupleDesc</name></type> <name>resultDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>save_windowclause</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>save_windowtlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>force_colno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/* Insert the WITH clause if given */</comment>
	<expr_stmt><expr><call><name>get_with_clause</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set up context for possible window functions */</comment>
	<expr_stmt><expr><name>save_windowclause</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>windowClause</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>windowClause</name></name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>windowClause</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>save_windowtlist</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>windowTList</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>windowTList</name></name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the Query node has a setOperations tree, then it's the top level of
	 * a UNION/INTERSECT/EXCEPT query; only the WITH, ORDER BY and LIMIT
	 * fields are interesting in the top query itself.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>setOperations</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>get_setop_query</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>setOperations</name></name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>resultDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* ORDER BY clauses must be simple in this case */</comment>
		<expr_stmt><expr><name>force_colno</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>get_basic_select_query</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>resultDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>force_colno</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Add the ORDER BY clause if given */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>sortClause</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">" ORDER BY "</literal></expr></argument>,
							 <argument><expr><operator>-</operator><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>get_rule_orderby</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>sortClause</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
						 <argument><expr><name>force_colno</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Add the LIMIT/OFFSET clauses if given. If non-default options, use the
	 * standard spelling of LIMIT.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>limitOffset</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">" OFFSET "</literal></expr></argument>,
							 <argument><expr><operator>-</operator><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>limitOffset</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>limitOption</name></name> <operator>==</operator> <name>LIMIT_OPTION_WITH_TIES</name></expr>)</condition>
		<block>{<block_content>
			<comment type="line">// had to add '(' and ')' here because it fails with casting</comment>
			<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">" FETCH FIRST ("</literal></expr></argument>,
								 <argument><expr><operator>-</operator><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>limitCount</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">") ROWS WITH TIES"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">" LIMIT "</literal></expr></argument>,
								 <argument><expr><operator>-</operator><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>limitCount</name></name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>limitCount</name></name><operator>)</operator><operator>-&gt;</operator><name>constisnull</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ALL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>limitCount</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Add FOR [KEY] UPDATE/SHARE clauses if present */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>hasForUpdate</name></name></expr>)</condition>
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>query-&gt;rowMarks</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RowMarkClause</name> <modifier>*</modifier></type><name>rc</name> <init>= <expr><operator>(</operator><name>RowMarkClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* don't print implicit clauses */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>rc</name><operator>-&gt;</operator><name>pushedDown</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<switch>switch <condition>(<expr><name><name>rc</name><operator>-&gt;</operator><name>strength</name></name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>LCS_NONE</name></expr>:</case>
					<comment type="block">/* we intentionally throw an error for LCS_NONE */</comment>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized LockClauseStrength %d"</literal></expr></argument>,
						 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>rc</name><operator>-&gt;</operator><name>strength</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>LCS_FORKEYSHARE</name></expr>:</case>
					<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">" FOR KEY SHARE"</literal></expr></argument>,
										 <argument><expr><operator>-</operator><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>LCS_FORSHARE</name></expr>:</case>
					<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">" FOR SHARE"</literal></expr></argument>,
										 <argument><expr><operator>-</operator><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>LCS_FORNOKEYUPDATE</name></expr>:</case>
					<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">" FOR NO KEY UPDATE"</literal></expr></argument>,
										 <argument><expr><operator>-</operator><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>LCS_FORUPDATE</name></expr>:</case>
					<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">" FOR UPDATE"</literal></expr></argument>,
										 <argument><expr><operator>-</operator><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>

			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" OF %s"</literal></expr></argument>,
							 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>get_rtable_name</name><argument_list>(<argument><expr><name><name>rc</name><operator>-&gt;</operator><name>rti</name></name></expr></argument>,
															  <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>rc</name><operator>-&gt;</operator><name>waitPolicy</name></name> <operator>==</operator> <name>LockWaitError</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" NOWAIT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>rc</name><operator>-&gt;</operator><name>waitPolicy</name></name> <operator>==</operator> <name>LockWaitSkip</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" SKIP LOCKED"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>windowClause</name></name> <operator>=</operator> <name>save_windowclause</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>windowTList</name></name> <operator>=</operator> <name>save_windowtlist</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Detect whether query looks like SELECT ... FROM VALUES();
 * if so, return the VALUES RTE.  Otherwise return NULL.
 */</comment>
<function><type><specifier>static</specifier> <name>RangeTblEntry</name> <modifier>*</modifier></type>
<name>get_simple_values_rte</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>resultDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>colno</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We want to return true even if the Query also contains OLD or NEW rule
	 * RTEs.  So the idea is to scan the rtable and see if there is only one
	 * inFromCl RTE that is a VALUES RTE.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>query-&gt;rtable</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_VALUES</name> <operator>&amp;&amp;</operator> <name><name>rte</name><operator>-&gt;</operator><name>inFromCl</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* multiple VALUES (probably not possible) */</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>rte</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>rte</name><operator>-&gt;</operator><name>inFromCl</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if>			<comment type="block">/* ignore rule entries */</comment>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></else></if_stmt>		<comment type="block">/* something else -&gt; not simple VALUES */</comment>
	</block_content>}</block>

	<comment type="block">/*
	 * We don't need to check the targetlist in any great detail, because
	 * parser/analyze.c will never generate a "bare" VALUES RTE --- they only
	 * appear inside auto-generated sub-queries with very restricted
	 * structure.  However, DefineView might have modified the tlist by
	 * injecting new column aliases; so compare tlist resnames against the
	 * RTE's names to detect that.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lcn</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* this probably cannot happen */</comment>
		<expr_stmt><expr><name>colno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<macro><name>forboth</name><argument_list>(<argument>lc</argument>, <argument>query-&gt;targetList</argument>, <argument>lcn</argument>, <argument>result-&gt;eref-&gt;colnames</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cname</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lcn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>colname</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* this probably cannot happen */</comment>
			<comment type="block">/* compute name that get_target_list would use for column */</comment>
			<expr_stmt><expr><name>colno</name><operator>++</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>resultDesc</name> <operator>&amp;&amp;</operator> <name>colno</name> <operator>&lt;=</operator> <name><name>resultDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>colname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>resultDesc</name></expr></argument>, <argument><expr><name>colno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>colname</name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>resname</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/* does it match the VALUES RTE? */</comment>
			<if_stmt><if>if <condition>(<expr><name>colname</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>colname</name></expr></argument>, <argument><expr><name>cname</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* column name has been changed */</comment>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_basic_select_query</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
					   <parameter><decl><type><name>TupleDesc</name></type> <name>resultDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>values_rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sep</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PRETTY_INDENT</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>indentLevel</name></name> <operator>+=</operator> <name>PRETTYINDENT_STD</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the query looks like SELECT * FROM (VALUES ...), then print just the
	 * VALUES part.  This reverses what transformValuesClause() did at parse
	 * time.
	 */</comment>
	<expr_stmt><expr><name>values_rte</name> <operator>=</operator> <call><name>get_simple_values_rte</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>resultDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>values_rte</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>get_values_def</name><argument_list>(<argument><expr><name><name>values_rte</name><operator>-&gt;</operator><name>values_lists</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Build up the query string - first we say SELECT
	 */</comment>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"SELECT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add the DISTINCT clause if given */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>distinctClause</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>hasDistinctOn</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" DISTINCT ON ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>query-&gt;distinctClause</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>srt</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>get_rule_sortgroupclause</name><argument_list>(<argument><expr><name><name>srt</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
										 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
			</block_content>}</block>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" DISTINCT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Then we tell what to select (the targetlist) */</comment>
	<expr_stmt><expr><call><name>get_target_list</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>resultDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add the FROM clause if needed */</comment>
	<expr_stmt><expr><call><name>get_from_clause</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">" FROM "</literal></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add the WHERE clause if given */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">" WHERE "</literal></expr></argument>,
							 <argument><expr><operator>-</operator><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Add the GROUP BY clause if given */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <name><name>query</name><operator>-&gt;</operator><name>groupingSets</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ParseExprKind</name></type> <name>save_exprkind</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">" GROUP BY "</literal></expr></argument>,
							 <argument><expr><operator>-</operator><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>save_exprkind</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>special_exprkind</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>special_exprkind</name></name> <operator>=</operator> <name>EXPR_KIND_GROUP_BY</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>groupingSets</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>query-&gt;groupClause</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>grp</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>get_rule_sortgroupclause</name><argument_list>(<argument><expr><name><name>grp</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
										 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>query-&gt;groupingSets</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>GroupingSet</name> <modifier>*</modifier></type><name>grp</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>get_rule_groupingset</name><argument_list>(<argument><expr><name>grp</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>special_exprkind</name></name> <operator>=</operator> <name>save_exprkind</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Add the HAVING clause if given */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>havingQual</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">" HAVING "</literal></expr></argument>,
							 <argument><expr><operator>-</operator><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Add the WINDOW clause if needed */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>windowClause</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>get_rule_windowclause</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * get_target_list			- Parse back a SELECT target list
 *
 * This is also used for RETURNING lists in INSERT/UPDATE/DELETE.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_target_list</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
				<parameter><decl><type><name>TupleDesc</name></type> <name>resultDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>targetbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>last_was_multiline</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sep</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>colno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/* we use targetbuf to hold each TLE's text temporarily */</comment>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>targetbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">" "</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>colno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>targetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>colname</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attname</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* ignore junk entries */</comment>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>colno</name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * Put the new field text into targetbuf so we can decide after we've
		 * got it whether or not it needs to go on a new line.
		 */</comment>
		<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>targetbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name> <operator>=</operator> <operator>&amp;</operator><name>targetbuf</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * We special-case Var nodes rather than using get_rule_expr. This is
		 * needed because get_rule_expr will display a whole-row Var as
		 * "foo.*", which is the preferred notation in most contexts, but at
		 * the top level of a SELECT list it's not right (the parser will
		 * expand that notation into multiple columns, yielding behavior
		 * different from a whole-row Var).  We need to call get_variable
		 * directly so that we can tell it to do the right thing, and so that
		 * we can get the attribute name which is the default AS label.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>attname</name> <operator>=</operator> <call><name>get_variable</name><argument_list>(<argument><expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* We'll show the AS name unless it's this: */</comment>
			<expr_stmt><expr><name>attname</name> <operator>=</operator> <literal type="string">"?column?"</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Figure out what the result column should be called.  In the context
		 * of a view, use the view's tuple descriptor (so as to pick up the
		 * effects of any column RENAME that's been done on the view).
		 * Otherwise, just use what we can find in the TLE.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>resultDesc</name> <operator>&amp;&amp;</operator> <name>colno</name> <operator>&lt;=</operator> <name><name>resultDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>colname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>resultDesc</name></expr></argument>, <argument><expr><name>colno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>colname</name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>resname</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* Show AS unless the column's name is correct as-is */</comment>
		<if_stmt><if>if <condition>(<expr><name>colname</name></expr>)</condition>			<comment type="block">/* resname could be NULL */</comment>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>attname</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>attname</name></expr></argument>, <argument><expr><name>colname</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>targetbuf</name></expr></argument>, <argument><expr><literal type="string">" AS %s"</literal></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Restore context's output buffer */</comment>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>

		<comment type="block">/* Consider line-wrapping if enabled */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PRETTY_INDENT</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>context</name><operator>-&gt;</operator><name>wrapColumn</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>leading_nl_pos</name></decl>;</decl_stmt>

			<comment type="block">/* Does the new field start with a new line? */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>targetbuf</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>targetbuf</name><operator>.</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>leading_nl_pos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>leading_nl_pos</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/* If so, we shouldn't add anything */</comment>
			<if_stmt><if>if <condition>(<expr><name>leading_nl_pos</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* instead, remove any trailing spaces currently in buf */</comment>
				<expr_stmt><expr><call><name>removeStringInfoSpaces</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>trailing_nl</name></decl>;</decl_stmt>

				<comment type="block">/* Locate the start of the current line in the output buffer */</comment>
				<expr_stmt><expr><name>trailing_nl</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>trailing_nl</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>trailing_nl</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>trailing_nl</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<comment type="block">/*
				 * Add a newline, plus some indentation, if the new field is
				 * not the first and either the new field would cause an
				 * overflow or the last field used more than one line.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>colno</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
					<operator>(</operator><operator>(</operator><call><name>strlen</name><argument_list>(<argument><expr><name>trailing_nl</name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>targetbuf</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <name><name>context</name><operator>-&gt;</operator><name>wrapColumn</name></name><operator>)</operator> <operator>||</operator>
					 <name>last_was_multiline</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><operator>-</operator><name>PRETTYINDENT_STD</name></expr></argument>,
										 <argument><expr><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><name>PRETTYINDENT_VAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/* Remember this field's multiline status for next iteration */</comment>
			<expr_stmt><expr><name>last_was_multiline</name> <operator>=</operator>
				<operator>(</operator><call><name>strchr</name><argument_list>(<argument><expr><name><name>targetbuf</name><operator>.</operator><name>data</name></name> <operator>+</operator> <name>leading_nl_pos</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Add the new field */</comment>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>targetbuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* clean up */</comment>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>targetbuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_setop_query</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>setOp</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
				<parameter><decl><type><name>TupleDesc</name></type> <name>resultDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>need_paren</name></decl>;</decl_stmt>

	<comment type="block">/* Guard against excessively long or deeply-nested queries */</comment>
	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>setOp</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rtr</name> <init>= <expr><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <name>setOp</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>subquery</name> <init>= <expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>subquery</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subquery</name><operator>-&gt;</operator><name>setOperations</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Need parens if WITH, ORDER BY, FOR UPDATE, or LIMIT; see gram.y */</comment>
		<expr_stmt><expr><name>need_paren</name> <operator>=</operator> <operator>(</operator><name><name>subquery</name><operator>-&gt;</operator><name>cteList</name></name> <operator>||</operator>
					  <name><name>subquery</name><operator>-&gt;</operator><name>sortClause</name></name> <operator>||</operator>
					  <name><name>subquery</name><operator>-&gt;</operator><name>rowMarks</name></name> <operator>||</operator>
					  <name><name>subquery</name><operator>-&gt;</operator><name>limitOffset</name></name> <operator>||</operator>
					  <name><name>subquery</name><operator>-&gt;</operator><name>limitCount</name></name><operator>)</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>need_paren</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>get_query_def</name><argument_list>(<argument><expr><name>subquery</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>namespaces</name></name></expr></argument>, <argument><expr><name>resultDesc</name></expr></argument>,
					  <argument><expr><name><name>context</name><operator>-&gt;</operator><name>prettyFlags</name></name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>wrapColumn</name></name></expr></argument>,
					  <argument><expr><name><name>context</name><operator>-&gt;</operator><name>indentLevel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>need_paren</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>setOp</name></expr></argument>, <argument><expr><name>SetOperationStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><operator>(</operator><name>SetOperationStmt</name> <operator>*</operator><operator>)</operator> <name>setOp</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>subindent</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * We force parens when nesting two SetOperationStmts, except when the
		 * lefthand input is another setop of the same kind.  Syntactically,
		 * we could omit parens in rather more cases, but it seems best to use
		 * parens to flag cases where the setop operator changes.  If we use
		 * parens, we also increase the indentation level for the child query.
		 *
		 * There are some cases in which parens are needed around a leaf query
		 * too, but those are more easily handled at the next level down (see
		 * code above).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>, <argument><expr><name>SetOperationStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>lop</name> <init>= <expr><operator>(</operator><name>SetOperationStmt</name> <operator>*</operator><operator>)</operator> <name><name>op</name><operator>-&gt;</operator><name>larg</name></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name><name>lop</name><operator>-&gt;</operator><name>op</name></name> <operator>&amp;&amp;</operator> <name><name>op</name><operator>-&gt;</operator><name>all</name></name> <operator>==</operator> <name><name>lop</name><operator>-&gt;</operator><name>all</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>need_paren</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>need_paren</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>need_paren</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>need_paren</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>subindent</name> <operator>=</operator> <name>PRETTYINDENT_STD</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>subindent</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>subindent</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>get_setop_query</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>resultDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>need_paren</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">") "</literal></expr></argument>, <argument><expr><operator>-</operator><name>subindent</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>PRETTY_INDENT</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><operator>-</operator><name>subindent</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<switch>switch <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>op</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>SETOP_UNION</name></expr>:</case>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"UNION "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>SETOP_INTERSECT</name></expr>:</case>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"INTERSECT "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>SETOP_EXCEPT</name></expr>:</case>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"EXCEPT "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized set op: %d"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>op</name><operator>-&gt;</operator><name>op</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
		<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>all</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ALL "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Always parenthesize if RHS is another setop */</comment>
		<expr_stmt><expr><name>need_paren</name> <operator>=</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>, <argument><expr><name>SetOperationStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * The indentation code here is deliberately a bit different from that
		 * for the lefthand input, because we want the line breaks in
		 * different places.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>need_paren</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>subindent</name> <operator>=</operator> <name>PRETTYINDENT_STD</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>subindent</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>subindent</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>get_setop_query</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>resultDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PRETTY_INDENT</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>indentLevel</name></name> <operator>-=</operator> <name>subindent</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>need_paren</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>setOp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Display a sort/group clause.
 *
 * Also returns the expression tree, so caller need not find it again.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>get_rule_sortgroupclause</name><parameter_list>(<parameter><decl><type><name>Index</name></type> <name>ref</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>force_colno</name></decl></parameter>,
						 <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>get_sortgroupref_tle</name><argument_list>(<argument><expr><name>ref</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Use column-number form if requested by caller.  Otherwise, if
	 * expression is a constant, force it to be dumped with an explicit cast
	 * as decoration --- this is because a simple integer constant is
	 * ambiguous (and will be misinterpreted by findTargetlistEntry()) if we
	 * dump it without any decoration.  If it's anything more complex than a
	 * simple Var, then force extra parens around it, to ensure it can't be
	 * misinterpreted as a cube() or rollup() construct.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>force_colno</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>expr</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>get_const_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name>expr</name> <operator>||</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * We must force parens for function-like expressions even if
		 * PRETTY_PAREN is off, since those are the ones in danger of
		 * misparsing. For other expressions we need to force them only if
		 * PRETTY_PAREN is on, since otherwise the expression will output them
		 * itself. (We can't skip the parens.)
		 */</comment>
		<decl_stmt><decl><type><name>bool</name></type>		<name>need_paren</name> <init>= <expr><operator>(</operator><call><name>PRETTY_PAREN</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call>
								  <operator>||</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call>
								  <operator>||</operator><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call>
								  <operator>||</operator><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>WindowFunc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>need_paren</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>need_paren</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>expr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Display a GroupingSet
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_rule_groupingset</name><parameter_list>(<parameter><decl><type><name>GroupingSet</name> <modifier>*</modifier></type><name>gset</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetlist</name></decl></parameter>,
					 <parameter><decl><type><name>bool</name></type> <name>omit_parens</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>omit_child_parens</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sep</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>gset</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>GROUPING_SET_EMPTY</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>

		<case>case <expr><name>GROUPING_SET_SIMPLE</name></expr>:</case>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>omit_parens</name> <operator>||</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>gset</name><operator>-&gt;</operator><name>content</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>gset-&gt;content</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Index</name></type>		<name>ref</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>get_rule_sortgroupclause</name><argument_list>(<argument><expr><name>ref</name></expr></argument>, <argument><expr><name>targetlist</name></expr></argument>,
											 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
				</block_content>}</block>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>omit_parens</name> <operator>||</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>gset</name><operator>-&gt;</operator><name>content</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
			<return>return;</return>

		<case>case <expr><name>GROUPING_SET_ROLLUP</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ROLLUP("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>GROUPING_SET_CUBE</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"CUBE("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>GROUPING_SET_SETS</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"GROUPING SETS ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>omit_child_parens</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>gset-&gt;content</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>get_rule_groupingset</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>targetlist</name></expr></argument>, <argument><expr><name>omit_child_parens</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Display an ORDER BY list.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_rule_orderby</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>orderList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name></type> <name>force_colno</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sep</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>orderList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>srt</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>sortexpr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>sortcoltype</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sortexpr</name> <operator>=</operator> <call><name>get_rule_sortgroupclause</name><argument_list>(<argument><expr><name><name>srt</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name></expr></argument>, <argument><expr><name>targetList</name></expr></argument>,
											<argument><expr><name>force_colno</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sortcoltype</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>sortexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* See whether operator is default &lt; or &gt; for datatype */</comment>
		<expr_stmt><expr><name>typentry</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name>sortcoltype</name></expr></argument>,
									 <argument><expr><name>TYPECACHE_LT_OPR</name> <operator>|</operator> <name>TYPECACHE_GT_OPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>srt</name><operator>-&gt;</operator><name>sortop</name></name> <operator>==</operator> <name><name>typentry</name><operator>-&gt;</operator><name>lt_opr</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* ASC is default, so emit nothing for it */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>srt</name><operator>-&gt;</operator><name>nulls_first</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" NULLS FIRST"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>srt</name><operator>-&gt;</operator><name>sortop</name></name> <operator>==</operator> <name><name>typentry</name><operator>-&gt;</operator><name>gt_opr</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" DESC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* DESC defaults to NULLS FIRST */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>srt</name><operator>-&gt;</operator><name>nulls_first</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" NULLS LAST"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" USING %s"</literal></expr></argument>,
							 <argument><expr><call><name>generate_operator_name</name><argument_list>(<argument><expr><name><name>srt</name><operator>-&gt;</operator><name>sortop</name></name></expr></argument>,
													<argument><expr><name>sortcoltype</name></expr></argument>,
													<argument><expr><name>sortcoltype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* be specific to eliminate ambiguity */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>srt</name><operator>-&gt;</operator><name>nulls_first</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" NULLS FIRST"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" NULLS LAST"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Display a WINDOW clause.
 *
 * Note that the windowClause list might contain only anonymous window
 * specifications, in which case we should print nothing here.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_rule_windowclause</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sep</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>sep</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>query-&gt;windowClause</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WindowClause</name> <modifier>*</modifier></type><name>wc</name> <init>= <expr><operator>(</operator><name>WindowClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>wc</name><operator>-&gt;</operator><name>name</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* ignore anonymous windows */</comment>

		<if_stmt><if>if <condition>(<expr><name>sep</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">" WINDOW "</literal></expr></argument>,
								 <argument><expr><operator>-</operator><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s AS "</literal></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name><name>wc</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>get_rule_windowspec</name><argument_list>(<argument><expr><name>wc</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Display a window definition
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_rule_windowspec</name><parameter_list>(<parameter><decl><type><name>WindowClause</name> <modifier>*</modifier></type><name>wc</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>,
					<parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>needspace</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sep</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>wc</name><operator>-&gt;</operator><name>refname</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name><name>wc</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>needspace</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* partition clauses are always inherited, so only print if no refname */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>wc</name><operator>-&gt;</operator><name>partitionClause</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>wc</name><operator>-&gt;</operator><name>refname</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>needspace</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"PARTITION BY "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>wc-&gt;partitionClause</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>grp</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>get_rule_sortgroupclause</name><argument_list>(<argument><expr><name><name>grp</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name></expr></argument>, <argument><expr><name>targetList</name></expr></argument>,
									 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><name>needspace</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* print ordering clause only if not inherited */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>wc</name><operator>-&gt;</operator><name>orderClause</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>wc</name><operator>-&gt;</operator><name>copiedOrder</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>needspace</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>get_rule_orderby</name><argument_list>(<argument><expr><name><name>wc</name><operator>-&gt;</operator><name>orderClause</name></name></expr></argument>, <argument><expr><name>targetList</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>needspace</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* framing clause is never inherited, so print unless it's default */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>wc</name><operator>-&gt;</operator><name>frameOptions</name></name> <operator>&amp;</operator> <name>FRAMEOPTION_NONDEFAULT</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>needspace</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>wc</name><operator>-&gt;</operator><name>frameOptions</name></name> <operator>&amp;</operator> <name>FRAMEOPTION_RANGE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"RANGE "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>wc</name><operator>-&gt;</operator><name>frameOptions</name></name> <operator>&amp;</operator> <name>FRAMEOPTION_ROWS</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ROWS "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>wc</name><operator>-&gt;</operator><name>frameOptions</name></name> <operator>&amp;</operator> <name>FRAMEOPTION_GROUPS</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"GROUPS "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>wc</name><operator>-&gt;</operator><name>frameOptions</name></name> <operator>&amp;</operator> <name>FRAMEOPTION_BETWEEN</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"BETWEEN "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>wc</name><operator>-&gt;</operator><name>frameOptions</name></name> <operator>&amp;</operator> <name>FRAMEOPTION_START_UNBOUNDED_PRECEDING</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"UNBOUNDED PRECEDING "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>wc</name><operator>-&gt;</operator><name>frameOptions</name></name> <operator>&amp;</operator> <name>FRAMEOPTION_START_CURRENT_ROW</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"CURRENT ROW "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>wc</name><operator>-&gt;</operator><name>frameOptions</name></name> <operator>&amp;</operator> <name>FRAMEOPTION_START_OFFSET</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name><name>wc</name><operator>-&gt;</operator><name>startOffset</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>wc</name><operator>-&gt;</operator><name>frameOptions</name></name> <operator>&amp;</operator> <name>FRAMEOPTION_START_OFFSET_PRECEDING</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" PRECEDING "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>wc</name><operator>-&gt;</operator><name>frameOptions</name></name> <operator>&amp;</operator> <name>FRAMEOPTION_START_OFFSET_FOLLOWING</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" FOLLOWING "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>wc</name><operator>-&gt;</operator><name>frameOptions</name></name> <operator>&amp;</operator> <name>FRAMEOPTION_BETWEEN</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"AND "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>wc</name><operator>-&gt;</operator><name>frameOptions</name></name> <operator>&amp;</operator> <name>FRAMEOPTION_END_UNBOUNDED_FOLLOWING</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"UNBOUNDED FOLLOWING "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>wc</name><operator>-&gt;</operator><name>frameOptions</name></name> <operator>&amp;</operator> <name>FRAMEOPTION_END_CURRENT_ROW</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"CURRENT ROW "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>wc</name><operator>-&gt;</operator><name>frameOptions</name></name> <operator>&amp;</operator> <name>FRAMEOPTION_END_OFFSET</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name><name>wc</name><operator>-&gt;</operator><name>endOffset</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>wc</name><operator>-&gt;</operator><name>frameOptions</name></name> <operator>&amp;</operator> <name>FRAMEOPTION_END_OFFSET_PRECEDING</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" PRECEDING "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name><name>wc</name><operator>-&gt;</operator><name>frameOptions</name></name> <operator>&amp;</operator> <name>FRAMEOPTION_END_OFFSET_FOLLOWING</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" FOLLOWING "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>wc</name><operator>-&gt;</operator><name>frameOptions</name></name> <operator>&amp;</operator> <name>FRAMEOPTION_EXCLUDE_CURRENT_ROW</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"EXCLUDE CURRENT ROW "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>wc</name><operator>-&gt;</operator><name>frameOptions</name></name> <operator>&amp;</operator> <name>FRAMEOPTION_EXCLUDE_GROUP</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"EXCLUDE GROUP "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>wc</name><operator>-&gt;</operator><name>frameOptions</name></name> <operator>&amp;</operator> <name>FRAMEOPTION_EXCLUDE_TIES</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"EXCLUDE TIES "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* we will now have a trailing space; remove it */</comment>
		<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>len</name></name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * get_insert_query_def			- Parse back an INSERT parsetree
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_insert_query_def</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>select_rte</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>values_rte</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sep</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>strippedexprs</name></decl>;</decl_stmt>

	<comment type="block">/* Insert the WITH clause if given */</comment>
	<expr_stmt><expr><call><name>get_with_clause</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If it's an INSERT ... SELECT or multi-row VALUES, there will be a
	 * single RTE for the SELECT or VALUES.  Plain VALUES has neither.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>query-&gt;rtable</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>rte</name> <operator>=</operator> <operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>select_rte</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"too many subquery RTEs in INSERT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>select_rte</name> <operator>=</operator> <name>rte</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_VALUES</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>values_rte</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"too many values RTEs in INSERT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>values_rte</name> <operator>=</operator> <name>rte</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<if_stmt><if>if <condition>(<expr><name>select_rte</name> <operator>&amp;&amp;</operator> <name>values_rte</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"both subquery and values RTEs in INSERT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Start the query with INSERT INTO relname
	 */</comment>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>resultRelation</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PRETTY_INDENT</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>indentLevel</name></name> <operator>+=</operator> <name>PRETTYINDENT_STD</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"INSERT INTO %s "</literal></expr></argument>,
					 <argument><expr><call><name>generate_relation_or_shard_name</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
													 <argument><expr><name><name>context</name><operator>-&gt;</operator><name>distrelid</name></name></expr></argument>,
													 <argument><expr><name><name>context</name><operator>-&gt;</operator><name>shardid</name></name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* INSERT requires AS keyword for target alias */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>alias</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"AS %s "</literal></expr></argument>,
						 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>get_rtable_name</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>resultRelation</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Add the insert-column-names list.  Any indirection decoration needed on
	 * the column names can be inferred from the top targetlist.
	 */</comment>
	<expr_stmt><expr><name>strippedexprs</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>query-&gt;targetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* ignore junk entries */</comment>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * Put out name of target column; look in the catalogs, not at
		 * tle-&gt;resname, since resname will fail to track RENAME.
		 */</comment>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,
							   <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>get_attname</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
															<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>,
															<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Print any indirection needed (subfields or subscripts), and strip
		 * off the top-level nodes representing the indirection assignments.
		 * Add the stripped expressions to strippedexprs.  (If it's a
		 * single-VALUES statement, the stripped expressions are the VALUES to
		 * print below.  Otherwise they're just Vars and not really
		 * interesting.)
		 */</comment>
		<expr_stmt><expr><name>strippedexprs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>strippedexprs</name></expr></argument>,
								<argument><expr><call><name>processIndirection</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
												   <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">") "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>override</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>override</name></name> <operator>==</operator> <name>OVERRIDING_SYSTEM_VALUE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"OVERRIDING SYSTEM VALUE "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>override</name></name> <operator>==</operator> <name>OVERRIDING_USER_VALUE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"OVERRIDING USER VALUE "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>select_rte</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Add the SELECT */</comment>
		<expr_stmt><expr><call><name>get_query_def</name><argument_list>(<argument><expr><name><name>select_rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					  <argument><expr><name><name>context</name><operator>-&gt;</operator><name>prettyFlags</name></name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>wrapColumn</name></name></expr></argument>,
					  <argument><expr><name><name>context</name><operator>-&gt;</operator><name>indentLevel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>values_rte</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Add the multi-VALUES expression lists */</comment>
		<expr_stmt><expr><call><name>get_values_def</name><argument_list>(<argument><expr><name><name>values_rte</name><operator>-&gt;</operator><name>values_lists</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>strippedexprs</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Add the single-VALUES expression list */</comment>
		<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"VALUES ("</literal></expr></argument>,
							 <argument><expr><operator>-</operator><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>strippedexprs</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* No expressions, so it must be DEFAULT VALUES */</comment>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"DEFAULT VALUES"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Add ON CONFLICT if present */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>onConflict</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OnConflictExpr</name> <modifier>*</modifier></type><name>confl</name> <init>= <expr><name><name>query</name><operator>-&gt;</operator><name>onConflict</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" ON CONFLICT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>confl</name><operator>-&gt;</operator><name>arbiterElems</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Add the single-VALUES expression list */</comment>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>confl</name><operator>-&gt;</operator><name>arbiterElems</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Add a WHERE clause (for partial indexes) if given */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>confl</name><operator>-&gt;</operator><name>arbiterWhere</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>bool</name></type>		<name>save_varprefix</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * Force non-prefixing of Vars, since parser assumes that they
				 * belong to target relation.  WHERE clause does not use
				 * InferenceElem, so this is separately required.
				 */</comment>
				<expr_stmt><expr><name>save_varprefix</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>varprefix</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>varprefix</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">" WHERE "</literal></expr></argument>,
									 <argument><expr><operator>-</operator><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name><name>confl</name><operator>-&gt;</operator><name>arbiterWhere</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>varprefix</name></name> <operator>=</operator> <name>save_varprefix</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>confl</name><operator>-&gt;</operator><name>constraint</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>constraint</name> <init>= <expr><call><name>get_constraint_name</name><argument_list>(<argument><expr><name><name>confl</name><operator>-&gt;</operator><name>constraint</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int64</name></type> <name>shardId</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>shardid</name></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>shardId</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><operator>&amp;</operator><name>constraint</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>constraint</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for constraint %u"</literal></expr></argument>,
					 <argument><expr><name><name>confl</name><operator>-&gt;</operator><name>constraint</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" ON CONSTRAINT %s"</literal></expr></argument>,
							 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>constraint</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>confl</name><operator>-&gt;</operator><name>action</name></name> <operator>==</operator> <name>ONCONFLICT_NOTHING</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" DO NOTHING"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" DO UPDATE SET "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Deparse targetlist */</comment>
			<expr_stmt><expr><call><name>get_update_query_targetlist_def</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name><name>confl</name><operator>-&gt;</operator><name>onConflictSet</name></name></expr></argument>,
											<argument><expr><name>context</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Add a WHERE clause if given */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>confl</name><operator>-&gt;</operator><name>onConflictWhere</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">" WHERE "</literal></expr></argument>,
									 <argument><expr><operator>-</operator><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name><name>confl</name><operator>-&gt;</operator><name>onConflictWhere</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Add RETURNING if present */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>returningList</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">" RETURNING"</literal></expr></argument>,
							 <argument><expr><operator>-</operator><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>get_target_list</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>returningList</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------
 * get_update_query_def			- Parse back an UPDATE parsetree
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_update_query_def</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>

	<comment type="block">/* Insert the WITH clause if given */</comment>
	<expr_stmt><expr><call><name>get_with_clause</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Start the query with UPDATE relname SET
	 */</comment>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>resultRelation</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PRETTY_INDENT</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>indentLevel</name></name> <operator>+=</operator> <name>PRETTYINDENT_STD</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* if it's a shard, do differently */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>GetRangeTblKind</name><argument_list>(<argument><expr><name>rte</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CITUS_RTE_SHARD</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>fragmentSchemaName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>fragmentTableName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ExtractRangeTblExtraData</name><argument_list>(<argument><expr><name>rte</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fragmentSchemaName</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fragmentTableName</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* use schema and table name from the remote alias */</comment>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"UPDATE %s%s"</literal></expr></argument>,
						 <argument><expr><call><name>only_marker</name><argument_list>(<argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>generate_fragment_name</name><argument_list>(<argument><expr><name>fragmentSchemaName</name></expr></argument>, <argument><expr><name>fragmentTableName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if<condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>,
					<argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>get_rtable_name</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>resultRelation</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"UPDATE %s%s"</literal></expr></argument>,
						 <argument><expr><call><name>only_marker</name><argument_list>(<argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>generate_relation_or_shard_name</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
														 <argument><expr><name><name>context</name><operator>-&gt;</operator><name>distrelid</name></name></expr></argument>,
														 <argument><expr><name><name>context</name><operator>-&gt;</operator><name>shardid</name></name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>alias</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>,
							 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>get_rtable_name</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>resultRelation</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" SET "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Deparse targetlist */</comment>
	<expr_stmt><expr><call><name>get_update_query_targetlist_def</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add the FROM clause if needed */</comment>
	<expr_stmt><expr><call><name>get_from_clause</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">" FROM "</literal></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add a WHERE clause if given */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">" WHERE "</literal></expr></argument>,
							 <argument><expr><operator>-</operator><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Add RETURNING if present */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>returningList</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">" RETURNING"</literal></expr></argument>,
							 <argument><expr><operator>-</operator><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>get_target_list</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>returningList</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------
 * get_update_query_targetlist_def			- Parse back an UPDATE targetlist
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_update_query_targetlist_def</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>,
								<parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>next_ma_cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>remaining_ma_columns</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sep</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SubLink</name>    <modifier>*</modifier></type><name>cur_ma_sublink</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>ma_sublinks</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Prepare to deal with MULTIEXPR assignments: collect the source SubLinks
	 * into a list.  We expect them to appear, in ID order, in resjunk tlist
	 * entries.
	 */</comment>
	<expr_stmt><expr><name>ma_sublinks</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>hasSubLinks</name></name></expr>)</condition>		<comment type="block">/* else there can't be any */</comment>
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>targetList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>SubLink</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SubLink</name>    <modifier>*</modifier></type><name>sl</name> <init>= <expr><operator>(</operator><name>SubLink</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>sl</name><operator>-&gt;</operator><name>subLinkType</name></name> <operator>==</operator> <name>MULTIEXPR_SUBLINK</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>ma_sublinks</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>ma_sublinks</name></expr></argument>, <argument><expr><name>sl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>sl</name><operator>-&gt;</operator><name>subLinkId</name></name> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>ma_sublinks</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>next_ma_cell</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>ma_sublinks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cur_ma_sublink</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>remaining_ma_columns</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* Add the comma separated list of 'attname = value' */</comment>
	<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>targetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* ignore junk entries */</comment>

		<comment type="block">/* Emit separator (OK whether we're in multiassignment or not) */</comment>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * Check to see if we're starting a multiassignment group: if so,
		 * output a left paren.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>next_ma_cell</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>cur_ma_sublink</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We must dig down into the expr to see if it's a PARAM_MULTIEXPR
			 * Param.  That could be buried under FieldStores and
			 * SubscriptingRefs and CoerceToDomains (cf processIndirection()),
			 * and underneath those there could be an implicit type coercion.
			 * Because we would ignore implicit type coercions anyway, we
			 * don't need to be as careful as processIndirection() is about
			 * descending past implicit CoerceToDomains.
			 */</comment>
			<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr>;</expr_stmt>
			<while>while <condition>(<expr><name>expr</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>FieldStore</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>FieldStore</name> <modifier>*</modifier></type><name>fstore</name> <init>= <expr><operator>(</operator><name>FieldStore</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>fstore</name><operator>-&gt;</operator><name>newvals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>SubscriptingRef</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>SubscriptingRef</name> <modifier>*</modifier></type><name>sbsref</name> <init>= <expr><operator>(</operator><name>SubscriptingRef</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>sbsref</name><operator>-&gt;</operator><name>refassgnexpr</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>sbsref</name><operator>-&gt;</operator><name>refassgnexpr</name></name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>CoerceToDomain</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>CoerceToDomain</name> <modifier>*</modifier></type><name>cdomain</name> <init>= <expr><operator>(</operator><name>CoerceToDomain</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>cdomain</name><operator>-&gt;</operator><name>coercionformat</name></name> <operator>!=</operator> <name>COERCE_IMPLICIT_CAST</name></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>cdomain</name><operator>-&gt;</operator><name>arg</name></name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<break>break;</break></block_content></block></else></if_stmt>
			</block_content>}</block></while>
			<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>strip_implicit_coercions</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>expr</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<operator>(</operator><operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>paramkind</name> <operator>==</operator> <name>PARAM_MULTIEXPR</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>cur_ma_sublink</name> <operator>=</operator> <operator>(</operator><name>SubLink</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>next_ma_cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>next_ma_cell</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>ma_sublinks</name></expr></argument>, <argument><expr><name>next_ma_cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>remaining_ma_columns</name> <operator>=</operator> <call><name>count_nonjunk_tlist_entries</name><argument_list>(
																   <argument><expr><operator>(</operator><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name><name>cur_ma_sublink</name><operator>-&gt;</operator><name>subselect</name></name><operator>)</operator><operator>-&gt;</operator><name>targetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>paramid</name> <operator>==</operator>
					   <operator>(</operator><operator>(</operator><name><name>cur_ma_sublink</name><operator>-&gt;</operator><name>subLinkId</name></name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>|</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Put out name of target column; look in the catalogs, not at
		 * tle-&gt;resname, since resname will fail to track RENAME.
		 */</comment>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,
							   <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>get_attname</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
															<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>,
															<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Print any indirection needed (subfields or subscripts), and strip
		 * off the top-level nodes representing the indirection assignments.
		 */</comment>
		<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>processIndirection</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we're in a multiassignment, skip printing anything more, unless
		 * this is the last column; in which case, what we print should be the
		 * sublink, not the Param.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>cur_ma_sublink</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>--</operator><name>remaining_ma_columns</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* not the last column of multiassignment */</comment>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>cur_ma_sublink</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>cur_ma_sublink</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/* ----------
 * get_delete_query_def			- Parse back a DELETE parsetree
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_delete_query_def</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>

	<comment type="block">/* Insert the WITH clause if given */</comment>
	<expr_stmt><expr><call><name>get_with_clause</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Start the query with DELETE FROM relname
	 */</comment>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>resultRelation</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PRETTY_INDENT</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>indentLevel</name></name> <operator>+=</operator> <name>PRETTYINDENT_STD</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* if it's a shard, do differently */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>GetRangeTblKind</name><argument_list>(<argument><expr><name>rte</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CITUS_RTE_SHARD</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>fragmentSchemaName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>fragmentTableName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ExtractRangeTblExtraData</name><argument_list>(<argument><expr><name>rte</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fragmentSchemaName</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fragmentTableName</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* use schema and table name from the remote alias */</comment>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"DELETE FROM %s%s"</literal></expr></argument>,
						 <argument><expr><call><name>only_marker</name><argument_list>(<argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>generate_fragment_name</name><argument_list>(<argument><expr><name>fragmentSchemaName</name></expr></argument>, <argument><expr><name>fragmentTableName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if<condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>,
					<argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>get_rtable_name</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>resultRelation</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"DELETE FROM %s%s"</literal></expr></argument>,
						 <argument><expr><call><name>only_marker</name><argument_list>(<argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>generate_relation_or_shard_name</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
														 <argument><expr><name><name>context</name><operator>-&gt;</operator><name>distrelid</name></name></expr></argument>,
														 <argument><expr><name><name>context</name><operator>-&gt;</operator><name>shardid</name></name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>alias</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>,
							 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>get_rtable_name</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>resultRelation</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Add the USING clause if given */</comment>
	<expr_stmt><expr><call><name>get_from_clause</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">" USING "</literal></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add a WHERE clause if given */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">" WHERE "</literal></expr></argument>,
							 <argument><expr><operator>-</operator><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Add RETURNING if present */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>returningList</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">" RETURNING"</literal></expr></argument>,
							 <argument><expr><operator>-</operator><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>get_target_list</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>returningList</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------
 * get_utility_query_def			- Parse back a UTILITY parsetree
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_utility_query_def</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>, <argument><expr><name>NotifyStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>NotifyStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>NotifyStmt</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>,
							 <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"NOTIFY %s"</literal></expr></argument>,
						 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>conditionname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>payload</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>simple_quote_literal</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>payload</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>, <argument><expr><name>TruncateStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TruncateStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>TruncateStmt</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>relationList</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>relations</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>relationCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>,
							 <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"TRUNCATE TABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<macro><name>foreach</name><argument_list>(<argument>relationCell</argument>, <argument>relationList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>relationVar</name> <init>= <expr><operator>(</operator><name>RangeVar</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>relationCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>relationVar</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>generate_relation_or_shard_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>,
																 <argument><expr><name><name>context</name><operator>-&gt;</operator><name>distrelid</name></name></expr></argument>,
																 <argument><expr><name><name>context</name><operator>-&gt;</operator><name>shardid</name></name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><name>relationName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>lnext</name><argument_list>(<argument><expr><name>relationList</name></expr></argument>, <argument><expr><name>relationCell</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>restart_seqs</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" RESTART IDENTITY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>behavior</name></name> <operator>==</operator> <name>DROP_CASCADE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" CASCADE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Currently only NOTIFY utility commands can appear in rules */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected utility statement type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Display a Var appropriately.
 *
 * In some cases (currently only when recursing into an unnamed join)
 * the Var's varlevelsup has to be interpreted with respect to a context
 * above the current one; levelsup indicates the offset.
 *
 * If istoplevel is true, the Var is at the top level of a SELECT's
 * targetlist, which means we need special treatment of whole-row Vars.
 * Instead of the normal "tab.*", we'll print "tab.*::typename", which is a
 * dirty hack to prevent "tab.*" from being expanded into multiple columns.
 * (The parser will strip the useless coercion, so no inefficiency is added in
 * dump and reload.)  We used to print just "tab" in such cases, but that is
 * ambiguous and will yield the wrong result if "tab" is also a plain column
 * name in the query.
 *
 * Returns the attname of the Var, or NULL if the Var has no attname (because
 * it is a whole-row Var or a subplan output reference).
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_variable</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>levelsup</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>istoplevel</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>		<name>varno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>varattno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>netlevelsup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>deparse_columns</name> <modifier>*</modifier></type><name>colinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>refname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attname</name></decl>;</decl_stmt>

	<comment type="block">/* Find appropriate nesting depth */</comment>
	<expr_stmt><expr><name>netlevelsup</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>+</operator> <name>levelsup</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>netlevelsup</name> <operator>&gt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>namespaces</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"bogus varlevelsup: %d offset %d"</literal></expr></argument>,
			 <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name></expr></argument>, <argument><expr><name>levelsup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>dpns</name> <operator>=</operator> <operator>(</operator><name>deparse_namespace</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>namespaces</name></name></expr></argument>,
										  <argument><expr><name>netlevelsup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>varno</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>varattno</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr>;</expr_stmt>


	<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varnosyn</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>var</name><operator>-&gt;</operator><name>varnosyn</name></name> <operator>&lt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>dpns</name><operator>-&gt;</operator><name>plan</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varnosyn</name></name></expr></argument>, <argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * if the rte var-&gt;varnosyn points to is not a regular table and it is a join
		 * then the correct relname will be found with var-&gt;varnosyn and var-&gt;varattnosyn
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_JOIN</name> <operator>&amp;&amp;</operator> <name><name>rte</name><operator>-&gt;</operator><name>relid</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>var</name><operator>-&gt;</operator><name>varnosyn</name></name> <operator>!=</operator> <name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>varno</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>varnosyn</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>varattno</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>varattnosyn</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Try to find the relevant RTE in this rtable.  In a plan tree, it's
	 * likely that varno is OUTER_VAR or INNER_VAR, in which case we must dig
	 * down into the subplans, or INDEX_VAR, which is resolved similarly. Also
	 * find the aliases previously assigned for this RTE.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>varno</name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>varno</name> <operator>&lt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>

		<comment type="block">/*
		 * We might have been asked to map child Vars to some parent relation.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>appendparents</name></name> <operator>&amp;&amp;</operator> <name><name>dpns</name><operator>-&gt;</operator><name>appendrels</name></name></expr>)</condition>
		<block>{<block_content>

			<decl_stmt><decl><type><name>Index</name></type>		<name>pvarno</name> <init>= <expr><name>varno</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>pvarattno</name> <init>= <expr><name>varattno</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo</name> <init>= <expr><name><name>dpns</name><operator>-&gt;</operator><name>appendrels</name><index>[<expr><name>pvarno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* Only map up to inheritance parents, not UNION ALL appendrels */</comment>
			<while>while <condition>(<expr><name>appinfo</name> <operator>&amp;&amp;</operator>
				   <call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>appinfo</name><operator>-&gt;</operator><name>parent_relid</name></name></expr></argument>,
							<argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>rtekind</name> <operator>==</operator> <name>RTE_RELATION</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>pvarattno</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>	<comment type="block">/* system columns stay as-is */</comment>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>pvarattno</name> <operator>&gt;</operator> <name><name>appinfo</name><operator>-&gt;</operator><name>num_child_cols</name></name></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>	<comment type="block">/* safety check */</comment>
					<expr_stmt><expr><name>pvarattno</name> <operator>=</operator> <name><name>appinfo</name><operator>-&gt;</operator><name>parent_colnos</name><index>[<expr><name>pvarattno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>pvarattno</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>	<comment type="block">/* Var is local to child */</comment>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name>pvarno</name> <operator>=</operator> <name><name>appinfo</name><operator>-&gt;</operator><name>parent_relid</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

				<comment type="block">/* If the parent is itself a child, continue up. */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pvarno</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>pvarno</name> <operator>&lt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>appinfo</name> <operator>=</operator> <name><name>dpns</name><operator>-&gt;</operator><name>appendrels</name><index>[<expr><name>pvarno</name></expr>]</index></name></expr>;</expr_stmt>
			</block_content>}</block></while>

			<comment type="block">/*
			 * If we found an ancestral rel, and that rel is included in
			 * appendparents, print that column not the original one.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>found</name> <operator>&amp;&amp;</operator> <call><name>bms_is_member</name><argument_list>(<argument><expr><name>pvarno</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>appendparents</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>varno</name> <operator>=</operator> <name>pvarno</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>varattno</name> <operator>=</operator> <name>pvarattno</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name>varno</name></expr></argument>, <argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>refname</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>rtable_names</name></name></expr></argument>, <argument><expr><name>varno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>colinfo</name> <operator>=</operator> <call><name>deparse_columns_fetch</name><argument_list>(<argument><expr><name>varno</name></expr></argument>, <argument><expr><name>dpns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>attnum</name> <operator>=</operator> <name>varattno</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>resolve_special_varno</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>get_special_variable</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * The planner will sometimes emit Vars referencing resjunk elements of a
	 * subquery's target list (this is currently only possible if it chooses
	 * to generate a "physical tlist" for a SubqueryScan or CteScan node).
	 * Although we prefer to print subquery-referencing Vars using the
	 * subquery's alias, that's not possible for resjunk items since they have
	 * no alias.  So in that case, drill down to the subplan and print the
	 * contents of the referenced tlist item.  This works because in a plan
	 * tree, such Vars can only occur in a SubqueryScan or CteScan node, and
	 * we'll have set dpns-&gt;inner_plan to reference the child plan node.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name> <operator>||</operator> <name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_CTE</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<name>attnum</name> <operator>&gt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<name><name>dpns</name><operator>-&gt;</operator><name>inner_plan</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>deparse_namespace</name></type> <name>save_dpns</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>get_tle_by_resno</name><argument_list>(<argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>inner_tlist</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tle</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid attnum %d for relation \"%s\""</literal></expr></argument>,
				 <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>netlevelsup</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>push_child_plan</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>inner_plan</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>save_dpns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Force parentheses because our caller probably assumed a Var is a
		 * simple expression.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>pop_child_plan</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>save_dpns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If it's an unnamed join, look at the expansion of the alias variable.
	 * If it's a simple reference to one of the input vars, then recursively
	 * print the name of that var instead.  When it's not a simple reference,
	 * we have to just print the unqualified join column name.  (This can only
	 * happen with "dangerous" merged columns in a JOIN USING; we took pains
	 * previously to make the unqualified column name unique in such cases.)
	 *
	 * This wouldn't work in decompiling plan trees, because we don't store
	 * joinaliasvars lists after planning; but a plan tree should never
	 * contain a join alias variable.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_JOIN</name> <operator>&amp;&amp;</operator> <name><name>rte</name><operator>-&gt;</operator><name>alias</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>joinaliasvars</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot decompile join alias var in plan tree"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>aliasvar</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>aliasvar</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>joinaliasvars</name></name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* we intentionally don't strip implicit coercions here */</comment>
			<if_stmt><if>if <condition>(<expr><name>aliasvar</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>aliasvar</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<return>return <expr><call><name>get_variable</name><argument_list>(<argument><expr><name>aliasvar</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>+</operator> <name>levelsup</name></expr></argument>,
									<argument><expr><name>istoplevel</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Unnamed join has no refname.  (Note: since it's unnamed, there is
		 * no way the user could have referenced it to create a whole-row Var
		 * for it.  So we don't have to cover that case below.)
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>refname</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>attname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>attnum</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Get column name to use from the colinfo struct */</comment>
		<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&gt;</operator> <name><name>colinfo</name><operator>-&gt;</operator><name>num_cols</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid attnum %d for relation \"%s\""</literal></expr></argument>,
				 <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>attname</name> <operator>=</operator> <name><name>colinfo</name><operator>-&gt;</operator><name>colnames</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>attname</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* dropped column? */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid attnum %d for relation \"%s\""</literal></expr></argument>,
				 <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>GetRangeTblKind</name><argument_list>(<argument><expr><name>rte</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CITUS_RTE_SHARD</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* System column on a Citus shard */</comment>
		<expr_stmt><expr><name>attname</name> <operator>=</operator> <call><name>get_attname</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* System column - name is fixed, get it from the catalog */</comment>
		<expr_stmt><expr><name>attname</name> <operator>=</operator> <call><name>get_rte_attribute_name</name><argument_list>(<argument><expr><name>rte</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>refname</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>context</name><operator>-&gt;</operator><name>varprefix</name></name> <operator>||</operator> <name>attname</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>refname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>attname</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'*'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>istoplevel</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>GetRangeTblKind</name><argument_list>(<argument><expr><name>rte</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CITUS_RTE_SHARD</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* use rel.*::shard_name instead of rel.*::table_name */</comment>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"::%s"</literal></expr></argument>,
								 <argument><expr><call><name>generate_rte_shard_name</name><argument_list>(<argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"::%s"</literal></expr></argument>,
								 <argument><expr><call><name>format_type_with_typemod</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>vartype</name></name></expr></argument>,
														  <argument><expr><name><name>var</name><operator>-&gt;</operator><name>vartypmod</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>attname</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Deparse a Var which references OUTER_VAR, INNER_VAR, or INDEX_VAR.  This
 * routine is actually a callback for get_special_varno, which handles finding
 * the correct TargetEntry.  We get the expression contained in that
 * TargetEntry and just need to deparse it, a job we can throw back on
 * get_rule_expr.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_special_variable</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>callback_arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * For a non-Var referent, force parentheses because our caller probably
	 *  assumed a Var is a simple expression.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Chase through plan references to special varnos (OUTER_VAR, INNER_VAR,
 * INDEX_VAR) until we find a real Var or some kind of non-Var node; then,
 * invoke the callback provided.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>resolve_special_varno</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>rsv_callback</name></type> <name>callback</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>callback_arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl>;</decl_stmt>

	<comment type="block">/* This function is recursive, so let's be paranoid. */</comment>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If it's not a Var, invoke the callback. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>callback</name>) <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>callback_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Find appropriate nesting depth */</comment>
	<expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>dpns</name> <operator>=</operator> <operator>(</operator><name>deparse_namespace</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>namespaces</name></name></expr></argument>,
										  <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * It's a special RTE, so recurse.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name>OUTER_VAR</name> <operator>&amp;&amp;</operator> <name><name>dpns</name><operator>-&gt;</operator><name>outer_tlist</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>deparse_namespace</name></type> <name>save_dpns</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>save_appendparents</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>get_tle_by_resno</name><argument_list>(<argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>outer_tlist</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tle</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"bogus varattno for OUTER_VAR var: %d"</literal></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* If we're descending to the first child of an Append or MergeAppend,
		 * update appendparents.  This will affect deparsing of all Vars
		 * appearing within the eventually-resolved subexpression.
		 */</comment>
		<expr_stmt><expr><name>save_appendparents</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>appendparents</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><name>Append</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>appendparents</name></name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>appendparents</name></name></expr></argument>,
											   <argument><expr><operator>(</operator><operator>(</operator><name>Append</name> <operator>*</operator><operator>)</operator> <name><name>dpns</name><operator>-&gt;</operator><name>plan</name></name><operator>)</operator><operator>-&gt;</operator><name>apprelids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><name>MergeAppend</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>appendparents</name></name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>appendparents</name></name></expr></argument>,
											   <argument><expr><operator>(</operator><operator>(</operator><name>MergeAppend</name> <operator>*</operator><operator>)</operator> <name><name>dpns</name><operator>-&gt;</operator><name>plan</name></name><operator>)</operator><operator>-&gt;</operator><name>apprelids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>push_child_plan</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>outer_plan</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>save_dpns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>resolve_special_varno</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>,
							  <argument><expr><name>callback</name></expr></argument>, <argument><expr><name>callback_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pop_child_plan</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>save_dpns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>appendparents</name></name> <operator>=</operator> <name>save_appendparents</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name>INNER_VAR</name> <operator>&amp;&amp;</operator> <name><name>dpns</name><operator>-&gt;</operator><name>inner_tlist</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>deparse_namespace</name></type> <name>save_dpns</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>get_tle_by_resno</name><argument_list>(<argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>inner_tlist</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tle</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"bogus varattno for INNER_VAR var: %d"</literal></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>push_child_plan</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>inner_plan</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>save_dpns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>resolve_special_varno</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>callback</name></expr></argument>, <argument><expr><name>callback_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pop_child_plan</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>save_dpns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name>INDEX_VAR</name> <operator>&amp;&amp;</operator> <name><name>dpns</name><operator>-&gt;</operator><name>index_tlist</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>get_tle_by_resno</name><argument_list>(<argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>index_tlist</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tle</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"bogus varattno for INDEX_VAR var: %d"</literal></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>resolve_special_varno</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>callback</name></expr></argument>, <argument><expr><name>callback_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>&gt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"bogus varno: %d"</literal></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Not special.  Just invoke the callback. */</comment>
	<expr_stmt><expr><call>(<modifier>*</modifier><name>callback</name>) <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>callback_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get the name of a field of an expression of composite type.  The
 * expression is usually a Var, but we handle other cases too.
 *
 * levelsup is an extra offset to interpret the Var's varlevelsup correctly.
 *
 * This is fairly straightforward when the expression has a named composite
 * type; we need only look up the type in the catalogs.  However, the type
 * could also be RECORD.  Since no actual table or view column is allowed to
 * have type RECORD, a Var of type RECORD must refer to a JOIN or FUNCTION RTE
 * or to a subquery output.  We drill down to find the ultimate defining
 * expression and attempt to infer the field name from it.  We ereport if we
 * can't determine the name.
 *
 * Similarly, a PARAM of type RECORD has to refer to some expression of
 * a determinable composite type.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_name_for_var_field</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fieldno</name></decl></parameter>,
					   <parameter><decl><type><name>int</name></type> <name>levelsup</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>netlevelsup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>		<name>varno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>varattno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupleDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If it's a RowExpr that was expanded from a whole-row Var, use the
	 * column names attached to it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>RowExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RowExpr</name>    <modifier>*</modifier></type><name>r</name> <init>= <expr><operator>(</operator><name>RowExpr</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>fieldno</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>fieldno</name> <operator>&lt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>r</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>r</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>, <argument><expr><name>fieldno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If it's a Param of type RECORD, try to find what the Param refers to.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Param</name>	   <modifier>*</modifier></type><name>param</name> <init>= <expr><operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>ancestor_cell</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>find_param_referent</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dpns</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ancestor_cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>expr</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Found a match, so recurse to decipher the field name */</comment>
			<decl_stmt><decl><type><name>deparse_namespace</name></type> <name>save_dpns</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>push_ancestor_plan</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><name>ancestor_cell</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>save_dpns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>get_name_for_var_field</name><argument_list>(<argument><expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>, <argument><expr><name>fieldno</name></expr></argument>,
											<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pop_ancestor_plan</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>save_dpns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>result</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If it's a Var of type RECORD, we have to find what the Var refers to;
	 * if not, we can use get_expr_result_tupdesc().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<name><name>var</name><operator>-&gt;</operator><name>vartype</name></name> <operator>!=</operator> <name>RECORDOID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tupleDesc</name> <operator>=</operator> <call><name>get_expr_result_tupdesc</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Got the tupdesc, so we can extract the field name */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>fieldno</name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>fieldno</name> <operator>&lt;=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>NameStr</name><argument_list>(<argument><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>fieldno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attname</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Find appropriate nesting depth */</comment>
	<expr_stmt><expr><name>netlevelsup</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>+</operator> <name>levelsup</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>netlevelsup</name> <operator>&gt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>namespaces</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"bogus varlevelsup: %d offset %d"</literal></expr></argument>,
			 <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name></expr></argument>, <argument><expr><name>levelsup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>dpns</name> <operator>=</operator> <operator>(</operator><name>deparse_namespace</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>namespaces</name></name></expr></argument>,
										  <argument><expr><name>netlevelsup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>varno</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>varattno</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varnosyn</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>var</name><operator>-&gt;</operator><name>varnosyn</name></name> <operator>&lt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>dpns</name><operator>-&gt;</operator><name>plan</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varnosyn</name></name></expr></argument>, <argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * if the rte var-&gt;varnosyn points to is not a regular table and it is a join
		 * then the correct relname will be found with var-&gt;varnosyn and var-&gt;varattnosyn
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_JOIN</name> <operator>&amp;&amp;</operator> <name><name>rte</name><operator>-&gt;</operator><name>relid</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>var</name><operator>-&gt;</operator><name>varnosyn</name></name> <operator>!=</operator> <name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>varno</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>varnosyn</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>varattno</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>varattnosyn</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Try to find the relevant RTE in this rtable.  In a plan tree, it's
	 * likely that varno is OUTER_VAR or INNER_VAR, in which case we must dig
	 * down into the subplans, or INDEX_VAR, which is resolved similarly.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>varno</name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>varno</name> <operator>&lt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name>varno</name></expr></argument>, <argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>attnum</name> <operator>=</operator> <name>varattno</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>varno</name> <operator>==</operator> <name>OUTER_VAR</name> <operator>&amp;&amp;</operator> <name><name>dpns</name><operator>-&gt;</operator><name>outer_tlist</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>deparse_namespace</name></type> <name>save_dpns</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>get_tle_by_resno</name><argument_list>(<argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>outer_tlist</name></name></expr></argument>, <argument><expr><name>varattno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tle</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"bogus varattno for OUTER_VAR var: %d"</literal></expr></argument>, <argument><expr><name>varattno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>netlevelsup</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>push_child_plan</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>outer_plan</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>save_dpns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>get_name_for_var_field</name><argument_list>(<argument><expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>fieldno</name></expr></argument>,
										<argument><expr><name>levelsup</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pop_child_plan</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>save_dpns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>varno</name> <operator>==</operator> <name>INNER_VAR</name> <operator>&amp;&amp;</operator> <name><name>dpns</name><operator>-&gt;</operator><name>inner_tlist</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>deparse_namespace</name></type> <name>save_dpns</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>get_tle_by_resno</name><argument_list>(<argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>inner_tlist</name></name></expr></argument>, <argument><expr><name>varattno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tle</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"bogus varattno for INNER_VAR var: %d"</literal></expr></argument>, <argument><expr><name>varattno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>netlevelsup</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>push_child_plan</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>inner_plan</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>save_dpns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>get_name_for_var_field</name><argument_list>(<argument><expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>fieldno</name></expr></argument>,
										<argument><expr><name>levelsup</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pop_child_plan</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>save_dpns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>varno</name> <operator>==</operator> <name>INDEX_VAR</name> <operator>&amp;&amp;</operator> <name><name>dpns</name><operator>-&gt;</operator><name>index_tlist</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>get_tle_by_resno</name><argument_list>(<argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>index_tlist</name></name></expr></argument>, <argument><expr><name>varattno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tle</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"bogus varattno for INDEX_VAR var: %d"</literal></expr></argument>, <argument><expr><name>varattno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>netlevelsup</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>get_name_for_var_field</name><argument_list>(<argument><expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>fieldno</name></expr></argument>,
										<argument><expr><name>levelsup</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"bogus varno: %d"</literal></expr></argument>, <argument><expr><name>varno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>			<comment type="block">/* keep compiler quiet */</comment>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Var is whole-row reference to RTE, so select the right field */</comment>
		<return>return <expr><call><name>get_rte_attribute_name</name><argument_list>(<argument><expr><name>rte</name></expr></argument>, <argument><expr><name>fieldno</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * This part has essentially the same logic as the parser's
	 * expandRecordVariable() function, but we are dealing with a different
	 * representation of the input context, and we only need one field name
	 * not a TupleDesc.  Also, we need special cases for finding subquery and
	 * CTE subplans when deparsing Plan trees.
	 */</comment>
	<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>var</name></expr>;</expr_stmt>		<comment type="block">/* default if we can't drill down */</comment>

	<switch>switch <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RTE_RELATION</name></expr>:</case>
		<case>case <expr><name>RTE_VALUES</name></expr>:</case>
		<case>case <expr><name>RTE_NAMEDTUPLESTORE</name></expr>:</case>
		<case>case <expr><name>RTE_RESULT</name></expr>:</case>

			<comment type="block">/*
			 * This case should not occur: a column of a table or values list
			 * shouldn't have type RECORD.  Fall through and fail (most
			 * likely) at the bottom.
			 */</comment>
			<break>break;</break>
		<case>case <expr><name>RTE_SUBQUERY</name></expr>:</case>
			<comment type="block">/* Subselect-in-FROM: examine sub-select's output expr */</comment>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>ste</name> <init>= <expr><call><name>get_tle_by_resno</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
														<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>ste</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>ste</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"subquery %s does not have attribute %d"</literal></expr></argument>,
							 <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>ste</name><operator>-&gt;</operator><name>expr</name></name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * Recurse into the sub-select to see what its Var
						 * refers to. We have to build an additional level of
						 * namespace to keep in step with varlevelsup in the
						 * subselect.
						 */</comment>
						<decl_stmt><decl><type><name>deparse_namespace</name></type> <name>mydpns</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

						<expr_stmt><expr><call><name>set_deparse_for_query</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mydpns</name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>,
											  <argument><expr><name><name>context</name><operator>-&gt;</operator><name>namespaces</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>namespaces</name></name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mydpns</name></expr></argument>,
													<argument><expr><name><name>context</name><operator>-&gt;</operator><name>namespaces</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>get_name_for_var_field</name><argument_list>(<argument><expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>, <argument><expr><name>fieldno</name></expr></argument>,
														<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>namespaces</name></name> <operator>=</operator>
							<call><name>list_delete_first</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>namespaces</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<return>return <expr><name>result</name></expr>;</return>
					</block_content>}</block></if></if_stmt>
					<comment type="block">/* else fall through to inspect the expression */</comment>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/*
					 * We're deparsing a Plan tree so we don't have complete
					 * RTE entries (in particular, rte-&gt;subquery is NULL). But
					 * the only place we'd see a Var directly referencing a
					 * SUBQUERY RTE is in a SubqueryScan plan node, and we can
					 * look into the child plan's tlist instead.
					 */</comment>
					<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>deparse_namespace</name></type> <name>save_dpns</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dpns</name><operator>-&gt;</operator><name>inner_plan</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to find plan for subquery %s"</literal></expr></argument>,
							 <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>get_tle_by_resno</name><argument_list>(<argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>inner_tlist</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tle</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"bogus varattno for subquery var: %d"</literal></expr></argument>,
							 <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>netlevelsup</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>push_child_plan</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>inner_plan</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>save_dpns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>get_name_for_var_field</name><argument_list>(<argument><expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>fieldno</name></expr></argument>,
													<argument><expr><name>levelsup</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>pop_child_plan</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>save_dpns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>result</name></expr>;</return>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>RTE_JOIN</name></expr>:</case>
			<comment type="block">/* Join RTE --- recursively inspect the alias variable */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>joinaliasvars</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot decompile join alias var in plan tree"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>attnum</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>attnum</name> <operator>&lt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>joinaliasvars</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>joinaliasvars</name></name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>expr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* we intentionally don't strip implicit coercions here */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>get_name_for_var_field</name><argument_list>(<argument><expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>, <argument><expr><name>fieldno</name></expr></argument>,
											  <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>+</operator> <name>levelsup</name></expr></argument>,
											  <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
			<comment type="block">/* else fall through to inspect the expression */</comment>
			<break>break;</break>
		<case>case <expr><name>RTE_FUNCTION</name></expr>:</case>
		<case>case <expr><name>RTE_TABLEFUNC</name></expr>:</case>

			<comment type="block">/*
			 * We couldn't get here unless a function is declared with one of
			 * its result columns as RECORD, which is not allowed.
			 */</comment>
			<break>break;</break>
		<case>case <expr><name>RTE_CTE</name></expr>:</case>
			<comment type="block">/* CTE reference: examine subquery's output expr */</comment>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CommonTableExpr</name> <modifier>*</modifier></type><name>cte</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Index</name></type>		<name>ctelevelsup</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * Try to find the referenced CTE using the namespace stack.
				 */</comment>
				<expr_stmt><expr><name>ctelevelsup</name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>ctelevelsup</name></name> <operator>+</operator> <name>netlevelsup</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>ctelevelsup</name> <operator>&gt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>namespaces</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>lc</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
				<else>else
				<block>{<block_content>
					<decl_stmt><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>ctedpns</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>ctedpns</name> <operator>=</operator> <operator>(</operator><name>deparse_namespace</name> <operator>*</operator><operator>)</operator>
						<call><name>list_nth</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>namespaces</name></name></expr></argument>, <argument><expr><name>ctelevelsup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>ctedpns-&gt;ctes</argument>)</argument_list></macro>
					<block>{<block_content>
						<expr_stmt><expr><name>cte</name> <operator>=</operator> <operator>(</operator><name>CommonTableExpr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>cte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<break>break;</break></block_content></block></if></if_stmt>
					</block_content>}</block>
				</block_content>}</block></else></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>lc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>ctequery</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name><name>cte</name><operator>-&gt;</operator><name>ctequery</name></name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>ste</name> <init>= <expr><call><name>get_tle_by_resno</name><argument_list>(<argument><expr><call><name>GetCTETargetList</name><argument_list>(<argument><expr><name>cte</name></expr></argument>)</argument_list></call></expr></argument>,
														<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>ste</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>ste</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"subquery %s does not have attribute %d"</literal></expr></argument>,
							 <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>ste</name><operator>-&gt;</operator><name>expr</name></name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * Recurse into the CTE to see what its Var refers to.
						 * We have to build an additional level of namespace
						 * to keep in step with varlevelsup in the CTE.
						 * Furthermore it could be an outer CTE, so we may
						 * have to delete some levels of namespace.
						 */</comment>
						<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>save_nslist</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>namespaces</name></name></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>new_nslist</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>deparse_namespace</name></type> <name>mydpns</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

						<expr_stmt><expr><call><name>set_deparse_for_query</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mydpns</name></expr></argument>, <argument><expr><name>ctequery</name></expr></argument>,
											  <argument><expr><name><name>context</name><operator>-&gt;</operator><name>namespaces</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><name>new_nslist</name> <operator>=</operator> <call><name>list_copy_tail</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>namespaces</name></name></expr></argument>,
													<argument><expr><name>ctelevelsup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>namespaces</name></name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mydpns</name></expr></argument>, <argument><expr><name>new_nslist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>get_name_for_var_field</name><argument_list>(<argument><expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>, <argument><expr><name>fieldno</name></expr></argument>,
														<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>namespaces</name></name> <operator>=</operator> <name>save_nslist</name></expr>;</expr_stmt>

						<return>return <expr><name>result</name></expr>;</return>
					</block_content>}</block></if></if_stmt>
					<comment type="block">/* else fall through to inspect the expression */</comment>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/*
					 * We're deparsing a Plan tree so we don't have a CTE
					 * list.  But the only place we'd see a Var directly
					 * referencing a CTE RTE is in a CteScan plan node, and we
					 * can look into the subplan's tlist instead.
					 */</comment>
					<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>deparse_namespace</name></type> <name>save_dpns</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dpns</name><operator>-&gt;</operator><name>inner_plan</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to find plan for CTE %s"</literal></expr></argument>,
							 <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>get_tle_by_resno</name><argument_list>(<argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>inner_tlist</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tle</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"bogus varattno for subquery var: %d"</literal></expr></argument>,
							 <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>netlevelsup</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>push_child_plan</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>inner_plan</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>save_dpns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>get_name_for_var_field</name><argument_list>(<argument><expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>fieldno</name></expr></argument>,
													<argument><expr><name>levelsup</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>pop_child_plan</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>save_dpns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>result</name></expr>;</return>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * We now have an expression we can't expand any more, so see if
	 * get_expr_result_tupdesc() can do anything with it.
	 */</comment>
	<expr_stmt><expr><name>tupleDesc</name> <operator>=</operator> <call><name>get_expr_result_tupdesc</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Got the tupdesc, so we can extract the field name */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>fieldno</name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>fieldno</name> <operator>&lt;=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>NameStr</name><argument_list>(<argument><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>fieldno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attname</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Try to find the referenced expression for a PARAM_EXEC Param that might
 * reference a parameter supplied by an upper NestLoop or SubPlan plan node.
 *
 * If successful, return the expression and set *dpns_p and *ancestor_cell_p
 * appropriately for calling push_ancestor_plan().  If no referent can be
 * found, return NULL.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>find_param_referent</name><parameter_list>(<parameter><decl><type><name>Param</name> <modifier>*</modifier></type><name>param</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
					<parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier><modifier>*</modifier></type><name>dpns_p</name></decl></parameter>, <parameter><decl><type><name>ListCell</name> <modifier>*</modifier><modifier>*</modifier></type><name>ancestor_cell_p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Initialize output parameters to prevent compiler warnings */</comment>
	<expr_stmt><expr><operator>*</operator><name>dpns_p</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>ancestor_cell_p</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If it's a PARAM_EXEC parameter, look for a matching NestLoopParam or
	 * SubPlan argument.  This will necessarily be in some ancestor of the
	 * current expression's Plan.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>param</name><operator>-&gt;</operator><name>paramkind</name></name> <operator>==</operator> <name>PARAM_EXEC</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Plan</name>  <modifier>*</modifier></type><name>child_plan</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>in_same_plan_level</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dpns</name> <operator>=</operator> <operator>(</operator><name>deparse_namespace</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>namespaces</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>child_plan</name> <operator>=</operator> <name><name>dpns</name><operator>-&gt;</operator><name>plan</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>in_same_plan_level</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>dpns-&gt;ancestors</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>ancestor</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * NestLoops transmit params to their inner child only; also, once
			 * we've crawled up out of a subplan, this couldn't possibly be
			 * the right match.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>ancestor</name></expr></argument>, <argument><expr><name>NestLoop</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<name>child_plan</name> <operator>==</operator> <call><name>innerPlan</name><argument_list>(<argument><expr><name>ancestor</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<name>in_same_plan_level</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>NestLoop</name>   <modifier>*</modifier></type><name>nl</name> <init>= <expr><operator>(</operator><name>NestLoop</name> <operator>*</operator><operator>)</operator> <name>ancestor</name></expr></init></decl>;</decl_stmt>

				<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>nl-&gt;nestParams</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>NestLoopParam</name> <modifier>*</modifier></type><name>nlp</name> <init>= <expr><operator>(</operator><name>NestLoopParam</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>nlp</name><operator>-&gt;</operator><name>paramno</name></name> <operator>==</operator> <name><name>param</name><operator>-&gt;</operator><name>paramid</name></name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* Found a match, so return it */</comment>
						<expr_stmt><expr><operator>*</operator><name>dpns_p</name> <operator>=</operator> <name>dpns</name></expr>;</expr_stmt>
						<expr_stmt><expr><operator>*</operator><name>ancestor_cell_p</name> <operator>=</operator> <name>lc</name></expr>;</expr_stmt>
						<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>nlp</name><operator>-&gt;</operator><name>paramval</name></name></expr>;</return>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Check to see if we're crawling up from a subplan.
			 */</comment>
			<if_stmt><if>if<condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>ancestor</name></expr></argument>, <argument><expr><name>SubPlan</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SubPlan</name>    <modifier>*</modifier></type><name>subplan</name> <init>= <expr><operator>(</operator><name>SubPlan</name> <operator>*</operator><operator>)</operator> <name>ancestor</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc3</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc4</name></decl>;</decl_stmt>

				<comment type="block">/* Matched subplan, so check its arguments */</comment>
				<macro><name>forboth</name><argument_list>(<argument>lc3</argument>, <argument>subplan-&gt;parParam</argument>, <argument>lc4</argument>, <argument>subplan-&gt;args</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type>			<name>paramid</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc3</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc4</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>paramid</name> <operator>==</operator> <name><name>param</name><operator>-&gt;</operator><name>paramid</name></name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * Found a match, so return it.  But, since Vars in
						 * the arg are to be evaluated in the surrounding
						 * context, we have to point to the next ancestor item
						 * that is *not* a SubPlan.
						 */</comment>
						<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>rest</name></decl>;</decl_stmt>

						<macro><name>for_each_cell</name><argument_list>(<argument>rest</argument>, <argument>dpns-&gt;ancestors</argument>,
									  <argument>lnext(dpns-&gt;ancestors, lc)</argument>)</argument_list></macro>
						<block>{<block_content>
							<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>ancestor2</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>rest</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

							<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>ancestor2</name></expr></argument>, <argument><expr><name>SubPlan</name></expr></argument>)</argument_list></call></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><operator>*</operator><name>dpns_p</name> <operator>=</operator> <name>dpns</name></expr>;</expr_stmt>
								<expr_stmt><expr><operator>*</operator><name>ancestor_cell_p</name> <operator>=</operator> <name>rest</name></expr>;</expr_stmt>
								<return>return <expr><name>arg</name></expr>;</return>
							</block_content>}</block></if></if_stmt>
						</block_content>}</block>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SubPlan cannot be outermost ancestor"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block>

				<comment type="block">/* We have emerged from a subplan. */</comment>
				<expr_stmt><expr><name>in_same_plan_level</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

				<comment type="block">/* SubPlan isn't a kind of Plan, so skip the rest */</comment>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Check to see if we're emerging from an initplan of the current
			 * ancestor plan.  Initplans never have any parParams, so no need
			 * to search that list, but we need to know if we should reset
			 * in_same_plan_level.
			 */</comment>
			<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>((Plan *) ancestor)-&gt;initPlan</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SubPlan</name>    <modifier>*</modifier></type><name>subplan</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>SubPlan</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>child_plan</name> <operator>!=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>subplans</name></name></expr></argument>,
													<argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>plan_id</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<comment type="block">/* No parameters to be had here. */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>parParam</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* We have emerged from an initplan. */</comment>
				<expr_stmt><expr><name>in_same_plan_level</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

			<comment type="block">/* No luck, crawl up to next ancestor */</comment>
			<expr_stmt><expr><name>child_plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>ancestor</name></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* No referent found */</comment>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Display a Param appropriately.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_parameter</name><parameter_list>(<parameter><decl><type><name>Param</name> <modifier>*</modifier></type><name>param</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>ancestor_cell</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If it's a PARAM_EXEC parameter, try to locate the expression from which
	 * the parameter was computed.  Note that failing to find a referent isn't
	 * an error, since the Param might well be a subplan output rather than an
	 * input.
	 */</comment>
	<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>find_param_referent</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dpns</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ancestor_cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>expr</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Found a match, so print it */</comment>
		<decl_stmt><decl><type><name>deparse_namespace</name></type> <name>save_dpns</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>save_varprefix</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>need_paren</name></decl>;</decl_stmt>

		<comment type="block">/* Switch attention to the ancestor plan node */</comment>
		<expr_stmt><expr><call><name>push_ancestor_plan</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><name>ancestor_cell</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>save_dpns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Force prefixing of Vars, since they won't belong to the relation
		 * being scanned in the original plan node.
		 */</comment>
		<expr_stmt><expr><name>save_varprefix</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>varprefix</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>varprefix</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * A Param's expansion is typically a Var, Aggref, or upper-level
		 * Param, which wouldn't need extra parentheses.  Otherwise, insert
		 * parens to ensure the expression looks atomic.
		 */</comment>
		<expr_stmt><expr><name>need_paren</name> <operator>=</operator> <operator>!</operator><operator>(</operator><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>||</operator>
					   <call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call> <operator>||</operator>
					   <call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>need_paren</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>need_paren</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>varprefix</name></name> <operator>=</operator> <name>save_varprefix</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pop_ancestor_plan</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>save_dpns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Not PARAM_EXEC, or couldn't find referent: for base types just print $N.
	 * For composite types, add cast to the parameter to ease remote node detect
	 * the type.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>param</name><operator>-&gt;</operator><name>paramtype</name></name> <operator>&gt;=</operator> <name>FirstNormalObjectId</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>typeName</name> <init>= <expr><call><name>format_type_with_typemod</name><argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>paramtype</name></name></expr></argument>, <argument><expr><name><name>param</name><operator>-&gt;</operator><name>paramtypmod</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="string">"$%d::%s"</literal></expr></argument>, <argument><expr><name><name>param</name><operator>-&gt;</operator><name>paramid</name></name></expr></argument>, <argument><expr><name>typeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="string">"$%d"</literal></expr></argument>, <argument><expr><name><name>param</name><operator>-&gt;</operator><name>paramid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_simple_binary_op_name
 *
 * helper function for isSimpleNode
 * will return single char binary operator name, or NULL if it's not
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_simple_binary_op_name</name><parameter_list>(<parameter><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>args</name> <init>= <expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* binary operator */</comment>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg1</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg2</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>op</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>op</name> <operator>=</operator> <call><name>generate_operator_name</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>, <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>op</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * isSimpleNode - check if given node is simple (doesn't need parenthesizing)
 *
 *	true   : simple in the context of parent node's type
 *	false  : not simple
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>isSimpleNode</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parentNode</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>prettyFlags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>node</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_Var</name></expr>:</case>
		<case>case <expr><name>T_Const</name></expr>:</case>
		<case>case <expr><name>T_Param</name></expr>:</case>
		<case>case <expr><name>T_CoerceToDomainValue</name></expr>:</case>
		<case>case <expr><name>T_SetToDefault</name></expr>:</case>
		<case>case <expr><name>T_CurrentOfExpr</name></expr>:</case>
			<comment type="block">/* single words: always simple */</comment>
			<return>return <expr><name>true</name></expr>;</return>

		<case>case <expr><name>T_SubscriptingRef</name></expr>:</case>
		<case>case <expr><name>T_ArrayExpr</name></expr>:</case>
		<case>case <expr><name>T_RowExpr</name></expr>:</case>
		<case>case <expr><name>T_CoalesceExpr</name></expr>:</case>
		<case>case <expr><name>T_MinMaxExpr</name></expr>:</case>
		<case>case <expr><name>T_SQLValueFunction</name></expr>:</case>
		<case>case <expr><name>T_XmlExpr</name></expr>:</case>
		<case>case <expr><name>T_NextValueExpr</name></expr>:</case>
		<case>case <expr><name>T_NullIfExpr</name></expr>:</case>
		<case>case <expr><name>T_Aggref</name></expr>:</case>
		<case>case <expr><name>T_WindowFunc</name></expr>:</case>
		<case>case <expr><name>T_FuncExpr</name></expr>:</case>
			<comment type="block">/* function-like: name(..) or name[..] */</comment>
			<return>return <expr><name>true</name></expr>;</return>

			<comment type="block">/* CASE keywords act as parentheses */</comment>
		<case>case <expr><name>T_CaseExpr</name></expr>:</case>
			<return>return <expr><name>true</name></expr>;</return>

		<case>case <expr><name>T_FieldSelect</name></expr>:</case>

			<comment type="block">/*
			 * appears simple since . has top precedence, unless parent is
			 * T_FieldSelect itself!
			 */</comment>
			<return>return <expr><operator>(</operator><ternary><condition><expr><call><name>IsA</name><argument_list>(<argument><expr><name>parentNode</name></expr></argument>, <argument><expr><name>FieldSelect</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>false</name></expr> </then><else>: <expr><name>true</name></expr></else></ternary><operator>)</operator></expr>;</return>

		<case>case <expr><name>T_FieldStore</name></expr>:</case>

			<comment type="block">/*
			 * treat like FieldSelect (probably doesn't matter)
			 */</comment>
			<return>return <expr><operator>(</operator><ternary><condition><expr><call><name>IsA</name><argument_list>(<argument><expr><name>parentNode</name></expr></argument>, <argument><expr><name>FieldStore</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>false</name></expr> </then><else>: <expr><name>true</name></expr></else></ternary><operator>)</operator></expr>;</return>

		<case>case <expr><name>T_CoerceToDomain</name></expr>:</case>
			<comment type="block">/* maybe simple, check args */</comment>
			<return>return <expr><call><name>isSimpleNode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>CoerceToDomain</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr></argument>,
								<argument><expr><name>node</name></expr></argument>, <argument><expr><name>prettyFlags</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_RelabelType</name></expr>:</case>
			<return>return <expr><call><name>isSimpleNode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr></argument>,
								<argument><expr><name>node</name></expr></argument>, <argument><expr><name>prettyFlags</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_CoerceViaIO</name></expr>:</case>
			<return>return <expr><call><name>isSimpleNode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>CoerceViaIO</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr></argument>,
								<argument><expr><name>node</name></expr></argument>, <argument><expr><name>prettyFlags</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_ArrayCoerceExpr</name></expr>:</case>
			<return>return <expr><call><name>isSimpleNode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>ArrayCoerceExpr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr></argument>,
								<argument><expr><name>node</name></expr></argument>, <argument><expr><name>prettyFlags</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_ConvertRowtypeExpr</name></expr>:</case>
			<return>return <expr><call><name>isSimpleNode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>ConvertRowtypeExpr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr></argument>,
								<argument><expr><name>node</name></expr></argument>, <argument><expr><name>prettyFlags</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>T_OpExpr</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/* depends on parent node type; needs further checking */</comment>
				<if_stmt><if>if <condition>(<expr><name>prettyFlags</name> <operator>&amp;</operator> <name>PRETTYFLAG_PAREN</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>parentNode</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>op</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>parentOp</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>bool</name></type>		<name>is_lopriop</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>bool</name></type>		<name>is_hipriop</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>bool</name></type>		<name>is_lopriparent</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>bool</name></type>		<name>is_hipriparent</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>op</name> <operator>=</operator> <call><name>get_simple_binary_op_name</name><argument_list>(<argument><expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>op</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

					<comment type="block">/* We know only the basic operators + - and * / % */</comment>
					<expr_stmt><expr><name>is_lopriop</name> <operator>=</operator> <operator>(</operator><call><name>strchr</name><argument_list>(<argument><expr><literal type="string">"+-"</literal></expr></argument>, <argument><expr><operator>*</operator><name>op</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>
					<expr_stmt><expr><name>is_hipriop</name> <operator>=</operator> <operator>(</operator><call><name>strchr</name><argument_list>(<argument><expr><literal type="string">"*/%"</literal></expr></argument>, <argument><expr><operator>*</operator><name>op</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>is_lopriop</name> <operator>||</operator> <name>is_hipriop</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

					<expr_stmt><expr><name>parentOp</name> <operator>=</operator> <call><name>get_simple_binary_op_name</name><argument_list>(<argument><expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>parentNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>parentOp</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

					<expr_stmt><expr><name>is_lopriparent</name> <operator>=</operator> <operator>(</operator><call><name>strchr</name><argument_list>(<argument><expr><literal type="string">"+-"</literal></expr></argument>, <argument><expr><operator>*</operator><name>parentOp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>
					<expr_stmt><expr><name>is_hipriparent</name> <operator>=</operator> <operator>(</operator><call><name>strchr</name><argument_list>(<argument><expr><literal type="string">"*/%"</literal></expr></argument>, <argument><expr><operator>*</operator><name>parentOp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>is_lopriparent</name> <operator>||</operator> <name>is_hipriparent</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><name>is_hipriop</name> <operator>&amp;&amp;</operator> <name>is_lopriparent</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* op binds tighter than parent */</comment>

					<if_stmt><if>if <condition>(<expr><name>is_lopriop</name> <operator>&amp;&amp;</operator> <name>is_hipriparent</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

					<comment type="block">/*
					 * Operators are same priority --- can skip parens only if
					 * we have (a - b) - c, not a - (b - c).
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>parentNode</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

					<return>return <expr><name>false</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<comment type="block">/* else do the same stuff as for T_SubLink et al. */</comment>
			</block_content>}</block>
			<comment type="block">/* FALLTHROUGH */</comment>

		<case>case <expr><name>T_SubLink</name></expr>:</case>
		<case>case <expr><name>T_NullTest</name></expr>:</case>
		<case>case <expr><name>T_BooleanTest</name></expr>:</case>
		<case>case <expr><name>T_DistinctExpr</name></expr>:</case>
			<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>parentNode</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>T_FuncExpr</name></expr>:</case>
					<block>{<block_content>
						<comment type="block">/* special handling for casts */</comment>
						<decl_stmt><decl><type><name>CoercionForm</name></type> <name>type</name> <init>= <expr><operator>(</operator><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>parentNode</name><operator>)</operator><operator>-&gt;</operator><name>funcformat</name></expr></init></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>COERCE_EXPLICIT_CAST</name> <operator>||</operator>
							<name>type</name> <operator>==</operator> <name>COERCE_IMPLICIT_CAST</name></expr>)</condition><block type="pseudo"><block_content>
							<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
						<return>return <expr><name>true</name></expr>;</return>	<comment type="block">/* own parentheses */</comment>
					</block_content>}</block>
				<case>case <expr><name>T_BoolExpr</name></expr>:</case>	<comment type="block">/* lower precedence */</comment>
				<case>case <expr><name>T_SubscriptingRef</name></expr>:</case>	<comment type="block">/* other separators */</comment>
				<case>case <expr><name>T_ArrayExpr</name></expr>:</case>	<comment type="block">/* other separators */</comment>
				<case>case <expr><name>T_RowExpr</name></expr>:</case> <comment type="block">/* other separators */</comment>
				<case>case <expr><name>T_CoalesceExpr</name></expr>:</case>	<comment type="block">/* own parentheses */</comment>
				<case>case <expr><name>T_MinMaxExpr</name></expr>:</case>	<comment type="block">/* own parentheses */</comment>
				<case>case <expr><name>T_XmlExpr</name></expr>:</case> <comment type="block">/* own parentheses */</comment>
				<case>case <expr><name>T_NullIfExpr</name></expr>:</case>	<comment type="block">/* other separators */</comment>
				<case>case <expr><name>T_Aggref</name></expr>:</case>	<comment type="block">/* own parentheses */</comment>
				<case>case <expr><name>T_WindowFunc</name></expr>:</case>	<comment type="block">/* own parentheses */</comment>
				<case>case <expr><name>T_CaseExpr</name></expr>:</case>	<comment type="block">/* other separators */</comment>
					<return>return <expr><name>true</name></expr>;</return>
				<default>default:</default>
					<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></switch>

		<case>case <expr><name>T_BoolExpr</name></expr>:</case>
			<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>parentNode</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>T_BoolExpr</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><name>prettyFlags</name> <operator>&amp;</operator> <name>PRETTYFLAG_PAREN</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>BoolExprType</name></type> <name>type</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>BoolExprType</name></type> <name>parentType</name></decl>;</decl_stmt>

						<expr_stmt><expr><name>type</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>boolop</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>parentType</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator> <name>parentNode</name><operator>)</operator><operator>-&gt;</operator><name>boolop</name></expr>;</expr_stmt>
						<switch>switch <condition>(<expr><name>type</name></expr>)</condition>
						<block>{<block_content>
							<case>case <expr><name>NOT_EXPR</name></expr>:</case>
							<case>case <expr><name>AND_EXPR</name></expr>:</case>
								<if_stmt><if>if <condition>(<expr><name>parentType</name> <operator>==</operator> <name>AND_EXPR</name> <operator>||</operator> <name>parentType</name> <operator>==</operator> <name>OR_EXPR</name></expr>)</condition><block type="pseudo"><block_content>
									<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
								<break>break;</break>
							<case>case <expr><name>OR_EXPR</name></expr>:</case>
								<if_stmt><if>if <condition>(<expr><name>parentType</name> <operator>==</operator> <name>OR_EXPR</name></expr>)</condition><block type="pseudo"><block_content>
									<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
								<break>break;</break>
						</block_content>}</block></switch>
					</block_content>}</block></if></if_stmt>
					<return>return <expr><name>false</name></expr>;</return>
				<case>case <expr><name>T_FuncExpr</name></expr>:</case>
					<block>{<block_content>
						<comment type="block">/* special handling for casts */</comment>
						<decl_stmt><decl><type><name>CoercionForm</name></type> <name>type</name> <init>= <expr><operator>(</operator><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>parentNode</name><operator>)</operator><operator>-&gt;</operator><name>funcformat</name></expr></init></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>COERCE_EXPLICIT_CAST</name> <operator>||</operator>
							<name>type</name> <operator>==</operator> <name>COERCE_IMPLICIT_CAST</name></expr>)</condition><block type="pseudo"><block_content>
							<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
						<return>return <expr><name>true</name></expr>;</return>	<comment type="block">/* own parentheses */</comment>
					</block_content>}</block>
				<case>case <expr><name>T_SubscriptingRef</name></expr>:</case>	<comment type="block">/* other separators */</comment>
				<case>case <expr><name>T_ArrayExpr</name></expr>:</case>	<comment type="block">/* other separators */</comment>
				<case>case <expr><name>T_RowExpr</name></expr>:</case> <comment type="block">/* other separators */</comment>
				<case>case <expr><name>T_CoalesceExpr</name></expr>:</case>	<comment type="block">/* own parentheses */</comment>
				<case>case <expr><name>T_MinMaxExpr</name></expr>:</case>	<comment type="block">/* own parentheses */</comment>
				<case>case <expr><name>T_XmlExpr</name></expr>:</case> <comment type="block">/* own parentheses */</comment>
				<case>case <expr><name>T_NullIfExpr</name></expr>:</case>	<comment type="block">/* other separators */</comment>
				<case>case <expr><name>T_Aggref</name></expr>:</case>	<comment type="block">/* own parentheses */</comment>
				<case>case <expr><name>T_WindowFunc</name></expr>:</case>	<comment type="block">/* own parentheses */</comment>
				<case>case <expr><name>T_CaseExpr</name></expr>:</case>	<comment type="block">/* other separators */</comment>
					<return>return <expr><name>true</name></expr>;</return>
				<default>default:</default>
					<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></switch>

		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>
	<comment type="block">/* those we don't know: in dubio complexo */</comment>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * appendContextKeyword - append a keyword to buffer
 *
 * If prettyPrint is enabled, perform a line break, and adjust indentation.
 * Otherwise, just append the keyword.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>appendContextKeyword</name><parameter_list>(<parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>,
					 <parameter><decl><type><name>int</name></type> <name>indentBefore</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>indentAfter</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>indentPlus</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PRETTY_INDENT</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>indentAmount</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>indentLevel</name></name> <operator>+=</operator> <name>indentBefore</name></expr>;</expr_stmt>

		<comment type="block">/* remove any trailing spaces currently in the buffer ... */</comment>
		<expr_stmt><expr><call><name>removeStringInfoSpaces</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* ... then add a newline and some spaces */</comment>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>indentLevel</name></name> <operator>&lt;</operator> <name>PRETTYINDENT_LIMIT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>indentAmount</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>indentLevel</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>+</operator> <name>indentPlus</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * If we're indented more than PRETTYINDENT_LIMIT characters, try
			 * to conserve horizontal space by reducing the per-level
			 * indentation.  For best results the scale factor here should
			 * divide all the indent amounts that get added to indentLevel
			 * (PRETTYINDENT_STD, etc).  It's important that the indentation
			 * not grow unboundedly, else deeply-nested trees use O(N^2)
			 * whitespace; so we also wrap modulo PRETTYINDENT_LIMIT.
			 */</comment>
			<expr_stmt><expr><name>indentAmount</name> <operator>=</operator> <name>PRETTYINDENT_LIMIT</name> <operator>+</operator>
				<operator>(</operator><name><name>context</name><operator>-&gt;</operator><name>indentLevel</name></name> <operator>-</operator> <name>PRETTYINDENT_LIMIT</name><operator>)</operator> <operator>/</operator>
				<operator>(</operator><name>PRETTYINDENT_STD</name> <operator>/</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>indentAmount</name> <operator>%=</operator> <name>PRETTYINDENT_LIMIT</name></expr>;</expr_stmt>
			<comment type="block">/* scale/wrap logic affects indentLevel, but not indentPlus */</comment>
			<expr_stmt><expr><name>indentAmount</name> <operator>+=</operator> <name>indentPlus</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfoSpaces</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>indentAmount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>indentLevel</name></name> <operator>+=</operator> <name>indentAfter</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>indentLevel</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>indentLevel</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * removeStringInfoSpaces - delete trailing spaces from a buffer.
 *
 * Possibly this should move to stringinfo.c at some point.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>removeStringInfoSpaces</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<while>while <condition>(<expr><name><name>str</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>str</name><operator>-&gt;</operator><name>data</name><index>[<expr><name><name>str</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>str</name><operator>-&gt;</operator><name>data</name><index>[<expr><operator>--</operator><operator>(</operator><name><name>str</name><operator>-&gt;</operator><name>len</name></name><operator>)</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></function>


<comment type="block">/*
 * get_rule_expr_paren	- deparse expr using get_rule_expr,
 * embracing the string with parentheses if necessary for prettyPrint.
 *
 * Never embrace if prettyFlags=0, because it's done in the calling node.
 *
 * Any node that does *not* embrace its argument node by sql syntax (with
 * parentheses, non-operator keywords like CASE/WHEN/ON, or comma etc) should
 * use get_rule_expr_paren instead of get_rule_expr so parentheses can be
 * added.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_rule_expr_paren</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
					<parameter><decl><type><name>bool</name></type> <name>showimplicit</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parentNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>need_paren</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>need_paren</name> <operator>=</operator> <call><name>PRETTY_PAREN</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>isSimpleNode</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>parentNode</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>prettyFlags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>need_paren</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>showimplicit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>need_paren</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------
 * get_rule_expr			- Parse back an expression
 *
 * Note: showimplicit determines whether we display any implicit cast that
 * is present at the top of the expression tree.  It is a passed argument,
 * not a field of the context struct, because we change the value as we
 * recurse down into the expression.  In general we suppress implicit casts
 * when the result type is known with certainty (eg, the arguments of an
 * OR must be boolean).  We display implicit casts for arguments of functions
 * and operators, since this is needed to be certain that the same function
 * or operator will be chosen when the expression is re-parsed.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_rule_expr</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
			  <parameter><decl><type><name>bool</name></type> <name>showimplicit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Guard against excessively long or deeply-nested queries */</comment>
	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Each level of get_rule_expr must emit an indivisible term
	 * (parenthesized if necessary) to ensure result is reparsed into the same
	 * expression tree.  The only exception is that when the input is a List,
	 * we emit the component items comma-separated with no surrounding
	 * decoration; this is convenient for most callers.
	 */</comment>
	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_Var</name></expr>:</case>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>get_variable</name><argument_list>(<argument><expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_Const</name></expr>:</case>
			<expr_stmt><expr><call><name>get_const_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_Param</name></expr>:</case>
			<expr_stmt><expr><call><name>get_parameter</name><argument_list>(<argument><expr><operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_Aggref</name></expr>:</case>
			<expr_stmt><expr><call><name>get_agg_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_GroupingFunc</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>GroupingFunc</name> <modifier>*</modifier></type><name>gexpr</name> <init>= <expr><operator>(</operator><name>GroupingFunc</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"GROUPING("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>gexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_WindowFunc</name></expr>:</case>
			<expr_stmt><expr><call><name>get_windowfunc_expr</name><argument_list>(<argument><expr><operator>(</operator><name>WindowFunc</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_SubscriptingRef</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SubscriptingRef</name> <modifier>*</modifier></type><name>sbsref</name> <init>= <expr><operator>(</operator><name>SubscriptingRef</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>need_parens</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * If the argument is a CaseTestExpr, we must be inside a
				 * FieldStore, ie, we are assigning to an element of an array
				 * within a composite column.  Since we already punted on
				 * displaying the FieldStore's target information, just punt
				 * here too, and display only the assignment source
				 * expression.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>sbsref</name><operator>-&gt;</operator><name>refexpr</name></name></expr></argument>, <argument><expr><name>CaseTestExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>sbsref</name><operator>-&gt;</operator><name>refassgnexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>sbsref</name><operator>-&gt;</operator><name>refassgnexpr</name></name></expr></argument>,
								  <argument><expr><name>context</name></expr></argument>, <argument><expr><name>showimplicit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * Parenthesize the argument unless it's a simple Var or a
				 * FieldSelect.  (In particular, if it's another
				 * SubscriptingRef, we *must* parenthesize to avoid
				 * confusion.)
				 */</comment>
				<expr_stmt><expr><name>need_parens</name> <operator>=</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>sbsref</name><operator>-&gt;</operator><name>refexpr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>sbsref</name><operator>-&gt;</operator><name>refexpr</name></name></expr></argument>, <argument><expr><name>FieldSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>need_parens</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>sbsref</name><operator>-&gt;</operator><name>refexpr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>showimplicit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>need_parens</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * If there's a refassgnexpr, we want to print the node in the
				 * format "container[subscripts] := refassgnexpr".  This is
				 * not legal SQL, so decompilation of INSERT or UPDATE
				 * statements should always use processIndirection as part of
				 * the statement-level syntax.  We should only see this when
				 * EXPLAIN tries to print the targetlist of a plan resulting
				 * from such a statement.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>sbsref</name><operator>-&gt;</operator><name>refassgnexpr</name></name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>refassgnexpr</name></decl>;</decl_stmt>

					<comment type="block">/*
					 * Use processIndirection to print this node's subscripts
					 * as well as any additional field selections or
					 * subscripting in immediate descendants.  It returns the
					 * RHS expr that is actually being "assigned".
					 */</comment>
					<expr_stmt><expr><name>refassgnexpr</name> <operator>=</operator> <call><name>processIndirection</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" := "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name>refassgnexpr</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>showimplicit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* Just an ordinary container fetch, so print subscripts */</comment>
					<expr_stmt><expr><call><name>printSubscripts</name><argument_list>(<argument><expr><name>sbsref</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_FuncExpr</name></expr>:</case>
			<expr_stmt><expr><call><name>get_func_expr</name><argument_list>(<argument><expr><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>showimplicit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_NamedArgExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>NamedArgExpr</name> <modifier>*</modifier></type><name>na</name> <init>= <expr><operator>(</operator><name>NamedArgExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s =&gt; "</literal></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name><name>na</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>na</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>showimplicit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_OpExpr</name></expr>:</case>
			<expr_stmt><expr><call><name>get_oper_expr</name><argument_list>(<argument><expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DistinctExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>DistinctExpr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>DistinctExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>args</name> <init>= <expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg1</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg2</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PRETTY_PAREN</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>get_rule_expr_paren</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" IS DISTINCT FROM "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>get_rule_expr_paren</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PRETTY_PAREN</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_NullIfExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>NullIfExpr</name> <modifier>*</modifier></type><name>nullifexpr</name> <init>= <expr><operator>(</operator><name>NullIfExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"NULLIF("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>nullifexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_ScalarArrayOpExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>ScalarArrayOpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>args</name> <init>= <expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg1</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg2</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PRETTY_PAREN</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>get_rule_expr_paren</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" %s %s ("</literal></expr></argument>,
								 <argument><expr><call><name>generate_operator_name</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>,
														<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr></argument>,
														<argument><expr><call><name>get_base_element_type</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><ternary><condition><expr><name><name>expr</name><operator>-&gt;</operator><name>useOr</name></name></expr> ?</condition><then> <expr><literal type="string">"ANY"</literal></expr> </then><else>: <expr><literal type="string">"ALL"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>get_rule_expr_paren</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * There's inherent ambiguity in "x op ANY/ALL (y)" when y is
				 * a bare sub-SELECT.  Since we're here, the sub-SELECT must
				 * be meant as a scalar sub-SELECT yielding an array value to
				 * be used in ScalarArrayOpExpr; but the grammar will
				 * preferentially interpret such a construct as an ANY/ALL
				 * SubLink.  To prevent misparsing the output that way, insert
				 * a dummy coercion (which will be stripped by parse analysis,
				 * so no inefficiency is added in dump and reload).  This is
				 * indeed most likely what the user wrote to get the construct
				 * accepted in the first place.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>, <argument><expr><name>SubLink</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<operator>(</operator><operator>(</operator><name>SubLink</name> <operator>*</operator><operator>)</operator> <name>arg2</name><operator>)</operator><operator>-&gt;</operator><name>subLinkType</name> <operator>==</operator> <name>EXPR_SUBLINK</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"::%s"</literal></expr></argument>,
									 <argument><expr><call><name>format_type_with_typemod</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr></argument>,
															  <argument><expr><call><name>exprTypmod</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PRETTY_PAREN</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_BoolExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>BoolExpr</name>   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>first_arg</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>list_second_cell</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<switch>switch <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>boolop</name></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>AND_EXPR</name></expr>:</case>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PRETTY_PAREN</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<expr_stmt><expr><call><name>get_rule_expr_paren</name><argument_list>(<argument><expr><name>first_arg</name></expr></argument>, <argument><expr><name>context</name></expr></argument>,
											<argument><expr><name>false</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<while>while <condition>(<expr><name>arg</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" AND "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>get_rule_expr_paren</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>,
												<argument><expr><name>false</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></while>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PRETTY_PAREN</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<break>break;</break>

					<case>case <expr><name>OR_EXPR</name></expr>:</case>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PRETTY_PAREN</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<expr_stmt><expr><call><name>get_rule_expr_paren</name><argument_list>(<argument><expr><name>first_arg</name></expr></argument>, <argument><expr><name>context</name></expr></argument>,
											<argument><expr><name>false</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<while>while <condition>(<expr><name>arg</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" OR "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>get_rule_expr_paren</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>,
												<argument><expr><name>false</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></while>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PRETTY_PAREN</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<break>break;</break>

					<case>case <expr><name>NOT_EXPR</name></expr>:</case>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PRETTY_PAREN</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"NOT "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>get_rule_expr_paren</name><argument_list>(<argument><expr><name>first_arg</name></expr></argument>, <argument><expr><name>context</name></expr></argument>,
											<argument><expr><name>false</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PRETTY_PAREN</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<break>break;</break>

					<default>default:</default>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized boolop: %d"</literal></expr></argument>,
							 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>boolop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></switch>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_SubLink</name></expr>:</case>
			<expr_stmt><expr><call><name>get_sublink_expr</name><argument_list>(<argument><expr><operator>(</operator><name>SubLink</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_SubPlan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SubPlan</name>    <modifier>*</modifier></type><name>subplan</name> <init>= <expr><operator>(</operator><name>SubPlan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * We cannot see an already-planned subplan in rule deparsing,
				 * only while EXPLAINing a query plan.  We don't try to
				 * reconstruct the original SQL, just reference the subplan
				 * that appears elsewhere in EXPLAIN's result.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>subplan</name><operator>-&gt;</operator><name>useHashTable</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"(hashed %s)"</literal></expr></argument>, <argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>plan_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"(%s)"</literal></expr></argument>, <argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>plan_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_AlternativeSubPlan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>AlternativeSubPlan</name> <modifier>*</modifier></type><name>asplan</name> <init>= <expr><operator>(</operator><name>AlternativeSubPlan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

				<comment type="block">/* As above, this can only happen during EXPLAIN */</comment>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"(alternatives: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>asplan-&gt;subplans</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>SubPlan</name>    <modifier>*</modifier></type><name>splan</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>SubPlan</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>splan</name><operator>-&gt;</operator><name>useHashTable</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"hashed %s"</literal></expr></argument>, <argument><expr><name><name>splan</name><operator>-&gt;</operator><name>plan_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>splan</name><operator>-&gt;</operator><name>plan_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>lnext</name><argument_list>(<argument><expr><name><name>asplan</name><operator>-&gt;</operator><name>subplans</name></name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" or "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_FieldSelect</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>FieldSelect</name> <modifier>*</modifier></type><name>fselect</name> <init>= <expr><operator>(</operator><name>FieldSelect</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>fselect</name><operator>-&gt;</operator><name>arg</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>fno</name> <init>= <expr><name><name>fselect</name><operator>-&gt;</operator><name>fieldnum</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fieldname</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>need_parens</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * Parenthesize the argument unless it's an SubscriptingRef or
				 * another FieldSelect.  Note in particular that it would be
				 * WRONG to not parenthesize a Var argument; simplicity is not
				 * the issue here, having the right number of names is.
				 */</comment>
				<expr_stmt><expr><name>need_parens</name> <operator>=</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>SubscriptingRef</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>FieldSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>need_parens</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>need_parens</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * Get and print the field name.
				 */</comment>
				<expr_stmt><expr><name>fieldname</name> <operator>=</operator> <call><name>get_name_for_var_field</name><argument_list>(<argument><expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></argument>, <argument><expr><name>fno</name></expr></argument>,
												   <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">".%s"</literal></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>fieldname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_FieldStore</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>FieldStore</name> <modifier>*</modifier></type><name>fstore</name> <init>= <expr><operator>(</operator><name>FieldStore</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>need_parens</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * There is no good way to represent a FieldStore as real SQL,
				 * so decompilation of INSERT or UPDATE statements should
				 * always use processIndirection as part of the
				 * statement-level syntax.  We should only get here when
				 * EXPLAIN tries to print the targetlist of a plan resulting
				 * from such a statement.  The plan case is even harder than
				 * ordinary rules would be, because the planner tries to
				 * collapse multiple assignments to the same field or subfield
				 * into one FieldStore; so we can see a list of target fields
				 * not just one, and the arguments could be FieldStores
				 * themselves.  We don't bother to try to print the target
				 * field names; we just print the source arguments, with a
				 * ROW() around them if there's more than one.  This isn't
				 * terribly complete, but it's probably good enough for
				 * EXPLAIN's purposes; especially since anything more would be
				 * either hopelessly confusing or an even poorer
				 * representation of what the plan is actually doing.
				 */</comment>
				<expr_stmt><expr><name>need_parens</name> <operator>=</operator> <operator>(</operator><call><name>list_length</name><argument_list>(<argument><expr><name><name>fstore</name><operator>-&gt;</operator><name>newvals</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>need_parens</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ROW("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>fstore</name><operator>-&gt;</operator><name>newvals</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>showimplicit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>need_parens</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_RelabelType</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RelabelType</name> <modifier>*</modifier></type><name>relabel</name> <init>= <expr><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * This is a Citus specific modification
				 * The planner converts CollateExpr to RelabelType
				 * and here we convert back.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>relabel</name><operator>-&gt;</operator><name>resultcollid</name></name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>CollateExpr</name> <modifier>*</modifier></type><name>collate</name> <init>= <expr><call><name>RelabelTypeToCollateExpr</name><argument_list>(<argument><expr><name>relabel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>collate</name><operator>-&gt;</operator><name>arg</name></name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PRETTY_PAREN</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>get_rule_expr_paren</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>showimplicit</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" COLLATE %s"</literal></expr></argument>,
									<argument><expr><call><name>generate_collation_name</name><argument_list>(<argument><expr><name><name>collate</name><operator>-&gt;</operator><name>collOid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PRETTY_PAREN</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>relabel</name><operator>-&gt;</operator><name>arg</name></name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>relabel</name><operator>-&gt;</operator><name>relabelformat</name></name> <operator>==</operator> <name>COERCE_IMPLICIT_CAST</name> <operator>&amp;&amp;</operator>
						<operator>!</operator><name>showimplicit</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* don't show the implicit cast */</comment>
						<expr_stmt><expr><call><name>get_rule_expr_paren</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><call><name>get_coercion_expr</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>context</name></expr></argument>,
										  <argument><expr><name><name>relabel</name><operator>-&gt;</operator><name>resulttype</name></name></expr></argument>,
										  <argument><expr><name><name>relabel</name><operator>-&gt;</operator><name>resulttypmod</name></name></expr></argument>,
										  <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_CoerceViaIO</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CoerceViaIO</name> <modifier>*</modifier></type><name>iocoerce</name> <init>= <expr><operator>(</operator><name>CoerceViaIO</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>iocoerce</name><operator>-&gt;</operator><name>arg</name></name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>iocoerce</name><operator>-&gt;</operator><name>coerceformat</name></name> <operator>==</operator> <name>COERCE_IMPLICIT_CAST</name> <operator>&amp;&amp;</operator>
					<operator>!</operator><name>showimplicit</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* don't show the implicit cast */</comment>
					<expr_stmt><expr><call><name>get_rule_expr_paren</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>get_coercion_expr</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>context</name></expr></argument>,
									  <argument><expr><name><name>iocoerce</name><operator>-&gt;</operator><name>resulttype</name></name></expr></argument>,
									  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
									  <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_ArrayCoerceExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ArrayCoerceExpr</name> <modifier>*</modifier></type><name>acoerce</name> <init>= <expr><operator>(</operator><name>ArrayCoerceExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>acoerce</name><operator>-&gt;</operator><name>arg</name></name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>acoerce</name><operator>-&gt;</operator><name>coerceformat</name></name> <operator>==</operator> <name>COERCE_IMPLICIT_CAST</name> <operator>&amp;&amp;</operator>
					<operator>!</operator><name>showimplicit</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* don't show the implicit cast */</comment>
					<expr_stmt><expr><call><name>get_rule_expr_paren</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>get_coercion_expr</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>context</name></expr></argument>,
									  <argument><expr><name><name>acoerce</name><operator>-&gt;</operator><name>resulttype</name></name></expr></argument>,
									  <argument><expr><name><name>acoerce</name><operator>-&gt;</operator><name>resulttypmod</name></name></expr></argument>,
									  <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_ConvertRowtypeExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ConvertRowtypeExpr</name> <modifier>*</modifier></type><name>convert</name> <init>= <expr><operator>(</operator><name>ConvertRowtypeExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>convert</name><operator>-&gt;</operator><name>arg</name></name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>convert</name><operator>-&gt;</operator><name>convertformat</name></name> <operator>==</operator> <name>COERCE_IMPLICIT_CAST</name> <operator>&amp;&amp;</operator>
					<operator>!</operator><name>showimplicit</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* don't show the implicit cast */</comment>
					<expr_stmt><expr><call><name>get_rule_expr_paren</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>get_coercion_expr</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>context</name></expr></argument>,
									  <argument><expr><name><name>convert</name><operator>-&gt;</operator><name>resulttype</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
									  <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_CollateExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CollateExpr</name> <modifier>*</modifier></type><name>collate</name> <init>= <expr><operator>(</operator><name>CollateExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>collate</name><operator>-&gt;</operator><name>arg</name></name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PRETTY_PAREN</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>get_rule_expr_paren</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>showimplicit</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" COLLATE %s"</literal></expr></argument>,
								 <argument><expr><call><name>generate_collation_name</name><argument_list>(<argument><expr><name><name>collate</name><operator>-&gt;</operator><name>collOid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PRETTY_PAREN</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_CaseExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CaseExpr</name>   <modifier>*</modifier></type><name>caseexpr</name> <init>= <expr><operator>(</operator><name>CaseExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>temp</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"CASE"</literal></expr></argument>,
									 <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>PRETTYINDENT_VAR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>caseexpr</name><operator>-&gt;</operator><name>arg</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>caseexpr</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<macro><name>foreach</name><argument_list>(<argument>temp</argument>, <argument>caseexpr-&gt;args</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>CaseWhen</name>   <modifier>*</modifier></type><name>when</name> <init>= <expr><operator>(</operator><name>CaseWhen</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>w</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>when</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>caseexpr</name><operator>-&gt;</operator><name>arg</name></name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * The parser should have produced WHEN clauses of the
						 * form "CaseTestExpr = RHS", possibly with an
						 * implicit coercion inserted above the CaseTestExpr.
						 * For accurate decompilation of rules it's essential
						 * that we show just the RHS.  However in an
						 * expression that's been through the optimizer, the
						 * WHEN clause could be almost anything (since the
						 * equality operator could have been expanded into an
						 * inline function).  If we don't recognize the form
						 * of the WHEN clause, just punt and display it as-is.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>args</name> <init>= <expr><operator>(</operator><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>w</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr></init></decl>;</decl_stmt>

							<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
								<call><name>IsA</name><argument_list>(<argument><expr><call><name>strip_implicit_coercions</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><name>CaseTestExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><name>w</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PRETTY_INDENT</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"WHEN "</literal></expr></argument>,
										 <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" THEN "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>when</name><operator>-&gt;</operator><name>result</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PRETTY_INDENT</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"ELSE "</literal></expr></argument>,
									 <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>caseexpr</name><operator>-&gt;</operator><name>defresult</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PRETTY_INDENT</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"END"</literal></expr></argument>,
									 <argument><expr><operator>-</operator><name>PRETTYINDENT_VAR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_CaseTestExpr</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * Normally we should never get here, since for expressions
				 * that can contain this node type we attempt to avoid
				 * recursing to it.  But in an optimized expression we might
				 * be unable to avoid that (see comments for CaseExpr).  If we
				 * do see one, print it as CASE_TEST_EXPR.
				 */</comment>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"CASE_TEST_EXPR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_ArrayExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ArrayExpr</name>  <modifier>*</modifier></type><name>arrayexpr</name> <init>= <expr><operator>(</operator><name>ArrayExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ARRAY["</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>arrayexpr</name><operator>-&gt;</operator><name>elements</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">']'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * If the array isn't empty, we assume its elements are
				 * coerced to the desired type.  If it's empty, though, we
				 * need an explicit coercion to the array type.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>arrayexpr</name><operator>-&gt;</operator><name>elements</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"::%s"</literal></expr></argument>,
									 <argument><expr><call><name>format_type_with_typemod</name><argument_list>(<argument><expr><name><name>arrayexpr</name><operator>-&gt;</operator><name>array_typeid</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_RowExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RowExpr</name>    <modifier>*</modifier></type><name>rowexpr</name> <init>= <expr><operator>(</operator><name>RowExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sep</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * If it's a named type and not RECORD, we may have to skip
				 * dropped columns and/or claim there are NULLs for added
				 * columns.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>rowexpr</name><operator>-&gt;</operator><name>row_typeid</name></name> <operator>!=</operator> <name>RECORDOID</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>lookup_rowtype_tupdesc</name><argument_list>(<argument><expr><name><name>rowexpr</name><operator>-&gt;</operator><name>row_typeid</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>rowexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * SQL99 allows "ROW" to be omitted when there is more than
				 * one column, but for simplicity we always print it.
				 */</comment>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ROW("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<macro><name>foreach</name><argument_list>(<argument>arg</argument>, <argument>rowexpr-&gt;args</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>tupdesc</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
						<operator>!</operator><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attisdropped</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<comment type="block">/* Whole-row Vars need special treatment here */</comment>
						<expr_stmt><expr><call><name>get_rule_expr_toplevel</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block>
				<if_stmt><if>if <condition>(<expr><name>tupdesc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attisdropped</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
						<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
					</block_content>}</block></while>

					<expr_stmt><expr><call><name>ReleaseTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>rowexpr</name><operator>-&gt;</operator><name>row_format</name></name> <operator>==</operator> <name>COERCE_EXPLICIT_CAST</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"::%s"</literal></expr></argument>,
									 <argument><expr><call><name>format_type_with_typemod</name><argument_list>(<argument><expr><name><name>rowexpr</name><operator>-&gt;</operator><name>row_typeid</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_RowCompareExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RowCompareExpr</name> <modifier>*</modifier></type><name>rcexpr</name> <init>= <expr><operator>(</operator><name>RowCompareExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sep</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * SQL99 allows "ROW" to be omitted when there is more than
				 * one column, but for simplicity we always print it.
				 */</comment>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"(ROW("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
				<macro><name>foreach</name><argument_list>(<argument>arg</argument>, <argument>rcexpr-&gt;largs</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
				</block_content>}</block>

				<comment type="block">/*
				 * We assume that the name of the first-column operator will
				 * do for all the rest too.  This is definitely open to
				 * failure, eg if some but not all operators were renamed
				 * since the construct was parsed, but there seems no way to
				 * be perfect.
				 */</comment>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">") %s ROW("</literal></expr></argument>,
								 <argument><expr><call><name>generate_operator_name</name><argument_list>(<argument><expr><call><name>linitial_oid</name><argument_list>(<argument><expr><name><name>rcexpr</name><operator>-&gt;</operator><name>opnos</name></name></expr></argument>)</argument_list></call></expr></argument>,
														<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>rcexpr</name><operator>-&gt;</operator><name>largs</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
														<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>rcexpr</name><operator>-&gt;</operator><name>rargs</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
				<macro><name>foreach</name><argument_list>(<argument>arg</argument>, <argument>rcexpr-&gt;rargs</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
				</block_content>}</block>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"))"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_CoalesceExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CoalesceExpr</name> <modifier>*</modifier></type><name>coalesceexpr</name> <init>= <expr><operator>(</operator><name>CoalesceExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"COALESCE("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>coalesceexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_MinMaxExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>MinMaxExpr</name> <modifier>*</modifier></type><name>minmaxexpr</name> <init>= <expr><operator>(</operator><name>MinMaxExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<switch>switch <condition>(<expr><name><name>minmaxexpr</name><operator>-&gt;</operator><name>op</name></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>IS_GREATEST</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"GREATEST("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>IS_LEAST</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"LEAST("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
				</block_content>}</block></switch>
				<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>minmaxexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_SQLValueFunction</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SQLValueFunction</name> <modifier>*</modifier></type><name>svf</name> <init>= <expr><operator>(</operator><name>SQLValueFunction</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * Note: this code knows that typmod for time, timestamp, and
				 * timestamptz just prints as integer.
				 */</comment>
				<switch>switch <condition>(<expr><name><name>svf</name><operator>-&gt;</operator><name>op</name></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>SVFOP_CURRENT_DATE</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"CURRENT_DATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>SVFOP_CURRENT_TIME</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"CURRENT_TIME"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>SVFOP_CURRENT_TIME_N</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"CURRENT_TIME(%d)"</literal></expr></argument>, <argument><expr><name><name>svf</name><operator>-&gt;</operator><name>typmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>SVFOP_CURRENT_TIMESTAMP</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"CURRENT_TIMESTAMP"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>SVFOP_CURRENT_TIMESTAMP_N</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"CURRENT_TIMESTAMP(%d)"</literal></expr></argument>,
										 <argument><expr><name><name>svf</name><operator>-&gt;</operator><name>typmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>SVFOP_LOCALTIME</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"LOCALTIME"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>SVFOP_LOCALTIME_N</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"LOCALTIME(%d)"</literal></expr></argument>, <argument><expr><name><name>svf</name><operator>-&gt;</operator><name>typmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>SVFOP_LOCALTIMESTAMP</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"LOCALTIMESTAMP"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>SVFOP_LOCALTIMESTAMP_N</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"LOCALTIMESTAMP(%d)"</literal></expr></argument>,
										 <argument><expr><name><name>svf</name><operator>-&gt;</operator><name>typmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>SVFOP_CURRENT_ROLE</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"CURRENT_ROLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>SVFOP_CURRENT_USER</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"CURRENT_USER"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>SVFOP_USER</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"USER"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>SVFOP_SESSION_USER</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"SESSION_USER"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>SVFOP_CURRENT_CATALOG</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"CURRENT_CATALOG"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>SVFOP_CURRENT_SCHEMA</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"CURRENT_SCHEMA"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
				</block_content>}</block></switch>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_XmlExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>XmlExpr</name>    <modifier>*</modifier></type><name>xexpr</name> <init>= <expr><operator>(</operator><name>XmlExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>needcomma</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>narg</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>con</name></decl>;</decl_stmt>

				<switch>switch <condition>(<expr><name><name>xexpr</name><operator>-&gt;</operator><name>op</name></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>IS_XMLCONCAT</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"XMLCONCAT("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>IS_XMLELEMENT</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"XMLELEMENT("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>IS_XMLFOREST</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"XMLFOREST("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>IS_XMLPARSE</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"XMLPARSE("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>IS_XMLPI</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"XMLPI("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>IS_XMLROOT</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"XMLROOT("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>IS_XMLSERIALIZE</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"XMLSERIALIZE("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>IS_DOCUMENT</name></expr>:</case>
						<break>break;</break>
				</block_content>}</block></switch>
				<if_stmt><if>if <condition>(<expr><name><name>xexpr</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>IS_XMLPARSE</name> <operator>||</operator> <name><name>xexpr</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>IS_XMLSERIALIZE</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>xexpr</name><operator>-&gt;</operator><name>xmloption</name></name> <operator>==</operator> <name>XMLOPTION_DOCUMENT</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"DOCUMENT "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"CONTENT "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>xexpr</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"NAME %s"</literal></expr></argument>,
									 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>map_xml_name_to_sql_identifier</name><argument_list>(<argument><expr><name><name>xexpr</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>needcomma</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>xexpr</name><operator>-&gt;</operator><name>named_args</name></name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>xexpr</name><operator>-&gt;</operator><name>op</name></name> <operator>!=</operator> <name>IS_XMLFOREST</name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name>needcomma</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"XMLATTRIBUTES("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>needcomma</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<macro><name>forboth</name><argument_list>(<argument>arg</argument>, <argument>xexpr-&gt;named_args</argument>, <argument>narg</argument>, <argument>xexpr-&gt;arg_names</argument>)</argument_list></macro>
					<block>{<block_content>
						<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>argname</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>narg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><name>needcomma</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>e</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" AS %s"</literal></expr></argument>,
										 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>map_xml_name_to_sql_identifier</name><argument_list>(<argument><expr><name>argname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>needcomma</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					</block_content>}</block>
					<if_stmt><if>if <condition>(<expr><name><name>xexpr</name><operator>-&gt;</operator><name>op</name></name> <operator>!=</operator> <name>IS_XMLFOREST</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>xexpr</name><operator>-&gt;</operator><name>args</name></name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>needcomma</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<switch>switch <condition>(<expr><name><name>xexpr</name><operator>-&gt;</operator><name>op</name></name></expr>)</condition>
					<block>{<block_content>
						<case>case <expr><name>IS_XMLCONCAT</name></expr>:</case>
						<case>case <expr><name>IS_XMLELEMENT</name></expr>:</case>
						<case>case <expr><name>IS_XMLFOREST</name></expr>:</case>
						<case>case <expr><name>IS_XMLPI</name></expr>:</case>
						<case>case <expr><name>IS_XMLSERIALIZE</name></expr>:</case>
							<comment type="block">/* no extra decoration needed */</comment>
							<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>xexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><name>IS_XMLPARSE</name></expr>:</case>
							<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>xexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

							<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>xexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

							<expr_stmt><expr><name>con</name> <operator>=</operator> <call><name>lsecond_node</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><name><name>xexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>con</name><operator>-&gt;</operator><name>constisnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,
													   <argument><expr><literal type="string">" PRESERVE WHITESPACE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
							<else>else<block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,
													   <argument><expr><literal type="string">" STRIP WHITESPACE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
							<break>break;</break>
						<case>case <expr><name>IS_XMLROOT</name></expr>:</case>
							<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>xexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

							<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>xexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

							<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", VERSION "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>con</name> <operator>=</operator> <operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>xexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
								<name><name>con</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"NO VALUE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
							<else>else<block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>con</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

							<expr_stmt><expr><name>con</name> <operator>=</operator> <call><name>lthird_node</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><name><name>xexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition><block type="pseudo"><block_content>
								 <comment type="block">/* suppress STANDALONE NO VALUE */</comment> <empty_stmt>;</empty_stmt></block_content></block></if>
							<else>else
							<block>{<block_content>
								<switch>switch <condition>(<expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr>)</condition>
								<block>{<block_content>
									<case>case <expr><name>XML_STANDALONE_YES</name></expr>:</case>
										<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,
															   <argument><expr><literal type="string">", STANDALONE YES"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
										<break>break;</break>
									<case>case <expr><name>XML_STANDALONE_NO</name></expr>:</case>
										<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,
															   <argument><expr><literal type="string">", STANDALONE NO"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
										<break>break;</break>
									<case>case <expr><name>XML_STANDALONE_NO_VALUE</name></expr>:</case>
										<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,
															   <argument><expr><literal type="string">", STANDALONE NO VALUE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
										<break>break;</break>
									<default>default:</default>
										<break>break;</break>
								</block_content>}</block></switch>
							</block_content>}</block></else></if_stmt>
							<break>break;</break>
						<case>case <expr><name>IS_DOCUMENT</name></expr>:</case>
							<expr_stmt><expr><call><name>get_rule_expr_paren</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>xexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
					</block_content>}</block></switch>

				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>xexpr</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>IS_XMLSERIALIZE</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" AS %s"</literal></expr></argument>,
									 <argument><expr><call><name>format_type_with_typemod</name><argument_list>(<argument><expr><name><name>xexpr</name><operator>-&gt;</operator><name>type</name></name></expr></argument>,
															  <argument><expr><name><name>xexpr</name><operator>-&gt;</operator><name>typmod</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>xexpr</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>IS_DOCUMENT</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" IS DOCUMENT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_NullTest</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>NullTest</name>   <modifier>*</modifier></type><name>ntest</name> <init>= <expr><operator>(</operator><name>NullTest</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PRETTY_PAREN</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>get_rule_expr_paren</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>ntest</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * For scalar inputs, we prefer to print as IS [NOT] NULL,
				 * which is shorter and traditional.  If it's a rowtype input
				 * but we're applying a scalar test, must print IS [NOT]
				 * DISTINCT FROM NULL to be semantically correct.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>ntest</name><operator>-&gt;</operator><name>argisrow</name></name> <operator>||</operator>
					<operator>!</operator><call><name>type_is_rowtype</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>ntest</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<switch>switch <condition>(<expr><name><name>ntest</name><operator>-&gt;</operator><name>nulltesttype</name></name></expr>)</condition>
					<block>{<block_content>
						<case>case <expr><name>IS_NULL</name></expr>:</case>
							<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" IS NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><name>IS_NOT_NULL</name></expr>:</case>
							<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" IS NOT NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
						<default>default:</default>
							<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized nulltesttype: %d"</literal></expr></argument>,
								 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>ntest</name><operator>-&gt;</operator><name>nulltesttype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></switch>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<switch>switch <condition>(<expr><name><name>ntest</name><operator>-&gt;</operator><name>nulltesttype</name></name></expr>)</condition>
					<block>{<block_content>
						<case>case <expr><name>IS_NULL</name></expr>:</case>
							<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" IS NOT DISTINCT FROM NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><name>IS_NOT_NULL</name></expr>:</case>
							<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" IS DISTINCT FROM NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
						<default>default:</default>
							<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized nulltesttype: %d"</literal></expr></argument>,
								 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>ntest</name><operator>-&gt;</operator><name>nulltesttype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></switch>
				</block_content>}</block></else></if_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PRETTY_PAREN</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_BooleanTest</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>BooleanTest</name> <modifier>*</modifier></type><name>btest</name> <init>= <expr><operator>(</operator><name>BooleanTest</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PRETTY_PAREN</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>get_rule_expr_paren</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>btest</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<switch>switch <condition>(<expr><name><name>btest</name><operator>-&gt;</operator><name>booltesttype</name></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>IS_TRUE</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" IS TRUE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>IS_NOT_TRUE</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" IS NOT TRUE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>IS_FALSE</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" IS FALSE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>IS_NOT_FALSE</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" IS NOT FALSE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>IS_UNKNOWN</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" IS UNKNOWN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>IS_NOT_UNKNOWN</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" IS NOT UNKNOWN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<default>default:</default>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized booltesttype: %d"</literal></expr></argument>,
							 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>btest</name><operator>-&gt;</operator><name>booltesttype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></switch>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PRETTY_PAREN</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_CoerceToDomain</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CoerceToDomain</name> <modifier>*</modifier></type><name>ctest</name> <init>= <expr><operator>(</operator><name>CoerceToDomain</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>ctest</name><operator>-&gt;</operator><name>arg</name></name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>ctest</name><operator>-&gt;</operator><name>coercionformat</name></name> <operator>==</operator> <name>COERCE_IMPLICIT_CAST</name> <operator>&amp;&amp;</operator>
					<operator>!</operator><name>showimplicit</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* don't show the implicit cast */</comment>
					<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>get_coercion_expr</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>context</name></expr></argument>,
									  <argument><expr><name><name>ctest</name><operator>-&gt;</operator><name>resulttype</name></name></expr></argument>,
									  <argument><expr><name><name>ctest</name><operator>-&gt;</operator><name>resulttypmod</name></name></expr></argument>,
									  <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_CoerceToDomainValue</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"VALUE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_SetToDefault</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"DEFAULT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CurrentOfExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CurrentOfExpr</name> <modifier>*</modifier></type><name>cexpr</name> <init>= <expr><operator>(</operator><name>CurrentOfExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>cexpr</name><operator>-&gt;</operator><name>cursor_name</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"CURRENT OF %s"</literal></expr></argument>,
									 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name><name>cexpr</name><operator>-&gt;</operator><name>cursor_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"CURRENT OF $%d"</literal></expr></argument>,
									 <argument><expr><name><name>cexpr</name><operator>-&gt;</operator><name>cursor_param</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_NextValueExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>NextValueExpr</name> <modifier>*</modifier></type><name>nvexpr</name> <init>= <expr><operator>(</operator><name>NextValueExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * This isn't exactly nextval(), but that seems close enough
				 * for EXPLAIN's purposes.
				 */</comment>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"nextval("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>simple_quote_literal</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,
									 <argument><expr><call><name>generate_relation_name</name><argument_list>(<argument><expr><name><name>nvexpr</name><operator>-&gt;</operator><name>seqid</name></name></expr></argument>,
															<argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_InferenceElem</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>InferenceElem</name> <modifier>*</modifier></type><name>iexpr</name> <init>= <expr><operator>(</operator><name>InferenceElem</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>save_varprefix</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>need_parens</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * InferenceElem can only refer to target relation, so a
				 * prefix is not useful, and indeed would cause parse errors.
				 */</comment>
				<expr_stmt><expr><name>save_varprefix</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>varprefix</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>varprefix</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * Parenthesize the element unless it's a simple Var or a bare
				 * function call.  Follows pg_get_indexdef_worker().
				 */</comment>
				<expr_stmt><expr><name>need_parens</name> <operator>=</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>iexpr</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>iexpr</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<operator>(</operator><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name><name>iexpr</name><operator>-&gt;</operator><name>expr</name></name><operator>)</operator><operator>-&gt;</operator><name>funcformat</name> <operator>==</operator>
					<name>COERCE_EXPLICIT_CALL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>need_parens</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>need_parens</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>iexpr</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
							  <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>need_parens</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>varprefix</name></name> <operator>=</operator> <name>save_varprefix</name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>iexpr</name><operator>-&gt;</operator><name>infercollid</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" COLLATE %s"</literal></expr></argument>,
									 <argument><expr><call><name>generate_collation_name</name><argument_list>(<argument><expr><name><name>iexpr</name><operator>-&gt;</operator><name>infercollid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/* Add the operator class name, if not default */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>iexpr</name><operator>-&gt;</operator><name>inferopclass</name></name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Oid</name></type>			<name>inferopclass</name> <init>= <expr><name><name>iexpr</name><operator>-&gt;</operator><name>inferopclass</name></name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Oid</name></type>			<name>inferopcinputtype</name> <init>= <expr><call><name>get_opclass_input_type</name><argument_list>(<argument><expr><name><name>iexpr</name><operator>-&gt;</operator><name>inferopclass</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>get_opclass_name</name><argument_list>(<argument><expr><name>inferopclass</name></expr></argument>, <argument><expr><name>inferopcinputtype</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_PartitionBoundSpec</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>spec</name> <init>= <expr><operator>(</operator><name>PartitionBoundSpec</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sep</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>spec</name><operator>-&gt;</operator><name>is_default</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"DEFAULT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>

				<switch>switch <condition>(<expr><name><name>spec</name><operator>-&gt;</operator><name>strategy</name></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>PARTITION_STRATEGY_HASH</name></expr>:</case>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>modulus</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>spec</name><operator>-&gt;</operator><name>remainder</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>modulus</name></name> <operator>&gt;</operator> <name><name>spec</name><operator>-&gt;</operator><name>remainder</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"FOR VALUES"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" WITH (modulus %d, remainder %d)"</literal></expr></argument>,
										 <argument><expr><name><name>spec</name><operator>-&gt;</operator><name>modulus</name></name></expr></argument>, <argument><expr><name><name>spec</name><operator>-&gt;</operator><name>remainder</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>PARTITION_STRATEGY_LIST</name></expr>:</case>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>listdatums</name></name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"FOR VALUES IN ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
						<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>spec-&gt;listdatums</argument>)</argument_list></macro>
						<block>{<block_content>
							<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>val</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

							<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>get_const_expr</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
						</block_content>}</block>

						<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>PARTITION_STRATEGY_RANGE</name></expr>:</case>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>lowerdatums</name></name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator>
							   <name><name>spec</name><operator>-&gt;</operator><name>upperdatums</name></name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator>
							   <call><name>list_length</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>lowerdatums</name></name></expr></argument>)</argument_list></call> <operator>==</operator>
							   <call><name>list_length</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>upperdatums</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"FOR VALUES FROM %s TO %s"</literal></expr></argument>,
										 <argument><expr><call><name>get_range_partbound_string</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>lowerdatums</name></name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><call><name>get_range_partbound_string</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>upperdatums</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>

					<default>default:</default>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized partition strategy: %d"</literal></expr></argument>,
							 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>spec</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
				</block_content>}</block></switch>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_List</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sep</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
				<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>(List *) node</argument>)</argument_list></macro>
				<block>{<block_content>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>showimplicit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
				</block_content>}</block>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_TableFunc</name></expr>:</case>
			<expr_stmt><expr><call><name>get_tablefunc</name><argument_list>(<argument><expr><operator>(</operator><name>TableFunc</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>showimplicit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CallStmt</name></expr>:</case>
			<expr_stmt><expr><call><name>get_func_expr</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>CallStmt</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>funcexpr</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>showimplicit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * get_rule_expr_toplevel		- Parse back a toplevel expression
 *
 * Same as get_rule_expr(), except that if the expr is just a Var, we pass
 * istoplevel = true not false to get_variable().  This causes whole-row Vars
 * to get printed with decoration that will prevent expansion of "*".
 * We need to use this in contexts such as ROW() and VALUES(), where the
 * parser would expand "foo.*" appearing at top level.  (In principle we'd
 * use this in get_target_list() too, but that has additional worries about
 * whether to print AS, so it needs to invoke get_variable() directly anyway.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_rule_expr_toplevel</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>showimplicit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>get_variable</name><argument_list>(<argument><expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>showimplicit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_rule_expr_funccall		- Parse back a function-call expression
 *
 * Same as get_rule_expr(), except that we guarantee that the output will
 * look like a function call, or like one of the things the grammar treats as
 * equivalent to a function call (see the func_expr_windowless production).
 * This is needed in places where the grammar uses func_expr_windowless and
 * you can't substitute a parenthesized a_expr.  If what we have isn't going
 * to look like a function call, wrap it in a dummy CAST() expression, which
 * will satisfy the grammar --- and, indeed, is likely what the user wrote to
 * produce such a thing.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_rule_expr_funccall</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>showimplicit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>looks_like_function</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>showimplicit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"CAST("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* no point in showing any top-level implicit cast */</comment>
		<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" AS %s)"</literal></expr></argument>,
						 <argument><expr><call><name>format_type_with_typemod</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>,
												  <argument><expr><call><name>exprTypmod</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function to identify node types that satisfy func_expr_windowless.
 * If in doubt, "false" is always a safe answer.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>looks_like_function</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* probably shouldn't happen */</comment>
	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_FuncExpr</name></expr>:</case>
			<comment type="block">/* OK, unless it's going to deparse as a cast */</comment>
			<return>return <expr><operator>(</operator><operator>(</operator><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>funcformat</name> <operator>==</operator> <name>COERCE_EXPLICIT_CALL</name><operator>)</operator></expr>;</return>
		<case>case <expr><name>T_NullIfExpr</name></expr>:</case>
		<case>case <expr><name>T_CoalesceExpr</name></expr>:</case>
		<case>case <expr><name>T_MinMaxExpr</name></expr>:</case>
		<case>case <expr><name>T_SQLValueFunction</name></expr>:</case>
		<case>case <expr><name>T_XmlExpr</name></expr>:</case>
			<comment type="block">/* these are all accepted by func_expr_common_subexpr */</comment>
			<return>return <expr><name>true</name></expr>;</return>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * get_oper_expr			- Parse back an OpExpr node
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_oper_expr</name><parameter_list>(<parameter><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>opno</name> <init>= <expr><name><name>expr</name><operator>-&gt;</operator><name>opno</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>args</name> <init>= <expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PRETTY_PAREN</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* binary operator */</comment>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg1</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg2</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>get_rule_expr_paren</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" %s "</literal></expr></argument>,
						 <argument><expr><call><name>generate_operator_name</name><argument_list>(<argument><expr><name>opno</name></expr></argument>,
												<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr></argument>,
												<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>get_rule_expr_paren</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* unary operator --- but which side? */</comment>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_operator</name></type> <name>optup</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>OPEROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for operator %u"</literal></expr></argument>, <argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>optup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_operator</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<switch>switch <condition>(<expr><name><name>optup</name><operator>-&gt;</operator><name>oprkind</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="char">'l'</literal></expr>:</case>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s "</literal></expr></argument>,
								 <argument><expr><call><name>generate_operator_name</name><argument_list>(<argument><expr><name>opno</name></expr></argument>,
														<argument><expr><name>InvalidOid</name></expr></argument>,
														<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>get_rule_expr_paren</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'r'</literal></expr>:</case>
				<expr_stmt><expr><call><name>get_rule_expr_paren</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>,
								 <argument><expr><call><name>generate_operator_name</name><argument_list>(<argument><expr><name>opno</name></expr></argument>,
														<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>,
														<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"bogus oprkind: %d"</literal></expr></argument>, <argument><expr><name><name>optup</name><operator>-&gt;</operator><name>oprkind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PRETTY_PAREN</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_func_expr			- Parse back a FuncExpr node
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_func_expr</name><parameter_list>(<parameter><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
			  <parameter><decl><type><name>bool</name></type> <name>showimplicit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>funcoid</name> <init>= <expr><name><name>expr</name><operator>-&gt;</operator><name>funcid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>argtypes</name><index>[<expr><name>FUNC_MAX_ARGS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>argnames</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>use_variadic</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the function call came from an implicit coercion, then just show the
	 * first argument --- unless caller wants to see implicit coercions.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>funcformat</name></name> <operator>==</operator> <name>COERCE_IMPLICIT_CAST</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>showimplicit</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>get_rule_expr_paren</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>,
							<argument><expr><name>false</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the function call came from a cast, then show the first argument
	 * plus an explicit cast operation.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>funcformat</name></name> <operator>==</operator> <name>COERCE_EXPLICIT_CAST</name> <operator>||</operator>
		<name><name>expr</name><operator>-&gt;</operator><name>funcformat</name></name> <operator>==</operator> <name>COERCE_IMPLICIT_CAST</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>rettype</name> <init>= <expr><name><name>expr</name><operator>-&gt;</operator><name>funcresulttype</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>coercedTypmod</name></decl>;</decl_stmt>

		<comment type="block">/* Get the typmod if this is a length-coercion function */</comment>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>exprIsLengthCoercion</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>coercedTypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>get_coercion_expr</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>context</name></expr></argument>,
						  <argument><expr><name>rettype</name></expr></argument>, <argument><expr><name>coercedTypmod</name></expr></argument>,
						  <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Normal function: display as proname(args).  First we need to extract
	 * the argument datatypes.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>FUNC_MAX_ARGS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_ARGUMENTS</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"too many arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>nargs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>argnames</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>expr-&gt;args</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>NamedArgExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>argnames</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>argnames</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>NamedArgExpr</name> <operator>*</operator><operator>)</operator> <name>arg</name><operator>)</operator><operator>-&gt;</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>argtypes</name><index>[<expr><name>nargs</name></expr>]</index></name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nargs</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s("</literal></expr></argument>,
					 <argument><expr><call><name>generate_function_name</name><argument_list>(<argument><expr><name>funcoid</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>,
											<argument><expr><name>argnames</name></expr></argument>, <argument><expr><name>argtypes</name></expr></argument>,
											<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>funcvariadic</name></name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>use_variadic</name></expr></argument>,
											<argument><expr><name><name>context</name><operator>-&gt;</operator><name>special_exprkind</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nargs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>expr-&gt;args</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>nargs</name><operator>++</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>use_variadic</name> <operator>&amp;&amp;</operator> <call><name>lnext</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"VARIADIC "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_agg_expr			- Parse back an Aggref node
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_agg_expr</name><parameter_list>(<parameter><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>aggref</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
			 <parameter><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>original_aggref</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>argtypes</name><index>[<expr><name>FUNC_MAX_ARGS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>use_variadic</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * For a combining aggregate, we look up and deparse the corresponding
	 * partial aggregate instead.  This is necessary because our input
	 * argument list has been replaced; the new argument list always has just
	 * one element, which will point to a partial Aggref that supplies us with
	 * transition states to combine.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>DO_AGGSPLIT_COMBINE</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggsplit</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>


		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>linitial_node</name><argument_list>(<argument><expr><name>TargetEntry</name></expr></argument>, <argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>resolve_special_varno</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>,
							  <argument><expr><name>get_agg_combine_expr</name></expr></argument>, <argument><expr><name>original_aggref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Mark as PARTIAL, if appropriate.  We look to the original aggref so as
	 * to avoid printing this when recursing from the code just above.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>DO_AGGSPLIT_SKIPFINAL</name><argument_list>(<argument><expr><name><name>original_aggref</name><operator>-&gt;</operator><name>aggsplit</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"PARTIAL "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Extract the argument types as seen by the parser */</comment>
	<expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>get_aggregate_argtypes</name><argument_list>(<argument><expr><name>aggref</name></expr></argument>, <argument><expr><name>argtypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Print the aggregate name, schema-qualified if needed */</comment>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s(%s"</literal></expr></argument>,
					 <argument><expr><call><name>generate_function_name</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggfnoid</name></name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>,
											<argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>argtypes</name></expr></argument>,
											<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggvariadic</name></name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>use_variadic</name></expr></argument>,
											<argument><expr><name><name>context</name><operator>-&gt;</operator><name>special_exprkind</name></name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><ternary><condition><expr><operator>(</operator><name><name>aggref</name><operator>-&gt;</operator><name>aggdistinct</name></name> <operator>!=</operator> <name>NIL</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"DISTINCT "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>AGGKIND_IS_ORDERED_SET</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggkind</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Ordered-set aggregates do not use "*" syntax.  Also, we needn't
		 * worry about inserting VARIADIC.  So we can just dump the direct
		 * args as-is.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>aggref</name><operator>-&gt;</operator><name>aggvariadic</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>aggref</name><operator>-&gt;</operator><name>aggdirectargs</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggorder</name></name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">") WITHIN GROUP (ORDER BY "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>get_rule_orderby</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggorder</name></name></expr></argument>, <argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* aggstar can be set only in zero-argument aggregates */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>aggref</name><operator>-&gt;</operator><name>aggstar</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'*'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>aggref-&gt;args</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>NamedArgExpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>i</name><operator>++</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>use_variadic</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>==</operator> <name>nargs</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"VARIADIC "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>aggref</name><operator>-&gt;</operator><name>aggorder</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" ORDER BY "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>get_rule_orderby</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggorder</name></name></expr></argument>, <argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>aggref</name><operator>-&gt;</operator><name>aggfilter</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">") FILTER (WHERE "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>aggref</name><operator>-&gt;</operator><name>aggfilter</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * This is a helper function for get_agg_expr().  It's used when we deparse
 * a combining Aggref; resolve_special_varno locates the corresponding partial
 * Aggref and then calls this.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_agg_combine_expr</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>callback_arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Aggref</name>	   <modifier>*</modifier></type><name>aggref</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Aggref</name>	   <modifier>*</modifier></type><name>original_aggref</name> <init>= <expr><name>callback_arg</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"combining Aggref does not point to an Aggref"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>aggref</name> <operator>=</operator> <operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>node</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>get_agg_expr</name><argument_list>(<argument><expr><name>aggref</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>original_aggref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_windowfunc_expr	- Parse back a WindowFunc node
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_windowfunc_expr</name><parameter_list>(<parameter><decl><type><name>WindowFunc</name> <modifier>*</modifier></type><name>wfunc</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>argtypes</name><index>[<expr><name>FUNC_MAX_ARGS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>argnames</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>wfunc</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>FUNC_MAX_ARGS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_ARGUMENTS</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"too many arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>nargs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>argnames</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>wfunc-&gt;args</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>NamedArgExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>argnames</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>argnames</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>NamedArgExpr</name> <operator>*</operator><operator>)</operator> <name>arg</name><operator>)</operator><operator>-&gt;</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>argtypes</name><index>[<expr><name>nargs</name></expr>]</index></name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nargs</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s("</literal></expr></argument>,
					 <argument><expr><call><name>generate_function_name</name><argument_list>(<argument><expr><name><name>wfunc</name><operator>-&gt;</operator><name>winfnoid</name></name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>,
											<argument><expr><name>argnames</name></expr></argument>, <argument><expr><name>argtypes</name></expr></argument>,
											<argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
											<argument><expr><name><name>context</name><operator>-&gt;</operator><name>special_exprkind</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* winstar can be set only in zero-argument aggregates */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>wfunc</name><operator>-&gt;</operator><name>winstar</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'*'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>wfunc</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>wfunc</name><operator>-&gt;</operator><name>aggfilter</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">") FILTER (WHERE "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>wfunc</name><operator>-&gt;</operator><name>aggfilter</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">") OVER "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>context-&gt;windowClause</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WindowClause</name> <modifier>*</modifier></type><name>wc</name> <init>= <expr><operator>(</operator><name>WindowClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>wc</name><operator>-&gt;</operator><name>winref</name></name> <operator>==</operator> <name><name>wfunc</name><operator>-&gt;</operator><name>winref</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>wc</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name><name>wc</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>get_rule_windowspec</name><argument_list>(<argument><expr><name>wc</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>windowTList</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<if_stmt><if>if <condition>(<expr><name>l</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>windowClause</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find window clause for winref %u"</literal></expr></argument>,
				 <argument><expr><name><name>wfunc</name><operator>-&gt;</operator><name>winref</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * In EXPLAIN, we don't have window context information available, so
		 * we have to settle for this:
		 */</comment>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"(?)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * get_coercion_expr
 *
 *	Make a string representation of a value coerced to a specific type
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_coercion_expr</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
				  <parameter><decl><type><name>Oid</name></type> <name>resulttype</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>resulttypmod</name></decl></parameter>,
				  <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parentNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Since parse_coerce.c doesn't immediately collapse application of
	 * length-coercion functions to constants, what we'll typically see in
	 * such cases is a Const with typmod -1 and a length-coercion function
	 * right above it.  Avoid generating redundant output. However, beware of
	 * suppressing casts when the user actually wrote something like
	 * 'foo'::text::char(3).
	 *
	 * Note: it might seem that we are missing the possibility of needing to
	 * print a COLLATE clause for such a Const.  However, a Const could only
	 * have nondefault collation in a post-constant-folding tree, in which the
	 * length coercion would have been folded too.  See also the special
	 * handling of CollateExpr in coerce_to_target_type(): any collation
	 * marking will be above the coercion node, not below it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>arg</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>arg</name><operator>)</operator><operator>-&gt;</operator><name>consttype</name> <operator>==</operator> <name>resulttype</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>arg</name><operator>)</operator><operator>-&gt;</operator><name>consttypmod</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Show the constant without normal ::typename decoration */</comment>
		<expr_stmt><expr><call><name>get_const_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PRETTY_PAREN</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>get_rule_expr_paren</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>parentNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PRETTY_PAREN</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"::%s"</literal></expr></argument>,
					 <argument><expr><call><name>format_type_with_typemod</name><argument_list>(<argument><expr><name>resulttype</name></expr></argument>, <argument><expr><name>resulttypmod</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * get_const_expr
 *
 *	Make a string representation of a Const
 *
 * showtype can be -1 to never show "::typename" decoration, or +1 to always
 * show it, or 0 to show it only if the constant wouldn't be assumed to be
 * the right type by default.
 *
 * If the Const's collation isn't default for its type, show that too.
 * We mustn't do this when showtype is -1 (since that means the caller will
 * print "::typename", and we can't put a COLLATE clause in between).  It's
 * caller's responsibility that collation isn't missed in such cases.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_const_expr</name><parameter_list>(<parameter><decl><type><name>Const</name> <modifier>*</modifier></type><name>constval</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>showtype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typoutput</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>typIsVarlena</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>extval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>needlabel</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>constval</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Always label the type of a NULL constant to prevent misdecisions
		 * about type when reparsing.
		 */</comment>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>showtype</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"::%s"</literal></expr></argument>,
							 <argument><expr><call><name>format_type_with_typemod</name><argument_list>(<argument><expr><name><name>constval</name><operator>-&gt;</operator><name>consttype</name></name></expr></argument>,
													  <argument><expr><name><name>constval</name><operator>-&gt;</operator><name>consttypmod</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>get_const_collation</name><argument_list>(<argument><expr><name>constval</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name><name>constval</name><operator>-&gt;</operator><name>consttype</name></name></expr></argument>,
					  <argument><expr><operator>&amp;</operator><name>typoutput</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typIsVarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>extval</name> <operator>=</operator> <call><name>OidOutputFunctionCall</name><argument_list>(<argument><expr><name>typoutput</name></expr></argument>, <argument><expr><name><name>constval</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>constval</name><operator>-&gt;</operator><name>consttype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>INT4OID</name></expr>:</case>

			<comment type="block">/*
			 * INT4 can be printed without any decoration, unless it is
			 * negative; in that case print it as '-nnn'::integer to ensure
			 * that the output will re-parse as a constant, not as a constant
			 * plus operator.  In most cases we could get away with printing
			 * (-nnn) instead, because of the way that gram.y handles negative
			 * literals; but that doesn't work for INT_MIN, and it doesn't
			 * seem that much prettier anyway.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>extval</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>extval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"'%s'"</literal></expr></argument>, <argument><expr><name>extval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>needlabel</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>	<comment type="block">/* we must attach a cast */</comment>
			</block_content>}</block></else></if_stmt>
			<break>break;</break>

		<case>case <expr><name>NUMERICOID</name></expr>:</case>

			<comment type="block">/*
			 * NUMERIC can be printed without quotes if it looks like a float
			 * constant (not an integer, and not Infinity or NaN) and doesn't
			 * have a leading sign (for the same reason as for INT4).
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name><name>extval</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<call><name>strcspn</name><argument_list>(<argument><expr><name>extval</name></expr></argument>, <argument><expr><literal type="string">"eE."</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>extval</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>extval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"'%s'"</literal></expr></argument>, <argument><expr><name>extval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>needlabel</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>	<comment type="block">/* we must attach a cast */</comment>
			</block_content>}</block></else></if_stmt>
			<break>break;</break>

		<case>case <expr><name>BITOID</name></expr>:</case>
		<case>case <expr><name>VARBITOID</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"B'%s'"</literal></expr></argument>, <argument><expr><name>extval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>BOOLOID</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>extval</name></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"false"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>simple_quote_literal</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>extval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>extval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>showtype</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * For showtype == 0, append ::typename unless the constant will be
	 * implicitly typed as the right type when it is read in.
	 *
	 * XXX this code has to be kept in sync with the behavior of the parser,
	 * especially make_const.
	 */</comment>
	<switch>switch <condition>(<expr><name><name>constval</name><operator>-&gt;</operator><name>consttype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>BOOLOID</name></expr>:</case>
		<case>case <expr><name>UNKNOWNOID</name></expr>:</case>
			<comment type="block">/* These types can be left unlabeled */</comment>
			<expr_stmt><expr><name>needlabel</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>INT4OID</name></expr>:</case>
			<comment type="block">/* We determined above whether a label is needed */</comment>
			<break>break;</break>
		<case>case <expr><name>NUMERICOID</name></expr>:</case>

			<comment type="block">/*
			 * Float-looking constants will be typed as numeric, which we
			 * checked above; but if there's a nondefault typmod we need to
			 * show it.
			 */</comment>
			<expr_stmt><expr><name>needlabel</name> <operator>|=</operator> <operator>(</operator><name><name>constval</name><operator>-&gt;</operator><name>consttypmod</name></name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><name>needlabel</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
	<if_stmt><if>if <condition>(<expr><name>needlabel</name> <operator>||</operator> <name>showtype</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"::%s"</literal></expr></argument>,
						 <argument><expr><call><name>format_type_with_typemod</name><argument_list>(<argument><expr><name><name>constval</name><operator>-&gt;</operator><name>consttype</name></name></expr></argument>,
												  <argument><expr><name><name>constval</name><operator>-&gt;</operator><name>consttypmod</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>get_const_collation</name><argument_list>(<argument><expr><name>constval</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * helper for get_const_expr: append COLLATE if needed
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_const_collation</name><parameter_list>(<parameter><decl><type><name>Const</name> <modifier>*</modifier></type><name>constval</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>constval</name><operator>-&gt;</operator><name>constcollid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>typcollation</name> <init>= <expr><call><name>get_typcollation</name><argument_list>(<argument><expr><name><name>constval</name><operator>-&gt;</operator><name>consttype</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>constval</name><operator>-&gt;</operator><name>constcollid</name></name> <operator>!=</operator> <name>typcollation</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" COLLATE %s"</literal></expr></argument>,
							 <argument><expr><call><name>generate_collation_name</name><argument_list>(<argument><expr><name><name>constval</name><operator>-&gt;</operator><name>constcollid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * simple_quote_literal - Format a string as a SQL literal, append to buf
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>simple_quote_literal</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>valptr</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We form the string literal according to the prevailing setting of
	 * standard_conforming_strings; we never use E''. User is responsible for
	 * making sure result is used correctly.
	 */</comment>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\''</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>valptr</name> <operator>=</operator> <name>val</name></expr>;</init> <condition><expr><operator>*</operator><name>valptr</name></expr>;</condition> <incr><expr><name>valptr</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name>ch</name> <init>= <expr><operator>*</operator><name>valptr</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>SQL_STR_DOUBLE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><operator>!</operator><name>standard_conforming_strings</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\''</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------
 * get_sublink_expr			- Parse back a sublink
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_sublink_expr</name><parameter_list>(<parameter><decl><type><name>SubLink</name> <modifier>*</modifier></type><name>sublink</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>query</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>sublink</name><operator>-&gt;</operator><name>subselect</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>opname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>need_paren</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>sublink</name><operator>-&gt;</operator><name>subLinkType</name></name> <operator>==</operator> <name>ARRAY_SUBLINK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ARRAY("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Note that we print the name of only the first operator, when there are
	 * multiple combining operators.  This is an approximation that could go
	 * wrong in various scenarios (operators in different schemas, renamed
	 * operators, etc) but there is not a whole lot we can do about it, since
	 * the syntax allows only one operator to be shown.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>sublink</name><operator>-&gt;</operator><name>testexpr</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>testexpr</name></name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* single combining operator */</comment>
			<decl_stmt><decl><type><name>OpExpr</name>	   <modifier>*</modifier></type><name>opexpr</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name><name>sublink</name><operator>-&gt;</operator><name>testexpr</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>opname</name> <operator>=</operator> <call><name>generate_operator_name</name><argument_list>(<argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>,
											<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>testexpr</name></name></expr></argument>, <argument><expr><name>BoolExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* multiple combining operators, = or &lt;&gt; cases */</comment>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sep</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>((BoolExpr *) sublink-&gt;testexpr)-&gt;args</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>OpExpr</name>	   <modifier>*</modifier></type><name>opexpr</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>OpExpr</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>opname</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>opname</name> <operator>=</operator> <call><name>generate_operator_name</name><argument_list>(<argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>,
													<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
													<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
			</block_content>}</block>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>testexpr</name></name></expr></argument>, <argument><expr><name>RowCompareExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* multiple combining operators, &lt; &lt;= &gt; &gt;= cases */</comment>
			<decl_stmt><decl><type><name>RowCompareExpr</name> <modifier>*</modifier></type><name>rcexpr</name> <init>= <expr><operator>(</operator><name>RowCompareExpr</name> <operator>*</operator><operator>)</operator> <name><name>sublink</name><operator>-&gt;</operator><name>testexpr</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rcexpr</name><operator>-&gt;</operator><name>largs</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>opname</name> <operator>=</operator> <call><name>generate_operator_name</name><argument_list>(<argument><expr><call><name>linitial_oid</name><argument_list>(<argument><expr><name><name>rcexpr</name><operator>-&gt;</operator><name>opnos</name></name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>rcexpr</name><operator>-&gt;</operator><name>largs</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>rcexpr</name><operator>-&gt;</operator><name>rargs</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized testexpr type: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>testexpr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>need_paren</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>sublink</name><operator>-&gt;</operator><name>subLinkType</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>EXISTS_SUBLINK</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"EXISTS "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>ANY_SUBLINK</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>opname</name></expr></argument>, <argument><expr><literal type="string">"="</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* Represent = ANY as IN */</comment>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" IN "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" %s ANY "</literal></expr></argument>, <argument><expr><name>opname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>

		<case>case <expr><name>ALL_SUBLINK</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" %s ALL "</literal></expr></argument>, <argument><expr><name>opname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>ROWCOMPARE_SUBLINK</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" %s "</literal></expr></argument>, <argument><expr><name>opname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>EXPR_SUBLINK</name></expr>:</case>
		<case>case <expr><name>MULTIEXPR_SUBLINK</name></expr>:</case>
		<case>case <expr><name>ARRAY_SUBLINK</name></expr>:</case>
			<expr_stmt><expr><name>need_paren</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>CTE_SUBLINK</name></expr>:</case>		<comment type="block">/* shouldn't occur in a SubLink */</comment>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized sublink type: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>sublink</name><operator>-&gt;</operator><name>subLinkType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><name>need_paren</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>get_query_def</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>namespaces</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
				  <argument><expr><name><name>context</name><operator>-&gt;</operator><name>prettyFlags</name></name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>wrapColumn</name></name></expr></argument>,
				  <argument><expr><name><name>context</name><operator>-&gt;</operator><name>indentLevel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>need_paren</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"))"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------
 * get_tablefunc			- Parse back a table function
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_tablefunc</name><parameter_list>(<parameter><decl><type><name>TableFunc</name> <modifier>*</modifier></type><name>tf</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>showimplicit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* XMLTABLE is the only existing implementation.  */</comment>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"XMLTABLE("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tf</name><operator>-&gt;</operator><name>ns_uris</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc1</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"XMLNAMESPACES ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>forboth</name><argument_list>(<argument>lc1</argument>, <argument>tf-&gt;ns_uris</argument>, <argument>lc2</argument>, <argument>tf-&gt;ns_names</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>name</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>showimplicit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" AS %s"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"DEFAULT "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>showimplicit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"), "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tf</name><operator>-&gt;</operator><name>rowexpr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>showimplicit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">") PASSING ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tf</name><operator>-&gt;</operator><name>docexpr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>showimplicit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tf</name><operator>-&gt;</operator><name>colexprs</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l1</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l2</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l3</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l4</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l5</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>colnum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" COLUMNS "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>forfive</name><argument_list>(<argument>l1</argument>, <argument>tf-&gt;colnames</argument>, <argument>l2</argument>, <argument>tf-&gt;coltypes</argument>, <argument>l3</argument>, <argument>tf-&gt;coltypmods</argument>,
				<argument>l4</argument>, <argument>tf-&gt;colexprs</argument>, <argument>l5</argument>, <argument>tf-&gt;coldefexprs</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>colname</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>typid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int32</name></type>		<name>typmod</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>l3</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>colexpr</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l4</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>coldefexpr</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l5</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>ordinality</name> <init>= <expr><operator>(</operator><name><name>tf</name><operator>-&gt;</operator><name>ordinalitycol</name></name> <operator>==</operator> <name>colnum</name><operator>)</operator></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>notnull</name> <init>= <expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>colnum</name></expr></argument>, <argument><expr><name><name>tf</name><operator>-&gt;</operator><name>notnulls</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>colnum</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>colnum</name><operator>++</operator></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s %s"</literal></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><ternary><condition><expr><name>ordinality</name></expr> ?</condition><then> <expr><literal type="string">"FOR ORDINALITY"</literal></expr> </then><else>:
							 <expr><call><name>format_type_with_typemod</name><argument_list>(<argument><expr><name>typid</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>ordinality</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>coldefexpr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" DEFAULT ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>coldefexpr</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>showimplicit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>colexpr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" PATH ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>colexpr</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>showimplicit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>notnull</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" NOT NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * get_from_clause			- Parse back a FROM clause
 *
 * "prefix" is the keyword that denotes the start of the list of FROM
 * elements. It is FROM when used to parse back SELECT and UPDATE, but
 * is USING when parsing back DELETE.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_from_clause</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We use the query's jointree as a guide to what to print.  However, we
	 * must ignore auto-added RTEs that are marked not inFromCl. (These can
	 * only appear at the top level of the jointree, so it's sufficient to
	 * check here.)  This check also ensures we ignore the rule pseudo-RTEs
	 * for NEW and OLD.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>query-&gt;jointree-&gt;fromlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>jtnode</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>varno</name> <init>= <expr><operator>(</operator><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <name>jtnode</name><operator>)</operator><operator>-&gt;</operator><name>rtindex</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name>varno</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rte</name><operator>-&gt;</operator><name>inFromCl</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>first</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>,
								 <argument><expr><operator>-</operator><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>get_from_clause_item</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>StringInfoData</name></type> <name>itembuf</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Put the new FROM item's text into itembuf so we can decide
			 * after we've got it whether or not it needs to go on a new line.
			 */</comment>
			<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>itembuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name> <operator>=</operator> <operator>&amp;</operator><name>itembuf</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>get_from_clause_item</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Restore context's output buffer */</comment>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>

			<comment type="block">/* Consider line-wrapping if enabled */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>PRETTY_INDENT</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>context</name><operator>-&gt;</operator><name>wrapColumn</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Does the new item start with a new line? */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>itembuf</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>itembuf</name><operator>.</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* If so, we shouldn't add anything */</comment>
					<comment type="block">/* instead, remove any trailing spaces currently in buf */</comment>
					<expr_stmt><expr><call><name>removeStringInfoSpaces</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>trailing_nl</name></decl>;</decl_stmt>

					<comment type="block">/* Locate the start of the current line in the buffer */</comment>
					<expr_stmt><expr><name>trailing_nl</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>trailing_nl</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>trailing_nl</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name>trailing_nl</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

					<comment type="block">/*
					 * Add a newline, plus some indentation, if the new item
					 * would cause an overflow.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>trailing_nl</name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>itembuf</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <name><name>context</name><operator>-&gt;</operator><name>wrapColumn</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><operator>-</operator><name>PRETTYINDENT_STD</name></expr></argument>,
											 <argument><expr><name>PRETTYINDENT_STD</name></expr></argument>,
											 <argument><expr><name>PRETTYINDENT_VAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Add the new item */</comment>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>itembuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* clean up */</comment>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>itembuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_from_clause_item</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>jtnode</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name> <init>= <expr><operator>(</operator><name>deparse_namespace</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>namespaces</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>varno</name> <init>= <expr><operator>(</operator><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <name>jtnode</name><operator>)</operator><operator>-&gt;</operator><name>rtindex</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name>varno</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>refname</name> <init>= <expr><call><name>get_rtable_name</name><argument_list>(<argument><expr><name>varno</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>deparse_columns</name> <modifier>*</modifier></type><name>colinfo</name> <init>= <expr><call><name>deparse_columns_fetch</name><argument_list>(<argument><expr><name>varno</name></expr></argument>, <argument><expr><name>dpns</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblFunction</name> <modifier>*</modifier></type><name>rtfunc1</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>printalias</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CitusRTEKind</name></type> <name>rteKind</name> <init>= <expr><call><name>GetRangeTblKind</name><argument_list>(<argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>lateral</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"LATERAL "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Print the FROM item proper */</comment>
		<switch>switch <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>RTE_RELATION</name></expr>:</case>
				<comment type="block">/* Normal relation RTE */</comment>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>,
								 <argument><expr><call><name>only_marker</name><argument_list>(<argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>generate_relation_or_shard_name</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
																 <argument><expr><name><name>context</name><operator>-&gt;</operator><name>distrelid</name></name></expr></argument>,
																 <argument><expr><name><name>context</name><operator>-&gt;</operator><name>shardid</name></name></expr></argument>,
																 <argument><expr><name><name>context</name><operator>-&gt;</operator><name>namespaces</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>RTE_SUBQUERY</name></expr>:</case>
				<comment type="block">/* Subquery RTE */</comment>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>get_query_def</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>namespaces</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							  <argument><expr><name><name>context</name><operator>-&gt;</operator><name>prettyFlags</name></name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>wrapColumn</name></name></expr></argument>,
							  <argument><expr><name><name>context</name><operator>-&gt;</operator><name>indentLevel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>RTE_FUNCTION</name></expr>:</case>
				<comment type="block">/* if it's a shard, do differently */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>GetRangeTblKind</name><argument_list>(<argument><expr><name>rte</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CITUS_RTE_SHARD</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>fragmentSchemaName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>fragmentTableName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>ExtractRangeTblExtraData</name><argument_list>(<argument><expr><name>rte</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fragmentSchemaName</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fragmentTableName</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* use schema and table name from the remote alias */</comment>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>,
									 <argument><expr><call><name>only_marker</name><argument_list>(<argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><call><name>generate_fragment_name</name><argument_list>(<argument><expr><name>fragmentSchemaName</name></expr></argument>,
															<argument><expr><name>fragmentTableName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* Function RTE */</comment>
				<expr_stmt><expr><name>rtfunc1</name> <operator>=</operator> <operator>(</operator><name>RangeTblFunction</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Omit ROWS FROM() syntax for just one function, unless it
				 * has both a coldeflist and WITH ORDINALITY. If it has both,
				 * we must use ROWS FROM() syntax to avoid ambiguity about
				 * whether the coldeflist includes the ordinality column.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
					<operator>(</operator><name><name>rtfunc1</name><operator>-&gt;</operator><name>funccolnames</name></name> <operator>==</operator> <name>NIL</name> <operator>||</operator> <operator>!</operator><name><name>rte</name><operator>-&gt;</operator><name>funcordinality</name></name><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>get_rule_expr_funccall</name><argument_list>(<argument><expr><name><name>rtfunc1</name><operator>-&gt;</operator><name>funcexpr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* we'll print the coldeflist below, if it has one */</comment>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<decl_stmt><decl><type><name>bool</name></type>		<name>all_unnest</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

					<comment type="block">/*
					 * If all the function calls in the list are to unnest,
					 * and none need a coldeflist, then collapse the list back
					 * down to UNNEST(args).  (If we had more than one
					 * built-in unnest function, this would get more
					 * difficult.)
					 *
					 * XXX This is pretty ugly, since it makes not-terribly-
					 * future-proof assumptions about what the parser would do
					 * with the output; but the alternative is to emit our
					 * nonstandard ROWS FROM() notation for what might have
					 * been a perfectly spec-compliant multi-argument
					 * UNNEST().
					 */</comment>
					<expr_stmt><expr><name>all_unnest</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rte-&gt;functions</argument>)</argument_list></macro>
					<block>{<block_content>
						<decl_stmt><decl><type><name>RangeTblFunction</name> <modifier>*</modifier></type><name>rtfunc</name> <init>= <expr><operator>(</operator><name>RangeTblFunction</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funcexpr</name></name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call> <operator>||</operator>
							<operator>(</operator><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name><name>rtfunc</name><operator>-&gt;</operator><name>funcexpr</name></name><operator>)</operator><operator>-&gt;</operator><name>funcid</name> <operator>!=</operator> <name>F_ARRAY_UNNEST</name> <operator>||</operator>
							<name><name>rtfunc</name><operator>-&gt;</operator><name>funccolnames</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>all_unnest</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block>

					<if_stmt><if>if <condition>(<expr><name>all_unnest</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>allargs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

						<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rte-&gt;functions</argument>)</argument_list></macro>
						<block>{<block_content>
							<decl_stmt><decl><type><name>RangeTblFunction</name> <modifier>*</modifier></type><name>rtfunc</name> <init>= <expr><operator>(</operator><name>RangeTblFunction</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>args</name> <init>= <expr><operator>(</operator><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name><name>rtfunc</name><operator>-&gt;</operator><name>funcexpr</name></name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr></init></decl>;</decl_stmt>

							<expr_stmt><expr><name>allargs</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>allargs</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block>

						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"UNNEST("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>allargs</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<decl_stmt><decl><type><name>int</name></type>			<name>funcno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ROWS FROM("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rte-&gt;functions</argument>)</argument_list></macro>
						<block>{<block_content>
							<decl_stmt><decl><type><name>RangeTblFunction</name> <modifier>*</modifier></type><name>rtfunc</name> <init>= <expr><operator>(</operator><name>RangeTblFunction</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

							<if_stmt><if>if <condition>(<expr><name>funcno</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
							<expr_stmt><expr><call><name>get_rule_expr_funccall</name><argument_list>(<argument><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funcexpr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funccolnames</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
							<block>{<block_content>
								<comment type="block">/* Reconstruct the column definition list */</comment>
								<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" AS "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>get_from_clause_coldeflist</name><argument_list>(<argument><expr><name>rtfunc</name></expr></argument>,
														   <argument><expr><name>NULL</name></expr></argument>,
														   <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>
							<expr_stmt><expr><name>funcno</name><operator>++</operator></expr>;</expr_stmt>
						</block_content>}</block>
						<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
					<comment type="block">/* prevent printing duplicate coldeflist below */</comment>
					<expr_stmt><expr><name>rtfunc1</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>funcordinality</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" WITH ORDINALITY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><name>RTE_TABLEFUNC</name></expr>:</case>
				<expr_stmt><expr><call><name>get_tablefunc</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>tablefunc</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>RTE_VALUES</name></expr>:</case>
				<comment type="block">/* Values list RTE */</comment>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>get_values_def</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>values_lists</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>RTE_CTE</name></expr>:</case>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized RTE kind: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>

		<comment type="block">/* Print the relation alias, if needed */</comment>
		<expr_stmt><expr><name>printalias</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>alias</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Always print alias if user provided one */</comment>
			<expr_stmt><expr><name>printalias</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>colinfo</name><operator>-&gt;</operator><name>printaliases</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Always print alias if we need to print column aliases */</comment>
			<expr_stmt><expr><name>printalias</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * No need to print alias if it's same as relation name (this
			 * would normally be the case, but not if set_rtable_names had to
			 * resolve a conflict).
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>refname</name></expr></argument>, <argument><expr><call><name>get_relation_name</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>printalias</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_FUNCTION</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * For a function RTE, always print alias.  This covers possible
			 * renaming of the function and/or instability of the
			 * FigureColname rules for things that aren't simple functions.
			 * Note we'd need to force it anyway for the columndef list case.
			 */</comment>
			<expr_stmt><expr><name>printalias</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_VALUES</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Alias is syntactically required for VALUES */</comment>
			<expr_stmt><expr><name>printalias</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_CTE</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * No need to print alias if it's same as CTE name (this would
			 * normally be the case, but not if set_rtable_names had to
			 * resolve a conflict).
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>refname</name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>printalias</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* subquery requires alias too */</comment>
			<expr_stmt><expr><name>printalias</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>printalias</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>refname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Print the column definitions or aliases, if needed */</comment>
		<if_stmt><if>if <condition>(<expr><name>rtfunc1</name> <operator>&amp;&amp;</operator> <name><name>rtfunc1</name><operator>-&gt;</operator><name>funccolnames</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Reconstruct the columndef list, which is also the aliases */</comment>
			<expr_stmt><expr><call><name>get_from_clause_coldeflist</name><argument_list>(<argument><expr><name>rtfunc1</name></expr></argument>, <argument><expr><name>colinfo</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>GetRangeTblKind</name><argument_list>(<argument><expr><name>rte</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CITUS_RTE_SHARD</name> <operator>||</operator>
				 <operator>(</operator><name><name>rte</name><operator>-&gt;</operator><name>alias</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>rte</name><operator>-&gt;</operator><name>alias</name><operator>-&gt;</operator><name>colnames</name></name> <operator>!=</operator> <name>NIL</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Else print column aliases as needed */</comment>
			<expr_stmt><expr><call><name>get_column_alias_list</name><argument_list>(<argument><expr><name>colinfo</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<comment type="block">/* check if column's are given aliases in distributed tables */</comment>
		<if type="elseif">else if <condition>(<expr><name><name>colinfo</name><operator>-&gt;</operator><name>parentUsing</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>colinfo</name><operator>-&gt;</operator><name>printaliases</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>get_column_alias_list</name><argument_list>(<argument><expr><name>colinfo</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Tablesample clause must go after any alias */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>rteKind</name> <operator>==</operator> <name>CITUS_RTE_RELATION</name> <operator>||</operator> <name>rteKind</name> <operator>==</operator> <name>CITUS_RTE_SHARD</name><operator>)</operator> <operator>&amp;&amp;</operator>
			<name><name>rte</name><operator>-&gt;</operator><name>tablesample</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>get_tablesample_def</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>tablesample</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JoinExpr</name>   <modifier>*</modifier></type><name>j</name> <init>= <expr><operator>(</operator><name>JoinExpr</name> <operator>*</operator><operator>)</operator> <name>jtnode</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>deparse_columns</name> <modifier>*</modifier></type><name>colinfo</name> <init>= <expr><call><name>deparse_columns_fetch</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>, <argument><expr><name>dpns</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>need_paren_on_right</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>need_paren_on_right</name> <operator>=</operator> <call><name>PRETTY_PAREN</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>!</operator><operator>(</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>, <argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator><operator>(</operator><operator>(</operator><name>JoinExpr</name> <operator>*</operator><operator>)</operator> <name><name>j</name><operator>-&gt;</operator><name>rarg</name></name><operator>)</operator><operator>-&gt;</operator><name>alias</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PRETTY_PAREN</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>j</name><operator>-&gt;</operator><name>alias</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>get_from_clause_item</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<switch>switch <condition>(<expr><name><name>j</name><operator>-&gt;</operator><name>jointype</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>JOIN_INNER</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name><name>j</name><operator>-&gt;</operator><name>quals</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">" JOIN "</literal></expr></argument>,
										 <argument><expr><operator>-</operator><name>PRETTYINDENT_STD</name></expr></argument>,
										 <argument><expr><name>PRETTYINDENT_STD</name></expr></argument>,
										 <argument><expr><name>PRETTYINDENT_JOIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">" CROSS JOIN "</literal></expr></argument>,
										 <argument><expr><operator>-</operator><name>PRETTYINDENT_STD</name></expr></argument>,
										 <argument><expr><name>PRETTYINDENT_STD</name></expr></argument>,
										 <argument><expr><name>PRETTYINDENT_JOIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>
			<case>case <expr><name>JOIN_LEFT</name></expr>:</case>
				<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">" LEFT JOIN "</literal></expr></argument>,
									 <argument><expr><operator>-</operator><name>PRETTYINDENT_STD</name></expr></argument>,
									 <argument><expr><name>PRETTYINDENT_STD</name></expr></argument>,
									 <argument><expr><name>PRETTYINDENT_JOIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>JOIN_FULL</name></expr>:</case>
				<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">" FULL JOIN "</literal></expr></argument>,
									 <argument><expr><operator>-</operator><name>PRETTYINDENT_STD</name></expr></argument>,
									 <argument><expr><name>PRETTYINDENT_STD</name></expr></argument>,
									 <argument><expr><name>PRETTYINDENT_JOIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>JOIN_RIGHT</name></expr>:</case>
				<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">" RIGHT JOIN "</literal></expr></argument>,
									 <argument><expr><operator>-</operator><name>PRETTYINDENT_STD</name></expr></argument>,
									 <argument><expr><name>PRETTYINDENT_STD</name></expr></argument>,
									 <argument><expr><name>PRETTYINDENT_JOIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized join type: %d"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>j</name><operator>-&gt;</operator><name>jointype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>

		<if_stmt><if>if <condition>(<expr><name>need_paren_on_right</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>get_from_clause_item</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>need_paren_on_right</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>j</name><operator>-&gt;</operator><name>usingClause</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" USING ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Use the assigned names, not what's in usingClause */</comment>
			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>colinfo-&gt;usingNames</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>colname</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>first</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>j</name><operator>-&gt;</operator><name>quals</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" ON "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PRETTY_PAREN</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PRETTY_PAREN</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>j</name><operator>-&gt;</operator><name>jointype</name></name> <operator>!=</operator> <name>JOIN_INNER</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* If we didn't say CROSS JOIN above, we must provide an ON */</comment>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" ON TRUE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PRETTY_PAREN</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>j</name><operator>-&gt;</operator><name>alias</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Yes, it's correct to put alias after the right paren ... */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>j</name><operator>-&gt;</operator><name>alias</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Note that it's correct to emit an alias clause if and only if
			 * there was one originally.  Otherwise we'd be converting a named
			 * join to unnamed or vice versa, which creates semantic
			 * subtleties we don't want.  However, we might print a different
			 * alias name than was there originally.
			 */</comment>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>,
							 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>get_rtable_name</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>,
															  <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>get_column_alias_list</name><argument_list>(<argument><expr><name>colinfo</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_column_alias_list - print column alias list for an RTE
 *
 * Caller must already have printed the relation's alias name.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_column_alias_list</name><parameter_list>(<parameter><decl><type><name>deparse_columns</name> <modifier>*</modifier></type><name>colinfo</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Don't print aliases if not needed */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>colinfo</name><operator>-&gt;</operator><name>printaliases</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>colinfo</name><operator>-&gt;</operator><name>num_new_cols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>colname</name> <init>= <expr><name><name>colinfo</name><operator>-&gt;</operator><name>new_colnames</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>first</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_from_clause_coldeflist - reproduce FROM clause coldeflist
 *
 * When printing a top-level coldeflist (which is syntactically also the
 * relation's column alias list), use column names from colinfo.  But when
 * printing a coldeflist embedded inside ROWS FROM(), we prefer to use the
 * original coldeflist's names, which are available in rtfunc-&gt;funccolnames.
 * Pass NULL for colinfo to select the latter behavior.
 *
 * The coldeflist is appended immediately (no space) to buf.  Caller is
 * responsible for ensuring that an alias or AS is present before it.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_from_clause_coldeflist</name><parameter_list>(<parameter><decl><type><name>RangeTblFunction</name> <modifier>*</modifier></type><name>rtfunc</name></decl></parameter>,
						   <parameter><decl><type><name>deparse_columns</name> <modifier>*</modifier></type><name>colinfo</name></decl></parameter>,
						   <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l3</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l4</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>forfour</name><argument_list>(<argument>l1</argument>, <argument>rtfunc-&gt;funccoltypes</argument>,
			<argument>l2</argument>, <argument>rtfunc-&gt;funccoltypmods</argument>,
			<argument>l3</argument>, <argument>rtfunc-&gt;funccolcollations</argument>,
			<argument>l4</argument>, <argument>rtfunc-&gt;funccolnames</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>atttypid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>atttypmod</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>attcollation</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l3</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attname</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>colinfo</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>attname</name> <operator>=</operator> <name><name>colinfo</name><operator>-&gt;</operator><name>colnames</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>attname</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l4</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* shouldn't be any dropped columns here */</comment>

		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s %s"</literal></expr></argument>,
						 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>format_type_with_typemod</name><argument_list>(<argument><expr><name>atttypid</name></expr></argument>, <argument><expr><name>atttypmod</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>attcollation</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<name>attcollation</name> <operator>!=</operator> <call><name>get_typcollation</name><argument_list>(<argument><expr><name>atttypid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" COLLATE %s"</literal></expr></argument>,
							 <argument><expr><call><name>generate_collation_name</name><argument_list>(<argument><expr><name>attcollation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_tablesample_def			- print a TableSampleClause
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_tablesample_def</name><parameter_list>(<parameter><decl><type><name>TableSampleClause</name> <modifier>*</modifier></type><name>tablesample</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>argtypes</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We should qualify the handler's function name if it wouldn't be
	 * resolved by lookup in the current search path.
	 */</comment>
	<expr_stmt><expr><name><name>argtypes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>INTERNALOID</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" TABLESAMPLE %s ("</literal></expr></argument>,
					 <argument><expr><call><name>generate_function_name</name><argument_list>(<argument><expr><name><name>tablesample</name><operator>-&gt;</operator><name>tsmhandler</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
											<argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>argtypes</name></expr></argument>,
											<argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>EXPR_KIND_NONE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>nargs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>tablesample-&gt;args</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>nargs</name><operator>++</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tablesample</name><operator>-&gt;</operator><name>repeatable</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" REPEATABLE ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tablesample</name><operator>-&gt;</operator><name>repeatable</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * get_opclass_name			- fetch name of an index operator class
 *
 * The opclass name is appended (after a space) to buf.
 *
 * Output is suppressed if the opclass is the default for the given
 * actual_datatype.  (If you don't want this behavior, just pass
 * InvalidOid for actual_datatype.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_opclass_name</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opclass</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>actual_datatype</name></decl></parameter>,
				 <parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>ht_opc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_opclass</name></type> <name>opcrec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>opcname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nspname</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ht_opc</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>CLAOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opclass</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>ht_opc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for opclass %u"</literal></expr></argument>, <argument><expr><name>opclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>opcrec</name> <operator>=</operator> <operator>(</operator><name>Form_pg_opclass</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>ht_opc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>actual_datatype</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>GetDefaultOpClass</name><argument_list>(<argument><expr><name>actual_datatype</name></expr></argument>, <argument><expr><name><name>opcrec</name><operator>-&gt;</operator><name>opcmethod</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>opclass</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Okay, we need the opclass name.  Do we need to qualify it? */</comment>
		<expr_stmt><expr><name>opcname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>opcrec</name><operator>-&gt;</operator><name>opcname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OpclassIsVisible</name><argument_list>(<argument><expr><name>opclass</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>opcname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>opcrec</name><operator>-&gt;</operator><name>opcnamespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" %s.%s"</literal></expr></argument>,
							 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>opcname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>ht_opc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * processIndirection - take care of array and subfield assignment
 *
 * We strip any top-level FieldStore or assignment SubscriptingRef nodes that
 * appear in the input, printing them as decoration for the base column
 * name (which we assume the caller just printed).  We might also need to
 * strip CoerceToDomain nodes, but only ones that appear above assignment
 * nodes.
 *
 * Returns the subexpression that's to be assigned.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>processIndirection</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CoerceToDomain</name> <modifier>*</modifier></type><name>cdomain</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>FieldStore</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>FieldStore</name> <modifier>*</modifier></type><name>fstore</name> <init>= <expr><operator>(</operator><name>FieldStore</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>typrelid</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fieldname</name></decl>;</decl_stmt>

			<comment type="block">/* lookup tuple type */</comment>
			<expr_stmt><expr><name>typrelid</name> <operator>=</operator> <call><name>get_typ_typrelid</name><argument_list>(<argument><expr><name><name>fstore</name><operator>-&gt;</operator><name>resulttype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>typrelid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"argument type %s of FieldStore is not a tuple type"</literal></expr></argument>,
					 <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>fstore</name><operator>-&gt;</operator><name>resulttype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Print the field name.  There should only be one target field in
			 * stored rules.  There could be more than that in executable
			 * target lists, but this function cannot be used for that case.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>fstore</name><operator>-&gt;</operator><name>fieldnums</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>fieldname</name> <operator>=</operator> <call><name>get_attname</name><argument_list>(<argument><expr><name>typrelid</name></expr></argument>,
									<argument><expr><call><name>linitial_int</name><argument_list>(<argument><expr><name><name>fstore</name><operator>-&gt;</operator><name>fieldnums</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">".%s"</literal></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>fieldname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * We ignore arg since it should be an uninteresting reference to
			 * the target column or subcolumn.
			 */</comment>
			<expr_stmt><expr><name>node</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>fstore</name><operator>-&gt;</operator><name>newvals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SubscriptingRef</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SubscriptingRef</name>   <modifier>*</modifier></type><name>sbsref</name> <init>= <expr><operator>(</operator><name>SubscriptingRef</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>sbsref</name><operator>-&gt;</operator><name>refassgnexpr</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>printSubscripts</name><argument_list>(<argument><expr><name>sbsref</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * We ignore refexpr since it should be an uninteresting reference
			 * to the target column or subcolumn.
			 */</comment>
			<expr_stmt><expr><name>node</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>sbsref</name><operator>-&gt;</operator><name>refassgnexpr</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>CoerceToDomain</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>cdomain</name> <operator>=</operator> <operator>(</operator><name>CoerceToDomain</name> <operator>*</operator><operator>)</operator> <name>node</name></expr>;</expr_stmt>
			<comment type="block">/* If it's an explicit domain coercion, we're done */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>cdomain</name><operator>-&gt;</operator><name>coercionformat</name></name> <operator>!=</operator> <name>COERCE_IMPLICIT_CAST</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<comment type="block">/* Tentatively descend past the CoerceToDomain */</comment>
			<expr_stmt><expr><name>node</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>cdomain</name><operator>-&gt;</operator><name>arg</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<break>break;</break></block_content></block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * If we descended past a CoerceToDomain whose argument turned out not to
	 * be a FieldStore or array assignment, back up to the CoerceToDomain.
	 * (This is not enough to be fully correct if there are nested implicit
	 * CoerceToDomains, but such cases shouldn't ever occur.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>cdomain</name> <operator>&amp;&amp;</operator> <name>node</name> <operator>==</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>cdomain</name><operator>-&gt;</operator><name>arg</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>node</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>cdomain</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>printSubscripts</name><parameter_list>(<parameter><decl><type><name>SubscriptingRef</name> <modifier>*</modifier></type><name>sbsref</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lowlist_item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>uplist_item</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>lowlist_item</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>sbsref</name><operator>-&gt;</operator><name>reflowerindexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* could be NULL */</comment>
	<macro><name>foreach</name><argument_list>(<argument>uplist_item</argument>, <argument>sbsref-&gt;refupperindexpr</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'['</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>lowlist_item</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* If subexpression is NULL, get_rule_expr prints nothing */</comment>
			<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lowlist_item</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>lowlist_item</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name><name>sbsref</name><operator>-&gt;</operator><name>reflowerindexpr</name></name></expr></argument>, <argument><expr><name>lowlist_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* If subexpression is NULL, get_rule_expr prints nothing */</comment>
		<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>uplist_item</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">']'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * get_relation_name
 *		Get the unqualified name of a relation specified by OID
 *
 * This differs from the underlying get_rel_name() function in that it will
 * throw error instead of silently returning NULL if the OID is bad.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_relation_name</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>relname</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>relname</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>relname</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * generate_relation_or_shard_name
 *		Compute the name to display for a relation or shard
 *
 * If the provided relid is equal to the provided distrelid, this function
 * returns a shard-extended relation name; otherwise, it falls through to a
 * simple generate_relation_name call.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>generate_relation_or_shard_name</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>distrelid</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>shardid</name></decl></parameter>,
								<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>namespaces</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>relid</name> <operator>==</operator> <name>distrelid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>relname</name> <operator>=</operator> <call><name>get_relation_name</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>shardid</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type> <name>schemaOid</name> <init>= <expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>schemaName</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>schemaOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><operator>&amp;</operator><name>relname</name></expr></argument>, <argument><expr><name>shardid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>relname</name> <operator>=</operator> <call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>relname</name> <operator>=</operator> <call><name>generate_relation_name</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>namespaces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>relname</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * generate_relation_name
 *		Compute the name to display for a relation specified by OID
 *
 * The result includes all necessary quoting and schema-prefixing.
 *
 * If namespaces isn't NIL, it must be a list of deparse_namespace nodes.
 * We will forcibly qualify the relation name if it equals any CTE name
 * visible in the namespace list.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>generate_relation_name</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>namespaces</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>reltup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>need_qual</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>nslist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>relname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nspname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>reltup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>relname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>reltup</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check for conflicting CTE name */</comment>
	<expr_stmt><expr><name>need_qual</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>nslist</argument>, <argument>namespaces</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name> <init>= <expr><operator>(</operator><name>deparse_namespace</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>nslist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>ctlist</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>ctlist</argument>, <argument>dpns-&gt;ctes</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CommonTableExpr</name> <modifier>*</modifier></type><name>cte</name> <init>= <expr><operator>(</operator><name>CommonTableExpr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>ctlist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>cte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>, <argument><expr><name>relname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>need_qual</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
		<if_stmt><if>if <condition>(<expr><name>need_qual</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* Otherwise, qualify the name if not visible in search path */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>need_qual</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>need_qual</name> <operator>=</operator> <operator>!</operator><call><name>RelationIsVisible</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>need_qual</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>reltup</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>nspname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * generate_rte_shard_name returns the qualified name of the shard given a
 * CITUS_RTE_SHARD range table entry.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>generate_rte_shard_name</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>shardSchemaName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>shardTableName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>GetRangeTblKind</name><argument_list>(<argument><expr><name>rangeTableEntry</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CITUS_RTE_SHARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExtractRangeTblExtraData</name><argument_list>(<argument><expr><name>rangeTableEntry</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shardSchemaName</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shardTableName</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>generate_fragment_name</name><argument_list>(<argument><expr><name>shardSchemaName</name></expr></argument>, <argument><expr><name>shardTableName</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * generate_fragment_name
 *		Compute the name to display for a shard or merged table
 *
 * The result includes all necessary quoting and schema-prefixing. The schema
 * name can be NULL for regular shards. For merged tables, they are always
 * declared within a job-specific schema, and therefore can't have null schema
 * names.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>generate_fragment_name</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>schemaName</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>tableName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>fragmentNameString</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>schemaName</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>fragmentNameString</name></expr></argument>, <argument><expr><literal type="string">"%s.%s"</literal></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>tableName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>fragmentNameString</name></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>tableName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name><name>fragmentNameString</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * generate_function_name
 *		Compute the name to display for a function specified by OID,
 *		given that it is being called with the specified actual arg names and
 *		types.  (Those matter because of ambiguous-function resolution rules.)
 *
 * If we're dealing with a potentially variadic function (in practice, this
 * means a FuncExpr or Aggref, not some other way of calling a function), then
 * has_variadic must specify whether variadic arguments have been merged,
 * and *use_variadic_p will be set to indicate whether to print VARIADIC in
 * the output.  For non-FuncExpr cases, has_variadic should be false and
 * use_variadic_p can be NULL.
 *
 * The result includes all necessary quoting and schema-prefixing.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>generate_function_name</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>argnames</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>argtypes</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>has_variadic</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>use_variadic_p</name></decl></parameter>,
					   <parameter><decl><type><name>ParseExprKind</name></type> <name>special_exprkind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>proctup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>procform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>proname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>use_variadic</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nspname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncDetailCode</name></type> <name>p_result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>p_funcid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>p_rettype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>p_retset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>p_nvargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>p_vatype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>p_true_typeids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>force_qualify</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>proctup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>procform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>proname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>procform</name><operator>-&gt;</operator><name>proname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Due to parser hacks to avoid needing to reserve CUBE, we need to force
	 * qualification in some special cases.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>special_exprkind</name> <operator>==</operator> <name>EXPR_KIND_GROUP_BY</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>proname</name></expr></argument>, <argument><expr><literal type="string">"cube"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>proname</name></expr></argument>, <argument><expr><literal type="string">"rollup"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>force_qualify</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Determine whether VARIADIC should be printed.  We must do this first
	 * since it affects the lookup rules in func_get_detail().
	 *
	 * Currently, we always print VARIADIC if the function has a merged
	 * variadic-array argument.  Note that this is always the case for
	 * functions taking a VARIADIC argument type other than VARIADIC ANY.
	 *
	 * In principle, if VARIADIC wasn't originally specified and the array
	 * actual argument is deconstructable, we could print the array elements
	 * separately and not print VARIADIC, thus more nearly reproducing the
	 * original input.  For the moment that seems like too much complication
	 * for the benefit, and anyway we do not know whether VARIADIC was
	 * originally specified if it's a non-ANY type.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>use_variadic_p</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Parser should not have set funcvariadic unless fn is variadic */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>has_variadic</name> <operator>||</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>procform</name><operator>-&gt;</operator><name>provariadic</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>use_variadic</name> <operator>=</operator> <name>has_variadic</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>use_variadic_p</name> <operator>=</operator> <name>use_variadic</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>has_variadic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>use_variadic</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * The idea here is to schema-qualify only if the parser would fail to
	 * resolve the correct function given the unqualified func name with the
	 * specified argtypes and VARIADIC flag.  But if we already decided to
	 * force qualification, then we can skip the lookup and pretend we didn't
	 * find it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>force_qualify</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>p_result</name> <operator>=</operator> <call><name>func_get_detail</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>proname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>argnames</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>, <argument><expr><name>argtypes</name></expr></argument>,
								   <argument><expr><operator>!</operator><name>use_variadic</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>p_funcid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p_rettype</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>p_retset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p_nvargs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p_vatype</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>p_true_typeids</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>p_result</name> <operator>=</operator> <name>FUNCDETAIL_NOTFOUND</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>p_funcid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>p_result</name> <operator>==</operator> <name>FUNCDETAIL_NORMAL</name> <operator>||</operator>
		 <name>p_result</name> <operator>==</operator> <name>FUNCDETAIL_AGGREGATE</name> <operator>||</operator>
		 <name>p_result</name> <operator>==</operator> <name>FUNCDETAIL_WINDOWFUNC</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<name>p_funcid</name> <operator>==</operator> <name>funcid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nspname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>procform</name><operator>-&gt;</operator><name>pronamespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>proname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * generate_operator_name
 *		Compute the name to display for an operator specified by OID,
 *		given that it is being called with the specified actual arg types.
 *		(Arg types matter because of ambiguous-operator resolution rules.
 *		Pass InvalidOid for unused arg of a unary operator.)
 *
 * The result includes all necessary quoting and schema-prefixing,
 * plus the OPERATOR() decoration needed to use a qualified operator name
 * in an expression.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>generate_operator_name</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>operid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>arg1</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>arg2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>opertup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_operator</name></type> <name>operform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oprname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nspname</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>opertup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>OPEROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>operid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>opertup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for operator %u"</literal></expr></argument>, <argument><expr><name>operid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>operform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_operator</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>opertup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oprname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>operform</name><operator>-&gt;</operator><name>oprname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Unlike generate_operator_name() in postgres/src/backend/utils/adt/ruleutils.c,
	 * we don't check if the operator is in current namespace or not. This is
	 * because this check is costly when the operator is not in current namespace.
	 */</comment>
	<expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>operform</name><operator>-&gt;</operator><name>oprnamespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nspname</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"OPERATOR(%s."</literal></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>oprname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>opertup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_one_range_partition_bound_string
 *		A C string representation of one range partition bound
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>get_range_partbound_string</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>bound_datums</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>deparse_context</name></type> <name>context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sep</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>deparse_context</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>buf</name></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>bound_datums</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitionRangeDatum</name> <modifier>*</modifier></type><name>datum</name> <init>=
		<expr><call><name>castNode</name><argument_list>(<argument><expr><name>PartitionRangeDatum</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>datum</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>PARTITION_RANGE_DATUM_MINVALUE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"MINVALUE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>datum</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>PARTITION_RANGE_DATUM_MAXVALUE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"MAXVALUE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>val</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><name><name>datum</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>get_const_expr</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>buf</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Collect a list of OIDs of all sequences owned by the specified relation,
 * and column if specified.  If deptype is not zero, then only find sequences
 * with the specified dependency type.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>getOwnedSequences_internal</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attnum</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>deptype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>depRel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>depRel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>DependRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_depend_refclassid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_depend_refobjid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>attnum</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
					<argument><expr><name>Anum_pg_depend_refobjsubid</name></expr></argument>,
					<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_INT4EQ</name></expr></argument>,
					<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>depRel</name></expr></argument>, <argument><expr><name>DependReferenceIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><ternary><condition><expr><name>attnum</name></expr> ?</condition><then> <expr><literal type="number">3</literal></expr> </then><else>: <expr><literal type="number">2</literal></expr></else></ternary></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_depend</name></type> <name>deprec</name> <init>= <expr><operator>(</operator><name>Form_pg_depend</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * We assume any auto or internal dependency of a sequence on a column
		 * must be what we are looking for.  (We need the relkind test because
		 * indexes can also have auto dependencies on columns.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>deprec</name><operator>-&gt;</operator><name>classid</name></name> <operator>==</operator> <name>RelationRelationId</name> <operator>&amp;&amp;</operator>
			<name><name>deprec</name><operator>-&gt;</operator><name>objsubid</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<name><name>deprec</name><operator>-&gt;</operator><name>refobjsubid</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>deprec</name><operator>-&gt;</operator><name>deptype</name></name> <operator>==</operator> <name>DEPENDENCY_AUTO</name> <operator>||</operator> <name><name>deprec</name><operator>-&gt;</operator><name>deptype</name></name> <operator>==</operator> <name>DEPENDENCY_INTERNAL</name><operator>)</operator> <operator>&amp;&amp;</operator>
			<call><name>get_rel_relkind</name><argument_list>(<argument><expr><name><name>deprec</name><operator>-&gt;</operator><name>objid</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RELKIND_SEQUENCE</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>deptype</name> <operator>||</operator> <name><name>deprec</name><operator>-&gt;</operator><name>deptype</name></name> <operator>==</operator> <name>deptype</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>deprec</name><operator>-&gt;</operator><name>objid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>depRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* (PG_VERSION_NUM &gt;= PG_VERSION_13) &amp;&amp; (PG_VERSION_NUM &lt; PG_VERSION_14) */</comment>
</unit>
