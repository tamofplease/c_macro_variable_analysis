<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/builded_projects/citus/src/backend/distributed/deparser/citus_ruleutils.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * citus_ruleutils.c
 *	  Version independent ruleutils wrapper
 *
 * Copyright (c) Citus Data, Inc.
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_version_constants.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stddef.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/attnum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/skey.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/stratnum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <name>PG_VERSION_14</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/toast_compression.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tupdesc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_attribute.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_authid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_class.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_depend.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_extension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_foreign_data_wrapper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/extension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_ruleutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_partitioning_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_sync.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/namespace_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/relay_utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/version_compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"foreign/foreign.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/stringinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/parsenodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pg_list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_utilcmd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parser.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/elog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/errcodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/palloc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ruleutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>deparse_index_columns</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexParameterList</name></decl></parameter>,
								  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>deparseContext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AppendStorageParametersToString</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>stringBuffer</name></decl></parameter>,
											<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>optionList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>convert_aclright_to_string</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>aclright</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>simple_quote_literal</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AddVacuumParams</name><parameter_list>(<parameter><decl><type><name>ReindexStmt</name> <modifier>*</modifier></type><name>reindexStmt</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>buffer</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * pg_get_extensiondef_string finds the foreign data wrapper that corresponds to
 * the given foreign tableId, and checks if an extension owns this foreign data
 * wrapper. If it does, the function returns the extension's definition. If not,
 * the function returns null.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>pg_get_extensiondef_string</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>tableRelationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ForeignTable</name> <modifier>*</modifier></type><name>foreignTable</name> <init>= <expr><call><name>GetForeignTable</name><argument_list>(<argument><expr><name>tableRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ForeignServer</name> <modifier>*</modifier></type><name>server</name> <init>= <expr><call><name>GetForeignServer</name><argument_list>(<argument><expr><name><name>foreignTable</name><operator>-&gt;</operator><name>serverid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ForeignDataWrapper</name> <modifier>*</modifier></type><name>foreignDataWrapper</name> <init>= <expr><call><name>GetForeignDataWrapper</name><argument_list>(<argument><expr><name><name>server</name><operator>-&gt;</operator><name>fdwid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buffer</name> <init>= <expr><block>{ <expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>classId</name> <init>= <expr><name>ForeignDataWrapperRelationId</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>objectId</name> <init>= <expr><name><name>server</name><operator>-&gt;</operator><name>fdwid</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>extensionId</name> <init>= <expr><call><name>getExtensionOfObject</name><argument_list>(<argument><expr><name>classId</name></expr></argument>, <argument><expr><name>objectId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>extensionId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>extensionName</name> <init>= <expr><call><name>get_extension_name</name><argument_list>(<argument><expr><name>extensionId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>extensionSchemaId</name> <init>= <expr><call><name>get_extension_schema</name><argument_list>(<argument><expr><name>extensionId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>extensionSchema</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>extensionSchemaId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"CREATE EXTENSION IF NOT EXISTS %s WITH SCHEMA %s"</literal></expr></argument>,
						 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>extensionName</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>extensionSchema</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"foreign-data wrapper \"%s\" does not have an "</literal>
								<literal type="string">"extension defined"</literal></expr></argument>, <argument><expr><name><name>foreignDataWrapper</name><operator>-&gt;</operator><name>fdwname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><operator>(</operator><name><name>buffer</name><operator>.</operator><name>data</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * get_extension_version - given an extension OID, fetch its extversion
 * or NULL if not found.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>get_extension_version</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>extensionId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>versionName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>ExtensionRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>entry</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_extension_oid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>extensionId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scanDesc</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>ExtensionOidIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
											  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name> <init>= <expr><call><name>systable_getnext</name><argument_list>(<argument><expr><name>scanDesc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* We assume that there can be at most one matching tuple */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>isNull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type> <name>versionDatum</name> <init>= <expr><call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_extension_extversion</name></expr></argument>,
										  <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isNull</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>versionName</name> <operator>=</operator> <call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>DatumGetTextPP</name><argument_list>(<argument><expr><name>versionDatum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scanDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>versionName</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * get_extension_schema - given an extension OID, fetch its extnamespace
 *
 * Returns InvalidOid if no such extension.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_extension_schema</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>ext_oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* *INDENT-OFF* */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>entry</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>ExtensionRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_extension_oid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>ext_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scandesc</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ExtensionOidIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scandesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We assume that there can be at most one matching tuple */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_extension</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>extnamespace</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scandesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
	<comment type="block">/* *INDENT-ON* */</comment>
</block_content>}</block></function>


<comment type="block">/*
 * pg_get_serverdef_string finds the foreign server that corresponds to the
 * given foreign tableId, and returns this server's definition.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>pg_get_serverdef_string</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>tableRelationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ForeignTable</name> <modifier>*</modifier></type><name>foreignTable</name> <init>= <expr><call><name>GetForeignTable</name><argument_list>(<argument><expr><name>tableRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ForeignServer</name> <modifier>*</modifier></type><name>server</name> <init>= <expr><call><name>GetForeignServer</name><argument_list>(<argument><expr><name><name>foreignTable</name><operator>-&gt;</operator><name>serverid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ForeignDataWrapper</name> <modifier>*</modifier></type><name>foreignDataWrapper</name> <init>= <expr><call><name>GetForeignDataWrapper</name><argument_list>(<argument><expr><name><name>server</name><operator>-&gt;</operator><name>fdwid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buffer</name> <init>= <expr><block>{ <expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"CREATE SERVER IF NOT EXISTS %s"</literal></expr></argument>,
					 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name><name>server</name><operator>-&gt;</operator><name>servername</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>server</name><operator>-&gt;</operator><name>servertype</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">" TYPE %s"</literal></expr></argument>,
						 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name><name>server</name><operator>-&gt;</operator><name>servertype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>server</name><operator>-&gt;</operator><name>serverversion</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">" VERSION %s"</literal></expr></argument>,
						 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name><name>server</name><operator>-&gt;</operator><name>serverversion</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">" FOREIGN DATA WRAPPER %s"</literal></expr></argument>,
					 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name><name>foreignDataWrapper</name><operator>-&gt;</operator><name>fdwname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* append server options, if any */</comment>
	<expr_stmt><expr><call><name>AppendOptionListToString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>server</name><operator>-&gt;</operator><name>options</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name><name>buffer</name><operator>.</operator><name>data</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * pg_get_sequencedef_string returns the definition of a given sequence. This
 * definition includes explicit values for all CREATE SEQUENCE options.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>pg_get_sequencedef_string</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>sequenceRelationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_sequence</name></type> <name>pgSequenceForm</name> <init>= <expr><call><name>pg_get_sequencedef</name><argument_list>(<argument><expr><name>sequenceRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* build our DDL command */</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>qualifiedSequenceName</name> <init>= <expr><call><name>generate_qualified_relation_name</name><argument_list>(<argument><expr><name>sequenceRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>typeName</name> <init>= <expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>pgSequenceForm</name><operator>-&gt;</operator><name>seqtypid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sequenceDef</name> <init>= <expr><call><name>psprintf</name><argument_list>(<argument><expr><name>CREATE_SEQUENCE_COMMAND</name></expr></argument>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><ternary><condition><expr><operator>(</operator><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <name>PG_VERSION_15</name><operator>)</operator></expr></condition></ternary></expr></cpp:if>
								 <argument><expr><ternary><condition><expr><call><name>get_rel_persistence</name><argument_list>(<argument><expr><name>sequenceRelationId</name></expr></argument>)</argument_list></call> <operator>==</operator>
								 <name>RELPERSISTENCE_UNLOGGED</name></expr> ?</condition><then> <expr><literal type="string">"UNLOGGED "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
								 <argument><expr><name>qualifiedSequenceName</name></expr></argument>,
								 <argument><expr><name>typeName</name></expr></argument>,
								 <argument><expr><name><name>pgSequenceForm</name><operator>-&gt;</operator><name>seqincrement</name></name></expr></argument>, <argument><expr><name><name>pgSequenceForm</name><operator>-&gt;</operator><name>seqmin</name></name></expr></argument>,
								 <argument><expr><name><name>pgSequenceForm</name><operator>-&gt;</operator><name>seqmax</name></name></expr></argument>, <argument><expr><name><name>pgSequenceForm</name><operator>-&gt;</operator><name>seqstart</name></name></expr></argument>,
								 <argument><expr><name><name>pgSequenceForm</name><operator>-&gt;</operator><name>seqcache</name></name></expr></argument>,
								 <argument><expr><ternary><condition><expr><name><name>pgSequenceForm</name><operator>-&gt;</operator><name>seqcycle</name></name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"NO "</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>sequenceDef</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * pg_get_sequencedef returns the Form_pg_sequence data about the sequence with the given
 * object id.
 */</comment>
<function><type><name>Form_pg_sequence</name></type>
<name>pg_get_sequencedef</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>sequenceRelationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>heapTuple</name> <init>= <expr><call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>SEQRELID</name></expr></argument>, <argument><expr><name>sequenceRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for sequence %u"</literal></expr></argument>, <argument><expr><name>sequenceRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Form_pg_sequence</name></type> <name>pgSequenceForm</name> <init>= <expr><operator>(</operator><name>Form_pg_sequence</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>pgSequenceForm</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * pg_get_tableschemadef_string returns the definition of a given table. This
 * definition includes table's schema, default column values, not null and check
 * constraints. The definition does not include constraints that trigger index
 * creations; specifically, unique and primary key constraints are excluded.
 * When includeSequenceDefaults is NEXTVAL_SEQUENCE_DEFAULTS, the function also creates
 * DEFAULT clauses for columns getting their default values from a sequence.
 * When it's WORKER_NEXTVAL_SEQUENCE_DEFAULTS, the function creates the DEFAULT
 * clause using worker_nextval('sequence') and not nextval('sequence')
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>pg_get_tableschemadef_string</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>tableRelationId</name></decl></parameter>, <parameter><decl><type><name>IncludeSequenceDefaults</name></type>
							 <name>includeSequenceDefaults</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>accessMethod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>firstAttributePrinted</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type> <name>defaultValueIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type> <name>constraintIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type> <name>constraintCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buffer</name> <init>= <expr><block>{ <expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Instead of retrieving values from system catalogs as other functions in
	 * ruleutils.c do, we follow an unusual approach here: we open the relation,
	 * and fetch the relation's tuple descriptor. We do this because the tuple
	 * descriptor already contains information harnessed from pg_attrdef,
	 * pg_attribute, pg_constraint, and pg_class; and therefore using the
	 * descriptor saves us from a lot of additional work.
	 */</comment>
	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name> <init>= <expr><call><name>relation_open</name><argument_list>(<argument><expr><name>tableRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>generate_relation_name</name><argument_list>(<argument><expr><name>tableRelationId</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>EnsureRelationKindSupported</name><argument_list>(<argument><expr><name>tableRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RegularTable</name><argument_list>(<argument><expr><name>tableRelationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"CREATE "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_UNLOGGED</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"UNLOGGED "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"TABLE %s ("</literal></expr></argument>, <argument><expr><name>relationName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"CREATE FOREIGN TABLE %s ("</literal></expr></argument>, <argument><expr><name>relationName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Iterate over the table's columns. If a particular column is not dropped
	 * and is not inherited from another table, print the column's name and its
	 * formatted type.
	 */</comment>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleConstr</name> <modifier>*</modifier></type><name>tupleConstraints</name> <init>= <expr><name><name>tupleDescriptor</name><operator>-&gt;</operator><name>constr</name></name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>attributeIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>attributeIndex</name> <operator>&lt;</operator> <name><name>tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition>
		 <incr><expr><name>attributeIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attributeForm</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><name>attributeIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * We disregard the inherited attributes (i.e., attinhcount &gt; 0) here. The
		 * reasoning behind this is that Citus implements declarative partitioning
		 * by creating the partitions first and then sending
		 * "ALTER TABLE parent_table ATTACH PARTITION .." command. This may not play
		 * well with regular inherited tables, which isn't a big concern from Citus'
		 * perspective.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>attributeForm</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>firstAttributePrinted</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>firstAttributePrinted</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>attributeName</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attributeForm</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"%s "</literal></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>attributeName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>attributeTypeName</name> <init>= <expr><call><name>format_type_with_typemod</name><argument_list>(
				<argument><expr><name><name>attributeForm</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
				<argument><expr><name><name>attributeForm</name><operator>-&gt;</operator>
				<name>atttypmod</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name>attributeTypeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <name>PG_VERSION_14</name></expr></cpp:if>
			<if_stmt><if>if <condition>(<expr><call><name>CompressionMethodIsValid</name><argument_list>(<argument><expr><name><name>attributeForm</name><operator>-&gt;</operator><name>attcompression</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">" COMPRESSION %s"</literal></expr></argument>,
								 <argument><expr><call><name>GetCompressionMethodName</name><argument_list>(<argument><expr><name><name>attributeForm</name><operator>-&gt;</operator><name>attcompression</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

			<comment type="block">/* if this column has a default value, append the default value */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>attributeForm</name><operator>-&gt;</operator><name>atthasdef</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>defaultContext</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>defaultString</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tupleConstraints</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<decl_stmt><decl><type><name>AttrDefault</name> <modifier>*</modifier></type><name>defaultValueList</name> <init>= <expr><name><name>tupleConstraints</name><operator>-&gt;</operator><name>defval</name></name></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>defaultValueList</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<decl_stmt><decl><type><name>AttrDefault</name> <modifier>*</modifier></type><name>defaultValue</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>defaultValueList</name><index>[<expr><name>defaultValueIndex</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name>defaultValueIndex</name><operator>++</operator></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>defaultValue</name><operator>-&gt;</operator><name>adnum</name></name> <operator>==</operator> <operator>(</operator><name>attributeIndex</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>defaultValueIndex</name> <operator>&lt;=</operator> <name><name>tupleConstraints</name><operator>-&gt;</operator><name>num_defval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* convert expression to node tree, and prepare deparse context */</comment>
				<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>defaultNode</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><name><name>defaultValue</name><operator>-&gt;</operator><name>adbin</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * if column default value is explicitly requested, or it is
				 * not set from a sequence then we include DEFAULT clause for
				 * this column.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>includeSequenceDefaults</name> <operator>||</operator>
					<operator>!</operator><call><name>contain_nextval_expression_walker</name><argument_list>(<argument><expr><name>defaultNode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>defaultContext</name> <operator>=</operator> <call><name>deparse_context_for</name><argument_list>(<argument><expr><name>relationName</name></expr></argument>, <argument><expr><name>tableRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* deparse default value string */</comment>
					<expr_stmt><expr><name>defaultString</name> <operator>=</operator> <call><name>deparse_expression</name><argument_list>(<argument><expr><name>defaultNode</name></expr></argument>, <argument><expr><name>defaultContext</name></expr></argument>,
													   <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>attributeForm</name><operator>-&gt;</operator><name>attgenerated</name></name> <operator>==</operator> <name>ATTRIBUTE_GENERATED_STORED</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">" GENERATED ALWAYS AS (%s) STORED"</literal></expr></argument>,
										 <argument><expr><name>defaultString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<decl_stmt><decl><type><name>Oid</name></type> <name>seqOid</name> <init>= <expr><call><name>GetSequenceOid</name><argument_list>(<argument><expr><name>tableRelationId</name></expr></argument>, <argument><expr><name><name>defaultValue</name><operator>-&gt;</operator><name>adnum</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
						<if_stmt><if>if <condition>(<expr><name>includeSequenceDefaults</name> <operator>==</operator> <name>WORKER_NEXTVAL_SEQUENCE_DEFAULTS</name> <operator>&amp;&amp;</operator>
							<name>seqOid</name> <operator>!=</operator> <name>InvalidOid</name> <operator>&amp;&amp;</operator>
							<call><name>pg_get_sequencedef</name><argument_list>(<argument><expr><name>seqOid</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>seqtypid</name> <operator>!=</operator> <name>INT8OID</name></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/*
							 * We use worker_nextval for int and smallint types.
							 * Check issue #5126 and PR #5254 for details.
							 * https://github.com/citusdata/citus/issues/5126
							 */</comment>
							<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sequenceName</name> <init>= <expr><call><name>generate_qualified_relation_name</name><argument_list>(
								<argument><expr><name>seqOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
							<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>,
											 <argument><expr><literal type="string">" DEFAULT worker_nextval(%s::regclass)"</literal></expr></argument>,
											 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>sequenceName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if>
						<else>else
						<block>{<block_content>
							<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">" DEFAULT %s"</literal></expr></argument>, <argument><expr><name>defaultString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></else></if_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* if this column has a not null constraint, append the constraint */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>attributeForm</name><operator>-&gt;</operator><name>attnotnull</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">" NOT NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>attributeForm</name><operator>-&gt;</operator><name>attcollation</name></name> <operator>!=</operator> <name>InvalidOid</name> <operator>&amp;&amp;</operator>
				<name><name>attributeForm</name><operator>-&gt;</operator><name>attcollation</name></name> <operator>!=</operator> <name>DEFAULT_COLLATION_OID</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">" COLLATE %s"</literal></expr></argument>, <argument><expr><call><name>generate_collation_name</name><argument_list>(
									 <argument><expr><name><name>attributeForm</name><operator>-&gt;</operator><name>attcollation</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Now check if the table has any constraints. If it does, set the number of
	 * check constraints here. Then iterate over all check constraints and print
	 * them.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>tupleConstraints</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>constraintCount</name> <operator>=</operator> <name><name>tupleConstraints</name><operator>-&gt;</operator><name>num_check</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>constraintIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>constraintIndex</name> <operator>&lt;</operator> <name>constraintCount</name></expr>;</condition> <incr><expr><name>constraintIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ConstrCheck</name> <modifier>*</modifier></type><name>checkConstraintList</name> <init>= <expr><name><name>tupleConstraints</name><operator>-&gt;</operator><name>check</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ConstrCheck</name> <modifier>*</modifier></type><name>checkConstraint</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>checkConstraintList</name><index>[<expr><name>constraintIndex</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>


		<comment type="block">/* if an attribute or constraint has been printed, format properly */</comment>
		<if_stmt><if>if <condition>(<expr><name>firstAttributePrinted</name> <operator>||</operator> <name>constraintIndex</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"CONSTRAINT %s CHECK "</literal></expr></argument>,
						 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name><name>checkConstraint</name><operator>-&gt;</operator><name>ccname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* convert expression to node tree, and prepare deparse context */</comment>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>checkNode</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><name><name>checkConstraint</name><operator>-&gt;</operator><name>ccbin</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>checkContext</name> <init>= <expr><call><name>deparse_context_for</name><argument_list>(<argument><expr><name>relationName</name></expr></argument>, <argument><expr><name>tableRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* deparse check constraint string */</comment>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>checkString</name> <init>= <expr><call><name>deparse_expression</name><argument_list>(<argument><expr><name>checkNode</name></expr></argument>, <argument><expr><name>checkContext</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name>checkString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* close create table's outer parentheses */</comment>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the relation is a foreign table, append the server name and options to
	 * the create table statement.
	 */</comment>
	<decl_stmt><decl><type><name>char</name></type> <name>relationKind</name> <init>= <expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>relationKind</name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ForeignTable</name> <modifier>*</modifier></type><name>foreignTable</name> <init>= <expr><call><name>GetForeignTable</name><argument_list>(<argument><expr><name>tableRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ForeignServer</name> <modifier>*</modifier></type><name>foreignServer</name> <init>= <expr><call><name>GetForeignServer</name><argument_list>(<argument><expr><name><name>foreignTable</name><operator>-&gt;</operator><name>serverid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>serverName</name> <init>= <expr><name><name>foreignServer</name><operator>-&gt;</operator><name>servername</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">" SERVER %s"</literal></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>serverName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AppendOptionListToString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>foreignTable</name><operator>-&gt;</operator><name>options</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>relationKind</name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>partitioningInformation</name> <init>= <expr><call><name>GeneratePartitioningInformation</name><argument_list>(<argument><expr><name>tableRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">" PARTITION BY %s "</literal></expr></argument>, <argument><expr><name>partitioningInformation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Add table access methods when the table is configured with an
	 * access method
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>accessMethod</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">" USING %s"</literal></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>accessMethod</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relam</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type> <name>amTup</name> <init>= <expr><call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>AMOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(
											  <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relam</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>amTup</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for access method %u"</literal></expr></argument>,
				 <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<decl_stmt><decl><type><name>Form_pg_am</name></type> <name>amForm</name> <init>= <expr><operator>(</operator><name>Form_pg_am</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>amTup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">" USING %s"</literal></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>amForm</name><operator>-&gt;</operator><name>amname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>amTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Add any reloptions (storage parameters) defined on the table in a WITH
	 * clause.
	 */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>reloptions</name> <init>= <expr><call><name>flatten_reloptions</name><argument_list>(<argument><expr><name>tableRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>reloptions</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">" WITH (%s)"</literal></expr></argument>, <argument><expr><name>reloptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>reloptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name><name>buffer</name><operator>.</operator><name>data</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * EnsureRelationKindSupported errors out if the given relation is not supported
 * as a distributed relation.
 */</comment>
<function><type><name>void</name></type>
<name>EnsureRelationKindSupported</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name>relationKind</name> <init>= <expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>relationKind</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation with OID %d does not exist"</literal></expr></argument>,
							   <argument><expr><name>relationId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>supportedRelationKind</name> <init>= <expr><call><name>RegularTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call> <operator>||</operator>
								 <name>relationKind</name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Citus doesn't support bare inherited tables (i.e., not a partition or
	 * partitioned table)
	 */</comment>
	<expr_stmt><expr><name>supportedRelationKind</name> <operator>=</operator> <name>supportedRelationKind</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><call><name>IsChildTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call> <operator>||</operator>
													   <call><name>IsParentTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>supportedRelationKind</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s is not a regular, foreign or partitioned table"</literal></expr></argument>,
							   <argument><expr><name>relationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * pg_get_tablecolumnoptionsdef_string returns column storage type and column
 * statistics definitions for given table, _if_ these definitions differ from
 * their default values. The function returns null if all columns use default
 * values for their storage types and statistics.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>pg_get_tablecolumnoptionsdef_string</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>tableRelationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>columnOptionList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>columnOptionCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>firstOptionPrinted</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buffer</name> <init>= <expr><block>{ <expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Instead of retrieving values from system catalogs, we open the relation,
	 * and use the relation's tuple descriptor to access attribute information.
	 * This is primarily to maintain symmetry with pg_get_tableschemadef.
	 */</comment>
	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name> <init>= <expr><call><name>relation_open</name><argument_list>(<argument><expr><name>tableRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>EnsureRelationKindSupported</name><argument_list>(<argument><expr><name>tableRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Iterate over the table's columns. If a particular column is not dropped
	 * and is not inherited from another table, check if column storage or
	 * statistics statements need to be printed.
	 */</comment>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name> <operator>&gt;</operator> <name>MaxAttrNumber</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"bad number of tuple descriptor attributes"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>AttrNumber</name></type> <name>natts</name> <init>= <expr><name><name>tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
	<for>for <control>(<init><decl><type><name>AttrNumber</name></type> <name>attributeIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init>
		 <condition><expr><name>attributeIndex</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition>
		 <incr><expr><name>attributeIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attributeForm</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><name>attributeIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>attributeName</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attributeForm</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type> <name>defaultStorageType</name> <init>= <expr><call><name>get_typstorage</name><argument_list>(<argument><expr><name><name>attributeForm</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>attributeForm</name><operator>-&gt;</operator><name>attisdropped</name></name> <operator>&amp;&amp;</operator> <name><name>attributeForm</name><operator>-&gt;</operator><name>attinhcount</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If the user changed the column's default storage type, create
			 * alter statement and add statement to a list for later processing.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>attributeForm</name><operator>-&gt;</operator><name>attstorage</name></name> <operator>!=</operator> <name>defaultStorageType</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>storageName</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>StringInfoData</name></type> <name>statement</name> <init>= <expr><block>{ <expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>statement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<switch>switch <condition>(<expr><name><name>attributeForm</name><operator>-&gt;</operator><name>attstorage</name></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><literal type="char">'p'</literal></expr>:</case>
					<block>{<block_content>
						<expr_stmt><expr><name>storageName</name> <operator>=</operator> <literal type="string">"PLAIN"</literal></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block>

					<case>case <expr><literal type="char">'e'</literal></expr>:</case>
					<block>{<block_content>
						<expr_stmt><expr><name>storageName</name> <operator>=</operator> <literal type="string">"EXTERNAL"</literal></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block>

					<case>case <expr><literal type="char">'m'</literal></expr>:</case>
					<block>{<block_content>
						<expr_stmt><expr><name>storageName</name> <operator>=</operator> <literal type="string">"MAIN"</literal></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block>

					<case>case <expr><literal type="char">'x'</literal></expr>:</case>
					<block>{<block_content>
						<expr_stmt><expr><name>storageName</name> <operator>=</operator> <literal type="string">"EXTENDED"</literal></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block>

					<default>default:</default>
					<block>{<block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized storage type: %c"</literal></expr></argument>,
											   <argument><expr><name><name>attributeForm</name><operator>-&gt;</operator><name>attstorage</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block>
				</block_content>}</block></switch>

				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>statement</name></expr></argument>, <argument><expr><literal type="string">"ALTER COLUMN %s "</literal></expr></argument>,
								 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>attributeName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>statement</name></expr></argument>, <argument><expr><literal type="string">"SET STORAGE %s"</literal></expr></argument>, <argument><expr><name>storageName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>columnOptionList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>columnOptionList</name></expr></argument>, <argument><expr><name><name>statement</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * If the user changed the column's statistics target, create
			 * alter statement and add statement to a list for later processing.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>attributeForm</name><operator>-&gt;</operator><name>attstattarget</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>StringInfoData</name></type> <name>statement</name> <init>= <expr><block>{ <expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>statement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>statement</name></expr></argument>, <argument><expr><literal type="string">"ALTER COLUMN %s "</literal></expr></argument>,
								 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>attributeName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>statement</name></expr></argument>, <argument><expr><literal type="string">"SET STATISTICS %d"</literal></expr></argument>,
								 <argument><expr><name><name>attributeForm</name><operator>-&gt;</operator><name>attstattarget</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>columnOptionList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>columnOptionList</name></expr></argument>, <argument><expr><name><name>statement</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Iterate over column storage and statistics statements that we created,
	 * and append them to a single alter table statement.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>columnOptionCell</argument>, <argument>columnOptionList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>firstOptionPrinted</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE ONLY %s "</literal></expr></argument>,
							 <argument><expr><call><name>generate_relation_name</name><argument_list>(<argument><expr><name>tableRelationId</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>firstOptionPrinted</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>columnOptionStatement</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>columnOptionCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name>columnOptionStatement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>columnOptionStatement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>columnOptionList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name><name>buffer</name><operator>.</operator><name>data</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * deparse_shard_index_statement uses the provided CREATE INDEX node, dist.
 * relation, and shard identifier to populate a provided buffer with a string
 * representation of a shard-extended version of that command.
 */</comment>
<function><type><name>void</name></type>
<name>deparse_shard_index_statement</name><parameter_list>(<parameter><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>origStmt</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>distrelid</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>shardid</name></decl></parameter>,
							  <parameter><decl><type><name>StringInfo</name></type> <name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>indexStmt</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>origStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="block">/* copy to avoid modifications */</comment>

	<comment type="block">/* extend relation and index name using shard identifier */</comment>
	<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>indexStmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name><operator>)</operator></expr></argument>, <argument><expr><name>shardid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>indexStmt</name><operator>-&gt;</operator><name>idxname</name></name><operator>)</operator></expr></argument>, <argument><expr><name>shardid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><name><name>indexStmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>indexName</name> <init>= <expr><name><name>indexStmt</name><operator>-&gt;</operator><name>idxname</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* use extended shard name and transformed stmt for deparsing */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>deparseContext</name> <init>= <expr><call><name>deparse_context_for</name><argument_list>(<argument><expr><name>relationName</name></expr></argument>, <argument><expr><name>distrelid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>indexStmt</name> <operator>=</operator> <call><name>transformIndexStmt</name><argument_list>(<argument><expr><name>distrelid</name></expr></argument>, <argument><expr><name>indexStmt</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"CREATE %s INDEX %s %s %s ON %s %s USING %s "</literal></expr></argument>,
					 <argument><expr><operator>(</operator><ternary><condition><expr><name><name>indexStmt</name><operator>-&gt;</operator><name>unique</name></name></expr> ?</condition><then> <expr><literal type="string">"UNIQUE"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>,
					 <argument><expr><operator>(</operator><ternary><condition><expr><name><name>indexStmt</name><operator>-&gt;</operator><name>concurrent</name></name></expr> ?</condition><then> <expr><literal type="string">"CONCURRENTLY"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>,
					 <argument><expr><operator>(</operator><ternary><condition><expr><name><name>indexStmt</name><operator>-&gt;</operator><name>if_not_exists</name></name></expr> ?</condition><then> <expr><literal type="string">"IF NOT EXISTS"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>,
					 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>indexName</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><operator>(</operator><ternary><condition><expr><name><name>indexStmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>inh</name></name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"ONLY"</literal></expr></else></ternary><operator>)</operator></expr></argument>,
					 <argument><expr><call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name><name>indexStmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>,
												<argument><expr><name>relationName</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name><name>indexStmt</name><operator>-&gt;</operator><name>accessMethod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Switch to empty search_path to deparse_index_columns to produce fully-
	 * qualified names in expressions.
	 */</comment>
	<expr_stmt><expr><call><name>PushOverrideEmptySearchPath</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* index column or expression list begins here */</comment>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>deparse_index_columns</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>indexStmt</name><operator>-&gt;</operator><name>indexParams</name></name></expr></argument>, <argument><expr><name>deparseContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="string">") "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* column/expressions for INCLUDE list */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>indexStmt</name><operator>-&gt;</operator><name>indexIncludingParams</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"INCLUDE ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>deparse_index_columns</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>indexStmt</name><operator>-&gt;</operator><name>indexIncludingParams</name></name></expr></argument>, <argument><expr><name>deparseContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="string">") "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <name>PG_VERSION_15</name></expr></cpp:if>
	<if_stmt><if>if <condition>(<expr><name><name>indexStmt</name><operator>-&gt;</operator><name>nulls_not_distinct</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"NULLS NOT DISTINCT "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PG_VERSION_15 */</comment>

	<if_stmt><if>if <condition>(<expr><name><name>indexStmt</name><operator>-&gt;</operator><name>options</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"WITH ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AppendStorageParametersToString</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>indexStmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="string">") "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>indexStmt</name><operator>-&gt;</operator><name>whereClause</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"WHERE %s"</literal></expr></argument>, <argument><expr><call><name>deparse_expression</name><argument_list>(<argument><expr><name><name>indexStmt</name><operator>-&gt;</operator><name>whereClause</name></name></expr></argument>,
																<argument><expr><name>deparseContext</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
																<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* revert back to original search_path */</comment>
	<expr_stmt><expr><call><name>PopOverrideSearchPath</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * deparse_shard_reindex_statement uses the provided REINDEX node, dist.
 * relation, and shard identifier to populate a provided buffer with a string
 * representation of a shard-extended version of that command.
 */</comment>
<function><type><name>void</name></type>
<name>deparse_shard_reindex_statement</name><parameter_list>(<parameter><decl><type><name>ReindexStmt</name> <modifier>*</modifier></type><name>origStmt</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>distrelid</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>shardid</name></decl></parameter>,
								<parameter><decl><type><name>StringInfo</name></type> <name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ReindexStmt</name> <modifier>*</modifier></type><name>reindexStmt</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>origStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="block">/* copy to avoid modifications */</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>concurrentlyString</name> <init>=
		<expr><ternary><condition><expr><call><name>IsReindexWithParam_compat</name><argument_list>(<argument><expr><name>reindexStmt</name></expr></argument>, <argument><expr><literal type="string">"concurrently"</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"CONCURRENTLY "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>


	<if_stmt><if>if <condition>(<expr><name><name>reindexStmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>REINDEX_OBJECT_INDEX</name> <operator>||</operator>
		<name><name>reindexStmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>REINDEX_OBJECT_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* extend relation and index name using shard identifier */</comment>
		<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>reindexStmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name><operator>)</operator></expr></argument>, <argument><expr><name>shardid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>relationName</name> <operator>=</operator> <name><name>reindexStmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"REINDEX "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AddVacuumParams</name><argument_list>(<argument><expr><name>reindexStmt</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>reindexStmt</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>REINDEX_OBJECT_INDEX</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"INDEX %s%s"</literal></expr></argument>, <argument><expr><name>concurrentlyString</name></expr></argument>,
							 <argument><expr><call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name><name>reindexStmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>,
														<argument><expr><name>relationName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>REINDEX_OBJECT_TABLE</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"TABLE %s%s"</literal></expr></argument>, <argument><expr><name>concurrentlyString</name></expr></argument>,
							 <argument><expr><call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name><name>reindexStmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>,
														<argument><expr><name>relationName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>REINDEX_OBJECT_SCHEMA</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"SCHEMA %s%s"</literal></expr></argument>, <argument><expr><name>concurrentlyString</name></expr></argument>,
							 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name><name>reindexStmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>REINDEX_OBJECT_SYSTEM</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"SYSTEM %s%s"</literal></expr></argument>, <argument><expr><name>concurrentlyString</name></expr></argument>,
							 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name><name>reindexStmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>REINDEX_OBJECT_DATABASE</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"DATABASE %s%s"</literal></expr></argument>, <argument><expr><name>concurrentlyString</name></expr></argument>,
							 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name><name>reindexStmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>
	</block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
 * IsReindexWithParam_compat returns true if the given parameter
 * exists for the given reindexStmt.
 */</comment>
<function><type><name>bool</name></type>
<name>IsReindexWithParam_compat</name><parameter_list>(<parameter><decl><type><name>ReindexStmt</name> <modifier>*</modifier></type><name>reindexStmt</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>param</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <name>PG_VERSION_14</name></expr></cpp:if>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><literal type="string">"concurrently"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name><name>reindexStmt</name><operator>-&gt;</operator><name>concurrent</name></name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><literal type="string">"verbose"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name><name>reindexStmt</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>REINDEXOPT_VERBOSE</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>opt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>opt</argument>, <argument>reindexStmt-&gt;params</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><name>param</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><call><name>defGetBoolean</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>false</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>


<comment type="block">/*
 * AddVacuumParams adds vacuum params to the given buffer.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AddVacuumParams</name><parameter_list>(<parameter><decl><type><name>ReindexStmt</name> <modifier>*</modifier></type><name>reindexStmt</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>temp</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsReindexWithParam_compat</name><argument_list>(<argument><expr><name>reindexStmt</name></expr></argument>, <argument><expr><literal type="string">"verbose"</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>temp</name></expr></argument>, <argument><expr><literal type="string">"VERBOSE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <name>PG_VERSION_14</name></expr></cpp:if>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tableSpaceName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>opt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>opt</argument>, <argument>reindexStmt-&gt;params</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"tablespace"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>tableSpaceName</name> <operator>=</operator> <call><name>defGetString</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>tableSpaceName</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>temp</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>temp</name></expr></argument>, <argument><expr><literal type="string">", TABLESPACE %s"</literal></expr></argument>, <argument><expr><name>tableSpaceName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>temp</name></expr></argument>, <argument><expr><literal type="string">"TABLESPACE %s"</literal></expr></argument>, <argument><expr><name>tableSpaceName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><name><name>temp</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"(%s) "</literal></expr></argument>, <argument><expr><name><name>temp</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/* deparse_index_columns appends index or include parameters to the provided buffer */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>deparse_index_columns</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexParameterList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>deparseContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>indexParameterCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach</name><argument_list>(<argument>indexParameterCell</argument>, <argument>indexParameterList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>IndexElem</name> <modifier>*</modifier></type><name>indexElement</name> <init>= <expr><operator>(</operator><name>IndexElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>indexParameterCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* use commas to separate subsequent elements */</comment>
		<if_stmt><if>if <condition>(<expr><name>indexParameterCell</name> <operator>!=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>indexParameterList</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>indexElement</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"%s "</literal></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name><name>indexElement</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>indexElement</name><operator>-&gt;</operator><name>expr</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"(%s)"</literal></expr></argument>, <argument><expr><call><name>deparse_expression</name><argument_list>(<argument><expr><name><name>indexElement</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
																<argument><expr><name>deparseContext</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
																<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>indexElement</name><operator>-&gt;</operator><name>collation</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"COLLATE %s "</literal></expr></argument>,
							 <argument><expr><call><name>NameListToQuotedString</name><argument_list>(<argument><expr><name><name>indexElement</name><operator>-&gt;</operator><name>collation</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>indexElement</name><operator>-&gt;</operator><name>opclass</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"%s "</literal></expr></argument>,
							 <argument><expr><call><name>NameListToQuotedString</name><argument_list>(<argument><expr><name><name>indexElement</name><operator>-&gt;</operator><name>opclass</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Commit on postgres: 911e70207703799605f5a0e8aad9f06cff067c63*/</comment>
		<if_stmt><if>if <condition>(<expr><name><name>indexElement</name><operator>-&gt;</operator><name>opclassopts</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>AppendStorageParametersToString</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>indexElement</name><operator>-&gt;</operator><name>opclassopts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="string">") "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>indexElement</name><operator>-&gt;</operator><name>ordering</name></name> <operator>!=</operator> <name>SORTBY_DEFAULT</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type> <name>sortAsc</name> <init>= <expr><operator>(</operator><name><name>indexElement</name><operator>-&gt;</operator><name>ordering</name></name> <operator>==</operator> <name>SORTBY_ASC</name><operator>)</operator></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"%s "</literal></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>sortAsc</name></expr> ?</condition><then> <expr><literal type="string">"ASC"</literal></expr> </then><else>: <expr><literal type="string">"DESC"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>indexElement</name><operator>-&gt;</operator><name>nulls_ordering</name></name> <operator>!=</operator> <name>SORTBY_NULLS_DEFAULT</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type> <name>nullsFirst</name> <init>= <expr><operator>(</operator><name><name>indexElement</name><operator>-&gt;</operator><name>nulls_ordering</name></name> <operator>==</operator> <name>SORTBY_NULLS_FIRST</name><operator>)</operator></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"NULLS %s "</literal></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>nullsFirst</name></expr> ?</condition><then> <expr><literal type="string">"FIRST"</literal></expr> </then><else>: <expr><literal type="string">"LAST"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * pg_get_indexclusterdef_string returns the definition of a cluster statement
 * for given index. The function returns null if the table is not clustered on
 * given index.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>pg_get_indexclusterdef_string</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>indexRelationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buffer</name> <init>= <expr><block>{ <expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>indexTuple</name> <init>= <expr><call><name>SearchSysCache</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>indexRelationId</name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cache lookup failed for index %u"</literal></expr></argument>, <argument><expr><name>indexRelationId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Form_pg_index</name></type> <name>indexForm</name> <init>= <expr><operator>(</operator><name>Form_pg_index</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>tableRelationId</name> <init>= <expr><name><name>indexForm</name><operator>-&gt;</operator><name>indrelid</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* check if the table is clustered on this index */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>indexForm</name><operator>-&gt;</operator><name>indisclustered</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>qualifiedRelationName</name> <init>=
			<expr><call><name>generate_qualified_relation_name</name><argument_list>(<argument><expr><name>tableRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>indexName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>indexRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="block">/* needs to be quoted */</comment>

		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE %s CLUSTER ON %s"</literal></expr></argument>,
						 <argument><expr><name>qualifiedRelationName</name></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>indexName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name><name>buffer</name><operator>.</operator><name>data</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * pg_get_table_grants returns a list of sql statements which recreate the
 * permissions for a specific table.
 *
 * This function is modeled after aclexplode(), don't change too heavily.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>pg_get_table_grants</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* *INDENT-OFF* */</comment>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>defs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isNull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name> <init>= <expr><call><name>relation_open</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>generate_relation_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* lookup all table level grants */</comment>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>classTuple</name> <init>= <expr><call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>classTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation with OID %u does not exist"</literal></expr></argument>,
						<argument><expr><name>relationId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Datum</name></type> <name>aclDatum</name> <init>= <expr><call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><name>classTuple</name></expr></argument>, <argument><expr><name>Anum_pg_class_relacl</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>classTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isNull</name></expr>)</condition>
	<block>{<block_content>

		<comment type="block">/*
		 * First revoke all default permissions, so we can start adding the
		 * exact permissions from the master. Note that we only do so if there
		 * are any actual grants; an empty grant set signals default
		 * permissions.
		 *
		 * Note: This doesn't work correctly if default permissions have been
		 * changed with ALTER DEFAULT PRIVILEGES - but that's hard to fix
		 * properly currently.
		 */</comment>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"REVOKE ALL ON %s FROM PUBLIC"</literal></expr></argument>,
						 <argument><expr><name>relationName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>defs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>defs</name></expr></argument>, <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name><name>buffer</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* iterate through the acl datastructure, emit GRANTs */</comment>

		<decl_stmt><decl><type><name>Acl</name> <modifier>*</modifier></type><name>acl</name> <init>= <expr><call><name>DatumGetAclP</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AclItem</name> <modifier>*</modifier></type><name>aidat</name> <init>= <expr><call><name>ACL_DAT</name><argument_list>(<argument><expr><name>acl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>int</name></type> <name>offtype</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <call><name>ACL_NUM</name><argument_list>(<argument><expr><name>acl</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AclItem</name>    <modifier>*</modifier></type><name>aidata</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AclMode</name></type>		<name>priv_bit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>offtype</name><operator>++</operator></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>offtype</name> <operator>==</operator> <name>N_ACL_RIGHTS</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>offtype</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <call><name>ACL_NUM</name><argument_list>(<argument><expr><name>acl</name></expr></argument>)</argument_list></call></expr>)</condition> <comment type="block">/* done */</comment>
				<block>{<block_content>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>aidata</name> <operator>=</operator> <operator>&amp;</operator><name><name>aidat</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>priv_bit</name> <operator>=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>offtype</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>ACLITEM_GET_PRIVS</name><argument_list>(<argument><expr><operator>*</operator><name>aidata</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>priv_bit</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>roleName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>withGrant</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>aidata</name><operator>-&gt;</operator><name>ai_grantee</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>

					<decl_stmt><decl><type><name>HeapTuple</name></type> <name>htup</name> <init>= <expr><call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>AUTHOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>aidata</name><operator>-&gt;</operator><name>ai_grantee</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>Form_pg_authid</name></type> <name>authForm</name> <init>= <expr><operator>(</operator><operator>(</operator><name>Form_pg_authid</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>

						<expr_stmt><expr><name>roleName</name> <operator>=</operator> <call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>authForm</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for role %u"</literal></expr></argument>, <argument><expr><name><name>aidata</name><operator>-&gt;</operator><name>ai_grantee</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name>roleName</name> <operator>=</operator> <literal type="string">"PUBLIC"</literal></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>ACLITEM_GET_GOPTIONS</name><argument_list>(<argument><expr><operator>*</operator><name>aidata</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>priv_bit</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>withGrant</name> <operator>=</operator> <literal type="string">" WITH GRANT OPTION"</literal></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"GRANT %s ON %s TO %s%s"</literal></expr></argument>,
								 <argument><expr><call><name>convert_aclright_to_string</name><argument_list>(<argument><expr><name>priv_bit</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name>relationName</name></expr></argument>,
								 <argument><expr><name>roleName</name></expr></argument>,
								 <argument><expr><name>withGrant</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>defs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>defs</name></expr></argument>, <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name><name>buffer</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></while>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>defs</name></expr>;</return>
	<comment type="block">/* *INDENT-ON* */</comment>
</block_content>}</block></function>


<comment type="block">/*
 * generate_qualified_relation_name computes the schema-qualified name to display for a
 * relation specified by OID.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>generate_qualified_relation_name</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tp</name> <init>= <expr><call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>reltup</name> <init>= <expr><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relname</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>reltup</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nspname</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>reltup</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>nspname</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for namespace %u"</literal></expr></argument>,
			 <argument><expr><name><name>reltup</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AppendOptionListToString converts the option list to its textual format, and
 * appends this text to the given string buffer.
 */</comment>
<function><type><name>void</name></type>
<name>AppendOptionListToString</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>stringBuffer</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>optionList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>optionList</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>optionCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>firstOptionPrinted</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>stringBuffer</name></expr></argument>, <argument><expr><literal type="string">" OPTIONS ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<macro><name>foreach</name><argument_list>(<argument>optionCell</argument>, <argument>optionList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>option</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>optionCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>optionName</name> <init>= <expr><name><name>option</name><operator>-&gt;</operator><name>defname</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>optionValue</name> <init>= <expr><call><name>defGetString</name><argument_list>(<argument><expr><name>option</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>firstOptionPrinted</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>stringBuffer</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>firstOptionPrinted</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>stringBuffer</name></expr></argument>, <argument><expr><literal type="string">"%s "</literal></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>optionName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>stringBuffer</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>optionValue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>stringBuffer</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * AppendStorageParametersToString converts the storage parameter list to its
 * textual format, and appends this text to the given string buffer.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AppendStorageParametersToString</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>stringBuffer</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>optionList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>optionCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>firstOptionPrinted</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>optionCell</argument>, <argument>optionList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>option</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>optionCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>optionName</name> <init>= <expr><name><name>option</name><operator>-&gt;</operator><name>defname</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>optionValue</name> <init>= <expr><call><name>defGetString</name><argument_list>(<argument><expr><name>option</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>firstOptionPrinted</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>stringBuffer</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>firstOptionPrinted</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>stringBuffer</name></expr></argument>, <argument><expr><literal type="string">"%s = %s "</literal></expr></argument>,
						 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>optionName</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>optionValue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/* copy of postgresql's function, which is static as well */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>convert_aclright_to_string</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>aclright</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* *INDENT-OFF* */</comment>
	<switch>switch <condition>(<expr><name>aclright</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>ACL_INSERT</name></expr>:</case>
			<return>return <expr><literal type="string">"INSERT"</literal></expr>;</return>
		<case>case <expr><name>ACL_SELECT</name></expr>:</case>
			<return>return <expr><literal type="string">"SELECT"</literal></expr>;</return>
		<case>case <expr><name>ACL_UPDATE</name></expr>:</case>
			<return>return <expr><literal type="string">"UPDATE"</literal></expr>;</return>
		<case>case <expr><name>ACL_DELETE</name></expr>:</case>
			<return>return <expr><literal type="string">"DELETE"</literal></expr>;</return>
		<case>case <expr><name>ACL_TRUNCATE</name></expr>:</case>
			<return>return <expr><literal type="string">"TRUNCATE"</literal></expr>;</return>
		<case>case <expr><name>ACL_REFERENCES</name></expr>:</case>
			<return>return <expr><literal type="string">"REFERENCES"</literal></expr>;</return>
		<case>case <expr><name>ACL_TRIGGER</name></expr>:</case>
			<return>return <expr><literal type="string">"TRIGGER"</literal></expr>;</return>
		<case>case <expr><name>ACL_EXECUTE</name></expr>:</case>
			<return>return <expr><literal type="string">"EXECUTE"</literal></expr>;</return>
		<case>case <expr><name>ACL_USAGE</name></expr>:</case>
			<return>return <expr><literal type="string">"USAGE"</literal></expr>;</return>
		<case>case <expr><name>ACL_CREATE</name></expr>:</case>
			<return>return <expr><literal type="string">"CREATE"</literal></expr>;</return>
		<case>case <expr><name>ACL_CREATE_TEMP</name></expr>:</case>
			<return>return <expr><literal type="string">"TEMPORARY"</literal></expr>;</return>
		<case>case <expr><name>ACL_CONNECT</name></expr>:</case>
			<return>return <expr><literal type="string">"CONNECT"</literal></expr>;</return>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized aclright: %d"</literal></expr></argument>, <argument><expr><name>aclright</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></switch>
	<comment type="block">/* *INDENT-ON* */</comment>
</block_content>}</block></function>


<comment type="block">/*
 * contain_nextval_expression_walker walks over expression tree and returns
 * true if it contains call to 'nextval' function.
 */</comment>
<function><type><name>bool</name></type>
<name>contain_nextval_expression_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>funcExpr</name> <init>= <expr><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>funcExpr</name><operator>-&gt;</operator><name>funcid</name></name> <operator>==</operator> <name>F_NEXTVAL</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>contain_nextval_expression_walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * pg_get_replica_identity_command function returns the required ALTER .. TABLE
 * command to define the replica identity.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>pg_get_replica_identity_command</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>tableRelationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>buf</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>tableRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name></type> <name>replicaIdentity</name> <init>= <expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relreplident</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>generate_qualified_relation_name</name><argument_list>(<argument><expr><name>tableRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>replicaIdentity</name> <operator>==</operator> <name>REPLICA_IDENTITY_INDEX</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>indexId</name> <init>= <expr><call><name>RelationGetReplicaIndex</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>indexId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE %s REPLICA IDENTITY USING INDEX %s "</literal></expr></argument>,
							 <argument><expr><name>relationName</name></expr></argument>,
							 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>indexId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>replicaIdentity</name> <operator>==</operator> <name>REPLICA_IDENTITY_NOTHING</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE %s REPLICA IDENTITY NOTHING"</literal></expr></argument>,
						 <argument><expr><name>relationName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>replicaIdentity</name> <operator>==</operator> <name>REPLICA_IDENTITY_FULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE %s REPLICA IDENTITY FULL"</literal></expr></argument>,
						 <argument><expr><name>relationName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><ternary><condition><expr><operator>(</operator><name><name>buf</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name><name>buf</name><operator>-&gt;</operator><name>data</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * pg_get_row_level_security_commands function returns the required ALTER .. TABLE
 * commands to define the row level security settings for a relation.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>pg_get_row_level_security_commands</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commands</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relrowsecurity</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>generate_qualified_relation_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE %s ENABLE ROW LEVEL SECURITY"</literal></expr></argument>,
						 <argument><expr><name>relationName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>commands</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>commands</name></expr></argument>, <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name><name>buffer</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relforcerowsecurity</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>generate_qualified_relation_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE %s FORCE ROW LEVEL SECURITY"</literal></expr></argument>,
						 <argument><expr><name>relationName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>commands</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>commands</name></expr></argument>, <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name><name>buffer</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>commands</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Generate a C string representing a relation's reloptions, or NULL if none.
 *
 * This function comes from PostgreSQL source code in
 * src/backend/utils/adt/ruleutils.c
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>flatten_reloptions</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isnull</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name> <init>= <expr><call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Datum</name></type> <name>reloptions</name> <init>= <expr><call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>,
									   <argument><expr><name>Anum_pg_class_reloptions</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>options</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>noptions</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>reloptions</name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>options</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>noptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>noptions</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>option</name> <init>= <expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name><name>options</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Each array element should have the form name=value.  If the "="
			 * is missing for some reason, treat it like an empty value.
			 */</comment>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name>option</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>separator</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>separator</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>separator</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>value</name> <operator>=</operator> <name>separator</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>value</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s="</literal></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * In general we need to quote the value; but to avoid unnecessary
			 * clutter, do not quote if it is an identifier that would not
			 * need quoting.  (We could also allow numbers, but that is a bit
			 * trickier than it looks --- for example, are leading zeroes
			 * significant?  We don't want to assume very much here about what
			 * custom reloptions might mean.)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>value</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>simple_quote_literal</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>option</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * simple_quote_literal - Format a string as a SQL literal, append to buf
 *
 * This function comes from PostgreSQL source code in
 * src/backend/utils/adt/ruleutils.c
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>simple_quote_literal</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We form the string literal according to the prevailing setting of
	 * standard_conforming_strings; we never use E''. User is responsible for
	 * making sure result is used correctly.
	 */</comment>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\''</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>valptr</name> <init>= <expr><name>val</name></expr></init></decl>;</init> <condition><expr><operator>*</operator><name>valptr</name></expr>;</condition> <incr><expr><name>valptr</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type> <name>ch</name> <init>= <expr><operator>*</operator><name>valptr</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>SQL_STR_DOUBLE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><operator>!</operator><name>standard_conforming_strings</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\''</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * RoleSpecString resolves the role specification to its string form that is suitable for transport to a worker node.
 * This function resolves the following identifiers from the current context so they are safe to transfer.
 *
 * CURRENT_USER - resolved to the user name of the current role being used
 * SESSION_USER - resolved to the user name of the user that opened the session
 * CURRENT_ROLE - same as CURRENT_USER, resolved to the user name of the current role being used
 * Postgres treats CURRENT_ROLE is equivalent to CURRENT_USER, and we follow the same approach.
 *
 * withQuoteIdentifier is used, because if the results will be used in a query the quotes are needed but if not there
 * should not be extra quotes.
 */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>RoleSpecString</name><parameter_list>(<parameter><decl><type><name>RoleSpec</name> <modifier>*</modifier></type><name>spec</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>withQuoteIdentifier</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name><name>spec</name><operator>-&gt;</operator><name>roletype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>ROLESPEC_CSTRING</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><ternary><condition><expr><name>withQuoteIdentifier</name></expr> ?</condition><then>
				   <expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>rolename</name></name></expr></argument>)</argument_list></call></expr> </then><else>:
				   <expr><name><name>spec</name><operator>-&gt;</operator><name>rolename</name></name></expr></else></ternary></expr>;</return>
		</block_content>}</block>

		<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <name>PG_VERSION_14</name></expr></cpp:if>
		<case>case <expr><name>ROLESPEC_CURRENT_ROLE</name></expr>:</case>
		<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<case>case <expr><name>ROLESPEC_CURRENT_USER</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><ternary><condition><expr><name>withQuoteIdentifier</name></expr> ?</condition><then>
				   <expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>GetUserNameFromId</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>:
				   <expr><call><name>GetUserNameFromId</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>ROLESPEC_SESSION_USER</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><ternary><condition><expr><name>withQuoteIdentifier</name></expr> ?</condition><then>
				   <expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>GetUserNameFromId</name><argument_list>(<argument><expr><call><name>GetSessionUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>:
				   <expr><call><name>GetUserNameFromId</name><argument_list>(<argument><expr><call><name>GetSessionUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>ROLESPEC_PUBLIC</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><literal type="string">"PUBLIC"</literal></expr>;</return>
		</block_content>}</block>

		<default>default:</default>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected role type %d"</literal></expr></argument>, <argument><expr><name><name>spec</name><operator>-&gt;</operator><name>roletype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></switch>
</block_content>}</block></function>
</unit>
