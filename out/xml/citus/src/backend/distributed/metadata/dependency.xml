<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/citus/src/backend/distributed/metadata/dependency.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * dependency.c
 *	  Functions to reason about distributed objects and their dependencies
 *
 * Copyright (c) Citus Data, Inc.
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_version_constants.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/skey.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_auth_members.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_authid_d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_class.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_constraint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_depend.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_extension_d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_foreign_data_wrapper_d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc_d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_rewrite.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_rewrite_d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_shdepend.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/extension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/hashfn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_depended_object.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands/utility_hook.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/hash_helpers.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata/distobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_sync.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/version_compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/hsearch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>

<comment type="block">/*
 * ObjectAddressCollector keeps track of collected ObjectAddresses. This can be used
 * together with RecurseObjectDependencies.
 *
 * We keep three different datastructures for the following reasons
 *  - A List ordered by insert/collect order
 *  - A Set to quickly O(1) check if an ObjectAddress has already been collected
 *  - A set to check which objects are already visited
 */</comment>
<typedef>typedef <type><struct>struct <name>ObjectAddressCollector</name>
<block>{
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>dependencyList</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>dependencySet</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>visitedObjects</name></decl>;</decl_stmt>
}</block></struct></type> <name>ObjectAddressCollector</name>;</typedef>

<comment type="block">/*
 * DependencyMode distinguishes the data stored in DependencyDefinition. For details see
 * DependencyDefinition's inline comments in the data union.
 */</comment>
<typedef>typedef <type><enum>enum <name>DependencyMode</name>
<block>{
	<decl><name>DependencyObjectAddress</name></decl>,
	<decl><name>DependencyPgDepend</name></decl>,
	<decl><name>DependencyPgShDepend</name></decl>
}</block></enum></type> <name>DependencyMode</name>;</typedef>

<typedef>typedef <type><struct>struct <name>DependencyDefinition</name>
<block>{
	<comment type="block">/* describe how the dependency data is stored in the data field */</comment>
	<decl_stmt><decl><type><name>DependencyMode</name></type> <name>mode</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Dependencies can be found in different ways and therefore stored differently on the
	 * definition.
	 */</comment>
	<union>union
	<block>{
		<comment type="block">/*
		 * pg_depend is used for dependencies found in the database local pg_depend table.
		 * The entry is copied while scanning the table. The record can be inspected
		 * during the chasing algorithm to follow dependencies of different classes, or
		 * based on dependency type.
		 */</comment>
		<decl_stmt><decl><type><name>FormData_pg_depend</name></type> <name>pg_depend</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * pg_shdepend is used for dependencies found in the global pg_shdepend table.
		 * The entry is copied while scanning the table. The record can be inspected
		 * during the chasing algorithm to follow dependencies of different classes, or
		 * based on dependency type.
		 */</comment>
		<decl_stmt><decl><type><name>FormData_pg_shdepend</name></type> <name>pg_shdepend</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * address is used for dependencies that are artificially added during the
		 * chasing. Since they are added by citus code we assume the dependency needs to
		 * be chased anyway, of course it will only actually be chased if the object is a
		 * supported object by citus
		 */</comment>
		<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>
	}</block> <decl><name>data</name></decl>;</union>
}</block></struct></type> <name>DependencyDefinition</name>;</typedef>

<comment type="block">/*
 * ViewDependencyNode represents a view (or possibly a table) in a dependency graph of
 * views.
 */</comment>
<typedef>typedef <type><struct>struct <name>ViewDependencyNode</name>
<block>{
	<decl_stmt><decl><type><name>Oid</name></type> <name>id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>remainingDependencyCount</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>dependingNodes</name></decl>;</decl_stmt>
}</block></struct></type><name>ViewDependencyNode</name>;</typedef>


<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>GetRelationSequenceDependencyList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>GetRelationFunctionDependencyList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>GetRelationTriggerFunctionDependencyList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>GetRelationStatsSchemaDependencyList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>GetRelationIndicesDependencyList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>DependencyDefinition</name> <modifier>*</modifier></type> <name>CreateObjectAddressDependencyDef</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>classId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>objectId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>GetTypeConstraintDependencyDefinition</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typeId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>CreateObjectAddressDependencyDefList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>classId</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>objectIdList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>DependencyDefinitionObjectAddress</name><parameter_list>(<parameter><decl><type><name>DependencyDefinition</name> <modifier>*</modifier></type><name>definition</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>DeferredErrorMessage</name> <modifier>*</modifier></type> <name>DeferErrorIfHasUnsupportedDependency</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type>
																   <name>objectAddress</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* forward declarations for functions to interact with the ObjectAddressCollector */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>InitObjectAddressCollector</name><parameter_list>(<parameter><decl><type><name>ObjectAddressCollector</name> <modifier>*</modifier></type><name>collector</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CollectObjectAddress</name><parameter_list>(<parameter><decl><type><name>ObjectAddressCollector</name> <modifier>*</modifier></type><name>collector</name></decl></parameter>,
								 <parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>address</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsObjectAddressCollected</name><parameter_list>(<parameter><decl><type><name>ObjectAddress</name></type> <name>findAddress</name></decl></parameter>,
									 <parameter><decl><type><name>ObjectAddressCollector</name> <modifier>*</modifier></type><name>collector</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type> <name>GetUndistributableDependency</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>objectAddress</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ObjectAddressHasExtensionDependency</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
												<parameter><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>extensionAddress</name></decl></parameter>,
												<parameter><decl><type><name>int</name></type> <name>extensionDependency</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>MarkObjectVisited</name><parameter_list>(<parameter><decl><type><name>ObjectAddressCollector</name> <modifier>*</modifier></type><name>collector</name></decl></parameter>,
							  <parameter><decl><type><name>ObjectAddress</name></type> <name>target</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>TargetObjectVisited</name><parameter_list>(<parameter><decl><type><name>ObjectAddressCollector</name> <modifier>*</modifier></type><name>collector</name></decl></parameter>,
								<parameter><decl><type><name>ObjectAddress</name></type> <name>target</name></decl></parameter>)</parameter_list>;</function_decl>

<typedef>typedef <function_decl><type><name>List</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>expandFn</name>)<parameter_list>(<parameter><decl><type><name>ObjectAddressCollector</name> <modifier>*</modifier></type><name>collector</name></decl></parameter>, <parameter><decl><type><name>ObjectAddress</name></type> <name>target</name></decl></parameter>)</parameter_list>;</function_decl></typedef>
<typedef>typedef <function_decl><type><name>bool</name></type> (<modifier>*</modifier><name>followFn</name>)<parameter_list>(<parameter><decl><type><name>ObjectAddressCollector</name> <modifier>*</modifier></type><name>collector</name></decl></parameter>,
						 <parameter><decl><type><name>DependencyDefinition</name> <modifier>*</modifier></type><name>definition</name></decl></parameter>)</parameter_list>;</function_decl></typedef>
<typedef>typedef <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>applyFn</name>)<parameter_list>(<parameter><decl><type><name>ObjectAddressCollector</name> <modifier>*</modifier></type><name>collector</name></decl></parameter>,
						<parameter><decl><type><name>DependencyDefinition</name> <modifier>*</modifier></type><name>definition</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<comment type="block">/* forward declaration of functions that recurse pg_depend */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RecurseObjectDependencies</name><parameter_list>(<parameter><decl><type><name>ObjectAddress</name></type> <name>target</name></decl></parameter>, <parameter><decl><type><name>expandFn</name></type> <name>expand</name></decl></parameter>,
									  <parameter><decl><type><name>followFn</name></type> <name>follow</name></decl></parameter>, <parameter><decl><type><name>applyFn</name></type> <name>apply</name></decl></parameter>,
									  <parameter><decl><type><name>ObjectAddressCollector</name> <modifier>*</modifier></type><name>collector</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>DependencyDefinitionFromPgDepend</name><parameter_list>(<parameter><decl><type><name>ObjectAddress</name></type> <name>target</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>DependencyDefinitionFromPgShDepend</name><parameter_list>(<parameter><decl><type><name>ObjectAddress</name></type> <name>target</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>FollowAllSupportedDependencies</name><parameter_list>(<parameter><decl><type><name>ObjectAddressCollector</name> <modifier>*</modifier></type><name>collector</name></decl></parameter>,
										   <parameter><decl><type><name>DependencyDefinition</name> <modifier>*</modifier></type><name>definition</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>FollowNewSupportedDependencies</name><parameter_list>(<parameter><decl><type><name>ObjectAddressCollector</name> <modifier>*</modifier></type><name>collector</name></decl></parameter>,
										   <parameter><decl><type><name>DependencyDefinition</name> <modifier>*</modifier></type><name>definition</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>FollowAllDependencies</name><parameter_list>(<parameter><decl><type><name>ObjectAddressCollector</name> <modifier>*</modifier></type><name>collector</name></decl></parameter>,
								  <parameter><decl><type><name>DependencyDefinition</name> <modifier>*</modifier></type><name>definition</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>FollowExtAndInternalDependencies</name><parameter_list>(<parameter><decl><type><name>ObjectAddressCollector</name> <modifier>*</modifier></type><name>collector</name></decl></parameter>,
											 <parameter><decl><type><name>DependencyDefinition</name> <modifier>*</modifier></type><name>definition</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ApplyAddToDependencyList</name><parameter_list>(<parameter><decl><type><name>ObjectAddressCollector</name> <modifier>*</modifier></type><name>collector</name></decl></parameter>,
									 <parameter><decl><type><name>DependencyDefinition</name> <modifier>*</modifier></type><name>definition</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ApplyAddCitusDependedObjectsToDependencyList</name><parameter_list>(
	<parameter><decl><type><name>ObjectAddressCollector</name> <modifier>*</modifier></type><name>collector</name></decl></parameter>,
	<parameter><decl><type><name>DependencyDefinition</name> <modifier>*</modifier></type><name>definition</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>GetViewRuleReferenceDependencyList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>ExpandCitusSupportedTypes</name><parameter_list>(<parameter><decl><type><name>ObjectAddressCollector</name> <modifier>*</modifier></type><name>collector</name></decl></parameter>,
										<parameter><decl><type><name>ObjectAddress</name></type> <name>target</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>ExpandForPgVanilla</name><parameter_list>(<parameter><decl><type><name>ObjectAddressCollector</name> <modifier>*</modifier></type><name>collector</name></decl></parameter>,
								 <parameter><decl><type><name>ObjectAddress</name></type> <name>target</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>GetDependentRoleIdsFDW</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>FDWOid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>ExpandRolesToGroups</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ViewDependencyNode</name> <modifier>*</modifier></type> <name>BuildViewDependencyGraph</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>nodeMap</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsObjectAddressOwnedByExtension</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
											<parameter><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>extensionAddress</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ErrorOrWarnIfObjectHasUnsupportedDependency</name><parameter_list>(<parameter><decl><type><specifier>const</specifier>
														<name>ObjectAddress</name> <modifier>*</modifier></type><name>objectAddress</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * GetUniqueDependenciesList takes a list of object addresses and returns a new list
 * of ObjectAddesses whose elements are unique.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>GetUniqueDependenciesList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>objectAddressesList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ObjectAddressCollector</name></type> <name>objectAddressCollector</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>InitObjectAddressCollector</name><argument_list>(<argument><expr><operator>&amp;</operator><name>objectAddressCollector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>objectAddress</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>objectAddress</argument>, <argument>objectAddressesList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IsObjectAddressCollected</name><argument_list>(<argument><expr><operator>*</operator><name>objectAddress</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>objectAddressCollector</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* skip objects that are already collected */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>CollectObjectAddress</name><argument_list>(<argument><expr><operator>&amp;</operator><name>objectAddressCollector</name></expr></argument>, <argument><expr><name>objectAddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name><name>objectAddressCollector</name><operator>.</operator><name>dependencyList</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetDependenciesForObject returns a list of ObjectAddesses to be created in order
 * before the target object could safely be created on a worker. Some of the object might
 * already be created on a worker. It should be created in an idempotent way.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>GetDependenciesForObject</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>target</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ObjectAddressCollector</name></type> <name>collector</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>InitObjectAddressCollector</name><argument_list>(<argument><expr><operator>&amp;</operator><name>collector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>RecurseObjectDependencies</name><argument_list>(<argument><expr><operator>*</operator><name>target</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>ExpandCitusSupportedTypes</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>FollowNewSupportedDependencies</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>ApplyAddToDependencyList</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>collector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>collector</name><operator>.</operator><name>dependencyList</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetAllSupportedDependenciesForObject returns a list of all the ObjectAddresses to be
 * created in order before the target object could safely be created on a worker, if all
 * dependent objects are distributable. As a caller, you probably need to use
 * GetDependenciesForObject() which eliminates already distributed objects from the returned
 * list.
 *
 * Some of the object might already be created on a worker. It should be created
 * in an idempotent way.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>GetAllSupportedDependenciesForObject</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>target</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ObjectAddressCollector</name></type> <name>collector</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>InitObjectAddressCollector</name><argument_list>(<argument><expr><operator>&amp;</operator><name>collector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>RecurseObjectDependencies</name><argument_list>(<argument><expr><operator>*</operator><name>target</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>ExpandCitusSupportedTypes</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>FollowAllSupportedDependencies</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>ApplyAddToDependencyList</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>collector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>collector</name><operator>.</operator><name>dependencyList</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetAllDependenciesForObject returns a list of all the dependent objects of the given
 * object irrespective of whether the dependent object is supported by Citus or not, if
 * the object can be found as dependency with RecurseObjectDependencies and
 * ExpandCitusSupportedTypes.
 *
 * This function will be used to provide meaningful error messages if any dependent
 * object for a given object is not supported. If you want to create dependencies for
 * an object, you probably need to use GetDependenciesForObject().
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>GetAllDependenciesForObject</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>target</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ObjectAddressCollector</name></type> <name>collector</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>InitObjectAddressCollector</name><argument_list>(<argument><expr><operator>&amp;</operator><name>collector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>RecurseObjectDependencies</name><argument_list>(<argument><expr><operator>*</operator><name>target</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>ExpandCitusSupportedTypes</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>FollowAllDependencies</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>ApplyAddToDependencyList</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>collector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>collector</name><operator>.</operator><name>dependencyList</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetAllCitusDependedDependenciesForObject returns all the dependencies
 * which are owned by citus extension for the target.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>GetAllCitusDependedDependenciesForObject</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>target</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ObjectAddressCollector</name></type> <name>collector</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>InitObjectAddressCollector</name><argument_list>(<argument><expr><operator>&amp;</operator><name>collector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>RecurseObjectDependencies</name><argument_list>(<argument><expr><operator>*</operator><name>target</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>ExpandForPgVanilla</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>FollowExtAndInternalDependencies</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>ApplyAddCitusDependedObjectsToDependencyList</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>collector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>collector</name><operator>.</operator><name>dependencyList</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * OrderObjectAddressListInDependencyOrder given a list of ObjectAddresses return a new
 * list of the same ObjectAddresses ordered on dependency order where dependencies
 * precedes the corresponding object in the list.
 *
 * The algortihm traveses pg_depend in a depth first order starting at the first object in
 * the provided list. By traversing depth first it will put the first dependency at the
 * head of the list with dependencies depending on them later.
 *
 * If the object is already in the list it is skipped for traversal. This happens when an
 * object was already added to the target list before it occurred in the input list.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>OrderObjectAddressListInDependencyOrder</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>objectAddressList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ObjectAddressCollector</name></type> <name>collector</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>InitObjectAddressCollector</name><argument_list>(<argument><expr><operator>&amp;</operator><name>collector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>objectAddress</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>objectAddress</argument>, <argument>objectAddressList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IsObjectAddressCollected</name><argument_list>(<argument><expr><operator>*</operator><name>objectAddress</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>collector</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* skip objects that are already ordered */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>RecurseObjectDependencies</name><argument_list>(<argument><expr><operator>*</operator><name>objectAddress</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>ExpandCitusSupportedTypes</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>FollowAllSupportedDependencies</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>ApplyAddToDependencyList</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>collector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CollectObjectAddress</name><argument_list>(<argument><expr><operator>&amp;</operator><name>collector</name></expr></argument>, <argument><expr><name>objectAddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name><name>collector</name><operator>.</operator><name>dependencyList</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RecurseObjectDependencies recursively visits all dependencies of an object. It sources
 * the dependencies from pg_depend and pg_shdepend while 'expanding' the list via an
 * optional `expand` function.
 *
 * Starting from the target ObjectAddress. For every dependency found the `follow`
 * function will be called. When `follow` returns true it will recursively visit the
 * dependencies for that object.
 *
 * Visiting will happen in depth first order, which is useful to create or sorted lists of
 * dependencies to create.
 *
 * For all dependencies that should be visited the apply function will be called. This
 * function is designed to be the mutating function for the context being passed. Although
 * nothing prevents the follow function to also mutate the context.
 *
 *  - follow will be called on the way down, so the invocation order is top to bottom of
 *    the dependency tree
 *  - apply is called on the way back, so the invocation order is bottom to top. Apply is
 *    not called for entries for which follow has returned false.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RecurseObjectDependencies</name><parameter_list>(<parameter><decl><type><name>ObjectAddress</name></type> <name>target</name></decl></parameter>, <parameter><decl><type><name>expandFn</name></type> <name>expand</name></decl></parameter>, <parameter><decl><type><name>followFn</name></type> <name>follow</name></decl></parameter>,
						  <parameter><decl><type><name>applyFn</name></type> <name>apply</name></decl></parameter>, <parameter><decl><type><name>ObjectAddressCollector</name> <modifier>*</modifier></type><name>collector</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>TargetObjectVisited</name><argument_list>(<argument><expr><name>collector</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* prevent infinite loops due to circular dependencies */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>MarkObjectVisited</name><argument_list>(<argument><expr><name>collector</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* lookup both pg_depend and pg_shdepend for dependencies */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>pgDependDefinitions</name> <init>= <expr><call><name>DependencyDefinitionFromPgDepend</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>pgShDependDefinitions</name> <init>= <expr><call><name>DependencyDefinitionFromPgShDepend</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>dependenyDefinitionList</name> <init>= <expr><call><name>list_concat</name><argument_list>(<argument><expr><name>pgDependDefinitions</name></expr></argument>,
												<argument><expr><name>pgShDependDefinitions</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* concat expanded entries if applicable */</comment>
	<if_stmt><if>if <condition>(<expr><name>expand</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>expandedEntries</name> <init>= <expr><call><name>expand</name><argument_list>(<argument><expr><name>collector</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>dependenyDefinitionList</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>dependenyDefinitionList</name></expr></argument>, <argument><expr><name>expandedEntries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* iterate all entries and recurse depth first */</comment>
	<decl_stmt><decl><type><name>DependencyDefinition</name> <modifier>*</modifier></type><name>dependencyDefinition</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>dependencyDefinition</argument>, <argument>dependenyDefinitionList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>follow</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>follow</name><argument_list>(<argument><expr><name>collector</name></expr></argument>, <argument><expr><name>dependencyDefinition</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* skip all pg_depend entries the user didn't want to follow */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * recurse depth first, this makes sure we call apply for the deepest dependency
		 * first.
		 */</comment>
		<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name> <init>= <expr><call><name>DependencyDefinitionObjectAddress</name><argument_list>(<argument><expr><name>dependencyDefinition</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>RecurseObjectDependencies</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>expand</name></expr></argument>, <argument><expr><name>follow</name></expr></argument>, <argument><expr><name>apply</name></expr></argument>, <argument><expr><name>collector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* now apply changes for current entry */</comment>
		<if_stmt><if>if <condition>(<expr><name>apply</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>apply</name><argument_list>(<argument><expr><name>collector</name></expr></argument>, <argument><expr><name>dependencyDefinition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * DependencyDefinitionFromPgDepend loads all pg_depend records describing the
 * dependencies of target.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>DependencyDefinitionFromPgDepend</name><parameter_list>(<parameter><decl><type><name>ObjectAddress</name></type> <name>target</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>depTup</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>dependenyDefinitionList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * iterate the actual pg_depend catalog
	 */</comment>
	<decl_stmt><decl><type><name>Relation</name></type> <name>depRel</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>DependRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* scan pg_depend for classid = $1 AND objid = $2 using pg_depend_depender_index */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_pg_depend_classid</name></expr></argument>, <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>target</name><operator>.</operator><name>classId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_pg_depend_objid</name></expr></argument>, <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>target</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>depScan</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(<argument><expr><name>depRel</name></expr></argument>, <argument><expr><name>DependDependerIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>,
											 <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>depTup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>depScan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_depend</name></type> <name>pg_depend</name> <init>= <expr><operator>(</operator><name>Form_pg_depend</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>depTup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DependencyDefinition</name> <modifier>*</modifier></type><name>dependency</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DependencyDefinition</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* keep track of all pg_depend records as dependency definitions */</comment>
		<expr_stmt><expr><name><name>dependency</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>DependencyPgDepend</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dependency</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>pg_depend</name></name> <operator>=</operator> <operator>*</operator><name>pg_depend</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>dependenyDefinitionList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>dependenyDefinitionList</name></expr></argument>, <argument><expr><name>dependency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>depScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>depRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>dependenyDefinitionList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DependencyDefinitionFromPgShDepend loads all pg_shdepend records describing the
 * dependencies of target.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>DependencyDefinitionFromPgShDepend</name><parameter_list>(<parameter><decl><type><name>ObjectAddress</name></type> <name>target</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>depTup</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>dependenyDefinitionList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * iterate the actual pg_shdepend catalog
	 */</comment>
	<decl_stmt><decl><type><name>Relation</name></type> <name>shdepRel</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>SharedDependRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Scan pg_shdepend for dbid = $1 AND classid = $2 AND objid = $3 using
	 * pg_shdepend_depender_index
	 *
	 * where $1 is decided as follows:
	 *   - shared dependencies $1 = InvalidOid
	 *   - other dependencies $1 = MyDatabaseId
	 * This is consistent with postgres' static classIdGetDbId function
	 */</comment>
	<decl_stmt><decl><type><name>Oid</name></type> <name>dbid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsSharedRelation</name><argument_list>(<argument><expr><name><name>target</name><operator>.</operator><name>classId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>dbid</name> <operator>=</operator> <name>MyDatabaseId</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_pg_shdepend_dbid</name></expr></argument>, <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>dbid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_pg_shdepend_classid</name></expr></argument>, <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>target</name><operator>.</operator><name>classId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_pg_shdepend_objid</name></expr></argument>, <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>target</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>shdepScan</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(<argument><expr><name>shdepRel</name></expr></argument>, <argument><expr><name>SharedDependDependerIndexId</name></expr></argument>,
											   <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>depTup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>shdepScan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_shdepend</name></type> <name>pg_shdepend</name> <init>= <expr><operator>(</operator><name>Form_pg_shdepend</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>depTup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DependencyDefinition</name> <modifier>*</modifier></type><name>dependency</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DependencyDefinition</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* keep track of all pg_shdepend records as dependency definitions */</comment>
		<expr_stmt><expr><name><name>dependency</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>DependencyPgShDepend</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dependency</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>pg_shdepend</name></name> <operator>=</operator> <operator>*</operator><name>pg_shdepend</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>dependenyDefinitionList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>dependenyDefinitionList</name></expr></argument>, <argument><expr><name>dependency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>shdepScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>shdepRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>dependenyDefinitionList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * InitObjectAddressCollector takes a pointer to an already allocated (possibly stack)
 * ObjectAddressCollector struct. It makes sure this struct is ready to be used for object
 * collection.
 *
 * If an already initialized collector is passed the collector will be cleared from its
 * contents to be reused.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>InitObjectAddressCollector</name><parameter_list>(<parameter><decl><type><name>ObjectAddressCollector</name> <modifier>*</modifier></type><name>collector</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>assert_valid_hash_key3</name><argument_list>(<argument><expr><name>ObjectAddress</name></expr></argument>, <argument><expr><name>classId</name></expr></argument>, <argument><expr><name>objectId</name></expr></argument>, <argument><expr><name>objectSubId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>collector</name><operator>-&gt;</operator><name>dependencySet</name></name> <operator>=</operator> <call><name>CreateSimpleHashSetWithName</name><argument_list>(<argument><expr><name>ObjectAddress</name></expr></argument>,
														   <argument><expr><literal type="string">"dependency set"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>collector</name><operator>-&gt;</operator><name>dependencyList</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>collector</name><operator>-&gt;</operator><name>visitedObjects</name></name> <operator>=</operator> <call><name>CreateSimpleHashSetWithName</name><argument_list>(<argument><expr><name>ObjectAddress</name></expr></argument>,
															<argument><expr><literal type="string">"visited object set"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * TargetObjectVisited returns true if the input target has been visited while
 * traversing pg_depend.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>TargetObjectVisited</name><parameter_list>(<parameter><decl><type><name>ObjectAddressCollector</name> <modifier>*</modifier></type><name>collector</name></decl></parameter>, <parameter><decl><type><name>ObjectAddress</name></type> <name>target</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* find in set */</comment>
	<expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name><name>collector</name><operator>-&gt;</operator><name>visitedObjects</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>target</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>found</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * MarkObjectVisited marks the object as visited during the traversal of
 * pg_depend.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>MarkObjectVisited</name><parameter_list>(<parameter><decl><type><name>ObjectAddressCollector</name> <modifier>*</modifier></type><name>collector</name></decl></parameter>, <parameter><decl><type><name>ObjectAddress</name></type> <name>target</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* add to set */</comment>
	<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>address</name> <init>= <expr><operator>(</operator><name>ObjectAddress</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>collector</name><operator>-&gt;</operator><name>visitedObjects</name></name></expr></argument>,
														   <argument><expr><operator>&amp;</operator><name>target</name></expr></argument>,
														   <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* copy object address in */</comment>
		<expr_stmt><expr><operator>*</operator><name>address</name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CollectObjectAddress adds an ObjectAddress to the collector.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CollectObjectAddress</name><parameter_list>(<parameter><decl><type><name>ObjectAddressCollector</name> <modifier>*</modifier></type><name>collector</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>collect</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* add to set */</comment>
	<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>address</name> <init>= <expr><operator>(</operator><name>ObjectAddress</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>collector</name><operator>-&gt;</operator><name>dependencySet</name></name></expr></argument>,
														   <argument><expr><name>collect</name></expr></argument>,
														   <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* copy object address in */</comment>
		<expr_stmt><expr><operator>*</operator><name>address</name> <operator>=</operator> <operator>*</operator><name>collect</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* add to list*/</comment>
	<expr_stmt><expr><name><name>collector</name><operator>-&gt;</operator><name>dependencyList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>collector</name><operator>-&gt;</operator><name>dependencyList</name></name></expr></argument>, <argument><expr><name>address</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * IsObjectAddressCollected is a helper function that can check if an ObjectAddress is
 * already in a (unsorted) list of ObjectAddresses
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsObjectAddressCollected</name><parameter_list>(<parameter><decl><type><name>ObjectAddress</name></type> <name>findAddress</name></decl></parameter>,
						 <parameter><decl><type><name>ObjectAddressCollector</name> <modifier>*</modifier></type><name>collector</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* add to set */</comment>
	<expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name><name>collector</name><operator>-&gt;</operator><name>dependencySet</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>findAddress</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>found</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SupportedDependencyByCitus returns whether citus has support to distribute the object
 * addressed.
 */</comment>
<function><type><name>bool</name></type>
<name>SupportedDependencyByCitus</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>address</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>EnableMetadataSync</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If the user has disabled object propagation we need to fall back to the legacy
		 * behaviour in which we only support schema creation
		 */</comment>
		<switch>switch <condition>(<expr><call><name>getObjectClass</name><argument_list>(<argument><expr><name>address</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>OCLASS_SCHEMA</name></expr>:</case>
			<block>{<block_content>
				<return>return <expr><operator>!</operator><call><name>isTempNamespace</name><argument_list>(<argument><expr><name><name>address</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block>

			<default>default:</default>
			<block>{<block_content>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block>
		</block_content>}</block></switch>

		<comment type="block">/* should be unreachable */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * looking at the type of a object to see if we know how to create the object on the
	 * workers.
	 */</comment>
	<switch>switch <condition>(<expr><call><name>getObjectClass</name><argument_list>(<argument><expr><name>address</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>OCLASS_AM</name></expr>:</case>
		<block>{<block_content>
			<comment type="block">/*
			 * Only support access methods if they came from extensions
			 * During the dependency resolution it will cascade into the extension and
			 * distributed that one instead of the Access Method. Now access methods can
			 * be configured on tables on the workers.
			 */</comment>
			<return>return <expr><call><name>IsObjectAddressOwnedByExtension</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>OCLASS_CONSTRAINT</name></expr>:</case>
		<block>{<block_content>
			<comment type="block">/*
			 * Constraints are only supported when on domain types. Other constraints have
			 * their typid set to InvalidOid.
			 */</comment>
			<return>return <expr><call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>get_constraint_typid</name><argument_list>(<argument><expr><name><name>address</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>OCLASS_COLLATION</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>OCLASS_SCHEMA</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><operator>!</operator><call><name>isTempNamespace</name><argument_list>(<argument><expr><name><name>address</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>OCLASS_PROC</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>OCLASS_DATABASE</name></expr>:</case>
		<block>{<block_content>
			<comment type="block">/* only to propagate its owner */</comment>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>OCLASS_FOREIGN_SERVER</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>OCLASS_ROLE</name></expr>:</case>
		<block>{<block_content>
			<comment type="block">/* if it is a reserved role do not propagate */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>IsReservedName</name><argument_list>(<argument><expr><call><name>GetUserNameFromId</name><argument_list>(<argument><expr><name><name>address</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>OCLASS_EXTENSION</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>OCLASS_TSCONFIG</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>OCLASS_TSDICT</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>OCLASS_TYPE</name></expr>:</case>
		<block>{<block_content>
			<switch>switch <condition>(<expr><call><name>get_typtype</name><argument_list>(<argument><expr><name><name>address</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>TYPTYPE_ENUM</name></expr>:</case>
				<case>case <expr><name>TYPTYPE_COMPOSITE</name></expr>:</case>
				<case>case <expr><name>TYPTYPE_DOMAIN</name></expr>:</case>
				<block>{<block_content>
					<return>return <expr><name>true</name></expr>;</return>
				</block_content>}</block>

				<case>case <expr><name>TYPTYPE_BASE</name></expr>:</case>
				<block>{<block_content>
					<comment type="block">/*
					 * array types should be followed but not created, as they get created
					 * by the original type.
					 */</comment>
					<return>return <expr><call><name>type_is_array</name><argument_list>(<argument><expr><name><name>address</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</return>
				</block_content>}</block>

				<default>default:</default>
				<block>{<block_content>
					<comment type="block">/* type not supported */</comment>
					<return>return <expr><name>false</name></expr>;</return>
				</block_content>}</block>
			</block_content>}</block></switch>

			<comment type="block">/*
			 * should be unreachable, break here is to make sure the function has a path
			 * without return, instead of falling through to the next block */</comment>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>OCLASS_CLASS</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type> <name>relKind</name> <init>= <expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name><name>address</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * composite types have a reference to a relation of composite type, we need
			 * to follow those to get the dependencies of type fields.
			 *
			 * As we also handle tables as objects as well, follow dependencies
			 * for tables.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>relKind</name> <operator>==</operator> <name>RELKIND_COMPOSITE_TYPE</name> <operator>||</operator>
				<name>relKind</name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
				<name>relKind</name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>||</operator>
				<name>relKind</name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>||</operator>
				<name>relKind</name> <operator>==</operator> <name>RELKIND_SEQUENCE</name> <operator>||</operator>
				<name>relKind</name> <operator>==</operator> <name>RELKIND_INDEX</name> <operator>||</operator>
				<name>relKind</name> <operator>==</operator> <name>RELKIND_PARTITIONED_INDEX</name> <operator>||</operator>
				<name>relKind</name> <operator>==</operator> <name>RELKIND_VIEW</name></expr>)</condition>
			<block>{<block_content>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block>

		<default>default:</default>
		<block>{<block_content>
			<comment type="block">/* unsupported type */</comment>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block>
	</block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
 * ErrorOrWarnIfObjectHasUnsupportedDependency returns false without throwing any message if
 * object doesn't have any unsupported dependency, else throws a message with proper level
 * (except the cluster doesn't have any node) and return true.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ErrorOrWarnIfObjectHasUnsupportedDependency</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>objectAddress</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DeferredErrorMessage</name> <modifier>*</modifier></type><name>errMsg</name> <init>= <expr><call><name>DeferErrorIfHasUnsupportedDependency</name><argument_list>(<argument><expr><name>objectAddress</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>errMsg</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Don't need to give any messages if there is no worker nodes in
		 * the cluster as user's experience won't be affected on the single node even
		 * if the object won't be distributed.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HasAnyNodes</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Since Citus drops and recreates some object while converting a table type
		 * giving a DEBUG1 message is enough if the process in table type conversion
		 * function call
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>InTableTypeConversionFunctionCall</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>RaiseDeferredError</name><argument_list>(<argument><expr><name>errMsg</name></expr></argument>, <argument><expr><name>DEBUG1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<comment type="block">/*
		 * If the view is object distributed, we should provide an error to not have
		 * different definition of object on coordinator and worker nodes. If the object
		 * is not distributed yet, we can create it locally to not affect user's local
		 * usage experience.
		 */</comment>
		<if type="elseif">else if <condition>(<expr><call><name>IsAnyObjectDistributed</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><operator>(</operator><name>ObjectAddress</name> <operator>*</operator><operator>)</operator> <name>objectAddress</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>RaiseDeferredError</name><argument_list>(<argument><expr><name>errMsg</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>EnableUnsupportedFeatureMessages</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>RaiseDeferredError</name><argument_list>(<argument><expr><name>errMsg</name></expr></argument>, <argument><expr><name>WARNING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ErrorOrWarnIfAnyObjectHasUnsupportedDependency iteratively calls
 * ErrorOrWarnIfObjectHasUnsupportedDependency for given addresses.
 */</comment>
<function><type><name>bool</name></type>
<name>ErrorOrWarnIfAnyObjectHasUnsupportedDependency</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>objectAddresses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>objectAddress</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>objectAddress</argument>, <argument>objectAddresses</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>ErrorOrWarnIfObjectHasUnsupportedDependency</name><argument_list>(<argument><expr><name>objectAddress</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DeferErrorIfHasUnsupportedDependency returns deferred error message if the given
 * object has any undistributable dependency.
 */</comment>
<function><type><specifier>static</specifier> <name>DeferredErrorMessage</name> <modifier>*</modifier></type>
<name>DeferErrorIfHasUnsupportedDependency</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>objectAddress</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>undistributableDependency</name> <init>= <expr><call><name>GetUndistributableDependency</name><argument_list>(
		<argument><expr><name>objectAddress</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>undistributableDependency</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>objectDescription</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dependencyDescription</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>errorInfo</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>detailInfo</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <name>PG_VERSION_14</name></expr></cpp:if>
	<expr_stmt><expr><name>objectDescription</name> <operator>=</operator> <call><name>getObjectDescription</name><argument_list>(<argument><expr><name>objectAddress</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dependencyDescription</name> <operator>=</operator> <call><name>getObjectDescription</name><argument_list>(<argument><expr><name>undistributableDependency</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>objectDescription</name> <operator>=</operator> <call><name>getObjectDescription</name><argument_list>(<argument><expr><name>objectAddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dependencyDescription</name> <operator>=</operator> <call><name>getObjectDescription</name><argument_list>(<argument><expr><name>undistributableDependency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * We expect callers to interpret the error returned from this function
	 * as a warning if the object itself is just being created. In that case,
	 * we expect them to report below error detail as well to indicate that
	 * object itself will not be propagated but will still be created locally.
	 *
	 * Otherwise, callers are expected to throw the error returned from this
	 * function as a hard one by ignoring the detail part.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsAnyObjectDistributed</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><operator>(</operator><name>ObjectAddress</name> <operator>*</operator><operator>)</operator> <name>objectAddress</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>detailInfo</name></expr></argument>, <argument><expr><literal type="string">"\"%s\" will be created only locally"</literal></expr></argument>,
						 <argument><expr><name>objectDescription</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>SupportedDependencyByCitus</name><argument_list>(<argument><expr><name>undistributableDependency</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>StringInfo</name></type> <name>hintInfo</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>errorInfo</name></expr></argument>, <argument><expr><literal type="string">"\"%s\" has dependency to \"%s\" that is not in "</literal>
									<literal type="string">"Citus' metadata"</literal></expr></argument>,
						 <argument><expr><name>objectDescription</name></expr></argument>,
						 <argument><expr><name>dependencyDescription</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsAnyObjectDistributed</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><operator>(</operator><name>ObjectAddress</name> <operator>*</operator><operator>)</operator> <name>objectAddress</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>hintInfo</name></expr></argument>,
							 <argument><expr><literal type="string">"Distribute \"%s\" first to modify \"%s\" on worker nodes"</literal></expr></argument>,
							 <argument><expr><name>dependencyDescription</name></expr></argument>,
							 <argument><expr><name>objectDescription</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>hintInfo</name></expr></argument>, <argument><expr><literal type="string">"Distribute \"%s\" first to distribute \"%s\""</literal></expr></argument>,
							 <argument><expr><name>dependencyDescription</name></expr></argument>,
							 <argument><expr><name>objectDescription</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
							 <argument><expr><name><name>errorInfo</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>detailInfo</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>hintInfo</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>errorInfo</name></expr></argument>, <argument><expr><literal type="string">"\"%s\" has dependency on unsupported "</literal>
								<literal type="string">"object \"%s\""</literal></expr></argument>, <argument><expr><name>objectDescription</name></expr></argument>,
					 <argument><expr><name>dependencyDescription</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
						 <argument><expr><name><name>errorInfo</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>detailInfo</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DeferErrorIfAnyObjectHasUnsupportedDependency iteratively calls
 * DeferErrorIfHasUnsupportedDependency for given addresses.
 */</comment>
<function><type><name>DeferredErrorMessage</name> <modifier>*</modifier></type>
<name>DeferErrorIfAnyObjectHasUnsupportedDependency</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>objectAddresses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DeferredErrorMessage</name> <modifier>*</modifier></type><name>deferredErrorMessage</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>objectAddress</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>objectAddress</argument>, <argument>objectAddresses</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>deferredErrorMessage</name> <operator>=</operator> <call><name>DeferErrorIfHasUnsupportedDependency</name><argument_list>(<argument><expr><name>objectAddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>deferredErrorMessage</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>deferredErrorMessage</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetUndistributableDependency checks whether object has any non-distributable
 * dependency. If any one found, it will be returned.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type>
<name>GetUndistributableDependency</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>objectAddress</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>dependencies</name> <init>= <expr><call><name>GetAllDependenciesForObject</name><argument_list>(<argument><expr><name>objectAddress</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>dependency</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Users can disable metadata sync by their own risk. If it is disabled, Citus
	 * doesn't propagate dependencies. So, if it is disabled, there is no undistributable
	 * dependency.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>EnableMetadataSync</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<macro><name>foreach_ptr</name><argument_list>(<argument>dependency</argument>, <argument>dependencies</argument>)</argument_list></macro>
	<block>{<block_content>
		<comment type="block">/*
		 * Objects with the id smaller than FirstNormalObjectId should be created within
		 * initdb. Citus needs to have such objects as distributed, so we can not add
		 * such check to dependency resolution logic. Though, Citus shouldn't error
		 * out if such dependency is not supported. So, skip them here.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>dependency</name><operator>-&gt;</operator><name>objectId</name></name> <operator>&lt;</operator> <name>FirstNormalObjectId</name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If object is distributed already, ignore it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsAnyObjectDistributed</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>dependency</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If the dependency is not supported with Citus, return the dependency.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SupportedDependencyByCitus</name><argument_list>(<argument><expr><name>dependency</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Skip roles and text search templates.
			 *
			 * Roles should be handled manually with Citus community whereas text search
			 * templates should be handled manually in both community and enterprise
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>getObjectClass</name><argument_list>(<argument><expr><name>dependency</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>OCLASS_ROLE</name> <operator>&amp;&amp;</operator>
				<call><name>getObjectClass</name><argument_list>(<argument><expr><name>dependency</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>OCLASS_TSTEMPLATE</name></expr>)</condition>
			<block>{<block_content>
				<return>return <expr><name>dependency</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>getObjectClass</name><argument_list>(<argument><expr><name>dependency</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>OCLASS_CLASS</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type> <name>relKind</name> <init>= <expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name><name>dependency</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>relKind</name> <operator>==</operator> <name>RELKIND_SEQUENCE</name> <operator>||</operator>
				<name>relKind</name> <operator>==</operator> <name>RELKIND_COMPOSITE_TYPE</name> <operator>||</operator>
				<name>relKind</name> <operator>==</operator> <name>RELKIND_VIEW</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* citus knows how to auto-distribute these dependencies */</comment>
				<continue>continue;</continue>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>relKind</name> <operator>==</operator> <name>RELKIND_INDEX</name> <operator>||</operator> <name>relKind</name> <operator>==</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Indexes are only qualified for distributed objects for dependency
				 * tracking purposes, so we can ignore those.
				 */</comment>
				<continue>continue;</continue>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * Citus doesn't know how to auto-distribute the rest of the RELKINDs
				 * via dependency resolution
				 */</comment>
				<return>return <expr><name>dependency</name></expr>;</return>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsTableOwnedByExtension returns whether the table with the given relation ID is
 * owned by an extension.
 */</comment>
<function><type><name>bool</name></type>
<name>IsTableOwnedByExtension</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>tableAddress</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>tableAddress</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>IsObjectAddressOwnedByExtension</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tableAddress</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ObjectAddressDependsOnExtension returns whether or not the object depends
 * on an extension. It is assumed that "an object having a dependency of type
 * DEPENDENCY_AUTO_EXTENSION to an extension" depends on that extension.
 */</comment>
<function><type><name>bool</name></type>
<name>ObjectAddressDependsOnExtension</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>target</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>ObjectAddressHasExtensionDependency</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
											   <argument><expr><name>DEPENDENCY_AUTO_EXTENSION</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsObjectAddressOwnedByExtension returns whether or not the object is owned by an
 * extension. It is assumed that an object having a dependency on an extension is created
 * by that extension and therefore owned by that extension.
 *
 * If extensionAddress is not set to a NULL pointer the function will write the extension
 * address this function depends on into this location.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsObjectAddressOwnedByExtension</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
								<parameter><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>extensionAddress</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>ObjectAddressHasExtensionDependency</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>extensionAddress</name></expr></argument>,
											   <argument><expr><name>DEPENDENCY_EXTENSION</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ObjectAddressHasExtensionDependency is a helper function that returns true if
 * given object has a dependency record (of type DEPENDENCY_EXTENSION or
 * DEPENDENCY_AUTO_EXTENSION) for an extension.
 *
 * If extensionAddress is not set to a NULL pointer the function will write the
 * extension address this function depends on into this location.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ObjectAddressHasExtensionDependency</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
									<parameter><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>extensionAddress</name></decl></parameter>,
									<parameter><decl><type><name>int</name></type> <name>extensionDependency</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>extensionDependency</name> <operator>==</operator> <name>DEPENDENCY_EXTENSION</name> <operator>||</operator>
		   <name>extensionDependency</name> <operator>==</operator> <name>DEPENDENCY_AUTO_EXTENSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>depTup</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>depRel</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>DependRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* scan pg_depend for classid = $1 AND objid = $2 using pg_depend_depender_index */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_pg_depend_classid</name></expr></argument>, <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>classId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_pg_depend_objid</name></expr></argument>, <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>depScan</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(<argument><expr><name>depRel</name></expr></argument>, <argument><expr><name>DependDependerIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>,
											 <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>depTup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>depScan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_depend</name></type> <name>pg_depend</name> <init>= <expr><operator>(</operator><name>Form_pg_depend</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>depTup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>pg_depend</name><operator>-&gt;</operator><name>deptype</name></name> <operator>==</operator> <name>extensionDependency</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>extensionAddress</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ObjectAddressSubSet</name><argument_list>(<argument><expr><operator>*</operator><name>extensionAddress</name></expr></argument>, <argument><expr><name><name>pg_depend</name><operator>-&gt;</operator><name>refclassid</name></name></expr></argument>,
									<argument><expr><name><name>pg_depend</name><operator>-&gt;</operator><name>refobjid</name></name></expr></argument>, <argument><expr><name><name>pg_depend</name><operator>-&gt;</operator><name>refobjsubid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>depScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>depRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsAnyObjectAddressOwnedByExtension iteratively calls IsObjectAddressOwnedByExtension
 * for given addresses to determine if any address is owned by an extension.
 */</comment>
<function><type><name>bool</name></type>
<name>IsAnyObjectAddressOwnedByExtension</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>targets</name></decl></parameter>,
								   <parameter><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>extensionAddress</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>target</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>target</argument>, <argument>targets</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IsObjectAddressOwnedByExtension</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>extensionAddress</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsObjectAddressOwnedByCitus returns true if the given object address
 * is owned by the citus or citus_columnar extensions.
 */</comment>
<function><type><name>bool</name></type>
<name>IsObjectAddressOwnedByCitus</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>objectAddress</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>citusId</name> <init>= <expr><call><name>get_extension_oid</name><argument_list>(<argument><expr><literal type="string">"citus"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>citusColumnarId</name> <init>= <expr><call><name>get_extension_oid</name><argument_list>(<argument><expr><literal type="string">"citus_columnar"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* return false because we could not find any citus extension */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>citusId</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>citusColumnarId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>extObjectAddress</name> <init>= <expr><name>InvalidObjectAddress</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>ownedByExt</name> <init>= <expr><call><name>IsObjectAddressOwnedByExtension</name><argument_list>(<argument><expr><name>objectAddress</name></expr></argument>,
													  <argument><expr><operator>&amp;</operator><name>extObjectAddress</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ownedByExt</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>ownedByCitus</name> <init>= <expr><name><name>extObjectAddress</name><operator>.</operator><name>objectId</name></name> <operator>==</operator> <name>citusId</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>ownedByCitusColumnar</name> <init>= <expr><name><name>extObjectAddress</name><operator>.</operator><name>objectId</name></name> <operator>==</operator> <name>citusColumnarId</name></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>ownedByCitus</name> <operator>||</operator> <name>ownedByCitusColumnar</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FollowNewSupportedDependencies applies filters on pg_depend entries to follow all
 * objects which should be distributed before the root object can safely be created.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>FollowNewSupportedDependencies</name><parameter_list>(<parameter><decl><type><name>ObjectAddressCollector</name> <modifier>*</modifier></type><name>collector</name></decl></parameter>,
							   <parameter><decl><type><name>DependencyDefinition</name> <modifier>*</modifier></type><name>definition</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>definition</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>DependencyPgDepend</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 *  For dependencies found in pg_depend:
		 *
		 *  Follow only normal and extension dependencies. The latter is used to reach the
		 *  extensions, the objects that directly depend on the extension are eliminated
		 *  during the "apply" phase.
		 *
		 *  Other dependencies are internal dependencies and managed by postgres.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>definition</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>pg_depend</name><operator>.</operator><name>deptype</name></name> <operator>!=</operator> <name>DEPENDENCY_NORMAL</name> <operator>&amp;&amp;</operator>
			<name><name>definition</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>pg_depend</name><operator>.</operator><name>deptype</name></name> <operator>!=</operator> <name>DEPENDENCY_EXTENSION</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* rest of the tests are to see if we want to follow the actual dependency */</comment>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name> <init>= <expr><call><name>DependencyDefinitionObjectAddress</name><argument_list>(<argument><expr><name>definition</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the object is already in our dependency list we do not have to follow any
	 * further
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsObjectAddressCollected</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>collector</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the object is already distributed it is not a `new` object that needs to be
	 * distributed before we create a dependent object
	 */</comment>
	<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>copyAddress</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ObjectAddress</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><operator>*</operator><name>copyAddress</name> <operator>=</operator> <name>address</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsAnyObjectDistributed</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>copyAddress</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We can only distribute dependencies that citus knows how to distribute.
	 *
	 * But we don't want to bail out if the object is owned by extension, because
	 * Citus can create the extension.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SupportedDependencyByCitus</name><argument_list>(<argument><expr><operator>&amp;</operator><name>address</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>IsObjectAddressOwnedByExtension</name><argument_list>(<argument><expr><operator>&amp;</operator><name>address</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CitusExtensionObject</name><argument_list>(<argument><expr><operator>&amp;</operator><name>address</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* following citus extension could complicate role management */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FollowAllSupportedDependencies applies filters on pg_depend entries to follow the
 * dependency tree of objects in depth first order. We will visit all supported objects.
 * This is used to sort a list of dependencies in dependency order.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>FollowAllSupportedDependencies</name><parameter_list>(<parameter><decl><type><name>ObjectAddressCollector</name> <modifier>*</modifier></type><name>collector</name></decl></parameter>,
							   <parameter><decl><type><name>DependencyDefinition</name> <modifier>*</modifier></type><name>definition</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>definition</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>DependencyPgDepend</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 *  For dependencies found in pg_depend:
		 *
		 *  Follow only normal and extension dependencies. The latter is used to reach the
		 *  extensions, the objects that directly depend on the extension are eliminated
		 *  during the "apply" phase.
		 *
		 *  Other dependencies are internal dependencies and managed by postgres.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>definition</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>pg_depend</name><operator>.</operator><name>deptype</name></name> <operator>!=</operator> <name>DEPENDENCY_NORMAL</name> <operator>&amp;&amp;</operator>
			<name><name>definition</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>pg_depend</name><operator>.</operator><name>deptype</name></name> <operator>!=</operator> <name>DEPENDENCY_EXTENSION</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* rest of the tests are to see if we want to follow the actual dependency */</comment>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name> <init>= <expr><call><name>DependencyDefinitionObjectAddress</name><argument_list>(<argument><expr><name>definition</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the object is already in our dependency list we do not have to follow any
	 * further
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsObjectAddressCollected</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>collector</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We can only distribute dependencies that citus knows how to distribute.
	 *
	 * But we don't want to bail out if the object is owned by extension, because
	 * Citus can create the extension.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SupportedDependencyByCitus</name><argument_list>(<argument><expr><operator>&amp;</operator><name>address</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>IsObjectAddressOwnedByExtension</name><argument_list>(<argument><expr><operator>&amp;</operator><name>address</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CitusExtensionObject</name><argument_list>(<argument><expr><operator>&amp;</operator><name>address</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* following citus extension could complicate role management */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FollowAllDependencies applies filters on pg_depend entries to follow the dependency
 * tree of objects in depth first order. We will visit all objects irrespective of it is
 * supported by Citus or not.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>FollowAllDependencies</name><parameter_list>(<parameter><decl><type><name>ObjectAddressCollector</name> <modifier>*</modifier></type><name>collector</name></decl></parameter>,
					  <parameter><decl><type><name>DependencyDefinition</name> <modifier>*</modifier></type><name>definition</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>definition</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>DependencyPgDepend</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 *  For dependencies found in pg_depend:
		 *
		 *  Follow only normal and extension dependencies. The latter is used to reach the
		 *  extensions, the objects that directly depend on the extension are eliminated
		 *  during the "apply" phase.
		 *
		 *  Other dependencies are internal dependencies and managed by postgres.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>definition</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>pg_depend</name><operator>.</operator><name>deptype</name></name> <operator>!=</operator> <name>DEPENDENCY_NORMAL</name> <operator>&amp;&amp;</operator>
			<name><name>definition</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>pg_depend</name><operator>.</operator><name>deptype</name></name> <operator>!=</operator> <name>DEPENDENCY_EXTENSION</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* rest of the tests are to see if we want to follow the actual dependency */</comment>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name> <init>= <expr><call><name>DependencyDefinitionObjectAddress</name><argument_list>(<argument><expr><name>definition</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the object is already in our dependency list we do not have to follow any
	 * further
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsObjectAddressCollected</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>collector</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CitusExtensionObject</name><argument_list>(<argument><expr><operator>&amp;</operator><name>address</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* following citus extension could complicate role management */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FollowExtAndInternalDependencies applies filters on pg_depend entries to follow
 * the dependency tree of objects in depth first order. We will visit all objects
 * irrespective of it is supported by Citus or not and it is internal or not.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>FollowExtAndInternalDependencies</name><parameter_list>(<parameter><decl><type><name>ObjectAddressCollector</name> <modifier>*</modifier></type><name>collector</name></decl></parameter>,
								 <parameter><decl><type><name>DependencyDefinition</name> <modifier>*</modifier></type><name>definition</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name> <init>= <expr><call><name>DependencyDefinitionObjectAddress</name><argument_list>(<argument><expr><name>definition</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the object is already in our dependency list we do not have to follow any
	 * further
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsObjectAddressCollected</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>collector</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CitusExtensionObject</name><argument_list>(<argument><expr><operator>&amp;</operator><name>address</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We do not need to follow citus extension because the purpose
		 * of our walk is to find if an object is owned by citus.
		 */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ApplyAddToDependencyList is an apply function for RecurseObjectDependencies that will
 * collect all the ObjectAddresses for pg_depend entries to the context, except it is
 * extension owned one.
 *
 * The context here is assumed to be a (ObjectAddressCollector *) to the location where
 * all ObjectAddresses will be collected.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ApplyAddToDependencyList</name><parameter_list>(<parameter><decl><type><name>ObjectAddressCollector</name> <modifier>*</modifier></type><name>collector</name></decl></parameter>,
						 <parameter><decl><type><name>DependencyDefinition</name> <modifier>*</modifier></type><name>definition</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name> <init>= <expr><call><name>DependencyDefinitionObjectAddress</name><argument_list>(<argument><expr><name>definition</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Objects owned by an extension are assumed to be created on the workers by creating
	 * the extension in the cluster, we we don't want explicitly create them.
	 *
	 * Since we do need to capture the extension as a dependency we are following the
	 * object instead of breaking the traversal there.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsObjectAddressOwnedByExtension</name><argument_list>(<argument><expr><operator>&amp;</operator><name>address</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>CollectObjectAddress</name><argument_list>(<argument><expr><name>collector</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>address</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ApplyAddCitusDependedObjectsToDependencyList is an apply function for
 * RecurseObjectDependencies that will collect all the ObjectAddresses for
 * pg_depend entries to the context if it is citus extension owned one.
 *
 * The context here is assumed to be a (ObjectAddressCollector *) to the location where
 * all ObjectAddresses will be collected.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ApplyAddCitusDependedObjectsToDependencyList</name><parameter_list>(<parameter><decl><type><name>ObjectAddressCollector</name> <modifier>*</modifier></type><name>collector</name></decl></parameter>,
											 <parameter><decl><type><name>DependencyDefinition</name> <modifier>*</modifier></type><name>definition</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name> <init>= <expr><call><name>DependencyDefinitionObjectAddress</name><argument_list>(<argument><expr><name>definition</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We only collect the object if it is owned by citus extension.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsObjectAddressOwnedByCitus</name><argument_list>(<argument><expr><operator>&amp;</operator><name>address</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CollectObjectAddress</name><argument_list>(<argument><expr><name>collector</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>address</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ExpandCitusSupportedTypes base on supported types by citus we might want to expand
 * the list of objects to visit in pg_depend.
 *
 * An example where we want to expand is for types. Their dependencies are not captured
 * with an entry in pg_depend from their object address, but by the object address of the
 * relation describing the type.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>ExpandCitusSupportedTypes</name><parameter_list>(<parameter><decl><type><name>ObjectAddressCollector</name> <modifier>*</modifier></type><name>collector</name></decl></parameter>, <parameter><decl><type><name>ObjectAddress</name></type> <name>target</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>target</name><operator>.</operator><name>classId</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>AuthIdRelationId</name></expr>:</case>
		<block>{<block_content>
			<comment type="block">/*
			 * Roles are members of other roles. These relations are not recorded directly
			 * but can be deduced from pg_auth_members
			 */</comment>
			<return>return <expr><call><name>ExpandRolesToGroups</name><argument_list>(<argument><expr><name><name>target</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>ExtensionRelationId</name></expr>:</case>
		<block>{<block_content>
			<comment type="block">/*
			 * FDWs get propagated along with the extensions they belong to.
			 * In case there are GRANTed privileges on FDWs to roles, those
			 * GRANT statements will be propagated to. In order to make sure
			 * that those GRANT statements work, the privileged roles should
			 * exist on the worker nodes. Hence, here we find these dependent
			 * roles and add them as dependencies.
			 */</comment>

			<decl_stmt><decl><type><name>Oid</name></type> <name>extensionId</name> <init>= <expr><name><name>target</name><operator>.</operator><name>objectId</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>FDWOids</name> <init>= <expr><call><name>GetDependentFDWsToExtension</name><argument_list>(<argument><expr><name>extensionId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>Oid</name></type> <name>FDWOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
			<macro><name>foreach_oid</name><argument_list>(<argument>FDWOid</argument>, <argument>FDWOids</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>dependentRoleIds</name> <init>= <expr><call><name>GetDependentRoleIdsFDW</name><argument_list>(<argument><expr><name>FDWOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>dependencies</name> <init>=
					<expr><call><name>CreateObjectAddressDependencyDefList</name><argument_list>(<argument><expr><name>AuthIdRelationId</name></expr></argument>,
														 <argument><expr><name>dependentRoleIds</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>dependencies</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>

			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>TypeRelationId</name></expr>:</case>
		<block>{<block_content>
			<switch>switch <condition>(<expr><call><name>get_typtype</name><argument_list>(<argument><expr><name><name>target</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * types depending on other types are not captured in pg_depend, instead
				 * they are described with their dependencies by the relation that
				 * describes the composite type.
				 */</comment>
				<case>case <expr><name>TYPTYPE_COMPOSITE</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Oid</name></type> <name>typeRelationId</name> <init>= <expr><call><name>get_typ_typrelid</name><argument_list>(<argument><expr><name><name>target</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>DependencyDefinition</name> <modifier>*</modifier></type><name>dependency</name> <init>=
						<expr><call><name>CreateObjectAddressDependencyDef</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
														 <argument><expr><name>typeRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>dependency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block>

				<comment type="block">/*
				 * Domains can have constraints associated with them. Constraints themself
				 * can depend on things like functions. To support the propagation of
				 * these functions we will add the constraints to the list of objects to
				 * be created.
				 */</comment>
				<case>case <expr><name>TYPTYPE_DOMAIN</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>dependencies</name> <init>=
						<expr><call><name>GetTypeConstraintDependencyDefinition</name><argument_list>(<argument><expr><name><name>target</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>dependencies</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block>
			</block_content>}</block></switch>

			<comment type="block">/*
			 * array types don't have a normal dependency on their element type, instead
			 * their dependency is an internal one. We can't follow interal dependencies
			 * as that would cause a cyclic dependency on others, instead we expand here
			 * to follow the dependency on the element type.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>type_is_array</name><argument_list>(<argument><expr><name><name>target</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type> <name>typeId</name> <init>= <expr><call><name>get_element_type</name><argument_list>(<argument><expr><name><name>target</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>DependencyDefinition</name> <modifier>*</modifier></type><name>dependency</name> <init>=
					<expr><call><name>CreateObjectAddressDependencyDef</name><argument_list>(<argument><expr><name>TypeRelationId</name></expr></argument>, <argument><expr><name>typeId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>dependency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>RelationRelationId</name></expr>:</case>
		<block>{<block_content>
			<comment type="block">/*
			 * Triggers both depend to the relations and to the functions they
			 * execute. Also, pg_depend records dependencies from triggers to the
			 * functions but not from relations to their triggers. Given above two,
			 * we directly expand depencies for the relations to trigger functions.
			 * That way, we won't attempt to create the trigger as a dependency of
			 * the relation, which would fail as the relation itself is not created
			 * yet when ensuring dependencies.
			 */</comment>
			<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name><name>target</name><operator>.</operator><name>objectId</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>triggerFunctionDepencyList</name> <init>=
				<expr><call><name>GetRelationTriggerFunctionDependencyList</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>triggerFunctionDepencyList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Statistics' both depend to the relations and to the schemas they belong
			 * to. Also, pg_depend records dependencies from statistics to their schemas
			 * but not from relations to their statistics' schemas. Given above two,
			 * we directly expand dependencies for the relations to schemas of
			 * statistics.
			 */</comment>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>statisticsSchemaDependencyList</name> <init>=
				<expr><call><name>GetRelationStatsSchemaDependencyList</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>statisticsSchemaDependencyList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Get the dependent sequences for tables (both as serial columns and
			 * columns have nextval with existing sequences) and expand dependency list
			 * with them.
			 */</comment>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>sequenceDependencyList</name> <init>= <expr><call><name>GetRelationSequenceDependencyList</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>sequenceDependencyList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Get the dependent functions for tables as columns has default values
			 * and contraints, then expand dependency list with them.
			 */</comment>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>functionDependencyList</name> <init>= <expr><call><name>GetRelationFunctionDependencyList</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>functionDependencyList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Tables could have indexes. Indexes themself could have dependencies that
			 * need to be propagated. eg. TEXT SEARCH CONFIGURATIONS. Here we add the
			 * addresses of all indices to the list of objects to vist, as to make sure we
			 * create all objects required by the indices before we create the table
			 * including indices.
			 */</comment>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>indexDependencyList</name> <init>= <expr><call><name>GetRelationIndicesDependencyList</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>indexDependencyList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Get the dependencies of the rule for the given view. PG keeps internal
			 * dependency between view and rule. As it is stated on the PG doc, if
			 * there is an internal dependency, dependencies of the dependent object
			 * behave much like they were dependencies of the referenced object.
			 *
			 * We need to expand dependencies by including dependencies of the rule
			 * internally dependent to the view. PG doesn't keep any dependencies
			 * from view to any object, but it keeps an internal dependency to the
			 * rule and that rule has dependencies to other objects.
			 */</comment>
			<decl_stmt><decl><type><name>char</name></type> <name>relKind</name> <init>= <expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>relKind</name> <operator>==</operator> <name>RELKIND_VIEW</name> <operator>||</operator> <name>relKind</name> <operator>==</operator> <name>RELKIND_MATVIEW</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>ruleRefDepList</name> <init>= <expr><call><name>GetViewRuleReferenceDependencyList</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>ruleRefDepList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<default>default:</default>
		<block>{<block_content>
			<comment type="block">/* no expansion for unsupported types */</comment>
			<break>break;</break>
		</block_content>}</block>
	</block_content>}</block></switch>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExpandForPgVanilla only expands only comosite types because other types
 * will find their dependencies in pg_depend. The method should only be called by
 * is_citus_depended_object udf.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>ExpandForPgVanilla</name><parameter_list>(<parameter><decl><type><name>ObjectAddressCollector</name> <modifier>*</modifier></type><name>collector</name></decl></parameter>,
				   <parameter><decl><type><name>ObjectAddress</name></type> <name>target</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* should only be called if GUC is enabled */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>HideCitusDependentObjects</name> <operator>==</operator> <name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>target</name><operator>.</operator><name>classId</name></name> <operator>==</operator> <name>TypeRelationId</name> <operator>&amp;&amp;</operator> <call><name>get_typtype</name><argument_list>(<argument><expr><name><name>target</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call> <operator>==</operator>
		<name>TYPTYPE_COMPOSITE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * types depending on other types are not captured in pg_depend, instead
		 * they are described with their dependencies by the relation that
		 * describes the composite type.
		 */</comment>
		<decl_stmt><decl><type><name>Oid</name></type> <name>typeRelationId</name> <init>= <expr><call><name>get_typ_typrelid</name><argument_list>(<argument><expr><name><name>target</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DependencyDefinition</name> <modifier>*</modifier></type><name>dependency</name> <init>=
			<expr><call><name>CreateObjectAddressDependencyDef</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
											 <argument><expr><name>typeRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>dependency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetDependentRoleIdsFDW returns a list of role oids that has privileges on the
 * FDW with the given object id.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>GetDependentRoleIdsFDW</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>FDWOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>roleIds</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Acl</name> <modifier>*</modifier></type><name>aclEntry</name> <init>= <expr><call><name>GetPrivilegesForFDW</name><argument_list>(<argument><expr><name>FDWOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>aclEntry</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>AclItem</name> <modifier>*</modifier></type><name>privileges</name> <init>= <expr><call><name>ACL_DAT</name><argument_list>(<argument><expr><name>aclEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>numberOfPrivsGranted</name> <init>= <expr><call><name>ACL_NUM</name><argument_list>(<argument><expr><name>aclEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numberOfPrivsGranted</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>roleIds</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>roleIds</name></expr></argument>, <argument><expr><name><name>privileges</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ai_grantee</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>roleIds</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExpandRolesToGroups returns a list of object addresses pointing to roles that roleid
 * depends on.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>ExpandRolesToGroups</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>pgAuthMembers</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>AuthMemRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scanKey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>scanKeyCount</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* scan pg_auth_members for member = $1 via index pg_auth_members_member_role_index */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_pg_auth_members_member</name></expr></argument>, <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scanDescriptor</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pgAuthMembers</name></expr></argument>, <argument><expr><name>AuthMemMemRoleIndexId</name></expr></argument>,
													<argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>scanKeyCount</name></expr></argument>, <argument><expr><name>scanKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>roles</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_auth_members</name></type> <name>membership</name> <init>= <expr><operator>(</operator><name>Form_pg_auth_members</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>DependencyDefinition</name> <modifier>*</modifier></type><name>definition</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DependencyDefinition</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>definition</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>DependencyObjectAddress</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name><name>definition</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>address</name></name></expr></argument>, <argument><expr><name>AuthIdRelationId</name></expr></argument>, <argument><expr><name><name>membership</name><operator>-&gt;</operator><name>roleid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>roles</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>roles</name></expr></argument>, <argument><expr><name>definition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pgAuthMembers</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>roles</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetViewRuleReferenceDependencyList returns the dependencies of the view's
 * internal rule dependencies.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>GetViewRuleReferenceDependencyList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>viewId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>dependencyTupleList</name> <init>= <expr><call><name>GetPgDependTuplesForDependingObjects</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
																	 <argument><expr><name>viewId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>nonInternalDependenciesOfDependingRules</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>depTup</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>depTup</argument>, <argument>dependencyTupleList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_depend</name></type> <name>pg_depend</name> <init>= <expr><operator>(</operator><name>Form_pg_depend</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>depTup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Dependencies of the internal rule dependency should be handled as the dependency
		 * of referenced view object.
		 *
		 * PG doesn't keep dependency relation between views and dependent objects directly
		 * but it keeps an internal dependency relation between the view and the rule, then
		 * keeps the dependent objects of the view as non-internal dependencies of the
		 * internally dependent rule object.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>pg_depend</name><operator>-&gt;</operator><name>deptype</name></name> <operator>==</operator> <name>DEPENDENCY_INTERNAL</name> <operator>&amp;&amp;</operator> <name><name>pg_depend</name><operator>-&gt;</operator><name>classid</name></name> <operator>==</operator>
			<name>RewriteRelationId</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>ruleAddress</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>ruleAddress</name></expr></argument>, <argument><expr><name>RewriteRelationId</name></expr></argument>, <argument><expr><name><name>pg_depend</name><operator>-&gt;</operator><name>objid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Expand results with the noninternal dependencies of it */</comment>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>ruleDependencies</name> <init>= <expr><call><name>DependencyDefinitionFromPgDepend</name><argument_list>(<argument><expr><name>ruleAddress</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>DependencyDefinition</name> <modifier>*</modifier></type><name>dependencyDef</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<macro><name>foreach_ptr</name><argument_list>(<argument>dependencyDef</argument>, <argument>ruleDependencies</argument>)</argument_list></macro>
			<block>{<block_content>
				<comment type="block">/*
				 * Follow all dependencies of the internally dependent rule dependencies
				 * except it is an internal dependency of view itself.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>dependencyDef</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>pg_depend</name><operator>.</operator><name>deptype</name></name> <operator>==</operator> <name>DEPENDENCY_INTERNAL</name> <operator>||</operator>
					<operator>(</operator><name><name>dependencyDef</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>pg_depend</name><operator>.</operator><name>refclassid</name></name> <operator>==</operator> <name>RelationRelationId</name> <operator>&amp;&amp;</operator>
					 <name><name>dependencyDef</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>pg_depend</name><operator>.</operator><name>refobjid</name></name> <operator>==</operator> <name>viewId</name><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name>nonInternalDependenciesOfDependingRules</name> <operator>=</operator>
					<call><name>lappend</name><argument_list>(<argument><expr><name>nonInternalDependenciesOfDependingRules</name></expr></argument>, <argument><expr><name>dependencyDef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>nonInternalDependenciesOfDependingRules</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetRelationSequenceDependencyList returns the sequence dependency definition
 * list for the given relation.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>GetRelationSequenceDependencyList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>seqInfoList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>GetDependentSequencesWithRelation</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>seqInfoList</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>seqIdList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SequenceInfo</name> <modifier>*</modifier></type><name>seqInfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>seqInfo</argument>, <argument>seqInfoList</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>seqIdList</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>seqIdList</name></expr></argument>, <argument><expr><name><name>seqInfo</name><operator>-&gt;</operator><name>sequenceOid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>sequenceDependencyDefList</name> <init>=
		<expr><call><name>CreateObjectAddressDependencyDefList</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>seqIdList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>sequenceDependencyDefList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetRelationFunctionDependencyList returns the function dependency definition
 * list for the given relation.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>GetRelationFunctionDependencyList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>dependentFunctionOids</name> <init>= <expr><call><name>GetDependentFunctionsWithRelation</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>functionDependencyDefList</name> <init>=
		<expr><call><name>CreateObjectAddressDependencyDefList</name><argument_list>(<argument><expr><name>ProcedureRelationId</name></expr></argument>, <argument><expr><name>dependentFunctionOids</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>functionDependencyDefList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetRelationStatsSchemaDependencyList returns a list of DependencyDefinition
 * objects for the schemas that statistics' of the relation with relationId depends.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>GetRelationStatsSchemaDependencyList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>schemaIds</name> <init>= <expr><call><name>GetExplicitStatisticsSchemaIdList</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>CreateObjectAddressDependencyDefList</name><argument_list>(<argument><expr><name>NamespaceRelationId</name></expr></argument>, <argument><expr><name>schemaIds</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CollectIndexOids implements PGIndexProcessor to create a list of all index oids
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CollectIndexOids</name><parameter_list>(<parameter><decl><type><name>Form_pg_index</name></type> <name>formPgIndex</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>oids</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>*</operator><name>oids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><operator>*</operator><name>oids</name></expr></argument>, <argument><expr><name><name>formPgIndex</name><operator>-&gt;</operator><name>indexrelid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * GetRelationIndicesDependencyList creates a list of ObjectAddressDependencies for the
 * indexes on a given relation.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>GetRelationIndicesDependencyList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>indexIds</name> <init>= <expr><call><name>ExecuteFunctionOnEachTableIndex</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>CollectIndexOids</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>CreateObjectAddressDependencyDefList</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>indexIds</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetRelationTriggerFunctionDependencyList returns a list of DependencyDefinition
 * objects for the functions that triggers of the relation with relationId depends.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>GetRelationTriggerFunctionDependencyList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>dependencyList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>triggerIdList</name> <init>= <expr><call><name>GetExplicitTriggerIdList</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>triggerId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>triggerId</argument>, <argument>triggerIdList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>functionId</name> <init>= <expr><call><name>GetTriggerFunctionId</name><argument_list>(<argument><expr><name>triggerId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DependencyDefinition</name> <modifier>*</modifier></type><name>dependency</name> <init>=
			<expr><call><name>CreateObjectAddressDependencyDef</name><argument_list>(<argument><expr><name>ProcedureRelationId</name></expr></argument>, <argument><expr><name>functionId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>dependencyList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>dependencyList</name></expr></argument>, <argument><expr><name>dependency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>dependencyList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetTypeConstraintDependencyDefinition creates a list of constraint dependency
 * definitions for a given type
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>GetTypeConstraintDependencyDefinition</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typeId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* lookup and look all constraints to add them to the CreateDomainStmt */</comment>
	<decl_stmt><decl><type><name>Relation</name></type> <name>conRel</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Look for CHECK Constraints on this domain */</comment>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_constraint_contypid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typeId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(<argument><expr><name>conRel</name></expr></argument>, <argument><expr><name>ConstraintTypidIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
										  <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>dependencies</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>conTup</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>conTup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>c</name> <init>= <expr><operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>conTup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>contype</name></name> <operator>!=</operator> <name>CONSTRAINT_CHECK</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Ignore non-CHECK constraints, shouldn't be any */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>dependencies</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>dependencies</name></expr></argument>, <argument><expr><call><name>CreateObjectAddressDependencyDef</name><argument_list>(
								   <argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>conRel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>dependencies</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateObjectAddressDependencyDef returns DependencyDefinition object that
 * stores the ObjectAddress for the database object identified by classId and
 * objectId.
 */</comment>
<function><type><specifier>static</specifier> <name>DependencyDefinition</name> <modifier>*</modifier></type>
<name>CreateObjectAddressDependencyDef</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>classId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>objectId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DependencyDefinition</name> <modifier>*</modifier></type><name>dependency</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DependencyDefinition</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>dependency</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>DependencyObjectAddress</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name><name>dependency</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>address</name></name></expr></argument>, <argument><expr><name>classId</name></expr></argument>, <argument><expr><name>objectId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>dependency</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateObjectAddressDependencyDefList is a wrapper function for
 * CreateObjectAddressDependencyDef to operate on a list of relation oids,
 * instead of a single oid.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>CreateObjectAddressDependencyDefList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>classId</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>objectIdList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>dependencyList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>objectId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>objectId</argument>, <argument>objectIdList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DependencyDefinition</name> <modifier>*</modifier></type><name>dependency</name> <init>=
			<expr><call><name>CreateObjectAddressDependencyDef</name><argument_list>(<argument><expr><name>classId</name></expr></argument>, <argument><expr><name>objectId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>dependencyList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>dependencyList</name></expr></argument>, <argument><expr><name>dependency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>dependencyList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DependencyDefinitionObjectAddress returns the object address of the dependency defined
 * by the dependency definition, irregardless what the source of the definition is
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>DependencyDefinitionObjectAddress</name><parameter_list>(<parameter><decl><type><name>DependencyDefinition</name> <modifier>*</modifier></type><name>definition</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name><name>definition</name><operator>-&gt;</operator><name>mode</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>DependencyObjectAddress</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><name><name>definition</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>address</name></name></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>DependencyPgDepend</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>,
							 <argument><expr><name><name>definition</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>pg_depend</name><operator>.</operator><name>refclassid</name></name></expr></argument>,
							 <argument><expr><name><name>definition</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>pg_depend</name><operator>.</operator><name>refobjid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>address</name></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>DependencyPgShDepend</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>,
							 <argument><expr><name><name>definition</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>pg_shdepend</name><operator>.</operator><name>refclassid</name></name></expr></argument>,
							 <argument><expr><name><name>definition</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>pg_shdepend</name><operator>.</operator><name>refobjid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>address</name></expr>;</return>
		</block_content>}</block>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unsupported dependency definition mode"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * BuildViewDependencyGraph gets a relation (or a view) and builds a dependency graph for the
 * depending views.
 */</comment>
<function><type><specifier>static</specifier> <name>ViewDependencyNode</name> <modifier>*</modifier></type>
<name>BuildViewDependencyGraph</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>nodeMap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ViewDependencyNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>ViewDependencyNode</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>nodeMap</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>relationId</name></expr></argument>,
																  <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>node</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <name>relationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>remainingDependencyCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>dependingNodes</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>targetObjectClassId</name> <init>= <expr><name>RelationRelationId</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>targetObjectId</name> <init>= <expr><name>relationId</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>dependencyTupleList</name> <init>= <expr><call><name>GetPgDependTuplesForDependingObjects</name><argument_list>(<argument><expr><name>targetObjectClassId</name></expr></argument>,
																	 <argument><expr><name>targetObjectId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>depTup</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>depTup</argument>, <argument>dependencyTupleList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_depend</name></type> <name>pg_depend</name> <init>= <expr><operator>(</operator><name>Form_pg_depend</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>depTup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Oid</name></type> <name>dependingView</name> <init>= <expr><call><name>GetDependingView</name><argument_list>(<argument><expr><name>pg_depend</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>dependingView</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ViewDependencyNode</name> <modifier>*</modifier></type><name>dependingNode</name> <init>= <expr><call><name>BuildViewDependencyGraph</name><argument_list>(<argument><expr><name>dependingView</name></expr></argument>,
																		 <argument><expr><name>nodeMap</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>dependingNodes</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>dependingNodes</name></name></expr></argument>, <argument><expr><name>dependingNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>dependingNode</name><operator>-&gt;</operator><name>remainingDependencyCount</name></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetPgDependTuplesForDependingObjects scans pg_depend for given object and
 * returns a list of heap tuples for the objects depending on it.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>GetPgDependTuplesForDependingObjects</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>targetObjectClassId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>targetObjectId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>dependencyTupleList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>pgDepend</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>DependRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>scanKeyCount</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_pg_depend_refclassid</name></expr></argument>, <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>targetObjectClassId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_pg_depend_refobjid</name></expr></argument>, <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>targetObjectId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>useIndex</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>depScan</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pgDepend</name></expr></argument>, <argument><expr><name>DependReferenceIndexId</name></expr></argument>,
											 <argument><expr><name>useIndex</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>scanKeyCount</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>dependencyTuple</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>dependencyTuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>depScan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* copy the tuple first */</comment>
		<expr_stmt><expr><name>dependencyTuple</name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><name>dependencyTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>dependencyTupleList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>dependencyTupleList</name></expr></argument>, <argument><expr><name>dependencyTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>depScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>pgDepend</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>dependencyTupleList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetDependingViews takes a relation id, finds the views that depend on the relation
 * and returns list of the oids of those views. It recurses on the pg_depend table to
 * find the views that recursively depend on the table.
 *
 * The returned views will have the correct order for creating them, from the point of
 * dependencies between.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>GetDependingViews</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>nodeMap</name> <init>= <expr><call><name>CreateSimpleHashWithName</name><argument_list>(<argument><expr><name>Oid</name></expr></argument>, <argument><expr><name>ViewDependencyNode</name></expr></argument>,
											 <argument><expr><literal type="string">"view dependency map (oid)"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ViewDependencyNode</name> <modifier>*</modifier></type><name>tableNode</name> <init>= <expr><call><name>BuildViewDependencyGraph</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>nodeMap</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>dependingViews</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>nodeQueue</name> <init>= <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>tableNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ViewDependencyNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr_append</name><argument_list>(<argument>node</argument>, <argument>nodeQueue</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ViewDependencyNode</name> <modifier>*</modifier></type><name>dependingNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>dependingNode</argument>, <argument>node-&gt;dependingNodes</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>relationAddress</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>relationAddress</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name><name>dependingNode</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * This function does not catch views with circular dependencies,
			 * because of the remaining dependency count check below.
			 * Here we check if the view has a circular dependency or not.
			 * If yes, we error out with a message that tells the user that
			 * Citus does not handle circular dependencies.
			 */</comment>
			<decl_stmt><decl><type><name>DeferredErrorMessage</name> <modifier>*</modifier></type><name>depError</name> <init>=
				<expr><call><name>DeferErrorIfCircularDependencyExists</name><argument_list>(<argument><expr><operator>&amp;</operator><name>relationAddress</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>depError</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>RaiseDeferredError</name><argument_list>(<argument><expr><name>depError</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name><name>dependingNode</name><operator>-&gt;</operator><name>remainingDependencyCount</name></name><operator>--</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>dependingNode</name><operator>-&gt;</operator><name>remainingDependencyCount</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>nodeQueue</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>nodeQueue</name></expr></argument>, <argument><expr><name>dependingNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>dependingViews</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>dependingViews</name></expr></argument>, <argument><expr><name><name>dependingNode</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block>
	<return>return <expr><name>dependingViews</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetDependingView gets a row of pg_depend and returns the oid of the view that is depended.
 * If the depended object is not a rewrite object, the object to rewrite is not a view or it
 * is the same view with the depending one InvalidOid is returned.
 */</comment>
<function><type><name>Oid</name></type>
<name>GetDependingView</name><parameter_list>(<parameter><decl><type><name>Form_pg_depend</name></type> <name>pg_depend</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>pg_depend</name><operator>-&gt;</operator><name>classid</name></name> <operator>!=</operator> <name>RewriteRelationId</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>InvalidOid</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>rewriteRel</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>RewriteRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>rkey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rkey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_rewrite_oid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>pg_depend</name><operator>-&gt;</operator><name>objid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>rscan</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(<argument><expr><name>rewriteRel</name></expr></argument>, <argument><expr><name>RewriteOidIndexId</name></expr></argument>,
										   <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>rkey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>rewriteTup</name> <init>= <expr><call><name>systable_getnext</name><argument_list>(<argument><expr><name>rscan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>rewriteTup</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * This function already verified that objid's classid is
		 * RewriteRelationId, so it should exists. But be on the
		 * safe side.
		 */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"catalog lookup failed for view %u"</literal></expr></argument>,
							   <argument><expr><name><name>pg_depend</name><operator>-&gt;</operator><name>objid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Form_pg_rewrite</name></type> <name>pg_rewrite</name> <init>= <expr><operator>(</operator><name>Form_pg_rewrite</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>rewriteTup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>isView</name> <init>= <expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name><name>pg_rewrite</name><operator>-&gt;</operator><name>ev_class</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RELKIND_VIEW</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isMatView</name> <init>= <expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name><name>pg_rewrite</name><operator>-&gt;</operator><name>ev_class</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RELKIND_MATVIEW</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isDifferentThanRef</name> <init>= <expr><name><name>pg_rewrite</name><operator>-&gt;</operator><name>ev_class</name></name> <operator>!=</operator> <name><name>pg_depend</name><operator>-&gt;</operator><name>refobjid</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>dependingView</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>isView</name> <operator>||</operator> <name>isMatView</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>isDifferentThanRef</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>dependingView</name> <operator>=</operator> <name><name>pg_rewrite</name><operator>-&gt;</operator><name>ev_class</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>rscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rewriteRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>dependingView</name></expr>;</return>
</block_content>}</block></function>
</unit>
