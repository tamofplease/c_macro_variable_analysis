<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/citus/src/backend/distributed/metadata/metadata_cache.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * metadata_cache.c
 *	  Distributed table metadata cache
 *
 * Copyright (c) Citus Data, Inc.
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_version_constants.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_version_compat.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stdint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-fe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/nbtree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_enum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_extension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"citus_version.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/dbcommands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/extension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/backend_data.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_depended_object.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/colocation_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/connection_management.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_ruleutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/function_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/foreign_key_relationship.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata/pg_dist_object.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_physical_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_dist_local_group.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_dist_node_metadata.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_dist_node.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_dist_partition.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_dist_shard.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_dist_placement.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shared_library_init.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shardinterval_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/utils/array_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/utils/function.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/version_compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_manager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/memnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pg_list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_func.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/catcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/elog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/hsearch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/jsonb.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/hashfn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/inval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/palloc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relfilenodemap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relmapper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/resowner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>


<comment type="block">/* user configuration */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>ReadFromSecondaries</name> <init>= <expr><name>USE_SECONDARY_NODES_NEVER</name></expr></init></decl>;</decl_stmt>


<comment type="block">/*
 * CitusTableCacheEntrySlot is entry type for DistTableCacheHash,
 * entry data outlives slot on invalidation, so requires indirection.
 */</comment>
<typedef>typedef <type><struct>struct <name>CitusTableCacheEntrySlot</name>
<block>{
	<comment type="block">/* lookup key - must be first. A pg_class.oid oid. */</comment>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name></decl>;</decl_stmt>

	<comment type="block">/* Citus table metadata (NULL for local tables) */</comment>
	<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>citusTableMetadata</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If isValid is false, we need to recheck whether the relation ID
	 * belongs to a Citus or not.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>isValid</name></decl>;</decl_stmt>
}</block></struct></type> <name>CitusTableCacheEntrySlot</name>;</typedef>


<comment type="block">/*
 * ShardIdCacheEntry is the entry type for ShardIdCacheHash.
 *
 * This should never be used outside of this file. Use ShardInterval instead.
 */</comment>
<typedef>typedef <type><struct>struct <name>ShardIdCacheEntry</name>
<block>{
	<comment type="block">/* hash key, needs to be first */</comment>
	<decl_stmt><decl><type><name>uint64</name></type> <name>shardId</name></decl>;</decl_stmt>

	<comment type="block">/* pointer to the table entry to which this shard currently belongs */</comment>
	<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>tableEntry</name></decl>;</decl_stmt>

	<comment type="block">/* index of the shard interval in the sortedShardIntervalArray of the table entry */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>shardIndex</name></decl>;</decl_stmt>
}</block></struct></type> <name>ShardIdCacheEntry</name>;</typedef>


<comment type="block">/*
 * State which should be cleared upon DROP EXTENSION. When the configuration
 * changes, e.g. because extension is dropped, these summarily get set to 0.
 */</comment>
<typedef>typedef <type><struct>struct <name>MetadataCacheData</name>
<block>{
	<decl_stmt><decl><type><name>bool</name></type> <name>extensionLoaded</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distShardRelationId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distPlacementRelationId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distBackgroundJobRelationId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distBackgroundJobPKeyIndexId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distBackgroundJobJobIdSequenceId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distBackgroundTaskRelationId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distBackgroundTaskPKeyIndexId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distBackgroundTaskJobIdTaskIdIndexId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distBackgroundTaskStatusTaskIdIndexId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distBackgroundTaskTaskIdSequenceId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distBackgroundTaskDependRelationId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distBackgroundTaskDependTaskIdIndexId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distBackgroundTaskDependDependsOnIndexId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>citusJobStatusScheduledId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>citusJobStatusRunningId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>citusJobStatusCancellingId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>citusJobStatusFinishedId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>citusJobStatusCancelledId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>citusJobStatusFailedId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>citusJobStatusFailingId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>citusTaskStatusBlockedId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>citusTaskStatusRunnableId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>citusTaskStatusRunningId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>citusTaskStatusDoneId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>citusTaskStatusErrorId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>citusTaskStatusUnscheduledId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>citusTaskStatusCancelledId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>citusTaskStatusCancellingId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distRebalanceStrategyRelationId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distNodeRelationId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distNodeNodeIdIndexId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distLocalGroupRelationId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distObjectRelationId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distObjectPrimaryKeyIndexId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distCleanupRelationId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distCleanupPrimaryKeyIndexId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distColocationRelationId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distColocationConfigurationIndexId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distPartitionRelationId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distPartitionLogicalRelidIndexId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distPartitionColocationidIndexId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distShardLogicalRelidIndexId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distShardShardidIndexId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distPlacementShardidIndexId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distPlacementPlacementidIndexId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distColocationidIndexId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distPlacementGroupidIndexId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distTransactionRelationId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distTransactionGroupIndexId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>citusCatalogNamespaceId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>copyFormatTypeId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>readIntermediateResultFuncId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>readIntermediateResultArrayFuncId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>extraDataContainerFuncId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>workerHashFunctionId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>anyValueFunctionId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>textSendAsJsonbFunctionId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>textoutFunctionId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>extensionOwner</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>binaryCopyFormatId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>textCopyFormatId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>primaryNodeRoleId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>secondaryNodeRoleId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>pgTableIsVisibleFuncId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>citusTableIsVisibleFuncId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distAuthinfoRelationId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distAuthinfoIndexId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distPoolinfoRelationId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distPoolinfoIndexId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationIsAKnownShardFuncId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>jsonbExtractPathFuncId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>jsonbExtractPathTextFuncId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>CitusDependentObjectFuncId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distClockLogicalSequenceId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>databaseNameValid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>databaseName</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>MetadataCacheData</name>;</typedef>


<decl_stmt><decl><type><specifier>static</specifier> <name>MetadataCacheData</name></type> <name>MetadataCache</name></decl>;</decl_stmt>

<comment type="block">/* Citus extension version variables */</comment>
<decl_stmt><decl><type><name>bool</name></type> <name>EnableVersionChecks</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt> <comment type="block">/* version checks are enabled */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>citusVersionKnownCompatible</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Variable to determine if we are in the process of creating citus */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>CreateCitusTransactionLevel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* Hash table for informations about each partition */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>DistTableCacheHash</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>DistTableCacheExpired</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Hash table for informations about each shard */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>ShardIdCacheHash</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>MemoryContext</name></type> <name>MetadataCacheMemoryContext</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Hash table for information about each object */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>DistObjectCacheHash</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Hash table for informations about worker nodes */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>WorkerNodeHash</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>WorkerNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>WorkerNodeArray</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>WorkerNodeCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>workerNodeHashValid</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* default value is -1, for coordinator it's 0 and for worker nodes &gt; 0 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int32</name></type> <name>LocalGroupId</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* default value is -1, increases with every node starting from 1 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int32</name></type> <name>LocalNodeId</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* built first time through in InitializeDistCache */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>ScanKeyData</name></type> <name><name>DistPartitionScanKey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ScanKeyData</name></type> <name><name>DistShardScanKey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ScanKeyData</name></type> <name><name>DistObjectScanKey</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>


<comment type="block">/* local function forward declarations */</comment>
<function_decl><type><specifier>static</specifier> <name>HeapTuple</name></type> <name>PgDistPartitionTupleViaCatalog</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ShardIdCacheEntry</name> <modifier>*</modifier></type> <name>LookupShardIdCacheEntry</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>shardId</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missingOk</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>CitusTableCacheEntry</name> <modifier>*</modifier></type> <name>BuildCitusTableCacheEntry</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>BuildCachedShardList</name><parameter_list>(<parameter><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>cacheEntry</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>PrepareWorkerNodeCache</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>CheckInstalledVersion</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>AvailableExtensionVersion</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>InstalledExtensionVersion</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>CitusHasBeenLoadedInternal</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>InitializeCaches</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>InitializeDistCache</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>InitializeDistObjectCache</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>InitializeWorkerNodeCache</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RegisterForeignKeyGraphCacheCallbacks</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RegisterWorkerNodeCacheCallbacks</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RegisterLocalGroupIdCacheCallbacks</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RegisterAuthinfoCacheCallbacks</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RegisterCitusTableCacheEntryReleaseCallbacks</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ResetCitusTableCacheEntry</name><parameter_list>(<parameter><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>cacheEntry</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RemoveStaleShardIdCacheEntries</name><parameter_list>(<parameter><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>tableEntry</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CreateDistTableCache</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CreateShardIdCache</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CreateDistObjectCache</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>InvalidateForeignRelationGraphCacheCallback</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>argument</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>InvalidateDistRelationCacheCallback</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>argument</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>InvalidateNodeRelationCacheCallback</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>argument</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>InvalidateLocalGroupIdRelationCacheCallback</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>argument</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>InvalidateConnParamsCacheCallback</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>argument</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CitusTableCacheEntryReleaseCallback</name><parameter_list>(<parameter><decl><type><name>ResourceReleasePhase</name></type> <name>phase</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isCommit</name></decl></parameter>,
												<parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HeapTuple</name></type> <name>LookupDistPartitionTuple</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>pgDistPartition</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>GetPartitionTypeInputInfo</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>partitionKeyString</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>partitionMethod</name></decl></parameter>,
									  <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>columnTypeId</name></decl></parameter>, <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>columnTypeMod</name></decl></parameter>,
									  <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>intervalTypeId</name></decl></parameter>, <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>intervalTypeMod</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CachedNamespaceLookup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nspname</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>cachedOid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CachedRelationLookup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relationName</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>cachedOid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CachedRelationLookupExtended</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relationName</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>cachedOid</name></decl></parameter>,
										 <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CachedRelationNamespaceLookup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relationName</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relnamespace</name></decl></parameter>,
										  <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>cachedOid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CachedRelationNamespaceLookupExtended</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relationName</name></decl></parameter>,
												  <parameter><decl><type><name>Oid</name></type> <name>renamespace</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>cachedOid</name></decl></parameter>,
												  <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ShardPlacement</name> <modifier>*</modifier></type> <name>ResolveGroupShardPlacement</name><parameter_list>(
	<parameter><decl><type><name>GroupShardPlacement</name> <modifier>*</modifier></type><name>groupShardPlacement</name></decl></parameter>, <parameter><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>tableEntry</name></decl></parameter>,
	<parameter><decl><type><name>int</name></type> <name>shardIndex</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type> <name>LookupEnumValueId</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typeId</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>valueName</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>InvalidateCitusTableCacheEntrySlot</name><parameter_list>(<parameter><decl><type><name>CitusTableCacheEntrySlot</name> <modifier>*</modifier></type><name>cacheSlot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>InvalidateDistTableCache</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>InvalidateDistObjectCache</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>InitializeTableCacheEntry</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>shardId</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missingOk</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsCitusTableTypeInternal</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>partitionMethod</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>replicationModel</name></decl></parameter>,
									 <parameter><decl><type><name>CitusTableType</name></type> <name>tableType</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>RefreshTableCacheEntryIfInvalid</name><parameter_list>(<parameter><decl><type><name>ShardIdCacheEntry</name> <modifier>*</modifier></type><name>shardEntry</name></decl></parameter>, <parameter><decl><type><name>bool</name></type>
											<name>missingOk</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Oid</name></type> <name>DistAuthinfoRelationId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type> <name>DistAuthinfoIndexId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type> <name>DistPoolinfoRelationId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type> <name>DistPoolinfoIndexId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* exports for SQL callable functions */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>citus_dist_partition_cache_invalidate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>master_dist_partition_cache_invalidate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>citus_dist_shard_cache_invalidate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>master_dist_shard_cache_invalidate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>citus_dist_placement_cache_invalidate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>master_dist_placement_cache_invalidate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>citus_dist_node_cache_invalidate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>master_dist_node_cache_invalidate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>citus_dist_local_group_cache_invalidate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>master_dist_local_group_cache_invalidate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>citus_conninfo_cache_invalidate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>master_dist_authinfo_cache_invalidate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>citus_dist_object_cache_invalidate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>master_dist_object_cache_invalidate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>role_exists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>authinfo_valid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>poolinfo_valid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<comment type="block">/*
 * EnsureModificationsCanRun checks if the current node is in recovery mode or
 * citus.use_secondary_nodes is 'always'. If either is true the function errors out.
 */</comment>
<function><type><name>void</name></type>
<name>EnsureModificationsCanRun</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>WritableStandbyCoordinator</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"writing to worker nodes is not currently allowed"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"the database is read-only"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>ReadFromSecondaries</name> <operator>==</operator> <name>USE_SECONDARY_NODES_ALWAYS</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"writing to worker nodes is not currently allowed"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"citus.use_secondary_nodes is set to 'always'"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * EnsureModificationsCanRunOnRelation firsts calls into EnsureModificationsCanRun() and
 * then does one more additional check. The additional check is to give a proper error
 * message if any relation that is modified is replicated, as replicated tables use
 * 2PC and 2PC cannot happen when recovery is in progress.
 */</comment>
<function><type><name>void</name></type>
<name>EnsureModificationsCanRunOnRelation</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>EnsureModificationsCanRun</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* we are not interested in PG tables */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>modifiedTableReplicated</name> <init>=
		<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>REFERENCE_TABLE</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<operator>!</operator><call><name>SingleReplicatedTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCoordinator</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>AllowModificationsFromWorkersToReplicatedTables</name> <operator>&amp;&amp;</operator>
		<name>modifiedTableReplicated</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"modifications via the worker nodes are not "</literal>
							   <literal type="string">"allowed for replicated tables such as reference "</literal>
							   <literal type="string">"tables or hash distributed tables with replication "</literal>
							   <literal type="string">"factor greater than 1."</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"All modifications to replicated tables should "</literal>
								<literal type="string">"happen via the coordinator unless "</literal>
								<literal type="string">"citus.allow_modifications_from_workers_to_replicated_tables "</literal>
								<literal type="string">" = true."</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Allowing modifications from the worker nodes "</literal>
								  <literal type="string">"requires extra locking which might decrease "</literal>
								  <literal type="string">"the throughput."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Even if user allows writes from standby, we should not allow for
	 * replicated tables as they require 2PC. And, 2PC needs to write a log
	 * record on the coordinator.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>WritableStandbyCoordinator</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>modifiedTableReplicated</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"writing to worker nodes is not currently "</literal>
							   <literal type="string">"allowed for replicated tables such as reference "</literal>
							   <literal type="string">"tables or hash distributed tables with replication "</literal>
							   <literal type="string">"factor greater than 1."</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"All modifications to replicated tables "</literal>
								<literal type="string">"happen via 2PC, and 2PC requires the "</literal>
								<literal type="string">"database to be in a writable state."</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"the database is read-only"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * IsCitusTableType returns true if the given table with relationId
 * belongs to a citus table that matches the given table type. If cache
 * entry already exists, prefer using IsCitusTableTypeCacheEntry to avoid
 * an extra lookup.
 */</comment>
<function><type><name>bool</name></type>
<name>IsCitusTableType</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>CitusTableType</name></type> <name>tableType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>tableEntry</name> <init>= <expr><call><name>LookupCitusTableCacheEntry</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* we are not interested in postgres tables */</comment>
	<if_stmt><if>if <condition>(<expr><name>tableEntry</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>IsCitusTableTypeCacheEntry</name><argument_list>(<argument><expr><name>tableEntry</name></expr></argument>, <argument><expr><name>tableType</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsCitusTableTypeCacheEntry returns true if the given table cache entry
 * belongs to a citus table that matches the given table type.
 */</comment>
<function><type><name>bool</name></type>
<name>IsCitusTableTypeCacheEntry</name><parameter_list>(<parameter><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>tableEntry</name></decl></parameter>, <parameter><decl><type><name>CitusTableType</name></type> <name>tableType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>IsCitusTableTypeInternal</name><argument_list>(<argument><expr><name><name>tableEntry</name><operator>-&gt;</operator><name>partitionMethod</name></name></expr></argument>,
									<argument><expr><name><name>tableEntry</name><operator>-&gt;</operator><name>replicationModel</name></name></expr></argument>, <argument><expr><name>tableType</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsCitusTableTypeInternal returns true if the given table entry belongs to
 * the given table type group. For definition of table types, see CitusTableType.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsCitusTableTypeInternal</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>partitionMethod</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>replicationModel</name></decl></parameter>,
						 <parameter><decl><type><name>CitusTableType</name></type> <name>tableType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>tableType</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>HASH_DISTRIBUTED</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><name>partitionMethod</name> <operator>==</operator> <name>DISTRIBUTE_BY_HASH</name></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>APPEND_DISTRIBUTED</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><name>partitionMethod</name> <operator>==</operator> <name>DISTRIBUTE_BY_APPEND</name></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>RANGE_DISTRIBUTED</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><name>partitionMethod</name> <operator>==</operator> <name>DISTRIBUTE_BY_RANGE</name></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>DISTRIBUTED_TABLE</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><name>partitionMethod</name> <operator>==</operator> <name>DISTRIBUTE_BY_HASH</name> <operator>||</operator>
				   <name>partitionMethod</name> <operator>==</operator> <name>DISTRIBUTE_BY_RANGE</name> <operator>||</operator>
				   <name>partitionMethod</name> <operator>==</operator> <name>DISTRIBUTE_BY_APPEND</name></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>STRICTLY_PARTITIONED_DISTRIBUTED_TABLE</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><name>partitionMethod</name> <operator>==</operator> <name>DISTRIBUTE_BY_HASH</name> <operator>||</operator>
				   <name>partitionMethod</name> <operator>==</operator> <name>DISTRIBUTE_BY_RANGE</name></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>REFERENCE_TABLE</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><name>partitionMethod</name> <operator>==</operator> <name>DISTRIBUTE_BY_NONE</name> <operator>&amp;&amp;</operator>
				   <name>replicationModel</name> <operator>==</operator> <name>REPLICATION_MODEL_2PC</name></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>CITUS_LOCAL_TABLE</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><name>partitionMethod</name> <operator>==</operator> <name>DISTRIBUTE_BY_NONE</name> <operator>&amp;&amp;</operator>
				   <name>replicationModel</name> <operator>!=</operator> <name>REPLICATION_MODEL_2PC</name></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>CITUS_TABLE_WITH_NO_DIST_KEY</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><name>partitionMethod</name> <operator>==</operator> <name>DISTRIBUTE_BY_NONE</name></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>ANY_CITUS_TABLE_TYPE</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block>

		<default>default:</default>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Unknown table type %d"</literal></expr></argument>, <argument><expr><name>tableType</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></switch>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetTableTypeName returns string representation of the table type.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>GetTableTypeName</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>tableId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>regularTable</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>partitionMethod</name> <init>= <expr><literal type="char">' '</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>replicationModel</name> <init>= <expr><literal type="char">' '</literal></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>tableId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>referencingCacheEntry</name> <init>= <expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name>tableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>partitionMethod</name> <operator>=</operator> <name><name>referencingCacheEntry</name><operator>-&gt;</operator><name>partitionMethod</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>replicationModel</name> <operator>=</operator> <name><name>referencingCacheEntry</name><operator>-&gt;</operator><name>replicationModel</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>regularTable</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>regularTable</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><literal type="string">"regular table"</literal></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>partitionMethod</name> <operator>==</operator> <literal type="char">'h'</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><literal type="string">"distributed table"</literal></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>partitionMethod</name> <operator>==</operator> <literal type="char">'n'</literal> <operator>&amp;&amp;</operator> <name>replicationModel</name> <operator>==</operator> <literal type="char">'t'</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><literal type="string">"reference table"</literal></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>partitionMethod</name> <operator>==</operator> <literal type="char">'n'</literal> <operator>&amp;&amp;</operator> <name>replicationModel</name> <operator>!=</operator> <literal type="char">'t'</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><literal type="string">"citus local table"</literal></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<return>return <expr><literal type="string">"unknown table"</literal></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * IsCitusTable returns whether relationId is a distributed relation or
 * not.
 */</comment>
<function><type><name>bool</name></type>
<name>IsCitusTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>LookupCitusTableCacheEntry</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsCitusTableViaCatalog returns whether the given relation is a
 * distributed table or not.
 *
 * It does so by searching pg_dist_partition, explicitly bypassing caches,
 * because this function is designed to be used in cases where accessing
 * metadata tables is not safe.
 *
 * NB: Currently this still hardcodes pg_dist_partition logicalrelid column
 * offset and the corresponding index.  If we ever come close to changing
 * that, we'll have to work a bit harder.
 */</comment>
<function><type><name>bool</name></type>
<name>IsCitusTableViaCatalog</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>partitionTuple</name> <init>= <expr><call><name>PgDistPartitionTupleViaCatalog</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>heapTupleIsValid</name> <init>= <expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>partitionTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>heapTupleIsValid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>partitionTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>heapTupleIsValid</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PartitionMethodViaCatalog gets a relationId and returns the partition
 * method column from pg_dist_partition via reading from catalog.
 */</comment>
<function><type><name>char</name></type>
<name>PartitionMethodViaCatalog</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>partitionTuple</name> <init>= <expr><call><name>PgDistPartitionTupleViaCatalog</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>partitionTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>DISTRIBUTE_BY_INVALID</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Datum</name></type> <name><name>datumArray</name><index>[<expr><name>Natts_pg_dist_partition</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name><name>isNullArray</name><index>[<expr><name>Natts_pg_dist_partition</name></expr>]</index></name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>pgDistPartition</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><call><name>DistPartitionRelationId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pgDistPartition</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><name>partitionTuple</name></expr></argument>, <argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><name>datumArray</name></expr></argument>, <argument><expr><name>isNullArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>isNullArray</name><index>[<expr><name>Anum_pg_dist_partition_partmethod</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* partition method cannot be NULL, still let's make sure */</comment>
		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>partitionTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pgDistPartition</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>DISTRIBUTE_BY_INVALID</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Datum</name></type> <name>partitionMethodDatum</name> <init>= <expr><name><name>datumArray</name><index>[<expr><name>Anum_pg_dist_partition_partmethod</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>partitionMethodChar</name> <init>= <expr><call><name>DatumGetChar</name><argument_list>(<argument><expr><name>partitionMethodDatum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>partitionTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pgDistPartition</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>partitionMethodChar</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PartitionColumnViaCatalog gets a relationId and returns the partition
 * key column from pg_dist_partition via reading from catalog.
 */</comment>
<function><type><name>Var</name> <modifier>*</modifier></type>
<name>PartitionColumnViaCatalog</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>partitionTuple</name> <init>= <expr><call><name>PgDistPartitionTupleViaCatalog</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>partitionTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Datum</name></type> <name><name>datumArray</name><index>[<expr><name>Natts_pg_dist_partition</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name><name>isNullArray</name><index>[<expr><name>Natts_pg_dist_partition</name></expr>]</index></name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>pgDistPartition</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><call><name>DistPartitionRelationId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pgDistPartition</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><name>partitionTuple</name></expr></argument>, <argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><name>datumArray</name></expr></argument>, <argument><expr><name>isNullArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>isNullArray</name><index>[<expr><name>Anum_pg_dist_partition_partkey</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* partition key cannot be NULL, still let's make sure */</comment>
		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>partitionTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pgDistPartition</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Datum</name></type> <name>partitionKeyDatum</name> <init>= <expr><name><name>datumArray</name><index>[<expr><name>Anum_pg_dist_partition_partkey</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>partitionKeyString</name> <init>= <expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>partitionKeyDatum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* convert the string to a Node and ensure it is a Var */</comment>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>partitionNode</name> <init>= <expr><call><name>stringToNode</name><argument_list>(<argument><expr><name>partitionKeyString</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>partitionNode</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>partitionColumn</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>partitionNode</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>partitionTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pgDistPartition</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>partitionColumn</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColocationIdViaCatalog gets a relationId and returns the colocation
 * id column from pg_dist_partition via reading from catalog.
 */</comment>
<function><type><name>uint32</name></type>
<name>ColocationIdViaCatalog</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>partitionTuple</name> <init>= <expr><call><name>PgDistPartitionTupleViaCatalog</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>partitionTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>INVALID_COLOCATION_ID</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Datum</name></type> <name><name>datumArray</name><index>[<expr><name>Natts_pg_dist_partition</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name><name>isNullArray</name><index>[<expr><name>Natts_pg_dist_partition</name></expr>]</index></name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>pgDistPartition</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><call><name>DistPartitionRelationId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pgDistPartition</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><name>partitionTuple</name></expr></argument>, <argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><name>datumArray</name></expr></argument>, <argument><expr><name>isNullArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>isNullArray</name><index>[<expr><name>Anum_pg_dist_partition_colocationid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* colocation id cannot be NULL, still let's make sure */</comment>
		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>partitionTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pgDistPartition</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>INVALID_COLOCATION_ID</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Datum</name></type> <name>colocationIdDatum</name> <init>= <expr><name><name>datumArray</name><index>[<expr><name>Anum_pg_dist_partition_colocationid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>colocationId</name> <init>= <expr><call><name>DatumGetUInt32</name><argument_list>(<argument><expr><name>colocationIdDatum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>partitionTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pgDistPartition</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>colocationId</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PgDistPartitionTupleViaCatalog is a helper function that searches
 * pg_dist_partition for the given relationId. The caller is responsible
 * for ensuring that the returned heap tuple is valid before accessing
 * its fields.
 */</comment>
<function><type><specifier>static</specifier> <name>HeapTuple</name></type>
<name>PgDistPartitionTupleViaCatalog</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>scanKeyCount</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scanKey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>indexOK</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>pgDistPartition</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><call><name>DistPartitionRelationId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_pg_dist_partition_logicalrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scanDescriptor</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pgDistPartition</name></expr></argument>,
													<argument><expr><call><name>DistPartitionLogicalRelidIndexId</name><argument_list>()</argument_list></call></expr></argument>,
													<argument><expr><name>indexOK</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>scanKeyCount</name></expr></argument>, <argument><expr><name>scanKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>partitionTuple</name> <init>= <expr><call><name>systable_getnext</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>partitionTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* callers should have the tuple in their memory contexts */</comment>
		<expr_stmt><expr><name>partitionTuple</name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><name>partitionTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pgDistPartition</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>partitionTuple</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsCitusLocalTableByDistParams returns true if given partitionMethod and
 * replicationModel would identify a citus local table.
 */</comment>
<function><type><name>bool</name></type>
<name>IsCitusLocalTableByDistParams</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>partitionMethod</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>replicationModel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>partitionMethod</name> <operator>==</operator> <name>DISTRIBUTE_BY_NONE</name> <operator>&amp;&amp;</operator>
		   <name>replicationModel</name> <operator>!=</operator> <name>REPLICATION_MODEL_2PC</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CitusTableList returns a list that includes all the valid distributed table
 * cache entries.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>CitusTableList</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>distributedTableList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>CitusHasBeenLoaded</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* first, we need to iterate over pg_dist_partition */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>citusTableIdList</name> <init>= <expr><call><name>CitusTableTypeIdList</name><argument_list>(<argument><expr><name>ANY_CITUS_TABLE_TYPE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>relationId</argument>, <argument>citusTableIdList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>cacheEntry</name> <init>= <expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>distributedTableList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>distributedTableList</name></expr></argument>, <argument><expr><name>cacheEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>distributedTableList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * LoadShardInterval returns the, cached, metadata about a shard.
 *
 * The return value is a copy of the cached ShardInterval struct and may
 * therefore be modified and/or freed.
 */</comment>
<function><type><name>ShardInterval</name> <modifier>*</modifier></type>
<name>LoadShardInterval</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>missingOk</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ShardIdCacheEntry</name> <modifier>*</modifier></type><name>shardIdEntry</name> <init>= <expr><call><name>LookupShardIdCacheEntry</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>tableEntry</name> <init>= <expr><name><name>shardIdEntry</name><operator>-&gt;</operator><name>tableEntry</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>shardIndex</name> <init>= <expr><name><name>shardIdEntry</name><operator>-&gt;</operator><name>shardIndex</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* the offset better be in a valid range */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>shardIndex</name> <operator>&lt;</operator> <name><name>tableEntry</name><operator>-&gt;</operator><name>shardIntervalArrayLength</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>sourceShardInterval</name> <init>=
		<expr><name><name>tableEntry</name><operator>-&gt;</operator><name>sortedShardIntervalArray</name><index>[<expr><name>shardIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* copy value to return */</comment>
	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><call><name>CopyShardInterval</name><argument_list>(<argument><expr><name>sourceShardInterval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>shardInterval</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ShardExists returns whether given shard exists or not. It fails if missingOk is false
 * and shard is not found.
 */</comment>
<function><type><name>bool</name></type>
<name>ShardExists</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>missingOk</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ShardIdCacheEntry</name> <modifier>*</modifier></type><name>shardIdEntry</name> <init>= <expr><call><name>LookupShardIdCacheEntry</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>shardIdEntry</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RelationIdOfShard returns the relationId of the given shardId.
 */</comment>
<function><type><name>Oid</name></type>
<name>RelationIdForShard</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>missingOk</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ShardIdCacheEntry</name> <modifier>*</modifier></type><name>shardIdEntry</name> <init>= <expr><call><name>LookupShardIdCacheEntry</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>tableEntry</name> <init>= <expr><name><name>shardIdEntry</name><operator>-&gt;</operator><name>tableEntry</name></name></expr></init></decl>;</decl_stmt>
	<return>return <expr><name><name>tableEntry</name><operator>-&gt;</operator><name>relationId</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ReferenceTableShardId returns true if the given shardId belongs to
 * a reference table.
 */</comment>
<function><type><name>bool</name></type>
<name>ReferenceTableShardId</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>missingOk</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ShardIdCacheEntry</name> <modifier>*</modifier></type><name>shardIdEntry</name> <init>= <expr><call><name>LookupShardIdCacheEntry</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>tableEntry</name> <init>= <expr><name><name>shardIdEntry</name><operator>-&gt;</operator><name>tableEntry</name></name></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>IsCitusTableTypeCacheEntry</name><argument_list>(<argument><expr><name>tableEntry</name></expr></argument>, <argument><expr><name>REFERENCE_TABLE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DistributedTableShardId returns true if the given shardId belongs to
 * a distributed table.
 */</comment>
<function><type><name>bool</name></type>
<name>DistributedTableShardId</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>shardId</name> <operator>==</operator> <name>INVALID_SHARD_ID</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>missingOk</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ShardIdCacheEntry</name> <modifier>*</modifier></type><name>shardIdEntry</name> <init>= <expr><call><name>LookupShardIdCacheEntry</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>tableEntry</name> <init>= <expr><name><name>shardIdEntry</name><operator>-&gt;</operator><name>tableEntry</name></name></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>IsCitusTableTypeCacheEntry</name><argument_list>(<argument><expr><name>tableEntry</name></expr></argument>, <argument><expr><name>DISTRIBUTED_TABLE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * LoadGroupShardPlacement returns the cached shard placement metadata
 *
 * The return value is a copy of the cached GroupShardPlacement struct and may
 * therefore be modified and/or freed.
 */</comment>
<function><type><name>GroupShardPlacement</name> <modifier>*</modifier></type>
<name>LoadGroupShardPlacement</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>placementId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>missingOk</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ShardIdCacheEntry</name> <modifier>*</modifier></type><name>shardIdEntry</name> <init>= <expr><call><name>LookupShardIdCacheEntry</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>tableEntry</name> <init>= <expr><name><name>shardIdEntry</name><operator>-&gt;</operator><name>tableEntry</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>shardIndex</name> <init>= <expr><name><name>shardIdEntry</name><operator>-&gt;</operator><name>shardIndex</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* the offset better be in a valid range */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>shardIndex</name> <operator>&lt;</operator> <name><name>tableEntry</name><operator>-&gt;</operator><name>shardIntervalArrayLength</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>GroupShardPlacement</name> <modifier>*</modifier></type><name>placementArray</name> <init>=
		<expr><name><name>tableEntry</name><operator>-&gt;</operator><name>arrayOfPlacementArrays</name><index>[<expr><name>shardIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>numberOfPlacements</name> <init>=
		<expr><name><name>tableEntry</name><operator>-&gt;</operator><name>arrayOfPlacementArrayLengths</name><index>[<expr><name>shardIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numberOfPlacements</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>placementArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>placementId</name> <operator>==</operator> <name>placementId</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>GroupShardPlacement</name> <modifier>*</modifier></type><name>shardPlacement</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>GroupShardPlacement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><operator>*</operator><name>shardPlacement</name> <operator>=</operator> <name><name>placementArray</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

			<return>return <expr><name>shardPlacement</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not find valid entry for shard placement "</literal>
						   <name>UINT64_FORMAT</name></expr></argument>, <argument><expr><name>placementId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * LoadShardPlacement returns a shard placement for the primary node.
 */</comment>
<function><type><name>ShardPlacement</name> <modifier>*</modifier></type>
<name>LoadShardPlacement</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>placementId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>missingOk</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ShardIdCacheEntry</name> <modifier>*</modifier></type><name>shardIdEntry</name> <init>= <expr><call><name>LookupShardIdCacheEntry</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>tableEntry</name> <init>= <expr><name><name>shardIdEntry</name><operator>-&gt;</operator><name>tableEntry</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>shardIndex</name> <init>= <expr><name><name>shardIdEntry</name><operator>-&gt;</operator><name>shardIndex</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GroupShardPlacement</name> <modifier>*</modifier></type><name>groupPlacement</name> <init>= <expr><call><name>LoadGroupShardPlacement</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>, <argument><expr><name>placementId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>nodePlacement</name> <init>= <expr><call><name>ResolveGroupShardPlacement</name><argument_list>(<argument><expr><name>groupPlacement</name></expr></argument>,
															   <argument><expr><name>tableEntry</name></expr></argument>, <argument><expr><name>shardIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>nodePlacement</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ShardPlacementOnGroupIncludingOrphanedPlacements returns the shard placement
 * for the given shard on the given group, or returns NULL if no placement for
 * the shard exists on the group.
 *
 * NOTE: This can return inactive or orphaned placements.
 */</comment>
<function><type><name>ShardPlacement</name> <modifier>*</modifier></type>
<name>ShardPlacementOnGroupIncludingOrphanedPlacements</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>groupId</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>placementOnNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>missingOk</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ShardIdCacheEntry</name> <modifier>*</modifier></type><name>shardIdEntry</name> <init>= <expr><call><name>LookupShardIdCacheEntry</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>tableEntry</name> <init>= <expr><name><name>shardIdEntry</name><operator>-&gt;</operator><name>tableEntry</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>shardIndex</name> <init>= <expr><name><name>shardIdEntry</name><operator>-&gt;</operator><name>shardIndex</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GroupShardPlacement</name> <modifier>*</modifier></type><name>placementArray</name> <init>=
		<expr><name><name>tableEntry</name><operator>-&gt;</operator><name>arrayOfPlacementArrays</name><index>[<expr><name>shardIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>numberOfPlacements</name> <init>=
		<expr><name><name>tableEntry</name><operator>-&gt;</operator><name>arrayOfPlacementArrayLengths</name><index>[<expr><name>shardIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>placementIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>placementIndex</name> <operator>&lt;</operator> <name>numberOfPlacements</name></expr>;</condition> <incr><expr><name>placementIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>GroupShardPlacement</name> <modifier>*</modifier></type><name>placement</name> <init>= <expr><operator>&amp;</operator><name><name>placementArray</name><index>[<expr><name>placementIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>placement</name><operator>-&gt;</operator><name>groupId</name></name> <operator>==</operator> <name>groupId</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>placementOnNode</name> <operator>=</operator> <call><name>ResolveGroupShardPlacement</name><argument_list>(<argument><expr><name>placement</name></expr></argument>, <argument><expr><name>tableEntry</name></expr></argument>,
														 <argument><expr><name>shardIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>placementOnNode</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ActiveShardPlacementOnGroup returns the active shard placement for the
 * given shard on the given group, or returns NULL if no active placement for
 * the shard exists on the group.
 */</comment>
<function><type><name>ShardPlacement</name> <modifier>*</modifier></type>
<name>ActiveShardPlacementOnGroup</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>groupId</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>placement</name> <init>=
		<expr><call><name>ShardPlacementOnGroupIncludingOrphanedPlacements</name><argument_list>(<argument><expr><name>groupId</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>placement</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>placement</name><operator>-&gt;</operator><name>shardState</name></name> <operator>!=</operator> <name>SHARD_STATE_ACTIVE</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>placement</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ResolveGroupShardPlacement takes a GroupShardPlacement and adds additional data to it,
 * such as the node we should consider it to be on.
 */</comment>
<function><type><specifier>static</specifier> <name>ShardPlacement</name> <modifier>*</modifier></type>
<name>ResolveGroupShardPlacement</name><parameter_list>(<parameter><decl><type><name>GroupShardPlacement</name> <modifier>*</modifier></type><name>groupShardPlacement</name></decl></parameter>,
						   <parameter><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>tableEntry</name></decl></parameter>,
						   <parameter><decl><type><name>int</name></type> <name>shardIndex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><name><name>tableEntry</name><operator>-&gt;</operator><name>sortedShardIntervalArray</name><index>[<expr><name>shardIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>shardPlacement</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>ShardPlacement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>groupId</name> <init>= <expr><name><name>groupShardPlacement</name><operator>-&gt;</operator><name>groupId</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><call><name>LookupNodeForGroup</name><argument_list>(<argument><expr><name>groupId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* copy everything into shardPlacement but preserve the header */</comment>
	<decl_stmt><decl><type><name>CitusNode</name></type> <name>header</name> <init>= <expr><name><name>shardPlacement</name><operator>-&gt;</operator><name>type</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GroupShardPlacement</name> <modifier>*</modifier></type><name>shardPlacementAsGroupPlacement</name> <init>=
		<expr><operator>(</operator><name>GroupShardPlacement</name> <operator>*</operator><operator>)</operator> <name>shardPlacement</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><operator>*</operator><name>shardPlacementAsGroupPlacement</name> <operator>=</operator> <operator>*</operator><name>groupShardPlacement</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shardPlacement</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>header</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SetPlacementNodeMetadata</name><argument_list>(<argument><expr><name>shardPlacement</name></expr></argument>, <argument><expr><name>workerNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* fill in remaining fields */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tableEntry</name><operator>-&gt;</operator><name>partitionMethod</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shardPlacement</name><operator>-&gt;</operator><name>partitionMethod</name></name> <operator>=</operator> <name><name>tableEntry</name><operator>-&gt;</operator><name>partitionMethod</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shardPlacement</name><operator>-&gt;</operator><name>colocationGroupId</name></name> <operator>=</operator> <name><name>tableEntry</name><operator>-&gt;</operator><name>colocationId</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>tableEntry</name><operator>-&gt;</operator><name>partitionMethod</name></name> <operator>==</operator> <name>DISTRIBUTE_BY_HASH</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>minValueExists</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>valueTypeId</name></name> <operator>==</operator> <name>INT4OID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Use the lower boundary of the interval's range to identify
		 * it for colocation purposes. That remains meaningful even if
		 * a concurrent session splits a shard.
		 */</comment>
		<expr_stmt><expr><name><name>shardPlacement</name><operator>-&gt;</operator><name>representativeValue</name></name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>minValue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>shardPlacement</name><operator>-&gt;</operator><name>representativeValue</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>shardPlacement</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * HasAnyNodes returns whether there are any nodes in pg_dist_node.
 */</comment>
<function><type><name>bool</name></type>
<name>HasAnyNodes</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PrepareWorkerNodeCache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>WorkerNodeCount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * LookupNodeByNodeId returns a worker node by nodeId or NULL if the node
 * cannot be found.
 */</comment>
<function><type><name>WorkerNode</name> <modifier>*</modifier></type>
<name>LookupNodeByNodeId</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>nodeId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PrepareWorkerNodeCache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>workerNodeIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>workerNodeIndex</name> <operator>&lt;</operator> <name>WorkerNodeCount</name></expr>;</condition> <incr><expr><name>workerNodeIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><name><name>WorkerNodeArray</name><index>[<expr><name>workerNodeIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>workerNode</name><operator>-&gt;</operator><name>nodeId</name></name> <operator>==</operator> <name>nodeId</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNodeCopy</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WorkerNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><operator>*</operator><name>workerNodeCopy</name> <operator>=</operator> <operator>*</operator><name>workerNode</name></expr>;</expr_stmt>

			<return>return <expr><name>workerNodeCopy</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * LookupNodeByNodeIdOrError returns a worker node by nodeId or errors out if the
 * node cannot be found.
 */</comment>
<function><type><name>WorkerNode</name> <modifier>*</modifier></type>
<name>LookupNodeByNodeIdOrError</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>nodeId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>LookupNodeByNodeId</name><argument_list>(<argument><expr><name>nodeId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"node %d could not be found"</literal></expr></argument>, <argument><expr><name>nodeId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * LookupNodeForGroup searches the WorkerNodeHash for a worker which is a member of the
 * given group and also readable (a primary if we're reading from primaries, a secondary
 * if we're reading from secondaries). If such a node does not exist it emits an
 * appropriate error message.
 */</comment>
<function><type><name>WorkerNode</name> <modifier>*</modifier></type>
<name>LookupNodeForGroup</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>groupId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>foundAnyNodes</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PrepareWorkerNodeCache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>workerNodeIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>workerNodeIndex</name> <operator>&lt;</operator> <name>WorkerNodeCount</name></expr>;</condition> <incr><expr><name>workerNodeIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><name><name>WorkerNodeArray</name><index>[<expr><name>workerNodeIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type> <name>workerNodeGroupId</name> <init>= <expr><name><name>workerNode</name><operator>-&gt;</operator><name>groupId</name></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>workerNodeGroupId</name> <operator>!=</operator> <name>groupId</name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>foundAnyNodes</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>NodeIsReadable</name><argument_list>(<argument><expr><name>workerNode</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>workerNode</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>foundAnyNodes</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"there is a shard placement in node group %d but "</literal>
							   <literal type="string">"there are no nodes in that group"</literal></expr></argument>, <argument><expr><name>groupId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<switch>switch <condition>(<expr><name>ReadFromSecondaries</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>USE_SECONDARY_NODES_NEVER</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"node group %d does not have a primary node"</literal></expr></argument>,
								   <argument><expr><name>groupId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>USE_SECONDARY_NODES_ALWAYS</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"node group %d does not have a secondary node"</literal></expr></argument>,
								   <argument><expr><name>groupId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<default>default:</default>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized value for use_secondary_nodes"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
 * ShardPlacementList returns the list of placements for the given shard from
 * the cache. This list includes placements that are orphaned, because they
 * their deletion is postponed to a later point (shardstate = 4).
 *
 * The returned list is deep copied from the cache and thus can be modified
 * and pfree()d freely.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>ShardPlacementListIncludingOrphanedPlacements</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>placementList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>missingOk</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ShardIdCacheEntry</name> <modifier>*</modifier></type><name>shardIdEntry</name> <init>= <expr><call><name>LookupShardIdCacheEntry</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>tableEntry</name> <init>= <expr><name><name>shardIdEntry</name><operator>-&gt;</operator><name>tableEntry</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>shardIndex</name> <init>= <expr><name><name>shardIdEntry</name><operator>-&gt;</operator><name>shardIndex</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* the offset better be in a valid range */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>shardIndex</name> <operator>&lt;</operator> <name><name>tableEntry</name><operator>-&gt;</operator><name>shardIntervalArrayLength</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>GroupShardPlacement</name> <modifier>*</modifier></type><name>placementArray</name> <init>=
		<expr><name><name>tableEntry</name><operator>-&gt;</operator><name>arrayOfPlacementArrays</name><index>[<expr><name>shardIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>numberOfPlacements</name> <init>=
		<expr><name><name>tableEntry</name><operator>-&gt;</operator><name>arrayOfPlacementArrayLengths</name><index>[<expr><name>shardIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numberOfPlacements</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>GroupShardPlacement</name> <modifier>*</modifier></type><name>groupShardPlacement</name> <init>= <expr><operator>&amp;</operator><name><name>placementArray</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>shardPlacement</name> <init>= <expr><call><name>ResolveGroupShardPlacement</name><argument_list>(<argument><expr><name>groupShardPlacement</name></expr></argument>,
																	<argument><expr><name>tableEntry</name></expr></argument>,
																	<argument><expr><name>shardIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>placementList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>placementList</name></expr></argument>, <argument><expr><name>shardPlacement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* if no shard placements are found, warn the user */</comment>
	<if_stmt><if>if <condition>(<expr><name>numberOfPlacements</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not find any shard placements for shardId "</literal>
								 <name>UINT64_FORMAT</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>placementList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * InitializeTableCacheEntry initializes a shard in cache.  A possible reason
 * for not finding an entry in the cache is that the distributed table's cache
 * entry hasn't been accessed yet. Thus look up the distributed table, and
 * build the cache entry. Afterwards we know that the shard has to be in the
 * cache if it exists. If the shard does *not* exist, this function errors
 * (because LookupShardRelationFromCatalog errors out).
 *
 * If missingOk is true and the shard cannot be found, the function returns false.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>InitializeTableCacheEntry</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>shardId</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missingOk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>LookupShardRelationFromCatalog</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* trigger building the cache for the shard id */</comment>
	<expr_stmt><expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* lgtm[cpp/return-value-ignored] */</comment>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RefreshTableCacheEntryIfInvalid checks if the cache entry is still valid and
 * refreshes it in cache when it's not. It returns true if it refreshed the
 * entry in the cache and false if it didn't.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>RefreshTableCacheEntryIfInvalid</name><parameter_list>(<parameter><decl><type><name>ShardIdCacheEntry</name> <modifier>*</modifier></type><name>shardEntry</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missingOk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We might have some concurrent metadata changes. In order to get the changes,
	 * we first need to accept the cache invalidation messages.
	 */</comment>
	<expr_stmt><expr><call><name>AcceptInvalidationMessages</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>shardEntry</name><operator>-&gt;</operator><name>tableEntry</name><operator>-&gt;</operator><name>isValid</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>oldRelationId</name> <init>= <expr><name><name>shardEntry</name><operator>-&gt;</operator><name>tableEntry</name><operator>-&gt;</operator><name>relationId</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>currentRelationId</name> <init>= <expr><call><name>LookupShardRelationFromCatalog</name><argument_list>(<argument><expr><name><name>shardEntry</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>,
														   <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * The relation OID to which the shard belongs could have changed,
	 * most notably when the extension is dropped and a shard ID is
	 * reused. Reload the cache entries for both old and new relation
	 * ID and then look up the shard entry again.
	 */</comment>
	<expr_stmt><expr><call><name>LookupCitusTableCacheEntry</name><argument_list>(<argument><expr><name>oldRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LookupCitusTableCacheEntry</name><argument_list>(<argument><expr><name>currentRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * LookupShardCacheEntry returns the cache entry belonging to a shard.
 * It errors out if that shard is unknown and missingOk is false. Else,
 * it will return a NULL cache entry.
 */</comment>
<function><type><specifier>static</specifier> <name>ShardIdCacheEntry</name> <modifier>*</modifier></type>
<name>LookupShardIdCacheEntry</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>shardId</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missingOk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>foundInCache</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>recheck</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>CitusHasBeenLoaded</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InitializeCaches</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ShardIdCacheEntry</name> <modifier>*</modifier></type><name>shardEntry</name> <init>=
		<expr><call><name>hash_search</name><argument_list>(<argument><expr><name>ShardIdCacheHash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shardId</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>foundInCache</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>foundInCache</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>InitializeTableCacheEntry</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>recheck</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>recheck</name> <operator>=</operator> <call><name>RefreshTableCacheEntryIfInvalid</name><argument_list>(<argument><expr><name>shardEntry</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * If we (re-)loaded the table cache, re-search the shard cache - the
	 * shard index might have changed.  If we still can't find the entry, it
	 * can't exist.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>recheck</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>shardEntry</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>ShardIdCacheHash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shardId</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>foundInCache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>foundInCache</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>eflag</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>missingOk</name><operator>)</operator></expr> ?</condition><then> <expr><name>DEBUG1</name></expr> </then><else>: <expr><name>ERROR</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>eflag</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not find valid entry for shard "</literal>
								   <name>UINT64_FORMAT</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>shardEntry</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetCitusTableCacheEntry looks up a pg_dist_partition entry for a
 * relation.
 *
 * Errors out if no relation matching the criteria could be found.
 */</comment>
<function><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type>
<name>GetCitusTableCacheEntry</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>distributedRelationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>cacheEntry</name> <init>=
		<expr><call><name>LookupCitusTableCacheEntry</name><argument_list>(<argument><expr><name>distributedRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>cacheEntry</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>cacheEntry</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>distributedRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>relationName</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation with OID %u does not exist"</literal></expr></argument>,
								   <argument><expr><name>distributedRelationId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation %s is not distributed"</literal></expr></argument>, <argument><expr><name>relationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * GetCitusTableCacheEntry returns the distributed table metadata for the
 * passed relationId. For efficiency it caches lookups. This function returns
 * NULL if the relation isn't a distributed table.
 */</comment>
<function><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type>
<name>LookupCitusTableCacheEntry</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>foundInCache</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>hashKey</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>relationId</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Can't be a distributed relation if the extension hasn't been loaded
	 * yet. As we can't do lookups in nonexistent tables, directly return NULL
	 * here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CitusHasBeenLoaded</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>InitializeCaches</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the version is not known to be compatible, perform thorough check,
	 * unless such checks are disabled.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>citusVersionKnownCompatible</name> <operator>&amp;&amp;</operator> <name>EnableVersionChecks</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>isCitusTable</name> <init>= <expr><call><name>IsCitusTableViaCatalog</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>reportLevel</name> <init>= <expr><name>DEBUG1</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If there's a version-mismatch, and we're dealing with a distributed
		 * table, we have to error out as we can't return a valid entry.  We
		 * want to check compatibility in the non-distributed case as well, so
		 * future lookups can use the cache if compatible.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>isCitusTable</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>reportLevel</name> <operator>=</operator> <name>ERROR</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>reportLevel</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* incompatible, can't access cache, so return before doing so */</comment>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We might have some concurrent metadata changes. In order to get the changes,
	 * we first need to accept the cache invalidation messages.
	 */</comment>
	<expr_stmt><expr><call><name>AcceptInvalidationMessages</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>CitusTableCacheEntrySlot</name> <modifier>*</modifier></type><name>cacheSlot</name> <init>=
		<expr><call><name>hash_search</name><argument_list>(<argument><expr><name>DistTableCacheHash</name></expr></argument>, <argument><expr><name>hashKey</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>foundInCache</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* return valid matches */</comment>
	<if_stmt><if>if <condition>(<expr><name>foundInCache</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>cacheSlot</name><operator>-&gt;</operator><name>isValid</name></name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name><name>cacheSlot</name><operator>-&gt;</operator><name>citusTableMetadata</name></name></expr>;</return>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * An invalidation was received or we encountered an OOM while building
			 * the cache entry. We need to rebuild it.
			 */</comment>

			<if_stmt><if>if <condition>(<expr><name><name>cacheSlot</name><operator>-&gt;</operator><name>citusTableMetadata</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * The CitusTableCacheEntry might still be in use. We therefore do
				 * not reset it until the end of the transaction.
				 */</comment>
				<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>=
					<expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>MetadataCacheMemoryContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>DistTableCacheExpired</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>DistTableCacheExpired</name></expr></argument>,
												<argument><expr><name><name>cacheSlot</name><operator>-&gt;</operator><name>citusTableMetadata</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* zero out entry, but not the key part */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>cacheSlot</name><operator>)</operator> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
		   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CitusTableCacheEntrySlot</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We disable interrupts while creating the cache entry because loading
	 * shard metadata can take a while, and if statement_timeout is too low,
	 * this will get canceled on each call and we won't be able to run any
	 * queries on the table.
	 */</comment>
	<expr_stmt><expr><call><name>HOLD_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>cacheSlot</name><operator>-&gt;</operator><name>citusTableMetadata</name></name> <operator>=</operator> <call><name>BuildCitusTableCacheEntry</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Mark it as valid only after building the full entry, such that any
	 * error that happened during the build would trigger a rebuild.
	 */</comment>
	<expr_stmt><expr><name><name>cacheSlot</name><operator>-&gt;</operator><name>isValid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>RESUME_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>cacheSlot</name><operator>-&gt;</operator><name>citusTableMetadata</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * LookupDistObjectCacheEntry returns the distributed table metadata for the
 * passed relationId. For efficiency it caches lookups.
 */</comment>
<function><type><name>DistObjectCacheEntry</name> <modifier>*</modifier></type>
<name>LookupDistObjectCacheEntry</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>classid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>objid</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>objsubid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>foundInCache</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DistObjectCacheEntryKey</name></type> <name>hashKey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>pgDistObjectKey</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hashKey</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DistObjectCacheEntryKey</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashKey</name><operator>.</operator><name>classid</name></name> <operator>=</operator> <name>classid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashKey</name><operator>.</operator><name>objid</name></name> <operator>=</operator> <name>objid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashKey</name><operator>.</operator><name>objsubid</name></name> <operator>=</operator> <name>objsubid</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Can't be a distributed relation if the extension hasn't been loaded
	 * yet. As we can't do lookups in nonexistent tables, directly return NULL
	 * here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CitusHasBeenLoaded</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>InitializeCaches</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>DistObjectCacheEntry</name> <modifier>*</modifier></type><name>cacheEntry</name> <init>= <expr><call><name>hash_search</name><argument_list>(<argument><expr><name>DistObjectCacheHash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hashKey</name></expr></argument>,
												   <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>foundInCache</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* return valid matches */</comment>
	<if_stmt><if>if <condition>(<expr><name>foundInCache</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We might have some concurrent metadata changes. In order to get the changes,
		 * we first need to accept the cache invalidation messages.
		 */</comment>
		<expr_stmt><expr><call><name>AcceptInvalidationMessages</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>isValid</name></name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>cacheEntry</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * This is where we'd free the old entry's out of band data if it had any.
		 * Right now we don't have anything to free.
		 */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* zero out entry, but not the key part */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>cacheEntry</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DistObjectCacheEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>classid</name></name> <operator>=</operator> <name>classid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>objid</name></name> <operator>=</operator> <name>objid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>objsubid</name></name> <operator>=</operator> <name>objsubid</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>pgDistObjectRel</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><call><name>DistObjectRelationId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>pgDistObjectTupleDesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pgDistObjectRel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pgDistObjectKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_pg_dist_object_classid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>classid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pgDistObjectKey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_pg_dist_object_objid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>objid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pgDistObjectKey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_pg_dist_object_objsubid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_INT4EQ</name></expr></argument>, <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>objsubid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>pgDistObjectScan</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pgDistObjectRel</name></expr></argument>,
													  <argument><expr><call><name>DistObjectPrimaryKeyIndexId</name><argument_list>()</argument_list></call></expr></argument>,
													  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>pgDistObjectKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>pgDistObjectTup</name> <init>= <expr><call><name>systable_getnext</name><argument_list>(<argument><expr><name>pgDistObjectScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>pgDistObjectTup</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type> <name><name>datumArray</name><index>[<expr><name>Natts_pg_dist_object</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name><name>isNullArray</name><index>[<expr><name>Natts_pg_dist_object</name></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><name>pgDistObjectTup</name></expr></argument>, <argument><expr><name>pgDistObjectTupleDesc</name></expr></argument>, <argument><expr><name>datumArray</name></expr></argument>,
						  <argument><expr><name>isNullArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>isValid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>isDistributed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>distributionArgIndex</name></name> <operator>=</operator>
			<call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>datumArray</name><index>[<expr><name>Anum_pg_dist_object_distribution_argument_index</name> <operator>-</operator>
									 <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>colocationId</name></name> <operator>=</operator>
			<call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>datumArray</name><index>[<expr><name>Anum_pg_dist_object_colocationid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>forceDelegation</name></name> <operator>=</operator>
			<call><name>DatumGetBool</name><argument_list>(<argument><expr><name><name>datumArray</name><index>[<expr><name>Anum_pg_dist_object_force_delegation</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>isValid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>isDistributed</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>pgDistObjectScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>pgDistObjectRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>cacheEntry</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * BuildCitusTableCacheEntry is a helper routine for
 * LookupCitusTableCacheEntry() for building the cache contents.
 * This function returns NULL if the relation isn't a distributed table.
 */</comment>
<function><type><specifier>static</specifier> <name>CitusTableCacheEntry</name> <modifier>*</modifier></type>
<name>BuildCitusTableCacheEntry</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>pgDistPartition</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><call><name>DistPartitionRelationId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>distPartitionTuple</name> <init>=
		<expr><call><name>LookupDistPartitionTuple</name><argument_list>(<argument><expr><name>pgDistPartition</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>distPartitionTuple</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* not a distributed table, done */</comment>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pgDistPartition</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name><name>datumArray</name><index>[<expr><name>Natts_pg_dist_partition</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name><name>isNullArray</name><index>[<expr><name>Natts_pg_dist_partition</name></expr>]</index></name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pgDistPartition</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><name>distPartitionTuple</name></expr></argument>, <argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><name>datumArray</name></expr></argument>, <argument><expr><name>isNullArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>cacheEntry</name> <init>=
		<expr><call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>MetadataCacheMemoryContext</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CitusTableCacheEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>relationId</name></name> <operator>=</operator> <name>relationId</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>partitionMethod</name></name> <operator>=</operator> <name><name>datumArray</name><index>[<expr><name>Anum_pg_dist_partition_partmethod</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>partitionKeyDatum</name> <init>= <expr><name><name>datumArray</name><index>[<expr><name>Anum_pg_dist_partition_partkey</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>partitionKeyIsNull</name> <init>= <expr><name><name>isNullArray</name><index>[<expr><name>Anum_pg_dist_partition_partkey</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* note that for reference tables partitionKeyisNull is true */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>partitionKeyIsNull</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>MetadataCacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* get the string representation of the partition column Var */</comment>
		<expr_stmt><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>partitionKeyString</name></name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>partitionKeyDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* convert the string to a Node and ensure it is a Var */</comment>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>partitionNode</name> <init>= <expr><call><name>stringToNode</name><argument_list>(<argument><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>partitionKeyString</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>partitionNode</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>partitionColumn</name></name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>partitionNode</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>partitionKeyString</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>colocationId</name></name> <operator>=</operator> <name><name>datumArray</name><index>[<expr><name>Anum_pg_dist_partition_colocationid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>isNullArray</name><index>[<expr><name>Anum_pg_dist_partition_colocationid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>colocationId</name></name> <operator>=</operator> <name>INVALID_COLOCATION_ID</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Datum</name></type> <name>replicationModelDatum</name> <init>= <expr><name><name>datumArray</name><index>[<expr><name>Anum_pg_dist_partition_repmodel</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>isNullArray</name><index>[<expr><name>Anum_pg_dist_partition_repmodel</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * repmodel is NOT NULL but before ALTER EXTENSION citus UPGRADE the column
		 * doesn't exist
		 */</comment>
		<expr_stmt><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>replicationModel</name></name> <operator>=</operator> <literal type="char">'c'</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>replicationModel</name></name> <operator>=</operator> <call><name>DatumGetChar</name><argument_list>(<argument><expr><name>replicationModelDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>isNullArray</name><index>[<expr><name>Anum_pg_dist_partition_autoconverted</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We don't expect this to happen, but set it to false (the default value)
		 * to not break if anything goes wrong.
		 */</comment>
		<expr_stmt><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>autoConverted</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>autoConverted</name></name> <operator>=</operator> <call><name>DatumGetBool</name><argument_list>(
			<argument><expr><name><name>datumArray</name><index>[<expr><name>Anum_pg_dist_partition_autoconverted</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>distPartitionTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>BuildCachedShardList</name><argument_list>(<argument><expr><name>cacheEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* we only need hash functions for hash distributed tables */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>partitionMethod</name></name> <operator>==</operator> <name>DISTRIBUTE_BY_HASH</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>partitionColumn</name> <init>= <expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>partitionColumn</name></name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typeEntry</name> <init>= <expr><call><name>lookup_type_cache</name><argument_list>(<argument><expr><name><name>partitionColumn</name><operator>-&gt;</operator><name>vartype</name></name></expr></argument>,
													  <argument><expr><name>TYPECACHE_HASH_PROC_FINFO</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>hashFunction</name> <init>= <expr><call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>MetadataCacheMemoryContext</name></expr></argument>,
														<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>fmgr_info_copy</name><argument_list>(<argument><expr><name>hashFunction</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>typeEntry</name><operator>-&gt;</operator><name>hash_proc_finfo</name></name><operator>)</operator></expr></argument>,
					   <argument><expr><name>MetadataCacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>hashFunction</name></name> <operator>=</operator> <name>hashFunction</name></expr>;</expr_stmt>

		<comment type="block">/* check the shard distribution for hash partitioned tables */</comment>
		<expr_stmt><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>hasUniformHashDistribution</name></name> <operator>=</operator>
			<call><name>HasUniformHashDistribution</name><argument_list>(<argument><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>sortedShardIntervalArray</name></name></expr></argument>,
									   <argument><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>shardIntervalArrayLength</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>hashFunction</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>MetadataCacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>referencedRelationsViaForeignKey</name></name> <operator>=</operator> <call><name>ReferencedRelationIdList</name><argument_list>(
		<argument><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>referencingRelationsViaForeignKey</name></name> <operator>=</operator> <call><name>ReferencingRelationIdList</name><argument_list>(
		<argument><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pgDistPartition</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>isValid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<return>return <expr><name>cacheEntry</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * BuildCachedShardList() is a helper routine for BuildCitusTableCacheEntry()
 * building up the list of shards in a distributed relation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>BuildCachedShardList</name><parameter_list>(<parameter><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>cacheEntry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier><modifier>*</modifier></type><name>shardIntervalArray</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier><modifier>*</modifier></type><name>sortedShardIntervalArray</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>shardIntervalCompareFunction</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>shardColumnCompareFunction</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>columnTypeId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>columnTypeMod</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>intervalTypeId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>intervalTypeMod</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>GetPartitionTypeInputInfo</name><argument_list>(<argument><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>partitionKeyString</name></name></expr></argument>,
							  <argument><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>partitionMethod</name></name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>columnTypeId</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>columnTypeMod</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>intervalTypeId</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>intervalTypeMod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>distShardTupleList</name> <init>= <expr><call><name>LookupDistShardTuples</name><argument_list>(<argument><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>shardIntervalArrayLength</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>distShardTupleList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>shardIntervalArrayLength</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type> <name>distShardRelation</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><call><name>DistShardRelationId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleDesc</name></type> <name>distShardTupleDesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>distShardRelation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>arrayIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>shardIntervalArray</name> <operator>=</operator> <call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>MetadataCacheMemoryContext</name></expr></argument>,
													<argument><expr><name>shardIntervalArrayLength</name> <operator>*</operator>
													<sizeof>sizeof<argument_list>(<argument><expr><name>ShardInterval</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>arrayOfPlacementArrays</name></name> <operator>=</operator>
			<call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>MetadataCacheMemoryContext</name></expr></argument>,
								   <argument><expr><name>shardIntervalArrayLength</name> <operator>*</operator>
								   <sizeof>sizeof<argument_list>(<argument><expr><name>GroupShardPlacement</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>arrayOfPlacementArrayLengths</name></name> <operator>=</operator>
			<call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>MetadataCacheMemoryContext</name></expr></argument>,
								   <argument><expr><name>shardIntervalArrayLength</name> <operator>*</operator>
								   <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>HeapTuple</name></type> <name>shardTuple</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>shardTuple</argument>, <argument>distShardTupleList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><call><name>TupleToShardInterval</name><argument_list>(<argument><expr><name>shardTuple</name></expr></argument>,
																<argument><expr><name>distShardTupleDesc</name></expr></argument>,
																<argument><expr><name>intervalTypeId</name></expr></argument>,
																<argument><expr><name>intervalTypeMod</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>MetadataCacheMemoryContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>shardIntervalArray</name><index>[<expr><name>arrayIndex</name></expr>]</index></name> <operator>=</operator> <call><name>CopyShardInterval</name><argument_list>(<argument><expr><name>shardInterval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>shardTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>arrayIndex</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>distShardRelation</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* look up value comparison function */</comment>
	<if_stmt><if>if <condition>(<expr><name>columnTypeId</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* allocate the comparison function in the cache context */</comment>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>MetadataCacheMemoryContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>shardColumnCompareFunction</name> <operator>=</operator> <call><name>GetFunctionInfo</name><argument_list>(<argument><expr><name>columnTypeId</name></expr></argument>, <argument><expr><name>BTREE_AM_OID</name></expr></argument>,
													 <argument><expr><name>BTORDER_PROC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>shardColumnCompareFunction</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* look up interval comparison function */</comment>
	<if_stmt><if>if <condition>(<expr><name>intervalTypeId</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* allocate the comparison function in the cache context */</comment>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>MetadataCacheMemoryContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>shardIntervalCompareFunction</name> <operator>=</operator> <call><name>GetFunctionInfo</name><argument_list>(<argument><expr><name>intervalTypeId</name></expr></argument>, <argument><expr><name>BTREE_AM_OID</name></expr></argument>,
													   <argument><expr><name>BTORDER_PROC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>shardIntervalCompareFunction</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* reference tables has a single shard which is not initialized */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>partitionMethod</name></name> <operator>==</operator> <name>DISTRIBUTE_BY_NONE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>hasUninitializedShardInterval</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>hasOverlappingShardInterval</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Note that during create_reference_table() call,
		 * the reference table do not have any shards.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>shardIntervalArrayLength</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"reference table \"%s\" has more than 1 shard"</literal></expr></argument>,
								   <argument><expr><name>relationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* since there is a zero or one shard, it is already sorted */</comment>
		<expr_stmt><expr><name>sortedShardIntervalArray</name> <operator>=</operator> <name>shardIntervalArray</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* sort the interval array */</comment>
		<expr_stmt><expr><name>sortedShardIntervalArray</name> <operator>=</operator> <call><name>SortShardIntervalArray</name><argument_list>(<argument><expr><name>shardIntervalArray</name></expr></argument>,
														  <argument><expr><name>shardIntervalArrayLength</name></expr></argument>,
														  <argument><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>partitionColumn</name><operator>-&gt;</operator>
														  <name>varcollid</name></name></expr></argument>,
														  <argument><expr><name>shardIntervalCompareFunction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* check if there exists any shard intervals with no min/max values */</comment>
		<expr_stmt><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>hasUninitializedShardInterval</name></name> <operator>=</operator>
			<call><name>HasUninitializedShardInterval</name><argument_list>(<argument><expr><name>sortedShardIntervalArray</name></expr></argument>,
										  <argument><expr><name>shardIntervalArrayLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cacheEntry</name><operator>-&gt;</operator><name>hasUninitializedShardInterval</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>hasOverlappingShardInterval</name></name> <operator>=</operator>
				<call><name>HasOverlappingShardInterval</name><argument_list>(<argument><expr><name>sortedShardIntervalArray</name></expr></argument>,
											<argument><expr><name>shardIntervalArrayLength</name></expr></argument>,
											<argument><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>partitionColumn</name><operator>-&gt;</operator><name>varcollid</name></name></expr></argument>,
											<argument><expr><name>shardIntervalCompareFunction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>hasOverlappingShardInterval</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>ErrorIfInconsistentShardIntervals</name><argument_list>(<argument><expr><name>cacheEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>sortedShardIntervalArray</name></name> <operator>=</operator> <name>sortedShardIntervalArray</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>shardIntervalArrayLength</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* maintain shardId-&gt;(table,ShardInterval) cache */</comment>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>shardIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>shardIndex</name> <operator>&lt;</operator> <name>shardIntervalArrayLength</name></expr>;</condition> <incr><expr><name>shardIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><name><name>sortedShardIntervalArray</name><index>[<expr><name>shardIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int64</name></type> <name>shardId</name> <init>= <expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>placementOffset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Enable quick lookups of this shard ID by adding it to ShardIdCacheHash
		 * or overwriting the previous values.
		 */</comment>
		<decl_stmt><decl><type><name>ShardIdCacheEntry</name> <modifier>*</modifier></type><name>shardIdCacheEntry</name> <init>=
			<expr><call><name>hash_search</name><argument_list>(<argument><expr><name>ShardIdCacheHash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shardId</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>shardIdCacheEntry</name><operator>-&gt;</operator><name>tableEntry</name></name> <operator>=</operator> <name>cacheEntry</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shardIdCacheEntry</name><operator>-&gt;</operator><name>shardIndex</name></name> <operator>=</operator> <name>shardIndex</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * We should increment this only after we are sure this hasn't already
		 * been assigned to any other relations. ResetCitusTableCacheEntry()
		 * depends on this.
		 */</comment>
		<expr_stmt><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>shardIntervalArrayLength</name></name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/* build list of shard placements */</comment>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>placementList</name> <init>= <expr><call><name>BuildShardPlacementList</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>numberOfPlacements</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>placementList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* and copy that list into the cache entry */</comment>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>MetadataCacheMemoryContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>GroupShardPlacement</name> <modifier>*</modifier></type><name>placementArray</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><name>numberOfPlacements</name> <operator>*</operator>
													  <sizeof>sizeof<argument_list>(<argument><expr><name>GroupShardPlacement</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>GroupShardPlacement</name> <modifier>*</modifier></type><name>srcPlacement</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>srcPlacement</argument>, <argument>placementList</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name><name>placementArray</name><index>[<expr><name>placementOffset</name></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>srcPlacement</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>placementOffset</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>arrayOfPlacementArrays</name><index>[<expr><name>shardIndex</name></expr>]</index></name> <operator>=</operator> <name>placementArray</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>arrayOfPlacementArrayLengths</name><index>[<expr><name>shardIndex</name></expr>]</index></name> <operator>=</operator> <name>numberOfPlacements</name></expr>;</expr_stmt>

		<comment type="block">/* store the shard index in the ShardInterval */</comment>
		<expr_stmt><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardIndex</name></name> <operator>=</operator> <name>shardIndex</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>shardColumnCompareFunction</name></name> <operator>=</operator> <name>shardColumnCompareFunction</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>shardIntervalCompareFunction</name></name> <operator>=</operator> <name>shardIntervalCompareFunction</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ErrorIfInconsistentShardIntervals checks if shard intervals are consistent with
 * our expectations.
 */</comment>
<function><type><name>void</name></type>
<name>ErrorIfInconsistentShardIntervals</name><parameter_list>(<parameter><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>cacheEntry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If table is hash-partitioned and has shards, there never should be any
	 * uninitalized shards.  Historically we've not prevented that for range
	 * partitioned tables, but it might be a good idea to start doing so.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>partitionMethod</name></name> <operator>==</operator> <name>DISTRIBUTE_BY_HASH</name> <operator>&amp;&amp;</operator>
		<name><name>cacheEntry</name><operator>-&gt;</operator><name>hasUninitializedShardInterval</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"hash partitioned table has uninitialized shards"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>partitionMethod</name></name> <operator>==</operator> <name>DISTRIBUTE_BY_HASH</name> <operator>&amp;&amp;</operator>
		<name><name>cacheEntry</name><operator>-&gt;</operator><name>hasOverlappingShardInterval</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"hash partitioned table has overlapping shards"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * HasUniformHashDistribution determines whether the given list of sorted shards
 * has a uniform hash distribution, as produced by master_create_worker_shards for
 * hash partitioned tables.
 */</comment>
<function><type><name>bool</name></type>
<name>HasUniformHashDistribution</name><parameter_list>(<parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier><modifier>*</modifier></type><name>shardIntervalArray</name></decl></parameter>,
						   <parameter><decl><type><name>int</name></type> <name>shardIntervalArrayLength</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* if there are no shards, there is no uniform distribution */</comment>
	<if_stmt><if>if <condition>(<expr><name>shardIntervalArrayLength</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* calculate the hash token increment */</comment>
	<decl_stmt><decl><type><name>uint64</name></type> <name>hashTokenIncrement</name> <init>= <expr><name>HASH_TOKEN_COUNT</name> <operator>/</operator> <name>shardIntervalArrayLength</name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>shardIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>shardIndex</name> <operator>&lt;</operator> <name>shardIntervalArrayLength</name></expr>;</condition> <incr><expr><name>shardIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><name><name>shardIntervalArray</name><index>[<expr><name>shardIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type> <name>shardMinHashToken</name> <init>= <expr><name>PG_INT32_MIN</name> <operator>+</operator> <operator>(</operator><name>shardIndex</name> <operator>*</operator> <name>hashTokenIncrement</name><operator>)</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type> <name>shardMaxHashToken</name> <init>= <expr><name>shardMinHashToken</name> <operator>+</operator> <operator>(</operator><name>hashTokenIncrement</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>shardIndex</name> <operator>==</operator> <operator>(</operator><name>shardIntervalArrayLength</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>shardMaxHashToken</name> <operator>=</operator> <name>PG_INT32_MAX</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>minValue</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>shardMinHashToken</name> <operator>||</operator>
			<call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>maxValue</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>shardMaxHashToken</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * HasUninitializedShardInterval returns true if all the elements of the
 * sortedShardIntervalArray has min/max values. Callers of the function must
 * ensure that input shard interval array is sorted on shardminvalue and uninitialized
 * shard intervals are at the end of the array.
 */</comment>
<function><type><name>bool</name></type>
<name>HasUninitializedShardInterval</name><parameter_list>(<parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier><modifier>*</modifier></type><name>sortedShardIntervalArray</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>shardCount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>hasUninitializedShardInterval</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>shardCount</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>hasUninitializedShardInterval</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>sortedShardIntervalArray</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Since the shard interval array is sorted, and uninitialized ones stored
	 * in the end of the array, checking the last element is enough.
	 */</comment>
	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>lastShardInterval</name> <init>= <expr><name><name>sortedShardIntervalArray</name><index>[<expr><name>shardCount</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>lastShardInterval</name><operator>-&gt;</operator><name>minValueExists</name></name> <operator>||</operator> <operator>!</operator><name><name>lastShardInterval</name><operator>-&gt;</operator><name>maxValueExists</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>hasUninitializedShardInterval</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>hasUninitializedShardInterval</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * HasOverlappingShardInterval determines whether the given list of sorted
 * shards has overlapping ranges.
 */</comment>
<function><type><name>bool</name></type>
<name>HasOverlappingShardInterval</name><parameter_list>(<parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier><modifier>*</modifier></type><name>shardIntervalArray</name></decl></parameter>,
							<parameter><decl><type><name>int</name></type> <name>shardIntervalArrayLength</name></decl></parameter>,
							<parameter><decl><type><name>Oid</name></type> <name>shardIntervalCollation</name></decl></parameter>,
							<parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>shardIntervalSortCompareFunction</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type> <name>comparisonDatum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>comparisonResult</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* zero/a single shard can't overlap */</comment>
	<if_stmt><if>if <condition>(<expr><name>shardIntervalArrayLength</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>lastShardInterval</name> <init>= <expr><name><name>shardIntervalArray</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>shardIndex</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>shardIndex</name> <operator>&lt;</operator> <name>shardIntervalArrayLength</name></expr>;</condition> <incr><expr><name>shardIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>curShardInterval</name> <init>= <expr><name><name>shardIntervalArray</name><index>[<expr><name>shardIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* only called if !hasUninitializedShardInterval */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>lastShardInterval</name><operator>-&gt;</operator><name>minValueExists</name></name> <operator>&amp;&amp;</operator> <name><name>lastShardInterval</name><operator>-&gt;</operator><name>maxValueExists</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>curShardInterval</name><operator>-&gt;</operator><name>minValueExists</name></name> <operator>&amp;&amp;</operator> <name><name>curShardInterval</name><operator>-&gt;</operator><name>maxValueExists</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>comparisonDatum</name> <operator>=</operator> <call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><name>shardIntervalSortCompareFunction</name></expr></argument>,
											<argument><expr><name>shardIntervalCollation</name></expr></argument>,
											<argument><expr><name><name>lastShardInterval</name><operator>-&gt;</operator><name>maxValue</name></name></expr></argument>,
											<argument><expr><name><name>curShardInterval</name><operator>-&gt;</operator><name>minValue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>comparisonResult</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>comparisonDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>comparisonResult</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>lastShardInterval</name> <operator>=</operator> <name>curShardInterval</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CitusHasBeenLoaded returns true if the citus extension has been created
 * in the current database and the extension script has been executed. Otherwise,
 * it returns false. The result is cached as this is called very frequently.
 */</comment>
<function><type><name>bool</name></type>
<name>CitusHasBeenLoaded</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>MetadataCache</name><operator>.</operator><name>extensionLoaded</name></name> <operator>||</operator> <name>creating_extension</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Refresh if we have not determined whether the extension has been
		 * loaded yet, or in case of ALTER EXTENSION since we want to treat
		 * Citus as "not loaded" during ALTER EXTENSION citus.
		 */</comment>
		<decl_stmt><decl><type><name>bool</name></type> <name>extensionLoaded</name> <init>= <expr><call><name>CitusHasBeenLoadedInternal</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>extensionLoaded</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>MetadataCache</name><operator>.</operator><name>extensionLoaded</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Loaded Citus for the first time in this session, or first time after
			 * CREATE/ALTER EXTENSION citus. Do some initialisation.
			 */</comment>

			<comment type="block">/*
			 * Make sure the maintenance daemon is running if it was not already.
			 */</comment>
			<expr_stmt><expr><call><name>StartupCitusBackend</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * InvalidateDistRelationCacheCallback resets state such as extensionLoaded
			 * when it notices changes to pg_dist_partition (which usually indicate
			 * `DROP EXTENSION citus;` has been run)
			 *
			 * Ensure InvalidateDistRelationCacheCallback will notice those changes
			 * by caching pg_dist_partition's oid.
			 *
			 * We skip these checks during upgrade since pg_dist_partition is not
			 * present during early stages of upgrade operation.
			 */</comment>
			<expr_stmt><expr><call><name>DistPartitionRelationId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * This needs to be initialized so we can receive foreign relation graph
			 * invalidation messages in InvalidateForeignRelationGraphCacheCallback().
			 * See the comments of InvalidateForeignKeyGraph for more context.
			 */</comment>
			<expr_stmt><expr><call><name>DistColocationRelationId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>MetadataCache</name><operator>.</operator><name>extensionLoaded</name></name> <operator>=</operator> <name>extensionLoaded</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>extensionLoaded</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CitusHasBeenLoadedInternal returns true if the citus extension has been created
 * in the current database and the extension script has been executed. Otherwise,
 * it returns false.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>CitusHasBeenLoadedInternal</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>IsBinaryUpgrade</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* never use Citus logic during pg_upgrade */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>citusExtensionOid</name> <init>= <expr><call><name>get_extension_oid</name><argument_list>(<argument><expr><literal type="string">"citus"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>citusExtensionOid</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Citus extension does not exist yet */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>creating_extension</name> <operator>&amp;&amp;</operator> <name>CurrentExtensionObject</name> <operator>==</operator> <name>citusExtensionOid</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We do not use Citus hooks during CREATE/ALTER EXTENSION citus
		 * since the objects used by the C code might be not be there yet.
		 */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* citus extension exists and has been created */</comment>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetCitusCreationLevel returns the level of the transaction creating citus
 */</comment>
<function><type><name>int</name></type>
<name>GetCitusCreationLevel</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>CreateCitusTransactionLevel</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Sets the value of CreateCitusTransactionLevel based on int received which represents the
 * nesting level of the transaction that created the Citus extension
 */</comment>
<function><type><name>void</name></type>
<name>SetCreateCitusTransactionLevel</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>CreateCitusTransactionLevel</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CheckCitusVersion checks whether there is a version mismatch between the
 * available version and the loaded version or between the installed version
 * and the loaded version. Returns true if compatible, false otherwise.
 *
 * As a side effect, this function also sets citusVersionKnownCompatible global
 * variable to true which reduces version check cost of next calls.
 */</comment>
<function><type><name>bool</name></type>
<name>CheckCitusVersion</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>citusVersionKnownCompatible</name> <operator>||</operator>
		<operator>!</operator><call><name>CitusHasBeenLoaded</name><argument_list>()</argument_list></call> <operator>||</operator>
		<operator>!</operator><name>EnableVersionChecks</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CheckAvailableVersion</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>CheckInstalledVersion</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>citusVersionKnownCompatible</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CheckAvailableVersion compares CITUS_EXTENSIONVERSION and the currently
 * available version from the citus.control file. If they are not compatible,
 * this function logs an error with the specified elevel and returns false,
 * otherwise it returns true.
 */</comment>
<function><type><name>bool</name></type>
<name>CheckAvailableVersion</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>EnableVersionChecks</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>availableVersion</name> <init>= <expr><call><name>AvailableExtensionVersion</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MajorVersionsCompatible</name><argument_list>(<argument><expr><name>availableVersion</name></expr></argument>, <argument><expr><name>CITUS_EXTENSIONVERSION</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"loaded Citus library version differs from latest "</literal>
								<literal type="string">"available extension version"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Loaded library requires %s, but the latest control "</literal>
								   <literal type="string">"file specifies %s."</literal></expr></argument>, <argument><expr><name>CITUS_MAJORVERSION</name></expr></argument>,
								   <argument><expr><name>availableVersion</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Restart the database to load the latest Citus "</literal>
								 <literal type="string">"library."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CheckInstalledVersion compares CITUS_EXTENSIONVERSION and the
 * extension's current version from the pg_extension catalog table. If they
 * are not compatible, this function logs an error with the specified elevel,
 * otherwise it returns true.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>CheckInstalledVersion</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>CitusHasBeenLoaded</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>EnableVersionChecks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>installedVersion</name> <init>= <expr><call><name>InstalledExtensionVersion</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MajorVersionsCompatible</name><argument_list>(<argument><expr><name>installedVersion</name></expr></argument>, <argument><expr><name>CITUS_EXTENSIONVERSION</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"loaded Citus library version differs from installed "</literal>
								<literal type="string">"extension version"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Loaded library requires %s, but the installed "</literal>
								   <literal type="string">"extension version is %s."</literal></expr></argument>, <argument><expr><name>CITUS_MAJORVERSION</name></expr></argument>,
								   <argument><expr><name>installedVersion</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Run ALTER EXTENSION citus UPDATE and try again."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * InstalledAndAvailableVersionsSame compares extension's available version and
 * its current version from the pg_extension catalog table. If they are not same
 * returns false, otherwise returns true.
 */</comment>
<function><type><name>bool</name></type>
<name>InstalledAndAvailableVersionsSame</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>installedVersion</name> <init>= <expr><call><name>InstalledExtensionVersion</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>availableVersion</name> <init>= <expr><call><name>AvailableExtensionVersion</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>installedVersion</name></expr></argument>, <argument><expr><name>availableVersion</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * MajorVersionsCompatible checks whether both versions are compatible. They
 * are if major and minor version numbers match, the schema version is
 * ignored.  Returns true if compatible, false otherwise.
 */</comment>
<function><type><name>bool</name></type>
<name>MajorVersionsCompatible</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>leftVersion</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>rightVersion</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name>schemaVersionSeparator</name> <init>= <expr><literal type="char">'-'</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>leftSeperatorPosition</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>leftVersion</name></expr></argument>, <argument><expr><name>schemaVersionSeparator</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>rightSeperatorPosition</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>rightVersion</name></expr></argument>, <argument><expr><name>schemaVersionSeparator</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>leftComparisionLimit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rightComparisionLimit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>leftSeperatorPosition</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>leftComparisionLimit</name> <operator>=</operator> <name>leftSeperatorPosition</name> <operator>-</operator> <name>leftVersion</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>leftComparisionLimit</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>leftVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>rightSeperatorPosition</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>rightComparisionLimit</name> <operator>=</operator> <name>rightSeperatorPosition</name> <operator>-</operator> <name>rightVersion</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>rightComparisionLimit</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>leftVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* we can error out early if hypens are not in the same position */</comment>
	<if_stmt><if>if <condition>(<expr><name>leftComparisionLimit</name> <operator>!=</operator> <name>rightComparisionLimit</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>strncmp</name><argument_list>(<argument><expr><name>leftVersion</name></expr></argument>, <argument><expr><name>rightVersion</name></expr></argument>, <argument><expr><name>leftComparisionLimit</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AvailableExtensionVersion returns the Citus version from citus.control file. It also
 * saves the result, thus consecutive calls to CitusExtensionAvailableVersion will
 * not read the citus.control file again.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>AvailableExtensionVersion</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LOCAL_FCINFO</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name></type> <name>flinfo</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>goForward</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>doCopy</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>availableExtensionVersion</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>InitializeCaches</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name> <init>= <expr><call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ReturnSetInfo</name> <modifier>*</modifier></type><name>extensionsResultSet</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ReturnSetInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>extensionsResultSet</name><operator>-&gt;</operator><name>econtext</name></name> <operator>=</operator> <call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>extensionsResultSet</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>=</operator> <name>SFRM_Materialize</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>F_PG_AVAILABLE_EXTENSIONS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name>fcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>extensionsResultSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* pg_available_extensions returns result set containing all available extensions */</comment>
	<expr_stmt><expr><call>(<modifier>*</modifier><name>pg_available_extensions</name>)<argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>tupleTableSlot</name> <init>= <expr><call><name>MakeSingleTupleTableSlot</name><argument_list>(
		<argument><expr><name><name>extensionsResultSet</name><operator>-&gt;</operator><name>setDesc</name></name></expr></argument>,
		<argument><expr><operator>&amp;</operator><name>TTSOpsMinimalTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>hasTuple</name> <init>= <expr><call><name>tuplestore_gettupleslot</name><argument_list>(<argument><expr><name><name>extensionsResultSet</name><operator>-&gt;</operator><name>setResult</name></name></expr></argument>, <argument><expr><name>goForward</name></expr></argument>,
											<argument><expr><name>doCopy</name></expr></argument>,
											<argument><expr><name>tupleTableSlot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><name>hasTuple</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>isNull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Datum</name></type> <name>extensionNameDatum</name> <init>= <expr><call><name>slot_getattr</name><argument_list>(<argument><expr><name>tupleTableSlot</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>extensionName</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><call><name>DatumGetName</name><argument_list>(<argument><expr><name>extensionNameDatum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>extensionName</name></expr></argument>, <argument><expr><literal type="string">"citus"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type> <name>availableVersion</name> <init>= <expr><call><name>slot_getattr</name><argument_list>(<argument><expr><name>tupleTableSlot</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* we will cache the result of citus version to prevent catalog access */</comment>
			<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldMemoryContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(
				<argument><expr><name>MetadataCacheMemoryContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>availableExtensionVersion</name> <operator>=</operator> <call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>DatumGetTextPP</name><argument_list>(<argument><expr><name>availableVersion</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>tupleTableSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name>tupleTableSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<return>return <expr><name>availableExtensionVersion</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>tupleTableSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>hasTuple</name> <operator>=</operator> <call><name>tuplestore_gettupleslot</name><argument_list>(<argument><expr><name><name>extensionsResultSet</name><operator>-&gt;</operator><name>setResult</name></name></expr></argument>, <argument><expr><name>goForward</name></expr></argument>,
										   <argument><expr><name>doCopy</name></expr></argument>, <argument><expr><name>tupleTableSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name>tupleTableSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"citus extension is not found"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * InstalledExtensionVersion returns the Citus version in PostgreSQL pg_extension table.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>InstalledExtensionVersion</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>entry</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>installedExtensionVersion</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>InitializeCaches</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>ExtensionRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_pg_extension_extname</name></expr></argument>, <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_NAMEEQ</name></expr></argument>,
				<argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><literal type="string">"citus"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scandesc</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>ExtensionNameIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
											  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>extensionTuple</name> <init>= <expr><call><name>systable_getnext</name><argument_list>(<argument><expr><name>scandesc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* We assume that there can be at most one matching tuple */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>extensionTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>extensionIndex</name> <init>= <expr><name>Anum_pg_extension_extversion</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>isNull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Datum</name></type> <name>installedVersion</name> <init>= <expr><call><name>heap_getattr</name><argument_list>(<argument><expr><name>extensionTuple</name></expr></argument>, <argument><expr><name>extensionIndex</name></expr></argument>,
											  <argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"citus extension version is null"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* we will cache the result of citus version to prevent catalog access */</comment>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldMemoryContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(
			<argument><expr><name>MetadataCacheMemoryContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>installedExtensionVersion</name> <operator>=</operator> <call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>DatumGetTextPP</name><argument_list>(<argument><expr><name>installedVersion</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"citus extension is not loaded"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scandesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>installedExtensionVersion</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* return oid of pg_dist_shard relation */</comment>
<function><type><name>Oid</name></type>
<name>DistShardRelationId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CachedRelationLookup</name><argument_list>(<argument><expr><literal type="string">"pg_dist_shard"</literal></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>MetadataCache</name><operator>.</operator><name>distShardRelationId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>distShardRelationId</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* return oid of pg_dist_placement relation */</comment>
<function><type><name>Oid</name></type>
<name>DistPlacementRelationId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CachedRelationLookup</name><argument_list>(<argument><expr><literal type="string">"pg_dist_placement"</literal></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>MetadataCache</name><operator>.</operator><name>distPlacementRelationId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>distPlacementRelationId</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* return oid of pg_dist_node relation */</comment>
<function><type><name>Oid</name></type>
<name>DistNodeRelationId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CachedRelationLookup</name><argument_list>(<argument><expr><literal type="string">"pg_dist_node"</literal></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>MetadataCache</name><operator>.</operator><name>distNodeRelationId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>distNodeRelationId</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* return oid of pg_dist_node's primary key index */</comment>
<function><type><name>Oid</name></type>
<name>DistNodeNodeIdIndexId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CachedRelationLookup</name><argument_list>(<argument><expr><literal type="string">"pg_dist_node_pkey"</literal></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>MetadataCache</name><operator>.</operator><name>distNodeNodeIdIndexId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>distNodeNodeIdIndexId</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* return oid of pg_dist_local_group relation */</comment>
<function><type><name>Oid</name></type>
<name>DistLocalGroupIdRelationId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CachedRelationLookup</name><argument_list>(<argument><expr><literal type="string">"pg_dist_local_group"</literal></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>MetadataCache</name><operator>.</operator><name>distLocalGroupRelationId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>distLocalGroupRelationId</name></name></expr>;</return>
</block_content>}</block></function>


<function><type><name>Oid</name></type>
<name>DistBackgroundJobRelationId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CachedRelationLookup</name><argument_list>(<argument><expr><literal type="string">"pg_dist_background_job"</literal></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>MetadataCache</name><operator>.</operator><name>distBackgroundJobRelationId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>distBackgroundJobRelationId</name></name></expr>;</return>
</block_content>}</block></function>


<function><type><name>Oid</name></type>
<name>DistBackgroundJobPKeyIndexId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CachedRelationLookup</name><argument_list>(<argument><expr><literal type="string">"pg_dist_background_job_pkey"</literal></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>MetadataCache</name><operator>.</operator><name>distBackgroundJobPKeyIndexId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>distBackgroundJobPKeyIndexId</name></name></expr>;</return>
</block_content>}</block></function>


<function><type><name>Oid</name></type>
<name>DistBackgroundJobJobIdSequenceId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CachedRelationLookup</name><argument_list>(<argument><expr><literal type="string">"pg_dist_background_job_job_id_seq"</literal></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>MetadataCache</name><operator>.</operator><name>distBackgroundJobJobIdSequenceId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>distBackgroundJobJobIdSequenceId</name></name></expr>;</return>
</block_content>}</block></function>


<function><type><name>Oid</name></type>
<name>DistBackgroundTaskRelationId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CachedRelationLookup</name><argument_list>(<argument><expr><literal type="string">"pg_dist_background_task"</literal></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>MetadataCache</name><operator>.</operator><name>distBackgroundTaskRelationId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>distBackgroundTaskRelationId</name></name></expr>;</return>
</block_content>}</block></function>


<function><type><name>Oid</name></type>
<name>DistBackgroundTaskPKeyIndexId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CachedRelationLookup</name><argument_list>(<argument><expr><literal type="string">"pg_dist_background_task_pkey"</literal></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>MetadataCache</name><operator>.</operator><name>distBackgroundTaskPKeyIndexId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>distBackgroundTaskPKeyIndexId</name></name></expr>;</return>
</block_content>}</block></function>


<function><type><name>Oid</name></type>
<name>DistBackgroundTaskJobIdTaskIdIndexId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CachedRelationLookup</name><argument_list>(<argument><expr><literal type="string">"pg_dist_background_task_job_id_task_id"</literal></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>MetadataCache</name><operator>.</operator><name>distBackgroundTaskJobIdTaskIdIndexId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>distBackgroundTaskJobIdTaskIdIndexId</name></name></expr>;</return>
</block_content>}</block></function>


<function><type><name>Oid</name></type>
<name>DistBackgroundTaskStatusTaskIdIndexId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CachedRelationLookup</name><argument_list>(<argument><expr><literal type="string">"pg_dist_background_task_status_task_id_index"</literal></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>MetadataCache</name><operator>.</operator><name>distBackgroundTaskStatusTaskIdIndexId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>distBackgroundTaskStatusTaskIdIndexId</name></name></expr>;</return>
</block_content>}</block></function>


<function><type><name>Oid</name></type>
<name>DistBackgroundTaskTaskIdSequenceId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CachedRelationLookup</name><argument_list>(<argument><expr><literal type="string">"pg_dist_background_task_task_id_seq"</literal></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>MetadataCache</name><operator>.</operator><name>distBackgroundTaskTaskIdSequenceId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>distBackgroundTaskTaskIdSequenceId</name></name></expr>;</return>
</block_content>}</block></function>


<function><type><name>Oid</name></type>
<name>DistClockLogicalSequenceId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CachedRelationLookup</name><argument_list>(<argument><expr><literal type="string">"pg_dist_clock_logical_seq"</literal></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>MetadataCache</name><operator>.</operator><name>distClockLogicalSequenceId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>distClockLogicalSequenceId</name></name></expr>;</return>
</block_content>}</block></function>


<function><type><name>Oid</name></type>
<name>DistBackgroundTaskDependRelationId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CachedRelationLookup</name><argument_list>(<argument><expr><literal type="string">"pg_dist_background_task_depend"</literal></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>MetadataCache</name><operator>.</operator><name>distBackgroundTaskDependRelationId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>distBackgroundTaskDependRelationId</name></name></expr>;</return>
</block_content>}</block></function>


<function><type><name>Oid</name></type>
<name>DistBackgroundTaskDependTaskIdIndexId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CachedRelationLookup</name><argument_list>(<argument><expr><literal type="string">"pg_dist_background_task_depend_task_id"</literal></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>MetadataCache</name><operator>.</operator><name>distBackgroundTaskDependTaskIdIndexId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>distBackgroundTaskDependTaskIdIndexId</name></name></expr>;</return>
</block_content>}</block></function>


<function><type><name>Oid</name></type>
<name>DistBackgroundTaskDependDependsOnIndexId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CachedRelationLookup</name><argument_list>(<argument><expr><literal type="string">"pg_dist_background_task_depend_depends_on"</literal></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>MetadataCache</name><operator>.</operator><name>distBackgroundTaskDependDependsOnIndexId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>distBackgroundTaskDependDependsOnIndexId</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* return oid of pg_dist_rebalance_strategy relation */</comment>
<function><type><name>Oid</name></type>
<name>DistRebalanceStrategyRelationId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CachedRelationLookup</name><argument_list>(<argument><expr><literal type="string">"pg_dist_rebalance_strategy"</literal></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>MetadataCache</name><operator>.</operator><name>distRebalanceStrategyRelationId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>distRebalanceStrategyRelationId</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* return the oid of citus namespace */</comment>
<function><type><name>Oid</name></type>
<name>CitusCatalogNamespaceId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CachedNamespaceLookup</name><argument_list>(<argument><expr><literal type="string">"citus"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>MetadataCache</name><operator>.</operator><name>citusCatalogNamespaceId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>citusCatalogNamespaceId</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* return oid of pg_dist_object relation */</comment>
<function><type><name>Oid</name></type>
<name>DistObjectRelationId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * In older versions pg_dist_object was living in the `citus` namespace, With Citus 11
	 * this has been moved to pg_dist_catalog.
	 *
	 * During upgrades it could therefore be that we simply need to look in the old
	 * catalog. Since we expect to find it most of the time in the pg_catalog schema from
	 * now on we will start there.
	 *
	 * even after the table has been moved, the oid's stay the same, so we don't have to
	 * invalidate the cache after a move
	 *
	 * Note: during testing we also up/downgrade the extension, and sometimes interact
	 * with the database when the schema and the binary are not in sync. Hance we always
	 * allow the catalog to be missing on our first lookup. The error message might
	 * therefore become misleading as it will complain about citus.pg_dist_object not
	 * being found when called too early.
	 */</comment>
	<expr_stmt><expr><call><name>CachedRelationLookupExtended</name><argument_list>(<argument><expr><literal type="string">"pg_dist_object"</literal></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name><name>MetadataCache</name><operator>.</operator><name>distObjectRelationId</name></name></expr></argument>,
								 <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>MetadataCache</name><operator>.</operator><name>distObjectRelationId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We can only ever reach here while we are creating/altering our extension before
		 * the table is moved to pg_catalog.
		 */</comment>
		<expr_stmt><expr><call><name>CachedRelationNamespaceLookupExtended</name><argument_list>(<argument><expr><literal type="string">"pg_dist_object"</literal></expr></argument>,
											  <argument><expr><call><name>CitusCatalogNamespaceId</name><argument_list>()</argument_list></call></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name><name>MetadataCache</name><operator>.</operator><name>distObjectRelationId</name></name></expr></argument>,
											  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>distObjectRelationId</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* return oid of pg_dist_object_pkey */</comment>
<function><type><name>Oid</name></type>
<name>DistObjectPrimaryKeyIndexId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * In older versions pg_dist_object was living in the `citus` namespace, With Citus 11
	 * this has been moved to pg_dist_catalog.
	 *
	 * During upgrades it could therefore be that we simply need to look in the old
	 * catalog. Since we expect to find it most of the time in the pg_catalog schema from
	 * now on we will start there.
	 *
	 * even after the table has been moved, the oid's stay the same, so we don't have to
	 * invalidate the cache after a move
	 *
	 * Note: during testing we also up/downgrade the extension, and sometimes interact
	 * with the database when the schema and the binary are not in sync. Hance we always
	 * allow the catalog to be missing on our first lookup. The error message might
	 * therefore become misleading as it will complain about citus.pg_dist_object not
	 * being found when called too early.
	 */</comment>
	<expr_stmt><expr><call><name>CachedRelationLookupExtended</name><argument_list>(<argument><expr><literal type="string">"pg_dist_object_pkey"</literal></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name><name>MetadataCache</name><operator>.</operator><name>distObjectPrimaryKeyIndexId</name></name></expr></argument>,
								 <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>MetadataCache</name><operator>.</operator><name>distObjectPrimaryKeyIndexId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We can only ever reach here while we are creating/altering our extension before
		 * the table is moved to pg_catalog.
		 */</comment>
		<expr_stmt><expr><call><name>CachedRelationNamespaceLookupExtended</name><argument_list>(<argument><expr><literal type="string">"pg_dist_object_pkey"</literal></expr></argument>,
											  <argument><expr><call><name>CitusCatalogNamespaceId</name><argument_list>()</argument_list></call></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name><name>MetadataCache</name><operator>.</operator><name>distObjectPrimaryKeyIndexId</name></name></expr></argument>,
											  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>distObjectPrimaryKeyIndexId</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* return oid of pg_dist_cleanup relation */</comment>
<function><type><name>Oid</name></type>
<name>DistCleanupRelationId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CachedRelationLookup</name><argument_list>(<argument><expr><literal type="string">"pg_dist_cleanup"</literal></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>MetadataCache</name><operator>.</operator><name>distCleanupRelationId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>distCleanupRelationId</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* return oid of pg_dist_cleanup primary key index */</comment>
<function><type><name>Oid</name></type>
<name>DistCleanupPrimaryKeyIndexId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CachedRelationLookup</name><argument_list>(<argument><expr><literal type="string">"pg_dist_cleanup_pkey"</literal></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>MetadataCache</name><operator>.</operator><name>distCleanupPrimaryKeyIndexId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>distCleanupPrimaryKeyIndexId</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* return oid of pg_dist_colocation relation */</comment>
<function><type><name>Oid</name></type>
<name>DistColocationRelationId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CachedRelationLookup</name><argument_list>(<argument><expr><literal type="string">"pg_dist_colocation"</literal></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>MetadataCache</name><operator>.</operator><name>distColocationRelationId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>distColocationRelationId</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* return oid of pg_dist_colocation_configuration_index index */</comment>
<function><type><name>Oid</name></type>
<name>DistColocationConfigurationIndexId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CachedRelationLookup</name><argument_list>(<argument><expr><literal type="string">"pg_dist_colocation_configuration_index"</literal></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>MetadataCache</name><operator>.</operator><name>distColocationConfigurationIndexId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>distColocationConfigurationIndexId</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* return oid of pg_dist_partition relation */</comment>
<function><type><name>Oid</name></type>
<name>DistPartitionRelationId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CachedRelationLookup</name><argument_list>(<argument><expr><literal type="string">"pg_dist_partition"</literal></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>MetadataCache</name><operator>.</operator><name>distPartitionRelationId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>distPartitionRelationId</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* return oid of pg_dist_partition_logical_relid_index index */</comment>
<function><type><name>Oid</name></type>
<name>DistPartitionLogicalRelidIndexId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CachedRelationLookup</name><argument_list>(<argument><expr><literal type="string">"pg_dist_partition_logical_relid_index"</literal></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>MetadataCache</name><operator>.</operator><name>distPartitionLogicalRelidIndexId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>distPartitionLogicalRelidIndexId</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* return oid of pg_dist_partition_colocationid_index index */</comment>
<function><type><name>Oid</name></type>
<name>DistPartitionColocationidIndexId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CachedRelationLookup</name><argument_list>(<argument><expr><literal type="string">"pg_dist_partition_colocationid_index"</literal></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>MetadataCache</name><operator>.</operator><name>distPartitionColocationidIndexId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>distPartitionColocationidIndexId</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* return oid of pg_dist_shard_logical_relid_index index */</comment>
<function><type><name>Oid</name></type>
<name>DistShardLogicalRelidIndexId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CachedRelationLookup</name><argument_list>(<argument><expr><literal type="string">"pg_dist_shard_logical_relid_index"</literal></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>MetadataCache</name><operator>.</operator><name>distShardLogicalRelidIndexId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>distShardLogicalRelidIndexId</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* return oid of pg_dist_shard_shardid_index index */</comment>
<function><type><name>Oid</name></type>
<name>DistShardShardidIndexId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CachedRelationLookup</name><argument_list>(<argument><expr><literal type="string">"pg_dist_shard_shardid_index"</literal></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>MetadataCache</name><operator>.</operator><name>distShardShardidIndexId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>distShardShardidIndexId</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* return oid of pg_dist_placement_shardid_index */</comment>
<function><type><name>Oid</name></type>
<name>DistPlacementShardidIndexId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CachedRelationLookup</name><argument_list>(<argument><expr><literal type="string">"pg_dist_placement_shardid_index"</literal></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>MetadataCache</name><operator>.</operator><name>distPlacementShardidIndexId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>distPlacementShardidIndexId</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* return oid of pg_dist_placement_placementid_index */</comment>
<function><type><name>Oid</name></type>
<name>DistPlacementPlacementidIndexId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CachedRelationLookup</name><argument_list>(<argument><expr><literal type="string">"pg_dist_placement_placementid_index"</literal></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>MetadataCache</name><operator>.</operator><name>distPlacementPlacementidIndexId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>distPlacementPlacementidIndexId</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* return oid of pg_dist_colocation_pkey */</comment>
<function><type><name>Oid</name></type>
<name>DistColocationIndexId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CachedRelationLookup</name><argument_list>(<argument><expr><literal type="string">"pg_dist_colocation_pkey"</literal></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>MetadataCache</name><operator>.</operator><name>distColocationidIndexId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>distColocationidIndexId</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* return oid of pg_dist_transaction relation */</comment>
<function><type><name>Oid</name></type>
<name>DistTransactionRelationId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CachedRelationLookup</name><argument_list>(<argument><expr><literal type="string">"pg_dist_transaction"</literal></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>MetadataCache</name><operator>.</operator><name>distTransactionRelationId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>distTransactionRelationId</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* return oid of pg_dist_transaction_group_index */</comment>
<function><type><name>Oid</name></type>
<name>DistTransactionGroupIndexId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CachedRelationLookup</name><argument_list>(<argument><expr><literal type="string">"pg_dist_transaction_group_index"</literal></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>MetadataCache</name><operator>.</operator><name>distTransactionGroupIndexId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>distTransactionGroupIndexId</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* return oid of pg_dist_placement_groupid_index */</comment>
<function><type><name>Oid</name></type>
<name>DistPlacementGroupidIndexId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CachedRelationLookup</name><argument_list>(<argument><expr><literal type="string">"pg_dist_placement_groupid_index"</literal></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>MetadataCache</name><operator>.</operator><name>distPlacementGroupidIndexId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>distPlacementGroupidIndexId</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* return oid of pg_dist_authinfo relation */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>DistAuthinfoRelationId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CachedRelationLookup</name><argument_list>(<argument><expr><literal type="string">"pg_dist_authinfo"</literal></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>MetadataCache</name><operator>.</operator><name>distAuthinfoRelationId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>distAuthinfoRelationId</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* return oid of pg_dist_authinfo identification index */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>DistAuthinfoIndexId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CachedRelationLookup</name><argument_list>(<argument><expr><literal type="string">"pg_dist_authinfo_identification_index"</literal></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>MetadataCache</name><operator>.</operator><name>distAuthinfoIndexId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>distAuthinfoIndexId</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* return oid of pg_dist_poolinfo relation */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>DistPoolinfoRelationId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CachedRelationLookup</name><argument_list>(<argument><expr><literal type="string">"pg_dist_poolinfo"</literal></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>MetadataCache</name><operator>.</operator><name>distPoolinfoRelationId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>distPoolinfoRelationId</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* return oid of pg_dist_poolinfo primary key index */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>DistPoolinfoIndexId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CachedRelationLookup</name><argument_list>(<argument><expr><literal type="string">"pg_dist_poolinfo_pkey"</literal></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>MetadataCache</name><operator>.</operator><name>distPoolinfoIndexId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>distPoolinfoIndexId</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* return oid of the read_intermediate_result(text,citus_copy_format) function */</comment>
<function><type><name>Oid</name></type>
<name>CitusReadIntermediateResultFuncId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>MetadataCache</name><operator>.</operator><name>readIntermediateResultFuncId</name></name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>functionNameList</name> <init>= <expr><call><name>list_make2</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"pg_catalog"</literal></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"read_intermediate_result"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>copyFormatTypeOid</name> <init>= <expr><call><name>CitusCopyFormatTypeId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name><name>paramOids</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{ <expr><name>TEXTOID</name></expr>, <expr><name>copyFormatTypeOid</name></expr> }</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>missingOK</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>MetadataCache</name><operator>.</operator><name>readIntermediateResultFuncId</name></name> <operator>=</operator>
			<call><name>LookupFuncName</name><argument_list>(<argument><expr><name>functionNameList</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>paramOids</name></expr></argument>, <argument><expr><name>missingOK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>readIntermediateResultFuncId</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* return oid of the read_intermediate_results(text[],citus_copy_format) function */</comment>
<function><type><name>Oid</name></type>
<name>CitusReadIntermediateResultArrayFuncId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>MetadataCache</name><operator>.</operator><name>readIntermediateResultArrayFuncId</name></name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>functionNameList</name> <init>= <expr><call><name>list_make2</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"pg_catalog"</literal></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"read_intermediate_results"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>copyFormatTypeOid</name> <init>= <expr><call><name>CitusCopyFormatTypeId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name><name>paramOids</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{ <expr><name>TEXTARRAYOID</name></expr>, <expr><name>copyFormatTypeOid</name></expr> }</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>missingOK</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>MetadataCache</name><operator>.</operator><name>readIntermediateResultArrayFuncId</name></name> <operator>=</operator>
			<call><name>LookupFuncName</name><argument_list>(<argument><expr><name>functionNameList</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>paramOids</name></expr></argument>, <argument><expr><name>missingOK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>readIntermediateResultArrayFuncId</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* return oid of the citus.copy_format enum type */</comment>
<function><type><name>Oid</name></type>
<name>CitusCopyFormatTypeId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>MetadataCache</name><operator>.</operator><name>copyFormatTypeId</name></name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>typeName</name> <init>= <expr><literal type="string">"citus_copy_format"</literal></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>MetadataCache</name><operator>.</operator><name>copyFormatTypeId</name></name> <operator>=</operator> <call><name>GetSysCacheOid2</name><argument_list>(<argument><expr><name>TYPENAMENSP</name></expr></argument>,
														 <argument><expr><name>Anum_pg_enum_oid</name></expr></argument>,
														 <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>)</argument_list></call></expr></argument>,
														 <argument><expr><name>PG_CATALOG_NAMESPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>copyFormatTypeId</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* return oid of the 'binary' citus_copy_format enum value */</comment>
<function><type><name>Oid</name></type>
<name>BinaryCopyFormatId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>MetadataCache</name><operator>.</operator><name>binaryCopyFormatId</name></name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>copyFormatTypeId</name> <init>= <expr><call><name>CitusCopyFormatTypeId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>MetadataCache</name><operator>.</operator><name>binaryCopyFormatId</name></name> <operator>=</operator> <call><name>LookupEnumValueId</name><argument_list>(<argument><expr><name>copyFormatTypeId</name></expr></argument>, <argument><expr><literal type="string">"binary"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>binaryCopyFormatId</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* return oid of the 'text' citus_copy_format enum value */</comment>
<function><type><name>Oid</name></type>
<name>TextCopyFormatId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>MetadataCache</name><operator>.</operator><name>textCopyFormatId</name></name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>copyFormatTypeId</name> <init>= <expr><call><name>CitusCopyFormatTypeId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>MetadataCache</name><operator>.</operator><name>textCopyFormatId</name></name> <operator>=</operator> <call><name>LookupEnumValueId</name><argument_list>(<argument><expr><name>copyFormatTypeId</name></expr></argument>, <argument><expr><literal type="string">"text"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>textCopyFormatId</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* return oid of the citus_extradata_container(internal) function */</comment>
<function><type><name>Oid</name></type>
<name>CitusExtraDataContainerFuncId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>nameList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name><name>paramOids</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{ <expr><name>INTERNALOID</name></expr> }</block></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>MetadataCache</name><operator>.</operator><name>extraDataContainerFuncId</name></name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>nameList</name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"pg_catalog"</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"citus_extradata_container"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>MetadataCache</name><operator>.</operator><name>extraDataContainerFuncId</name></name> <operator>=</operator>
			<call><name>LookupFuncName</name><argument_list>(<argument><expr><name>nameList</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>paramOids</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>extraDataContainerFuncId</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* return oid of the any_value aggregate function */</comment>
<function><type><name>Oid</name></type>
<name>CitusAnyValueFunctionId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>MetadataCache</name><operator>.</operator><name>anyValueFunctionId</name></name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>argCount</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>MetadataCache</name><operator>.</operator><name>anyValueFunctionId</name></name> <operator>=</operator>
			<call><name>FunctionOid</name><argument_list>(<argument><expr><literal type="string">"pg_catalog"</literal></expr></argument>, <argument><expr><literal type="string">"any_value"</literal></expr></argument>, <argument><expr><name>argCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>anyValueFunctionId</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* return oid of the citus_text_send_as_jsonb(text) function */</comment>
<function><type><name>Oid</name></type>
<name>CitusTextSendAsJsonbFunctionId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>MetadataCache</name><operator>.</operator><name>textSendAsJsonbFunctionId</name></name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>nameList</name> <init>= <expr><call><name>list_make2</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"pg_catalog"</literal></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"citus_text_send_as_jsonb"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name><name>paramOids</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{ <expr><name>TEXTOID</name></expr> }</block></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>MetadataCache</name><operator>.</operator><name>textSendAsJsonbFunctionId</name></name> <operator>=</operator>
			<call><name>LookupFuncName</name><argument_list>(<argument><expr><name>nameList</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>paramOids</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>textSendAsJsonbFunctionId</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* return oid of the textout(text) function */</comment>
<function><type><name>Oid</name></type>
<name>TextOutFunctionId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>MetadataCache</name><operator>.</operator><name>textoutFunctionId</name></name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>nameList</name> <init>= <expr><call><name>list_make2</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"pg_catalog"</literal></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"textout"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name><name>paramOids</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{ <expr><name>TEXTOID</name></expr> }</block></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>MetadataCache</name><operator>.</operator><name>textoutFunctionId</name></name> <operator>=</operator>
			<call><name>LookupFuncName</name><argument_list>(<argument><expr><name>nameList</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>paramOids</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>textoutFunctionId</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RelationIsAKnownShardFuncId returns oid of the relation_is_a_known_shard function.
 */</comment>
<function><type><name>Oid</name></type>
<name>RelationIsAKnownShardFuncId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>MetadataCache</name><operator>.</operator><name>relationIsAKnownShardFuncId</name></name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>argCount</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>MetadataCache</name><operator>.</operator><name>relationIsAKnownShardFuncId</name></name> <operator>=</operator>
			<call><name>FunctionOid</name><argument_list>(<argument><expr><literal type="string">"pg_catalog"</literal></expr></argument>, <argument><expr><literal type="string">"relation_is_a_known_shard"</literal></expr></argument>, <argument><expr><name>argCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>relationIsAKnownShardFuncId</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * JsonbExtractPathFuncId returns oid of the jsonb_extract_path function.
 */</comment>
<function><type><name>Oid</name></type>
<name>JsonbExtractPathFuncId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>MetadataCache</name><operator>.</operator><name>jsonbExtractPathFuncId</name></name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>argCount</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>MetadataCache</name><operator>.</operator><name>jsonbExtractPathFuncId</name></name> <operator>=</operator>
			<call><name>FunctionOid</name><argument_list>(<argument><expr><literal type="string">"pg_catalog"</literal></expr></argument>, <argument><expr><literal type="string">"jsonb_extract_path"</literal></expr></argument>, <argument><expr><name>argCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>jsonbExtractPathFuncId</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * JsonbExtractPathTextFuncId returns oid of the jsonb_extract_path_text function.
 */</comment>
<function><type><name>Oid</name></type>
<name>JsonbExtractPathTextFuncId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>MetadataCache</name><operator>.</operator><name>jsonbExtractPathTextFuncId</name></name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>argCount</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>MetadataCache</name><operator>.</operator><name>jsonbExtractPathTextFuncId</name></name> <operator>=</operator>
			<call><name>FunctionOid</name><argument_list>(<argument><expr><literal type="string">"pg_catalog"</literal></expr></argument>, <argument><expr><literal type="string">"jsonb_extract_path_text"</literal></expr></argument>, <argument><expr><name>argCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>jsonbExtractPathTextFuncId</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CitusDependentObjectFuncId returns oid of the is_citus_depended_object function.
 */</comment>
<function><type><name>Oid</name></type>
<name>CitusDependentObjectFuncId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>HideCitusDependentObjects</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
							<argument><expr><literal type="string">"is_citus_depended_object can only be used while running the regression tests"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>MetadataCache</name><operator>.</operator><name>CitusDependentObjectFuncId</name></name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>argCount</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>MetadataCache</name><operator>.</operator><name>CitusDependentObjectFuncId</name></name> <operator>=</operator>
			<call><name>FunctionOid</name><argument_list>(<argument><expr><literal type="string">"pg_catalog"</literal></expr></argument>, <argument><expr><literal type="string">"is_citus_depended_object"</literal></expr></argument>, <argument><expr><name>argCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>CitusDependentObjectFuncId</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CurrentDatabaseName gets the name of the current database and caches
 * the result.
 *
 * Given that the database name cannot be changed when there is at least
 * one session connected to it, we do not need to implement any invalidation
 * mechanism.
 */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>CurrentDatabaseName</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>MetadataCache</name><operator>.</operator><name>databaseNameValid</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>databaseName</name> <init>= <expr><call><name>get_database_name</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>databaseName</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database that is connected to does not exist"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>MetadataCache</name><operator>.</operator><name>databaseName</name></name></expr></argument>, <argument><expr><name>databaseName</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>MetadataCache</name><operator>.</operator><name>databaseNameValid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>databaseName</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CitusExtensionOwner() returns the owner of the 'citus' extension. That user
 * is, amongst others, used to perform actions a normal user might not be
 * allowed to perform.
 */</comment>
<function><type><specifier>extern</specifier> <name>Oid</name></type>
<name>CitusExtensionOwner</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>entry</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_extension</name></type> <name>extensionForm</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>MetadataCache</name><operator>.</operator><name>extensionOwner</name></name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>extensionOwner</name></name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>ExtensionRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_extension_extname</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_NAMEEQ</name></expr></argument>,
				<argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><literal type="string">"citus"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scandesc</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>ExtensionNameIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
											  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>extensionTuple</name> <init>= <expr><call><name>systable_getnext</name><argument_list>(<argument><expr><name>scandesc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* We assume that there can be at most one matching tuple */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>extensionTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>extensionForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_extension</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>extensionTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * For some operations Citus requires superuser permissions; we use
		 * the extension owner for that. The extension owner is guaranteed to
		 * be a superuser (otherwise C functions can't be created), but it'd
		 * be possible to change the owner. So check that this still a
		 * superuser.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>superuser_arg</name><argument_list>(<argument><expr><name><name>extensionForm</name><operator>-&gt;</operator><name>extowner</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"citus extension needs to be owned by superuser"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>MetadataCache</name><operator>.</operator><name>extensionOwner</name></name> <operator>=</operator> <name><name>extensionForm</name><operator>-&gt;</operator><name>extowner</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>MetadataCache</name><operator>.</operator><name>extensionOwner</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"citus extension not loaded"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scandesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>extensionOwner</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CitusExtensionOwnerName returns the name of the owner of the extension.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>CitusExtensionOwnerName</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>superUserId</name> <init>= <expr><call><name>CitusExtensionOwner</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>GetUserNameFromId</name><argument_list>(<argument><expr><name>superUserId</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* return the username of the currently active role */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>CurrentUserName</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>userId</name> <init>= <expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>GetUserNameFromId</name><argument_list>(<argument><expr><name>userId</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * LookupTypeOid returns the Oid of the "{schemaNameSting}.{typeNameString}" type, or
 * InvalidOid if it does not exist.
 */</comment>
<function><type><name>Oid</name></type>
<name>LookupTypeOid</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>schemaNameSting</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>typeNameString</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>schemaName</name> <init>= <expr><call><name>makeString</name><argument_list>(<argument><expr><name>schemaNameSting</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>typeName</name> <init>= <expr><call><name>makeString</name><argument_list>(<argument><expr><name>typeNameString</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>qualifiedName</name> <init>= <expr><call><name>list_make2</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>, <argument><expr><name>typeName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeName</name> <modifier>*</modifier></type><name>enumTypeName</name> <init>= <expr><call><name>makeTypeNameFromNameList</name><argument_list>(<argument><expr><name>qualifiedName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


	<comment type="block">/* typenameTypeId but instead of raising an error return InvalidOid */</comment>
	<decl_stmt><decl><type><name>Type</name></type> <name>tup</name> <init>= <expr><call><name>LookupTypeName</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>enumTypeName</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>tup</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>InvalidOid</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>nodeRoleTypId</name> <init>= <expr><operator>(</operator><operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>oid</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>nodeRoleTypId</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * LookupStringEnumValueId returns the Oid of the value in "pg_catalog.{enumName}"
 * which matches the provided valueName, or InvalidOid if the enum doesn't exist yet.
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>LookupStringEnumValueId</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>enumName</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>valueName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>enumTypeId</name> <init>= <expr><call><name>LookupTypeOid</name><argument_list>(<argument><expr><literal type="string">"pg_catalog"</literal></expr></argument>, <argument><expr><name>enumName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>enumTypeId</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>InvalidOid</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>valueId</name> <init>= <expr><call><name>LookupEnumValueId</name><argument_list>(<argument><expr><name>enumTypeId</name></expr></argument>, <argument><expr><name>valueName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<return>return <expr><name>valueId</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * LookupEnumValueId looks up the OID of an enum value.
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>LookupEnumValueId</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typeId</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>valueName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type> <name>typeIdDatum</name> <init>= <expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typeId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>valueDatum</name> <init>= <expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>valueName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>valueIdDatum</name> <init>= <expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>enum_in</name></expr></argument>, <argument><expr><name>valueDatum</name></expr></argument>, <argument><expr><name>typeIdDatum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>valueId</name> <init>= <expr><call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name>valueIdDatum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>valueId</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* return the Oid of the 'primary' nodeRole enum value */</comment>
<function><type><name>Oid</name></type>
<name>PrimaryNodeRoleId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>MetadataCache</name><operator>.</operator><name>primaryNodeRoleId</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>MetadataCache</name><operator>.</operator><name>primaryNodeRoleId</name></name> <operator>=</operator> <call><name>LookupStringEnumValueId</name><argument_list>(<argument><expr><literal type="string">"noderole"</literal></expr></argument>, <argument><expr><literal type="string">"primary"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>primaryNodeRoleId</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* return the Oid of the 'secodary' nodeRole enum value */</comment>
<function><type><name>Oid</name></type>
<name>SecondaryNodeRoleId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>MetadataCache</name><operator>.</operator><name>secondaryNodeRoleId</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>MetadataCache</name><operator>.</operator><name>secondaryNodeRoleId</name></name> <operator>=</operator> <call><name>LookupStringEnumValueId</name><argument_list>(<argument><expr><literal type="string">"noderole"</literal></expr></argument>,
																	<argument><expr><literal type="string">"secondary"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>secondaryNodeRoleId</name></name></expr>;</return>
</block_content>}</block></function>


<function><type><name>Oid</name></type>
<name>CitusJobStatusScheduledId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>MetadataCache</name><operator>.</operator><name>citusJobStatusScheduledId</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>MetadataCache</name><operator>.</operator><name>citusJobStatusScheduledId</name></name> <operator>=</operator>
			<call><name>LookupStringEnumValueId</name><argument_list>(<argument><expr><literal type="string">"citus_job_status"</literal></expr></argument>, <argument><expr><literal type="string">"scheduled"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>citusJobStatusScheduledId</name></name></expr>;</return>
</block_content>}</block></function>


<function><type><name>Oid</name></type>
<name>CitusJobStatusRunningId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>MetadataCache</name><operator>.</operator><name>citusJobStatusRunningId</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>MetadataCache</name><operator>.</operator><name>citusJobStatusRunningId</name></name> <operator>=</operator>
			<call><name>LookupStringEnumValueId</name><argument_list>(<argument><expr><literal type="string">"citus_job_status"</literal></expr></argument>, <argument><expr><literal type="string">"running"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>citusJobStatusRunningId</name></name></expr>;</return>
</block_content>}</block></function>


<function><type><name>Oid</name></type>
<name>CitusJobStatusCancellingId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>MetadataCache</name><operator>.</operator><name>citusJobStatusCancellingId</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>MetadataCache</name><operator>.</operator><name>citusJobStatusCancellingId</name></name> <operator>=</operator>
			<call><name>LookupStringEnumValueId</name><argument_list>(<argument><expr><literal type="string">"citus_job_status"</literal></expr></argument>, <argument><expr><literal type="string">"cancelling"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>citusJobStatusCancellingId</name></name></expr>;</return>
</block_content>}</block></function>


<function><type><name>Oid</name></type>
<name>CitusJobStatusFinishedId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>MetadataCache</name><operator>.</operator><name>citusJobStatusFinishedId</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>MetadataCache</name><operator>.</operator><name>citusJobStatusFinishedId</name></name> <operator>=</operator>
			<call><name>LookupStringEnumValueId</name><argument_list>(<argument><expr><literal type="string">"citus_job_status"</literal></expr></argument>, <argument><expr><literal type="string">"finished"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>citusJobStatusFinishedId</name></name></expr>;</return>
</block_content>}</block></function>


<function><type><name>Oid</name></type>
<name>CitusJobStatusCancelledId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>MetadataCache</name><operator>.</operator><name>citusJobStatusCancelledId</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>MetadataCache</name><operator>.</operator><name>citusJobStatusCancelledId</name></name> <operator>=</operator>
			<call><name>LookupStringEnumValueId</name><argument_list>(<argument><expr><literal type="string">"citus_job_status"</literal></expr></argument>, <argument><expr><literal type="string">"cancelled"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>citusJobStatusCancelledId</name></name></expr>;</return>
</block_content>}</block></function>


<function><type><name>Oid</name></type>
<name>CitusJobStatusFailedId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>MetadataCache</name><operator>.</operator><name>citusJobStatusFailedId</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>MetadataCache</name><operator>.</operator><name>citusJobStatusFailedId</name></name> <operator>=</operator>
			<call><name>LookupStringEnumValueId</name><argument_list>(<argument><expr><literal type="string">"citus_job_status"</literal></expr></argument>, <argument><expr><literal type="string">"failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>citusJobStatusFailedId</name></name></expr>;</return>
</block_content>}</block></function>


<function><type><name>Oid</name></type>
<name>CitusJobStatusFailingId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>MetadataCache</name><operator>.</operator><name>citusJobStatusFailingId</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>MetadataCache</name><operator>.</operator><name>citusJobStatusFailingId</name></name> <operator>=</operator>
			<call><name>LookupStringEnumValueId</name><argument_list>(<argument><expr><literal type="string">"citus_job_status"</literal></expr></argument>, <argument><expr><literal type="string">"failing"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>citusJobStatusFailingId</name></name></expr>;</return>
</block_content>}</block></function>


<function><type><name>Oid</name></type>
<name>CitusTaskStatusBlockedId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>MetadataCache</name><operator>.</operator><name>citusTaskStatusBlockedId</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>MetadataCache</name><operator>.</operator><name>citusTaskStatusBlockedId</name></name> <operator>=</operator>
			<call><name>LookupStringEnumValueId</name><argument_list>(<argument><expr><literal type="string">"citus_task_status"</literal></expr></argument>, <argument><expr><literal type="string">"blocked"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>citusTaskStatusBlockedId</name></name></expr>;</return>
</block_content>}</block></function>


<function><type><name>Oid</name></type>
<name>CitusTaskStatusCancelledId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>MetadataCache</name><operator>.</operator><name>citusTaskStatusCancelledId</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>MetadataCache</name><operator>.</operator><name>citusTaskStatusCancelledId</name></name> <operator>=</operator>
			<call><name>LookupStringEnumValueId</name><argument_list>(<argument><expr><literal type="string">"citus_task_status"</literal></expr></argument>, <argument><expr><literal type="string">"cancelled"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>citusTaskStatusCancelledId</name></name></expr>;</return>
</block_content>}</block></function>


<function><type><name>Oid</name></type>
<name>CitusTaskStatusCancellingId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>MetadataCache</name><operator>.</operator><name>citusTaskStatusCancellingId</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>MetadataCache</name><operator>.</operator><name>citusTaskStatusCancellingId</name></name> <operator>=</operator>
			<call><name>LookupStringEnumValueId</name><argument_list>(<argument><expr><literal type="string">"citus_task_status"</literal></expr></argument>, <argument><expr><literal type="string">"cancelling"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>citusTaskStatusCancellingId</name></name></expr>;</return>
</block_content>}</block></function>


<function><type><name>Oid</name></type>
<name>CitusTaskStatusRunnableId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>MetadataCache</name><operator>.</operator><name>citusTaskStatusRunnableId</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>MetadataCache</name><operator>.</operator><name>citusTaskStatusRunnableId</name></name> <operator>=</operator>
			<call><name>LookupStringEnumValueId</name><argument_list>(<argument><expr><literal type="string">"citus_task_status"</literal></expr></argument>, <argument><expr><literal type="string">"runnable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>citusTaskStatusRunnableId</name></name></expr>;</return>
</block_content>}</block></function>


<function><type><name>Oid</name></type>
<name>CitusTaskStatusRunningId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>MetadataCache</name><operator>.</operator><name>citusTaskStatusRunningId</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>MetadataCache</name><operator>.</operator><name>citusTaskStatusRunningId</name></name> <operator>=</operator>
			<call><name>LookupStringEnumValueId</name><argument_list>(<argument><expr><literal type="string">"citus_task_status"</literal></expr></argument>, <argument><expr><literal type="string">"running"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>citusTaskStatusRunningId</name></name></expr>;</return>
</block_content>}</block></function>


<function><type><name>Oid</name></type>
<name>CitusTaskStatusDoneId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>MetadataCache</name><operator>.</operator><name>citusTaskStatusDoneId</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>MetadataCache</name><operator>.</operator><name>citusTaskStatusDoneId</name></name> <operator>=</operator>
			<call><name>LookupStringEnumValueId</name><argument_list>(<argument><expr><literal type="string">"citus_task_status"</literal></expr></argument>, <argument><expr><literal type="string">"done"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>citusTaskStatusDoneId</name></name></expr>;</return>
</block_content>}</block></function>


<function><type><name>Oid</name></type>
<name>CitusTaskStatusErrorId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>MetadataCache</name><operator>.</operator><name>citusTaskStatusErrorId</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>MetadataCache</name><operator>.</operator><name>citusTaskStatusErrorId</name></name> <operator>=</operator>
			<call><name>LookupStringEnumValueId</name><argument_list>(<argument><expr><literal type="string">"citus_task_status"</literal></expr></argument>, <argument><expr><literal type="string">"error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>citusTaskStatusErrorId</name></name></expr>;</return>
</block_content>}</block></function>


<function><type><name>Oid</name></type>
<name>CitusTaskStatusUnscheduledId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>MetadataCache</name><operator>.</operator><name>citusTaskStatusUnscheduledId</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>MetadataCache</name><operator>.</operator><name>citusTaskStatusUnscheduledId</name></name> <operator>=</operator>
			<call><name>LookupStringEnumValueId</name><argument_list>(<argument><expr><literal type="string">"citus_task_status"</literal></expr></argument>, <argument><expr><literal type="string">"unscheduled"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>MetadataCache</name><operator>.</operator><name>citusTaskStatusUnscheduledId</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * citus_dist_partition_cache_invalidate is a trigger function that performs
 * relcache invalidations when the contents of pg_dist_partition are changed
 * on the SQL level.
 *
 * NB: We decided there is little point in checking permissions here, there
 * are much easier ways to waste CPU than causing cache invalidations.
 */</comment>
<function><type><name>Datum</name></type>
<name>citus_dist_partition_cache_invalidate</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>TriggerData</name> <modifier>*</modifier></type><name>triggerData</name> <init>= <expr><operator>(</operator><name>TriggerData</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>oldLogicalRelationId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>newLogicalRelationId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CALLED_AS_TRIGGER</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must be called as trigger"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>triggerData</name><operator>-&gt;</operator><name>tg_relation</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>DistPartitionRelationId</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"triggered on incorrect relation"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>newTuple</name> <init>= <expr><name><name>triggerData</name><operator>-&gt;</operator><name>tg_newtuple</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>oldTuple</name> <init>= <expr><name><name>triggerData</name><operator>-&gt;</operator><name>tg_trigtuple</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* collect logicalrelid for OLD and NEW tuple */</comment>
	<if_stmt><if>if <condition>(<expr><name>oldTuple</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_dist_partition</name></type> <name>distPart</name> <init>= <expr><operator>(</operator><name>Form_pg_dist_partition</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>oldTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>oldLogicalRelationId</name> <operator>=</operator> <name><name>distPart</name><operator>-&gt;</operator><name>logicalrelid</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>newTuple</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_dist_partition</name></type> <name>distPart</name> <init>= <expr><operator>(</operator><name>Form_pg_dist_partition</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>newTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>newLogicalRelationId</name> <operator>=</operator> <name><name>distPart</name><operator>-&gt;</operator><name>logicalrelid</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Invalidate relcache for the relevant relation(s). In theory
	 * logicalrelid should never change, but it doesn't hurt to be
	 * paranoid.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>oldLogicalRelationId</name> <operator>!=</operator> <name>InvalidOid</name> <operator>&amp;&amp;</operator>
		<name>oldLogicalRelationId</name> <operator>!=</operator> <name>newLogicalRelationId</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CitusInvalidateRelcacheByRelid</name><argument_list>(<argument><expr><name>oldLogicalRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>newLogicalRelationId</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CitusInvalidateRelcacheByRelid</name><argument_list>(<argument><expr><name>newLogicalRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * master_dist_partition_cache_invalidate is a wrapper function for old UDF name.
 */</comment>
<function><type><name>Datum</name></type>
<name>master_dist_partition_cache_invalidate</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>citus_dist_partition_cache_invalidate</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * citus_dist_shard_cache_invalidate is a trigger function that performs
 * relcache invalidations when the contents of pg_dist_shard are changed
 * on the SQL level.
 *
 * NB: We decided there is little point in checking permissions here, there
 * are much easier ways to waste CPU than causing cache invalidations.
 */</comment>
<function><type><name>Datum</name></type>
<name>citus_dist_shard_cache_invalidate</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>TriggerData</name> <modifier>*</modifier></type><name>triggerData</name> <init>= <expr><operator>(</operator><name>TriggerData</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>oldLogicalRelationId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>newLogicalRelationId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CALLED_AS_TRIGGER</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must be called as trigger"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>triggerData</name><operator>-&gt;</operator><name>tg_relation</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>DistShardRelationId</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"triggered on incorrect relation"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>newTuple</name> <init>= <expr><name><name>triggerData</name><operator>-&gt;</operator><name>tg_newtuple</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>oldTuple</name> <init>= <expr><name><name>triggerData</name><operator>-&gt;</operator><name>tg_trigtuple</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* collect logicalrelid for OLD and NEW tuple */</comment>
	<if_stmt><if>if <condition>(<expr><name>oldTuple</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_dist_shard</name></type> <name>distShard</name> <init>= <expr><operator>(</operator><name>Form_pg_dist_shard</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>oldTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>oldLogicalRelationId</name> <operator>=</operator> <name><name>distShard</name><operator>-&gt;</operator><name>logicalrelid</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>newTuple</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_dist_shard</name></type> <name>distShard</name> <init>= <expr><operator>(</operator><name>Form_pg_dist_shard</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>newTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>newLogicalRelationId</name> <operator>=</operator> <name><name>distShard</name><operator>-&gt;</operator><name>logicalrelid</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Invalidate relcache for the relevant relation(s). In theory
	 * logicalrelid should never change, but it doesn't hurt to be
	 * paranoid.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>oldLogicalRelationId</name> <operator>!=</operator> <name>InvalidOid</name> <operator>&amp;&amp;</operator>
		<name>oldLogicalRelationId</name> <operator>!=</operator> <name>newLogicalRelationId</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CitusInvalidateRelcacheByRelid</name><argument_list>(<argument><expr><name>oldLogicalRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>newLogicalRelationId</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CitusInvalidateRelcacheByRelid</name><argument_list>(<argument><expr><name>newLogicalRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * master_dist_shard_cache_invalidate is a wrapper function for old UDF name.
 */</comment>
<function><type><name>Datum</name></type>
<name>master_dist_shard_cache_invalidate</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>citus_dist_shard_cache_invalidate</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * citus_dist_placement_cache_invalidate is a trigger function that performs
 * relcache invalidations when the contents of pg_dist_placement are
 * changed on the SQL level.
 *
 * NB: We decided there is little point in checking permissions here, there
 * are much easier ways to waste CPU than causing cache invalidations.
 */</comment>
<function><type><name>Datum</name></type>
<name>citus_dist_placement_cache_invalidate</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>TriggerData</name> <modifier>*</modifier></type><name>triggerData</name> <init>= <expr><operator>(</operator><name>TriggerData</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>oldShardId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>newShardId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CALLED_AS_TRIGGER</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must be called as trigger"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Before 7.0-2 this trigger is on pg_dist_shard_placement,
	 * ignore trigger in this scenario.
	 */</comment>
	<decl_stmt><decl><type><name>Oid</name></type> <name>pgDistShardPlacementId</name> <init>= <expr><call><name>get_relname_relid</name><argument_list>(<argument><expr><literal type="string">"pg_dist_shard_placement"</literal></expr></argument>,
												   <argument><expr><name>PG_CATALOG_NAMESPACE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>triggerData</name><operator>-&gt;</operator><name>tg_relation</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>pgDistShardPlacementId</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>triggerData</name><operator>-&gt;</operator><name>tg_relation</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>DistPlacementRelationId</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"triggered on incorrect relation"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>newTuple</name> <init>= <expr><name><name>triggerData</name><operator>-&gt;</operator><name>tg_newtuple</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>oldTuple</name> <init>= <expr><name><name>triggerData</name><operator>-&gt;</operator><name>tg_trigtuple</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* collect shardid for OLD and NEW tuple */</comment>
	<if_stmt><if>if <condition>(<expr><name>oldTuple</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_dist_placement</name></type> <name>distPlacement</name> <init>=
			<expr><operator>(</operator><name>Form_pg_dist_placement</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>oldTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>oldShardId</name> <operator>=</operator> <name><name>distPlacement</name><operator>-&gt;</operator><name>shardid</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>newTuple</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_dist_placement</name></type> <name>distPlacement</name> <init>=
			<expr><operator>(</operator><name>Form_pg_dist_placement</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>newTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>newShardId</name> <operator>=</operator> <name><name>distPlacement</name><operator>-&gt;</operator><name>shardid</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Invalidate relcache for the relevant relation(s). In theory shardId
	 * should never change, but it doesn't hurt to be paranoid.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>oldShardId</name> <operator>!=</operator> <name>InvalidOid</name> <operator>&amp;&amp;</operator>
		<name>oldShardId</name> <operator>!=</operator> <name>newShardId</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CitusInvalidateRelcacheByShardId</name><argument_list>(<argument><expr><name>oldShardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>newShardId</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CitusInvalidateRelcacheByShardId</name><argument_list>(<argument><expr><name>newShardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * master_dist_placement_cache_invalidate is a wrapper function for old UDF name.
 */</comment>
<function><type><name>Datum</name></type>
<name>master_dist_placement_cache_invalidate</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>citus_dist_placement_cache_invalidate</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * citus_dist_node_cache_invalidate is a trigger function that performs
 * relcache invalidations when the contents of pg_dist_node are changed
 * on the SQL level.
 *
 * NB: We decided there is little point in checking permissions here, there
 * are much easier ways to waste CPU than causing cache invalidations.
 */</comment>
<function><type><name>Datum</name></type>
<name>citus_dist_node_cache_invalidate</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CALLED_AS_TRIGGER</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must be called as trigger"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>CitusInvalidateRelcacheByRelid</name><argument_list>(<argument><expr><call><name>DistNodeRelationId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * master_dist_node_cache_invalidate is a wrapper function for old UDF name.
 */</comment>
<function><type><name>Datum</name></type>
<name>master_dist_node_cache_invalidate</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>citus_dist_node_cache_invalidate</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * citus_conninfo_cache_invalidate is a trigger function that performs
 * relcache invalidations when the contents of pg_dist_authinfo are changed
 * on the SQL level.
 *
 * NB: We decided there is little point in checking permissions here, there
 * are much easier ways to waste CPU than causing cache invalidations.
 */</comment>
<function><type><name>Datum</name></type>
<name>citus_conninfo_cache_invalidate</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CALLED_AS_TRIGGER</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must be called as trigger"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>CitusInvalidateRelcacheByRelid</name><argument_list>(<argument><expr><call><name>DistAuthinfoRelationId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * master_dist_authinfo_cache_invalidate is a wrapper function for old UDF name.
 */</comment>
<function><type><name>Datum</name></type>
<name>master_dist_authinfo_cache_invalidate</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>citus_conninfo_cache_invalidate</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * citus_dist_local_group_cache_invalidate is a trigger function that performs
 * relcache invalidations when the contents of pg_dist_local_group are changed
 * on the SQL level.
 *
 * NB: We decided there is little point in checking permissions here, there
 * are much easier ways to waste CPU than causing cache invalidations.
 */</comment>
<function><type><name>Datum</name></type>
<name>citus_dist_local_group_cache_invalidate</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CALLED_AS_TRIGGER</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must be called as trigger"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>CitusInvalidateRelcacheByRelid</name><argument_list>(<argument><expr><call><name>DistLocalGroupIdRelationId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * master_dist_local_group_cache_invalidate is a wrapper function for old UDF name.
 */</comment>
<function><type><name>Datum</name></type>
<name>master_dist_local_group_cache_invalidate</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>citus_dist_local_group_cache_invalidate</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * citus_dist_object_cache_invalidate is a trigger function that performs relcache
 * invalidation when the contents of pg_dist_object are changed on the SQL
 * level.
 *
 * NB: We decided there is little point in checking permissions here, there
 * are much easier ways to waste CPU than causing cache invalidations.
 */</comment>
<function><type><name>Datum</name></type>
<name>citus_dist_object_cache_invalidate</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CALLED_AS_TRIGGER</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must be called as trigger"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>CitusInvalidateRelcacheByRelid</name><argument_list>(<argument><expr><call><name>DistObjectRelationId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * master_dist_object_cache_invalidate is a wrapper function for old UDF name.
 */</comment>
<function><type><name>Datum</name></type>
<name>master_dist_object_cache_invalidate</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>citus_dist_object_cache_invalidate</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * InitializeCaches() registers invalidation handlers for metadata_cache.c's
 * caches.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>InitializeCaches</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>performedInitialization</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>performedInitialization</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>MetadataCacheMemoryContext</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * If either of dist table cache or shard cache
		 * allocation and initializations fail due to an exception
		 * that is caused by OOM or any other reason,
		 * we reset the flag, and delete the shard cache memory
		 * context to reclaim partially allocated memory.
		 *
		 * Command will continue to fail since we re-throw the exception.
		 */</comment>
		<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<comment type="block">/* set first, to avoid recursion dangers */</comment>
			<expr_stmt><expr><name>performedInitialization</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<comment type="block">/* make sure we've initialized CacheMemoryContext */</comment>
			<if_stmt><if>if <condition>(<expr><name>CacheMemoryContext</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>CreateCacheMemoryContext</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>MetadataCacheMemoryContext</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(
				<argument><expr><name>CacheMemoryContext</name></expr></argument>,
				<argument><expr><literal type="string">"MetadataCacheMemoryContext"</literal></expr></argument>,
				<argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>InitializeDistCache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>RegisterForeignKeyGraphCacheCallbacks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>RegisterWorkerNodeCacheCallbacks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>RegisterLocalGroupIdCacheCallbacks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>RegisterAuthinfoCacheCallbacks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>RegisterCitusTableCacheEntryReleaseCallbacks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<expr_stmt><expr><name>performedInitialization</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>MetadataCacheMemoryContext</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>MetadataCacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>MetadataCacheMemoryContext</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>DistTableCacheHash</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>DistTableCacheExpired</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>ShardIdCacheHash</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/* initialize the infrastructure for the metadata cache */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>InitializeDistCache</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* build initial scan keys, copied for every relation scan */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>DistPartitionScanKey</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DistPartitionScanKey</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>fmgr_info_cxt</name><argument_list>(<argument><expr><name>F_OIDEQ</name></expr></argument>,
				  <argument><expr><operator>&amp;</operator><name><name>DistPartitionScanKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>sk_func</name></expr></argument>,
				  <argument><expr><name>MetadataCacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>DistPartitionScanKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>sk_strategy</name> <operator>=</operator> <name>BTEqualStrategyNumber</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>DistPartitionScanKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>sk_subtype</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>DistPartitionScanKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>sk_collation</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>DistPartitionScanKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>sk_attno</name> <operator>=</operator> <name>Anum_pg_dist_partition_logicalrelid</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>DistShardScanKey</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DistShardScanKey</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>fmgr_info_cxt</name><argument_list>(<argument><expr><name>F_OIDEQ</name></expr></argument>,
				  <argument><expr><operator>&amp;</operator><name><name>DistShardScanKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>sk_func</name></expr></argument>,
				  <argument><expr><name>MetadataCacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>DistShardScanKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>sk_strategy</name> <operator>=</operator> <name>BTEqualStrategyNumber</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>DistShardScanKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>sk_subtype</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>DistShardScanKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>sk_collation</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>DistShardScanKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>sk_attno</name> <operator>=</operator> <name>Anum_pg_dist_shard_logicalrelid</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CreateDistTableCache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CreateShardIdCache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InitializeDistObjectCache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Watch for invalidation events. */</comment>
	<expr_stmt><expr><call><name>CacheRegisterRelcacheCallback</name><argument_list>(<argument><expr><name>InvalidateDistRelationCacheCallback</name></expr></argument>,
								  <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>InitializeDistObjectCache</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* build initial scan keys, copied for every relation scan */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>DistObjectScanKey</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DistObjectScanKey</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>fmgr_info_cxt</name><argument_list>(<argument><expr><name>F_OIDEQ</name></expr></argument>,
				  <argument><expr><operator>&amp;</operator><name><name>DistObjectScanKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>sk_func</name></expr></argument>,
				  <argument><expr><name>MetadataCacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>DistObjectScanKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>sk_strategy</name> <operator>=</operator> <name>BTEqualStrategyNumber</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>DistObjectScanKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>sk_subtype</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>DistObjectScanKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>sk_collation</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>DistObjectScanKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>sk_attno</name> <operator>=</operator> <name>Anum_pg_dist_object_classid</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>fmgr_info_cxt</name><argument_list>(<argument><expr><name>F_OIDEQ</name></expr></argument>,
				  <argument><expr><operator>&amp;</operator><name><name>DistObjectScanKey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>sk_func</name></expr></argument>,
				  <argument><expr><name>MetadataCacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>DistObjectScanKey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>sk_strategy</name> <operator>=</operator> <name>BTEqualStrategyNumber</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>DistObjectScanKey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>sk_subtype</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>DistObjectScanKey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>sk_collation</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>DistObjectScanKey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>sk_attno</name> <operator>=</operator> <name>Anum_pg_dist_object_objid</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>fmgr_info_cxt</name><argument_list>(<argument><expr><name>F_INT4EQ</name></expr></argument>,
				  <argument><expr><operator>&amp;</operator><name><name>DistObjectScanKey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>sk_func</name></expr></argument>,
				  <argument><expr><name>MetadataCacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>DistObjectScanKey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>sk_strategy</name> <operator>=</operator> <name>BTEqualStrategyNumber</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>DistObjectScanKey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>sk_subtype</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>DistObjectScanKey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>sk_collation</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>DistObjectScanKey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>sk_attno</name> <operator>=</operator> <name>Anum_pg_dist_object_objsubid</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CreateDistObjectCache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * GetWorkerNodeHash returns the worker node data as a hash with the nodename and
 * nodeport as a key.
 *
 * The hash is returned from the cache, if the cache is not (yet) valid, it is first
 * rebuilt.
 */</comment>
<function><type><name>HTAB</name> <modifier>*</modifier></type>
<name>GetWorkerNodeHash</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PrepareWorkerNodeCache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>WorkerNodeHash</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PrepareWorkerNodeCache makes sure the worker node data from pg_dist_node is cached,
 * if it is not already cached.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>PrepareWorkerNodeCache</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>InitializeCaches</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="block">/* ensure relevant callbacks are registered */</comment>

	<comment type="block">/*
	 * Simulate a SELECT from pg_dist_node, ensure pg_dist_node doesn't change while our
	 * caller is using WorkerNodeHash.
	 */</comment>
	<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><call><name>DistNodeRelationId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We might have some concurrent metadata changes. In order to get the changes,
	 * we first need to accept the cache invalidation messages.
	 */</comment>
	<expr_stmt><expr><call><name>AcceptInvalidationMessages</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>workerNodeHashValid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>InitializeWorkerNodeCache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>workerNodeHashValid</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * InitializeWorkerNodeCache initialize the infrastructure for the worker node cache.
 * The function reads the worker nodes from the metadata table, adds them to the hash and
 * finally registers an invalidation callback.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>InitializeWorkerNodeCache</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASHCTL</name></type> <name>info</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type> <name>maxTableSize</name> <init>= <expr><operator>(</operator><name>long</name><operator>)</operator> <name>MaxWorkerNodesTracked</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>includeNodesFromOtherClusters</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>workerNodeIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>InitializeCaches</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create the hash that holds the worker nodes. The key is the combination of
	 * nodename and nodeport, instead of the unique nodeid because worker nodes are
	 * searched by the nodename and nodeport in every physical plan creation.
	 */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>info</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>WORKER_LENGTH</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>WorkerNode</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name>MetadataCacheMemoryContext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>hash</name></name> <operator>=</operator> <name>WorkerNodeHashCode</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>match</name></name> <operator>=</operator> <name>WorkerNodeCompare</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>hashFlags</name> <init>= <expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_FUNCTION</name> <operator>|</operator> <name>HASH_CONTEXT</name> <operator>|</operator> <name>HASH_COMPARE</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>newWorkerNodeHash</name> <init>= <expr><call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"Worker Node Hash"</literal></expr></argument>, <argument><expr><name>maxTableSize</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>,
										  <argument><expr><name>hashFlags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* read the list from pg_dist_node */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>workerNodeList</name> <init>= <expr><call><name>ReadDistNode</name><argument_list>(<argument><expr><name>includeNodesFromOtherClusters</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>newWorkerNodeCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>workerNodeList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>newWorkerNodeArray</name> <init>= <expr><call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>MetadataCacheMemoryContext</name></expr></argument>,
														 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WorkerNode</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator>
														 <name>newWorkerNodeCount</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* iterate over the worker node list */</comment>
	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>currentNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>currentNode</argument>, <argument>workerNodeList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>handleFound</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* search for the worker node in the hash, and then insert the values */</comment>
		<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>hashKey</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>currentNode</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><operator>(</operator><name>WorkerNode</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>newWorkerNodeHash</name></expr></argument>, <argument><expr><name>hashKey</name></expr></argument>,
															<argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>handleFound</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* fill the newly allocated workerNode in the cache */</comment>
		<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>, <argument><expr><name><name>currentNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>, <argument><expr><name>WORKER_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerPort</name></name> <operator>=</operator> <name><name>currentNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>workerNode</name><operator>-&gt;</operator><name>groupId</name></name> <operator>=</operator> <name><name>currentNode</name><operator>-&gt;</operator><name>groupId</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>workerNode</name><operator>-&gt;</operator><name>nodeId</name></name> <operator>=</operator> <name><name>currentNode</name><operator>-&gt;</operator><name>nodeId</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerRack</name></name></expr></argument>, <argument><expr><name><name>currentNode</name><operator>-&gt;</operator><name>workerRack</name></name></expr></argument>, <argument><expr><name>WORKER_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>workerNode</name><operator>-&gt;</operator><name>hasMetadata</name></name> <operator>=</operator> <name><name>currentNode</name><operator>-&gt;</operator><name>hasMetadata</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>workerNode</name><operator>-&gt;</operator><name>metadataSynced</name></name> <operator>=</operator> <name><name>currentNode</name><operator>-&gt;</operator><name>metadataSynced</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>workerNode</name><operator>-&gt;</operator><name>isActive</name></name> <operator>=</operator> <name><name>currentNode</name><operator>-&gt;</operator><name>isActive</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>workerNode</name><operator>-&gt;</operator><name>nodeRole</name></name> <operator>=</operator> <name><name>currentNode</name><operator>-&gt;</operator><name>nodeRole</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>workerNode</name><operator>-&gt;</operator><name>shouldHaveShards</name></name> <operator>=</operator> <name><name>currentNode</name><operator>-&gt;</operator><name>shouldHaveShards</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>nodeCluster</name></name></expr></argument>, <argument><expr><name><name>currentNode</name><operator>-&gt;</operator><name>nodeCluster</name></name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>newWorkerNodeArray</name><index>[<expr><name>workerNodeIndex</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>workerNode</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>handleFound</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"multiple lines for worker node: \"%s:%u\""</literal></expr></argument>,
									 <argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>,
									 <argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* we do not need the currentNode anymore */</comment>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>currentNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* now, safe to destroy the old hash */</comment>
	<expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name>WorkerNodeHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>WorkerNodeArray</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>WorkerNodeArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>WorkerNodeCount</name> <operator>=</operator> <name>newWorkerNodeCount</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>WorkerNodeArray</name> <operator>=</operator> <name>newWorkerNodeArray</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>WorkerNodeHash</name> <operator>=</operator> <name>newWorkerNodeHash</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * RegisterForeignKeyGraphCacheCallbacks registers callbacks required for
 * the foreign key graph cache.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RegisterForeignKeyGraphCacheCallbacks</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Watch for invalidation events. */</comment>
	<expr_stmt><expr><call><name>CacheRegisterRelcacheCallback</name><argument_list>(<argument><expr><name>InvalidateForeignRelationGraphCacheCallback</name></expr></argument>,
								  <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * RegisterWorkerNodeCacheCallbacks registers the callbacks required for the
 * worker node cache.  It's separate from InitializeWorkerNodeCache so the
 * callback can be registered early, before the metadata tables exist.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RegisterWorkerNodeCacheCallbacks</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Watch for invalidation events. */</comment>
	<expr_stmt><expr><call><name>CacheRegisterRelcacheCallback</name><argument_list>(<argument><expr><name>InvalidateNodeRelationCacheCallback</name></expr></argument>,
								  <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * RegisterCitusTableCacheEntryReleaseCallbacks registers callbacks to release
 * cache entries. Data should be locked by callers to avoid staleness.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RegisterCitusTableCacheEntryReleaseCallbacks</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>RegisterResourceReleaseCallback</name><argument_list>(<argument><expr><name>CitusTableCacheEntryReleaseCallback</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * GetLocalGroupId returns the group identifier of the local node. The function assumes
 * that pg_dist_local_node_group has exactly one row and has at least one column.
 * Otherwise, the function errors out.
 */</comment>
<function><type><name>int32</name></type>
<name>GetLocalGroupId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scanKey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>scanKeyCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>groupId</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>InitializeCaches</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Already set the group id, no need to read the heap again.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>LocalGroupId</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>LocalGroupId</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>localGroupTableOid</name> <init>= <expr><call><name>DistLocalGroupIdRelationId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>localGroupTableOid</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>pgDistLocalGroupId</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>localGroupTableOid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scanDescriptor</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pgDistLocalGroupId</name></expr></argument>,
													<argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
													<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>scanKeyCount</name></expr></argument>, <argument><expr><name>scanKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pgDistLocalGroupId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>heapTuple</name> <init>= <expr><call><name>systable_getnext</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>isNull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type> <name>groupIdDatum</name> <init>= <expr><call><name>heap_getattr</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>,
										  <argument><expr><name>Anum_pg_dist_local_groupid</name></expr></argument>,
										  <argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>groupId</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>groupIdDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* set the local cache variable */</comment>
		<expr_stmt><expr><name>LocalGroupId</name> <operator>=</operator> <name>groupId</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Upgrade is happening. When upgrading postgres, pg_dist_local_group is
		 * temporarily empty before citus_finish_pg_upgrade() finishes execution.
		 */</comment>
		<expr_stmt><expr><name>groupId</name> <operator>=</operator> <name>GROUP_ID_UPGRADING</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pgDistLocalGroupId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>groupId</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetNodeId returns the node identifier of the local node.
 */</comment>
<function><type><name>int32</name></type>
<name>GetLocalNodeId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>InitializeCaches</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Already set the node id, no need to read the heap again.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>LocalNodeId</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>LocalNodeId</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>uint32</name></type> <name>nodeId</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int32</name></type> <name>localGroupId</name> <init>= <expr><call><name>GetLocalGroupId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>includeNodesFromOtherClusters</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>workerNodeList</name> <init>= <expr><call><name>ReadDistNode</name><argument_list>(<argument><expr><name>includeNodesFromOtherClusters</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>workerNode</argument>, <argument>workerNodeList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>workerNode</name><operator>-&gt;</operator><name>groupId</name></name> <operator>==</operator> <name>localGroupId</name> <operator>&amp;&amp;</operator>
			<name><name>workerNode</name><operator>-&gt;</operator><name>isActive</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>nodeId</name> <operator>=</operator> <name><name>workerNode</name><operator>-&gt;</operator><name>nodeId</name></name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * nodeId is -1 if we cannot find an active node whose group id is
	 * localGroupId in pg_dist_node.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>nodeId</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>, <argument><expr><literal type="string">"there is no active node with group id '%d' on pg_dist_node"</literal></expr></argument>,
			 <argument><expr><name>localGroupId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * This is expected if the coordinator is not added to the metadata.
		 * We'll return GLOBAL_PID_NODE_ID_FOR_NODES_NOT_IN_METADATA for this case and
		 * for all cases so views can function almost normally
		 */</comment>
		<expr_stmt><expr><name>nodeId</name> <operator>=</operator> <name>GLOBAL_PID_NODE_ID_FOR_NODES_NOT_IN_METADATA</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>LocalNodeId</name> <operator>=</operator> <name>nodeId</name></expr>;</expr_stmt>

	<return>return <expr><name>nodeId</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RegisterLocalGroupIdCacheCallbacks registers the callbacks required to
 * maintain LocalGroupId at a consistent value. It's separate from
 * GetLocalGroupId so the callback can be registered early, before metadata
 * tables exist.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RegisterLocalGroupIdCacheCallbacks</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Watch for invalidation events. */</comment>
	<expr_stmt><expr><call><name>CacheRegisterRelcacheCallback</name><argument_list>(<argument><expr><name>InvalidateLocalGroupIdRelationCacheCallback</name></expr></argument>,
								  <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * RegisterAuthinfoCacheCallbacks registers the callbacks required to
 * maintain cached connection parameters at fresh values.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RegisterAuthinfoCacheCallbacks</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Watch for invalidation events. */</comment>
	<expr_stmt><expr><call><name>CacheRegisterRelcacheCallback</name><argument_list>(<argument><expr><name>InvalidateConnParamsCacheCallback</name></expr></argument>, <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ResetCitusTableCacheEntry frees any out-of-band memory used by a cache entry,
 * but does not free the entry itself.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ResetCitusTableCacheEntry</name><parameter_list>(<parameter><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>cacheEntry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>partitionKeyString</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>partitionKeyString</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>partitionKeyString</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>shardIntervalCompareFunction</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>shardIntervalCompareFunction</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>shardIntervalCompareFunction</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>hashFunction</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>hashFunction</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>hashFunction</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>partitionColumn</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>partitionColumn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>partitionColumn</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>shardIntervalArrayLength</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* clean up ShardIdCacheHash */</comment>
	<expr_stmt><expr><call><name>RemoveStaleShardIdCacheEntries</name><argument_list>(<argument><expr><name>cacheEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>shardIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>shardIndex</name> <operator>&lt;</operator> <name><name>cacheEntry</name><operator>-&gt;</operator><name>shardIntervalArrayLength</name></name></expr>;</condition>
		 <incr><expr><name>shardIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>sortedShardIntervalArray</name><index>[<expr><name>shardIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>GroupShardPlacement</name> <modifier>*</modifier></type><name>placementArray</name> <init>=
			<expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>arrayOfPlacementArrays</name><index>[<expr><name>shardIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>valueByVal</name> <init>= <expr><name><name>shardInterval</name><operator>-&gt;</operator><name>valueByVal</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* delete the shard's placements */</comment>
		<if_stmt><if>if <condition>(<expr><name>placementArray</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>placementArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* delete data pointed to by ShardInterval */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>valueByVal</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>shardInterval</name><operator>-&gt;</operator><name>minValueExists</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>minValue</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>shardInterval</name><operator>-&gt;</operator><name>maxValueExists</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>maxValue</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* and finally the ShardInterval itself */</comment>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>shardInterval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>sortedShardIntervalArray</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>sortedShardIntervalArray</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>sortedShardIntervalArray</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>arrayOfPlacementArrayLengths</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>arrayOfPlacementArrayLengths</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>arrayOfPlacementArrayLengths</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>arrayOfPlacementArrays</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>arrayOfPlacementArrays</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>arrayOfPlacementArrays</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>referencedRelationsViaForeignKey</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>referencedRelationsViaForeignKey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>referencedRelationsViaForeignKey</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>referencingRelationsViaForeignKey</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>referencingRelationsViaForeignKey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>referencingRelationsViaForeignKey</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>shardIntervalArrayLength</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>hasUninitializedShardInterval</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>hasUniformHashDistribution</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>hasOverlappingShardInterval</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>autoConverted</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>cacheEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * RemoveStaleShardIdCacheEntries removes all shard ID cache entries belonging to the
 * given table entry. If the shard ID belongs to a different (newer) table entry,
 * we leave it in place.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RemoveStaleShardIdCacheEntries</name><parameter_list>(<parameter><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>invalidatedTableEntry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>shardIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>shardCount</name> <init>= <expr><name><name>invalidatedTableEntry</name><operator>-&gt;</operator><name>shardIntervalArrayLength</name></name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>shardIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>shardIndex</name> <operator>&lt;</operator> <name>shardCount</name></expr>;</condition> <incr><expr><name>shardIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>=
			<expr><name><name>invalidatedTableEntry</name><operator>-&gt;</operator><name>sortedShardIntervalArray</name><index>[<expr><name>shardIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int64</name></type> <name>shardId</name> <init>= <expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>foundInCache</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>ShardIdCacheEntry</name> <modifier>*</modifier></type><name>shardIdCacheEntry</name> <init>=
			<expr><call><name>hash_search</name><argument_list>(<argument><expr><name>ShardIdCacheHash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shardId</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>foundInCache</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>foundInCache</name> <operator>&amp;&amp;</operator> <name><name>shardIdCacheEntry</name><operator>-&gt;</operator><name>tableEntry</name></name> <operator>==</operator> <name>invalidatedTableEntry</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name>ShardIdCacheHash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shardId</name></expr></argument>, <argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>foundInCache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>


<comment type="block">/*
 * InvalidateForeignRelationGraphCacheCallback invalidates the foreign key relation
 * graph and entire distributed cache entries.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>InvalidateForeignRelationGraphCacheCallback</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>argument</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>relationId</name> <operator>==</operator> <name><name>MetadataCache</name><operator>.</operator><name>distColocationRelationId</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SetForeignConstraintRelationshipGraphInvalid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>InvalidateDistTableCache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * InvalidateForeignKeyGraph is used to invalidate the cached foreign key
 * graph (see ForeignKeyRelationGraph @ utils/foreign_key_relationship.c).
 *
 * To invalidate the foreign key graph, we hack around relcache invalidation
 * callbacks. Given that there is no metadata table associated with the foreign
 * key graph cache, we use pg_dist_colocation, which is never invalidated for
 * other purposes.
 *
 * We acknowledge that it is not a very intuitive way of implementing this cache
 * invalidation, but, seems acceptable for now. If this becomes problematic, we
 * could try using a magic oid where we're sure that no relation would ever use
 * that oid.
 */</comment>
<function><type><name>void</name></type>
<name>InvalidateForeignKeyGraph</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CitusHasBeenLoaded</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We should not try to invalidate foreign key graph
		 * if citus is not loaded.
		 */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>CitusInvalidateRelcacheByRelid</name><argument_list>(<argument><expr><call><name>DistColocationRelationId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* bump command counter to force invalidation to take effect */</comment>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * InvalidateDistRelationCacheCallback flushes cache entries when a relation
 * is updated (or flushes the entire cache).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>InvalidateDistRelationCacheCallback</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>argument</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* invalidate either entire cache or a specific entry */</comment>
	<if_stmt><if>if <condition>(<expr><name>relationId</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>InvalidateDistTableCache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>InvalidateDistObjectCache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>hashKey</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>relationId</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>foundInCache</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>CitusTableCacheEntrySlot</name> <modifier>*</modifier></type><name>cacheSlot</name> <init>=
			<expr><call><name>hash_search</name><argument_list>(<argument><expr><name>DistTableCacheHash</name></expr></argument>, <argument><expr><name>hashKey</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>foundInCache</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>foundInCache</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>InvalidateCitusTableCacheEntrySlot</name><argument_list>(<argument><expr><name>cacheSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If pg_dist_partition is being invalidated drop all state
		 * This happens pretty rarely, but most importantly happens during
		 * DROP EXTENSION citus; This isn't the only time when this happens
		 * though, it can happen for multiple other reasons, such as an
		 * autovacuum running ANALYZE on pg_dist_partition. Such an ANALYZE
		 * wouldn't really need a full Metadata cache invalidation, but we
		 * don't know how to differentiate between DROP EXTENSION and ANALYZE.
		 * So for now we simply drop it in both cases and take the slight
		 * temporary performance hit.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>relationId</name> <operator>==</operator> <name><name>MetadataCache</name><operator>.</operator><name>distPartitionRelationId</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>InvalidateMetadataSystemCache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>relationId</name> <operator>==</operator> <name><name>MetadataCache</name><operator>.</operator><name>distObjectRelationId</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>InvalidateDistObjectCache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * InvalidateCitusTableCacheEntrySlot marks a CitusTableCacheEntrySlot as invalid,
 * meaning it needs to be rebuilt and the citusTableMetadata (if any) should be
 * released.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>InvalidateCitusTableCacheEntrySlot</name><parameter_list>(<parameter><decl><type><name>CitusTableCacheEntrySlot</name> <modifier>*</modifier></type><name>cacheSlot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* recheck whether this is a distributed table */</comment>
	<expr_stmt><expr><name><name>cacheSlot</name><operator>-&gt;</operator><name>isValid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cacheSlot</name><operator>-&gt;</operator><name>citusTableMetadata</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* reload the metadata */</comment>
		<expr_stmt><expr><name><name>cacheSlot</name><operator>-&gt;</operator><name>citusTableMetadata</name><operator>-&gt;</operator><name>isValid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/* clean up ShardIdCacheHash */</comment>
		<expr_stmt><expr><call><name>RemoveStaleShardIdCacheEntries</name><argument_list>(<argument><expr><name><name>cacheSlot</name><operator>-&gt;</operator><name>citusTableMetadata</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * InvalidateDistTableCache marks all DistTableCacheHash entries invalid.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>InvalidateDistTableCache</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CitusTableCacheEntrySlot</name> <modifier>*</modifier></type><name>cacheSlot</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>DistTableCacheHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>cacheSlot</name> <operator>=</operator> <operator>(</operator><name>CitusTableCacheEntrySlot</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>InvalidateCitusTableCacheEntrySlot</name><argument_list>(<argument><expr><name>cacheSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>


<comment type="block">/*
 * InvalidateDistObjectCache marks all DistObjectCacheHash entries invalid.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>InvalidateDistObjectCache</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DistObjectCacheEntry</name> <modifier>*</modifier></type><name>cacheEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>DistObjectCacheHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>cacheEntry</name> <operator>=</operator> <operator>(</operator><name>DistObjectCacheEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>isValid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>


<comment type="block">/*
 * FlushDistTableCache flushes the entire distributed relation cache, frees
 * all entries, and recreates the cache.
 */</comment>
<function><type><name>void</name></type>
<name>FlushDistTableCache</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CitusTableCacheEntrySlot</name> <modifier>*</modifier></type><name>cacheSlot</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>DistTableCacheHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>cacheSlot</name> <operator>=</operator> <operator>(</operator><name>CitusTableCacheEntrySlot</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ResetCitusTableCacheEntry</name><argument_list>(<argument><expr><name><name>cacheSlot</name><operator>-&gt;</operator><name>citusTableMetadata</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name>DistTableCacheHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name>ShardIdCacheHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CreateDistTableCache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CreateShardIdCache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* CreateDistTableCache initializes the per-table hash table */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CreateDistTableCache</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASHCTL</name></type> <name>info</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>info</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>CitusTableCacheEntrySlot</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>hash</name></name> <operator>=</operator> <name>tag_hash</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name>MetadataCacheMemoryContext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>DistTableCacheHash</name> <operator>=</operator>
		<call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"Distributed Relation Cache"</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>,
					<argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_FUNCTION</name> <operator>|</operator> <name>HASH_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* CreateShardIdCache initializes the shard ID mapping */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CreateShardIdCache</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASHCTL</name></type> <name>info</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>info</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ShardIdCacheEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>hash</name></name> <operator>=</operator> <name>tag_hash</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name>MetadataCacheMemoryContext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ShardIdCacheHash</name> <operator>=</operator>
		<call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"Shard Id Cache"</literal></expr></argument>, <argument><expr><literal type="number">128</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>,
					<argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_FUNCTION</name> <operator>|</operator> <name>HASH_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* CreateDistObjectCache initializes the per-object hash table */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CreateDistObjectCache</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASHCTL</name></type> <name>info</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>info</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DistObjectCacheEntryKey</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DistObjectCacheEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>hash</name></name> <operator>=</operator> <name>tag_hash</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name>MetadataCacheMemoryContext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>DistObjectCacheHash</name> <operator>=</operator>
		<call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"Distributed Object Cache"</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>,
					<argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_FUNCTION</name> <operator>|</operator> <name>HASH_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * InvalidateMetadataSystemCache resets all the cached OIDs and the extensionLoaded flag,
 * and invalidates the worker node, ConnParams, and local group ID caches.
 */</comment>
<function><type><name>void</name></type>
<name>InvalidateMetadataSystemCache</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>InvalidateConnParamsHashEntries</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>MetadataCache</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>MetadataCache</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>workerNodeHashValid</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>LocalGroupId</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>LocalNodeId</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * AllCitusTableIds returns all citus table ids.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>AllCitusTableIds</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>CitusTableTypeIdList</name><argument_list>(<argument><expr><name>ANY_CITUS_TABLE_TYPE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CitusTableTypeIdList function scans pg_dist_partition and returns a
 * list of OID's for the tables matching given citusTableType.
 * To create the list, it performs sequential scan. Since it is not expected
 * that this function will be called frequently, it is OK not to use index
 * scan. If this function becomes performance bottleneck, it is possible to
 * modify this function to perform index scan.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>CitusTableTypeIdList</name><parameter_list>(<parameter><decl><type><name>CitusTableType</name></type> <name>citusTableType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scanKey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>scanKeyCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>relationIdList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>pgDistPartition</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><call><name>DistPartitionRelationId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scanDescriptor</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pgDistPartition</name></expr></argument>,
													<argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
													<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>scanKeyCount</name></expr></argument>, <argument><expr><name>scanKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pgDistPartition</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>heapTuple</name> <init>= <expr><call><name>systable_getnext</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name><name>isNullArray</name><index>[<expr><name>Natts_pg_dist_partition</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type> <name><name>datumArray</name><index>[<expr><name>Natts_pg_dist_partition</name></expr>]</index></name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>, <argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><name>datumArray</name></expr></argument>, <argument><expr><name>isNullArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>Datum</name></type> <name>partMethodDatum</name> <init>= <expr><name><name>datumArray</name><index>[<expr><name>Anum_pg_dist_partition_partmethod</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type> <name>replicationModelDatum</name> <init>= <expr><name><name>datumArray</name><index>[<expr><name>Anum_pg_dist_partition_repmodel</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Oid</name></type> <name>partitionMethod</name> <init>= <expr><call><name>DatumGetChar</name><argument_list>(<argument><expr><name>partMethodDatum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>replicationModel</name> <init>= <expr><call><name>DatumGetChar</name><argument_list>(<argument><expr><name>replicationModelDatum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableTypeInternal</name><argument_list>(<argument><expr><name>partitionMethod</name></expr></argument>, <argument><expr><name>replicationModel</name></expr></argument>, <argument><expr><name>citusTableType</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type> <name>relationIdDatum</name> <init>= <expr><name><name>datumArray</name><index>[<expr><name>Anum_pg_dist_partition_logicalrelid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name>relationIdDatum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>relationIdList</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>relationIdList</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>heapTuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pgDistPartition</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>relationIdList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * InvalidateNodeRelationCacheCallback destroys the WorkerNodeHash when
 * any change happens on pg_dist_node table. It also set WorkerNodeHash to
 * NULL, which allows consequent accesses to the hash read from the
 * pg_dist_node from scratch.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>InvalidateNodeRelationCacheCallback</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>argument</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>relationId</name> <operator>==</operator> <name>InvalidOid</name> <operator>||</operator> <name>relationId</name> <operator>==</operator> <name><name>MetadataCache</name><operator>.</operator><name>distNodeRelationId</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>workerNodeHashValid</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>LocalNodeId</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * InvalidateLocalGroupIdRelationCacheCallback sets the LocalGroupId to
 * the default value.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>InvalidateLocalGroupIdRelationCacheCallback</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>argument</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* when invalidation happens simply set the LocalGroupId to the default value */</comment>
	<if_stmt><if>if <condition>(<expr><name>relationId</name> <operator>==</operator> <name>InvalidOid</name> <operator>||</operator> <name>relationId</name> <operator>==</operator> <name><name>MetadataCache</name><operator>.</operator><name>distLocalGroupRelationId</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>LocalGroupId</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * InvalidateConnParamsCacheCallback sets isValid flag to false for all entries
 * in ConnParamsHash, a cache used during connection establishment.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>InvalidateConnParamsCacheCallback</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>argument</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>relationId</name> <operator>==</operator> <name><name>MetadataCache</name><operator>.</operator><name>distAuthinfoRelationId</name></name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name><name>MetadataCache</name><operator>.</operator><name>distPoolinfoRelationId</name></name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ConnParamsHashEntry</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>ConnParamsHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<while>while <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <operator>(</operator><name>ConnParamsHashEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>isValid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CitusTableCacheFlushInvalidatedEntries frees invalidated cache entries.
 * Invalidated entries aren't freed immediately as callers expect their lifetime
 * to extend beyond that scope.
 */</comment>
<function><type><name>void</name></type>
<name>CitusTableCacheFlushInvalidatedEntries</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>DistTableCacheHash</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>DistTableCacheExpired</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>cacheEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>cacheEntry</argument>, <argument>DistTableCacheExpired</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ResetCitusTableCacheEntry</name><argument_list>(<argument><expr><name>cacheEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>DistTableCacheExpired</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>DistTableCacheExpired</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CitusTableCacheEntryReleaseCallback frees invalidated cache entries.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CitusTableCacheEntryReleaseCallback</name><parameter_list>(<parameter><decl><type><name>ResourceReleasePhase</name></type> <name>phase</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isCommit</name></decl></parameter>,
									<parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>isTopLevel</name> <operator>&amp;&amp;</operator> <name>phase</name> <operator>==</operator> <name>RESOURCE_RELEASE_LOCKS</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CitusTableCacheFlushInvalidatedEntries</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * LookupDistPartitionTuple searches pg_dist_partition for relationId's entry
 * and returns that or, if no matching entry was found, NULL.
 */</comment>
<function><type><specifier>static</specifier> <name>HeapTuple</name></type>
<name>LookupDistPartitionTuple</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>pgDistPartition</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>distPartitionTuple</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scanKey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* copy scankey to local copy, it will be modified during the scan */</comment>
	<expr_stmt><expr><name><name>scanKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>DistPartitionScanKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/* set scan arguments */</comment>
	<expr_stmt><expr><name><name>scanKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>sk_argument</name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scanDescriptor</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pgDistPartition</name></expr></argument>,
													<argument><expr><call><name>DistPartitionLogicalRelidIndexId</name><argument_list>()</argument_list></call></expr></argument>,
													<argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>scanKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>currentPartitionTuple</name> <init>= <expr><call><name>systable_getnext</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>currentPartitionTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>distPartitionTuple</name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><name>currentPartitionTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>distPartitionTuple</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * LookupDistShardTuples returns a list of all dist_shard tuples for the
 * specified relation.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>LookupDistShardTuples</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>distShardTupleList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scanKey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>pgDistShard</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><call><name>DistShardRelationId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* copy scankey to local copy, it will be modified during the scan */</comment>
	<expr_stmt><expr><name><name>scanKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>DistShardScanKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/* set scan arguments */</comment>
	<expr_stmt><expr><name><name>scanKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>sk_argument</name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scanDescriptor</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pgDistShard</name></expr></argument>,
													<argument><expr><call><name>DistShardLogicalRelidIndexId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>,
													<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>scanKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>currentShardTuple</name> <init>= <expr><call><name>systable_getnext</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>currentShardTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type> <name>shardTupleCopy</name> <init>= <expr><call><name>heap_copytuple</name><argument_list>(<argument><expr><name>currentShardTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>distShardTupleList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>distShardTupleList</name></expr></argument>, <argument><expr><name>shardTupleCopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>currentShardTuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pgDistShard</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>distShardTupleList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * LookupShardRelationFromCatalog returns the logical relation oid a shard belongs to.
 *
 * Errors out if the shardId does not exist and missingOk is false.
 * Returns InvalidOid if the shardId does not exist and missingOk is true.
 */</comment>
<function><type><name>Oid</name></type>
<name>LookupShardRelationFromCatalog</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>shardId</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missingOk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scanKey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>scanKeyCount</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_dist_shard</name></type> <name>shardForm</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>pgDistShard</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><call><name>DistShardRelationId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_pg_dist_shard_shardid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_INT8EQ</name></expr></argument>, <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scanDescriptor</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pgDistShard</name></expr></argument>,
													<argument><expr><call><name>DistShardShardidIndexId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>,
													<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>scanKeyCount</name></expr></argument>, <argument><expr><name>scanKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>heapTuple</name> <init>= <expr><call><name>systable_getnext</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>missingOk</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not find valid entry for shard "</literal>
							   <name>UINT64_FORMAT</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>relationId</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>shardForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_dist_shard</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>relationId</name> <operator>=</operator> <name><name>shardForm</name><operator>-&gt;</operator><name>logicalrelid</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pgDistShard</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>relationId</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetPartitionTypeInputInfo populates output parameters with the interval type
 * identifier and modifier for the specified partition key/method combination.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>GetPartitionTypeInputInfo</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>partitionKeyString</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>partitionMethod</name></decl></parameter>,
						  <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>columnTypeId</name></decl></parameter>, <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>columnTypeMod</name></decl></parameter>,
						  <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>intervalTypeId</name></decl></parameter>, <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>intervalTypeMod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>*</operator><name>columnTypeId</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>columnTypeMod</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>intervalTypeId</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>intervalTypeMod</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>partitionMethod</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>DISTRIBUTE_BY_APPEND</name></expr>:</case>
		<case>case <expr><name>DISTRIBUTE_BY_RANGE</name></expr>:</case>
		<case>case <expr><name>DISTRIBUTE_BY_HASH</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>partitionNode</name> <init>= <expr><call><name>stringToNode</name><argument_list>(<argument><expr><name>partitionKeyString</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>partitionColumn</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>partitionNode</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>partitionNode</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>GetIntervalTypeInfo</name><argument_list>(<argument><expr><name>partitionMethod</name></expr></argument>, <argument><expr><name>partitionColumn</name></expr></argument>,
								<argument><expr><name>intervalTypeId</name></expr></argument>, <argument><expr><name>intervalTypeMod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><operator>*</operator><name>columnTypeId</name> <operator>=</operator> <name><name>partitionColumn</name><operator>-&gt;</operator><name>vartype</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>columnTypeMod</name> <operator>=</operator> <name><name>partitionColumn</name><operator>-&gt;</operator><name>vartypmod</name></name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>DISTRIBUTE_BY_NONE</name></expr>:</case>
		<block>{<block_content>
			<break>break;</break>
		</block_content>}</block>

		<default>default:</default>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unsupported table partition type: %c"</literal></expr></argument>,
								   <argument><expr><name>partitionMethod</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
 * GetIntervalTypeInfo gets type id and type mod of the min/max values
 * of shard intervals for a distributed table with given partition method
 * and partition column.
 */</comment>
<function><type><name>void</name></type>
<name>GetIntervalTypeInfo</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>partitionMethod</name></decl></parameter>, <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>partitionColumn</name></decl></parameter>,
					<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>intervalTypeId</name></decl></parameter>, <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>intervalTypeMod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>*</operator><name>intervalTypeId</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>intervalTypeMod</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>partitionMethod</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>DISTRIBUTE_BY_APPEND</name></expr>:</case>
		<case>case <expr><name>DISTRIBUTE_BY_RANGE</name></expr>:</case>
		<block>{<block_content>
			<comment type="block">/* we need a valid partition column Var in this case */</comment>
			<if_stmt><if>if <condition>(<expr><name>partitionColumn</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected partition column value: null"</literal></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Please report this to the Citus core team."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><operator>*</operator><name>intervalTypeId</name> <operator>=</operator> <name><name>partitionColumn</name><operator>-&gt;</operator><name>vartype</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>intervalTypeMod</name> <operator>=</operator> <name><name>partitionColumn</name><operator>-&gt;</operator><name>vartypmod</name></name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>DISTRIBUTE_BY_HASH</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>intervalTypeId</name> <operator>=</operator> <name>INT4OID</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<default>default:</default>
		<block>{<block_content>
			<break>break;</break>
		</block_content>}</block>
	</block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
 * TupleToShardInterval transforms the specified dist_shard tuple into a new
 * ShardInterval using the provided descriptor and partition type information.
 */</comment>
<function><type><name>ShardInterval</name> <modifier>*</modifier></type>
<name>TupleToShardInterval</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>heapTuple</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type>
					 <name>intervalTypeId</name></decl></parameter>,
					 <parameter><decl><type><name>int32</name></type> <name>intervalTypeMod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type> <name><name>datumArray</name><index>[<expr><name>Natts_pg_dist_shard</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name><name>isNullArray</name><index>[<expr><name>Natts_pg_dist_shard</name></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We use heap_deform_tuple() instead of heap_getattr() to expand tuple
	 * to contain missing values when ALTER TABLE ADD COLUMN happens.
	 */</comment>
	<expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>, <argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><name>datumArray</name></expr></argument>, <argument><expr><name>isNullArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>=
		<expr><call><name>DeformedDistShardTupleToShardInterval</name><argument_list>(<argument><expr><name>datumArray</name></expr></argument>, <argument><expr><name>isNullArray</name></expr></argument>,
											  <argument><expr><name>intervalTypeId</name></expr></argument>, <argument><expr><name>intervalTypeMod</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>shardInterval</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DeformedDistShardTupleToShardInterval transforms the specified deformed
 * pg_dist_shard tuple into a new ShardInterval.
 */</comment>
<function><type><name>ShardInterval</name> <modifier>*</modifier></type>
<name>DeformedDistShardTupleToShardInterval</name><parameter_list>(<parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>datumArray</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isNullArray</name></decl></parameter>,
									  <parameter><decl><type><name>Oid</name></type> <name>intervalTypeId</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>intervalTypeMod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>inputFunctionId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>typeIoParam</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>minValue</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>maxValue</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>minValueExists</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>maxValueExists</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type> <name>intervalTypeLen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>intervalByVal</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>intervalAlign</name> <init>= <expr><literal type="char">'0'</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>intervalDelim</name> <init>= <expr><literal type="char">'0'</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>=
		<expr><call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name><name>datumArray</name><index>[<expr><name>Anum_pg_dist_shard_logicalrelid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>shardId</name> <init>= <expr><call><name>DatumGetInt64</name><argument_list>(<argument><expr><name><name>datumArray</name><index>[<expr><name>Anum_pg_dist_shard_shardid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>storageType</name> <init>= <expr><call><name>DatumGetChar</name><argument_list>(<argument><expr><name><name>datumArray</name><index>[<expr><name>Anum_pg_dist_shard_shardstorage</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>minValueTextDatum</name> <init>= <expr><name><name>datumArray</name><index>[<expr><name>Anum_pg_dist_shard_shardminvalue</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>maxValueTextDatum</name> <init>= <expr><name><name>datumArray</name><index>[<expr><name>Anum_pg_dist_shard_shardmaxvalue</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>minValueNull</name> <init>= <expr><name><name>isNullArray</name><index>[<expr><name>Anum_pg_dist_shard_shardminvalue</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>maxValueNull</name> <init>= <expr><name><name>isNullArray</name><index>[<expr><name>Anum_pg_dist_shard_shardmaxvalue</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>minValueNull</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>maxValueNull</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>minValueString</name> <init>= <expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>minValueTextDatum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>maxValueString</name> <init>= <expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>maxValueTextDatum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* TODO: move this up the call stack to avoid per-tuple invocation? */</comment>
		<expr_stmt><expr><call><name>get_type_io_data</name><argument_list>(<argument><expr><name>intervalTypeId</name></expr></argument>, <argument><expr><name>IOFunc_input</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>intervalTypeLen</name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name>intervalByVal</name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name>intervalAlign</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>intervalDelim</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typeIoParam</name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name>inputFunctionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* finally convert min/max values to their actual types */</comment>
		<expr_stmt><expr><name>minValue</name> <operator>=</operator> <call><name>OidInputFunctionCall</name><argument_list>(<argument><expr><name>inputFunctionId</name></expr></argument>, <argument><expr><name>minValueString</name></expr></argument>,
										<argument><expr><name>typeIoParam</name></expr></argument>, <argument><expr><name>intervalTypeMod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>maxValue</name> <operator>=</operator> <call><name>OidInputFunctionCall</name><argument_list>(<argument><expr><name>inputFunctionId</name></expr></argument>, <argument><expr><name>maxValueString</name></expr></argument>,
										<argument><expr><name>typeIoParam</name></expr></argument>, <argument><expr><name>intervalTypeMod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>minValueExists</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>maxValueExists</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>ShardInterval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>relationId</name></name> <operator>=</operator> <name>relationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>storageType</name></name> <operator>=</operator> <name>storageType</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>valueTypeId</name></name> <operator>=</operator> <name>intervalTypeId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>valueTypeLen</name></name> <operator>=</operator> <name>intervalTypeLen</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>valueByVal</name></name> <operator>=</operator> <name>intervalByVal</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>minValueExists</name></name> <operator>=</operator> <name>minValueExists</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>maxValueExists</name></name> <operator>=</operator> <name>maxValueExists</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>minValue</name></name> <operator>=</operator> <name>minValue</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>maxValue</name></name> <operator>=</operator> <name>maxValue</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name> <operator>=</operator> <name>shardId</name></expr>;</expr_stmt>

	<return>return <expr><name>shardInterval</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CachedNamespaceLookup performs a cached lookup for the namespace (schema), with the
 * result cached in cachedOid.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CachedNamespaceLookup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nspname</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>cachedOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* force callbacks to be registered, so we always get notified upon changes */</comment>
	<expr_stmt><expr><call><name>InitializeCaches</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cachedOid</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>cachedOid</name> <operator>=</operator> <call><name>get_namespace_oid</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cachedOid</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
								<argument><expr><literal type="string">"cache lookup failed for namespace %s, called too early?"</literal></expr></argument>,
								<argument><expr><name>nspname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CachedRelationLookup performs a cached lookup for the relation
 * relationName, with the result cached in *cachedOid.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CachedRelationLookup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relationName</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>cachedOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CachedRelationNamespaceLookup</name><argument_list>(<argument><expr><name>relationName</name></expr></argument>, <argument><expr><name>PG_CATALOG_NAMESPACE</name></expr></argument>, <argument><expr><name>cachedOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CachedRelationLookupExtended performs a cached lookup for the relation
 * relationName, with the result cached in *cachedOid. Will _not_ throw an error when
 * missing_ok is set to true.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CachedRelationLookupExtended</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relationName</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>cachedOid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CachedRelationNamespaceLookupExtended</name><argument_list>(<argument><expr><name>relationName</name></expr></argument>, <argument><expr><name>PG_CATALOG_NAMESPACE</name></expr></argument>, <argument><expr><name>cachedOid</name></expr></argument>,
										  <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>CachedRelationNamespaceLookup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relationName</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relnamespace</name></decl></parameter>,
							  <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>cachedOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CachedRelationNamespaceLookupExtended</name><argument_list>(<argument><expr><name>relationName</name></expr></argument>, <argument><expr><name>relnamespace</name></expr></argument>, <argument><expr><name>cachedOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>CachedRelationNamespaceLookupExtended</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relationName</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relnamespace</name></decl></parameter>,
									  <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>cachedOid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* force callbacks to be registered, so we always get notified upon changes */</comment>
	<expr_stmt><expr><call><name>InitializeCaches</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cachedOid</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>cachedOid</name> <operator>=</operator> <call><name>get_relname_relid</name><argument_list>(<argument><expr><name>relationName</name></expr></argument>, <argument><expr><name>relnamespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cachedOid</name> <operator>==</operator> <name>InvalidOid</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>missing_ok</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
								<argument><expr><literal type="string">"cache lookup failed for %s, called too early?"</literal></expr></argument>,
								<argument><expr><name>relationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * RelationExists returns whether a relation with the given OID exists.
 */</comment>
<function><type><name>bool</name></type>
<name>RelationExists</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>relTuple</name> <init>= <expr><call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>relationExists</name> <init>= <expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>relTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>relationExists</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>relTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>relationExists</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Register a relcache invalidation for a non-shared relation.
 *
 * We ignore the case that there's no corresponding pg_class entry - that
 * happens if we register a relcache invalidation (e.g. for a
 * pg_dist_partition deletion) after the relation has been dropped. That's ok,
 * because in those cases we're guaranteed to already have registered an
 * invalidation for the target relation.
 */</comment>
<function><type><name>void</name></type>
<name>CitusInvalidateRelcacheByRelid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>classTuple</name> <init>= <expr><call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>classTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CacheInvalidateRelcacheByTuple</name><argument_list>(<argument><expr><name>classTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>classTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Register a relcache invalidation for the distributed relation associated
 * with the shard.
 */</comment>
<function><type><name>void</name></type>
<name>CitusInvalidateRelcacheByShardId</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>shardId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scanKey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>scanKeyCount</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_dist_shard</name></type> <name>shardForm</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>pgDistShard</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><call><name>DistShardRelationId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Load shard, to find the associated relation id. Can't use
	 * LoadShardInterval directly because that'd fail if the shard doesn't
	 * exist anymore, which we can't have. Also lower overhead is desirable
	 * here.
	 */</comment>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_pg_dist_shard_shardid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_INT8EQ</name></expr></argument>, <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scanDescriptor</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pgDistShard</name></expr></argument>,
													<argument><expr><call><name>DistShardShardidIndexId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>,
													<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>scanKeyCount</name></expr></argument>, <argument><expr><name>scanKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>heapTuple</name> <init>= <expr><call><name>systable_getnext</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>shardForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_dist_shard</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CitusInvalidateRelcacheByRelid</name><argument_list>(<argument><expr><name><name>shardForm</name><operator>-&gt;</operator><name>logicalrelid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Couldn't find associated relation. That can primarily happen in two cases:
		 *
		 * 1) A placement row is inserted before the shard row. That's fine,
		 *	  since we don't need invalidations via placements in that case.
		 *
		 * 2) The shard has been deleted, but some placements were
		 *    unreachable, and the user is manually deleting the rows. Not
		 *    much point in WARNING or ERRORing in that case either, there's
		 *    nothing to invalidate.
		 *
		 * Hence we just emit a DEBUG5 message.
		 */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
							 <argument><expr><literal type="string">"could not find distributed relation to invalidate for "</literal>
							 <literal type="string">"shard "</literal><name>INT64_FORMAT</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pgDistShard</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* bump command counter, to force invalidation to take effect */</comment>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * DistNodeMetadata returns the single metadata jsonb object stored in
 * pg_dist_node_metadata.
 */</comment>
<function><type><name>Datum</name></type>
<name>DistNodeMetadata</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type> <name>metadata</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scanKey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>scanKeyCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>metadataTableOid</name> <init>= <expr><call><name>get_relname_relid</name><argument_list>(<argument><expr><literal type="string">"pg_dist_node_metadata"</literal></expr></argument>,
											 <argument><expr><name>PG_CATALOG_NAMESPACE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>metadataTableOid</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"pg_dist_node_metadata was not found"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>pgDistNodeMetadata</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>metadataTableOid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scanDescriptor</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pgDistNodeMetadata</name></expr></argument>,
													<argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
													<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>scanKeyCount</name></expr></argument>, <argument><expr><name>scanKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pgDistNodeMetadata</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>heapTuple</name> <init>= <expr><call><name>systable_getnext</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>isNull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>metadata</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>, <argument><expr><name>Anum_pg_dist_node_metadata_metadata</name></expr></argument>,
								<argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
							<argument><expr><literal type="string">"could not find any entries in pg_dist_metadata"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Copy the jsonb result before closing the table
	 * since that memory can be freed.
	 */</comment>
	<expr_stmt><expr><name>metadata</name> <operator>=</operator> <call><name>JsonbPGetDatum</name><argument_list>(<argument><expr><call><name>DatumGetJsonbPCopy</name><argument_list>(<argument><expr><name>metadata</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pgDistNodeMetadata</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>metadata</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * role_exists is a check constraint which ensures that roles referenced in the
 * pg_dist_authinfo catalog actually exist (at least at the time of insertion).
 */</comment>
<function><type><name>Datum</name></type>
<name>role_exists</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Name</name></type> <name>roleName</name> <init>= <expr><call><name>PG_GETARG_NAME</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>roleExists</name> <init>= <expr><call><name>SearchSysCacheExists1</name><argument_list>(<argument><expr><name>AUTHNAME</name></expr></argument>, <argument><expr><call><name>NameGetDatum</name><argument_list>(<argument><expr><name>roleName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>roleExists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * GetPoolinfoViaCatalog searches the pg_dist_poolinfo table for a row matching
 * the provided nodeId and returns the poolinfo field of this row if found.
 * Otherwise, this function returns NULL.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>GetPoolinfoViaCatalog</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>nodeId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scanKey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>scanKeyCount</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>AttrNumber</name></type> <name>nodeIdIdx</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>poolinfoIdx</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>pgDistPoolinfo</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><call><name>DistPoolinfoRelationId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>indexOK</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>poolinfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* set scan arguments */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>nodeIdIdx</name></expr></argument>, <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_INT4EQ</name></expr></argument>,
				<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>nodeId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scanDescriptor</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pgDistPoolinfo</name></expr></argument>, <argument><expr><call><name>DistPoolinfoIndexId</name><argument_list>()</argument_list></call></expr></argument>,
													<argument><expr><name>indexOK</name></expr></argument>,
													<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>scanKeyCount</name></expr></argument>, <argument><expr><name>scanKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>heapTuple</name> <init>= <expr><call><name>systable_getnext</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pgDistPoolinfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>isNull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Datum</name></type> <name>poolinfoDatum</name> <init>= <expr><call><name>heap_getattr</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>, <argument><expr><name>poolinfoIdx</name></expr></argument>, <argument><expr><name>tupleDescriptor</name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>poolinfo</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>poolinfoDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pgDistPoolinfo</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>poolinfo</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetAuthinfoViaCatalog searches pg_dist_authinfo for a row matching a pro-
 * vided role and node id. Three types of rules are currently permitted: those
 * matching a specific node (non-zero nodeid), those matching all nodes (a
 * nodeid of zero), and those denoting a loopback connection (nodeid of -1).
 * Rolename must always be specified. If both types of rules exist for a given
 * user/host, the more specific (host-specific) rule wins. This means that when
 * both a zero and non-zero row exist for a given rolename, the non-zero row
 * has precedence.
 *
 * In short, this function will return a rule matching nodeId, or if that's
 * absent the rule for 0, or if that's absent, an empty string. Callers can
 * just use the returned authinfo and know the precedence has been honored.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>GetAuthinfoViaCatalog</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>roleName</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>nodeId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>authinfo</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name><name>nodeIdDatumArray</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{
		<expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>nodeId</name></expr></argument>)</argument_list></call></expr>,
		<macro><name>Int32GetDatum</name><argument_list>(<argument>WILDCARD_NODE_ID</argument>)</argument_list></macro>
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>nodeIdArrayType</name> <init>= <expr><call><name>DatumArrayToArrayType</name><argument_list>(<argument><expr><name>nodeIdDatumArray</name></expr></argument>,
													   <argument><expr><call><name>lengthof</name><argument_list>(<argument><expr><name>nodeIdDatumArray</name></expr></argument>)</argument_list></call></expr></argument>,
													   <argument><expr><name>INT4OID</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scanKey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>AttrNumber</name></type> <name>nodeIdIdx</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>roleIdx</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>, <decl><type ref="prev"/><name>authinfoIdx</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Our index's definition ensures correct precedence for positive nodeIds,
	 * but when handling a negative value we need to traverse backwards to keep
	 * the invariant that the zero rule has lowest precedence.
	 */</comment>
	<decl_stmt><decl><type><name>ScanDirection</name></type> <name>direction</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>nodeId</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>BackwardScanDirection</name></expr> </then><else>: <expr><name>ForwardScanDirection</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ReindexIsProcessingIndex</name><argument_list>(<argument><expr><call><name>DistAuthinfoIndexId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"authinfo is being reindexed; try again"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scanKey</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>scanKey</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* first column in index is rolename, need exact match there ... */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>roleIdx</name></expr></argument>, <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_NAMEEQ</name></expr></argument>, <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>roleName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* second column is nodeId, match against array of nodeid and zero (any node) ... */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanKey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>nodeIdIdx</name></expr></argument>, <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_INT4EQ</name></expr></argument>, <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>nodeIdArrayType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanKey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>sk_flags</name> <operator>|=</operator> <name>SK_SEARCHARRAY</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * It's important that we traverse the index in order: we need to ensure
	 * that rules with nodeid 0 are encountered last. We'll use the first tuple
	 * we find. This ordering defines the precedence order of authinfo rules.
	 */</comment>
	<decl_stmt><decl><type><name>Relation</name></type> <name>pgDistAuthinfo</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><call><name>DistAuthinfoRelationId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>pgDistAuthinfoIdx</name> <init>= <expr><call><name>index_open</name><argument_list>(<argument><expr><call><name>DistAuthinfoIndexId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scanDescriptor</name> <init>= <expr><call><name>systable_beginscan_ordered</name><argument_list>(<argument><expr><name>pgDistAuthinfo</name></expr></argument>,
															<argument><expr><name>pgDistAuthinfoIdx</name></expr></argument>,
															<argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>lengthof</name><argument_list>(<argument><expr><name>scanKey</name></expr></argument>)</argument_list></call></expr></argument>,
															<argument><expr><name>scanKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* first tuple represents highest-precedence rule for this node */</comment>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>authinfoTuple</name> <init>= <expr><call><name>systable_getnext_ordered</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>, <argument><expr><name>direction</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>authinfoTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pgDistAuthinfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>isNull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Datum</name></type> <name>authinfoDatum</name> <init>= <expr><call><name>heap_getattr</name><argument_list>(<argument><expr><name>authinfoTuple</name></expr></argument>, <argument><expr><name>authinfoIdx</name></expr></argument>,
										   <argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>authinfo</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>authinfoDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>systable_endscan_ordered</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>pgDistAuthinfoIdx</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pgDistAuthinfo</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>authinfo</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * authinfo_valid is a check constraint to verify that an inserted authinfo row
 * uses only permitted libpq parameters.
 */</comment>
<function><type><name>Datum</name></type>
<name>authinfo_valid</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>authinfo</name> <init>= <expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* this array _must_ be kept in an order usable by bsearch */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>allowList</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="string">"password"</literal></expr>, <expr><literal type="string">"sslcert"</literal></expr>, <expr><literal type="string">"sslkey"</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>authinfoValid</name> <init>= <expr><call><name>CheckConninfo</name><argument_list>(<argument><expr><name>authinfo</name></expr></argument>, <argument><expr><name>allowList</name></expr></argument>, <argument><expr><call><name>lengthof</name><argument_list>(<argument><expr><name>allowList</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>authinfoValid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * poolinfo_valid is a check constraint to verify that an inserted poolinfo row
 * uses only permitted libpq parameters.
 */</comment>
<function><type><name>Datum</name></type>
<name>poolinfo_valid</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>poolinfo</name> <init>= <expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* this array _must_ be kept in an order usable by bsearch */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>allowList</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="string">"dbname"</literal></expr>, <expr><literal type="string">"host"</literal></expr>, <expr><literal type="string">"port"</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>poolinfoValid</name> <init>= <expr><call><name>CheckConninfo</name><argument_list>(<argument><expr><name>poolinfo</name></expr></argument>, <argument><expr><name>allowList</name></expr></argument>, <argument><expr><call><name>lengthof</name><argument_list>(<argument><expr><name>allowList</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>poolinfoValid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
