<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/builded_projects/citus/src/backend/distributed/metadata/metadata_sync.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * metadata_sync.c
 *
 * Routines for synchronizing metadata to all workers.
 *
 * Copyright (c) Citus Data, Inc.
 *
 * $Id$
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/nbtree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_attrdef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_constraint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_depend.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_foreign_server.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/async.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/argutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/backend_data.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_ruleutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/colocation_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/deparser.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/distribution_column.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/coordinator_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/maintenanced.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_sync.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata/distobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata/pg_dist_object.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_join_order.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_partitioning_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_physical_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_dist_colocation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_dist_node.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_dist_shard.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/relation_access_tracking.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/remote_commands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/resource_lock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/utils/array_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/utils/function.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_manager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_transaction.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/version_compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands/utility_hook.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/spi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"foreign/foreign.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pg_list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/bgworker.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/postmaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>


<comment type="block">/* managed via a GUC */</comment>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>EnableManualMetadataChangesForUser</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>EnsureObjectMetadataIsSane</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>distributionArgumentIndex</name></decl></parameter>,
									   <parameter><decl><type><name>int</name></type> <name>colocationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>GetFunctionDependenciesForObjects</name><parameter_list>(<parameter><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>objectAddress</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>SchemaOwnerName</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>objectId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>HasMetadataWorkers</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CreateShellTableOnWorkers</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CreateTableMetadataOnWorkers</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CreateDependingViewsOnWorkers</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>NodeMetadataSyncResult</name></type> <name>SyncNodeMetadataToNodesOptional</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ShouldSyncTableMetadataInternal</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>hashDistributed</name></decl></parameter>,
											<parameter><decl><type><name>bool</name></type> <name>citusTableWithNoDistKey</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>SyncNodeMetadataSnapshotToNode</name><parameter_list>(<parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>raiseOnError</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DropMetadataSnapshotOnNode</name><parameter_list>(<parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>CreateSequenceDependencyCommand</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>sequenceId</name></decl></parameter>,
											  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>columnName</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>GrantStmt</name> <modifier>*</modifier></type> <name>GenerateGrantStmtForRights</name><parameter_list>(<parameter><decl><type><name>ObjectType</name></type> <name>objectType</name></decl></parameter>,
											  <parameter><decl><type><name>Oid</name></type> <name>roleOid</name></decl></parameter>,
											  <parameter><decl><type><name>Oid</name></type> <name>objectId</name></decl></parameter>,
											  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>permission</name></decl></parameter>,
											  <parameter><decl><type><name>bool</name></type> <name>withGrantOption</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>GetObjectsForGrantStmt</name><parameter_list>(<parameter><decl><type><name>ObjectType</name></type> <name>objectType</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>objectId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>AccessPriv</name> <modifier>*</modifier></type> <name>GetAccessPrivObjectForGrantStmt</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>permission</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>GenerateGrantOnSchemaQueriesFromAclItem</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>schemaOid</name></decl></parameter>,
													  <parameter><decl><type><name>AclItem</name> <modifier>*</modifier></type><name>aclItem</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>GenerateGrantOnFunctionQueriesFromAclItem</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>schemaOid</name></decl></parameter>,
														<parameter><decl><type><name>AclItem</name> <modifier>*</modifier></type><name>aclItem</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>GrantOnSequenceDDLCommands</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>sequenceOid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>GenerateGrantOnSequenceQueriesFromAclItem</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>sequenceOid</name></decl></parameter>,
														<parameter><decl><type><name>AclItem</name> <modifier>*</modifier></type><name>aclItem</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>GenerateSetRoleQuery</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>roleOid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>MetadataSyncSigTermHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>MetadataSyncSigAlrmHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ShouldSkipMetadataChecks</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>EnsurePartitionMetadataIsSane</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>distributionMethod</name></decl></parameter>,
										  <parameter><decl><type><name>int</name></type> <name>colocationId</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>replicationModel</name></decl></parameter>,
										  <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>distributionKey</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>EnsureCoordinatorInitiatedOperation</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>EnsureShardMetadataIsSane</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>shardId</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>storageType</name></decl></parameter>,
									  <parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>shardMinValue</name></decl></parameter>,
									  <parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>shardMaxValue</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>EnsureShardPlacementMetadataIsSane</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>shardId</name></decl></parameter>,
											   <parameter><decl><type><name>int64</name></type> <name>placementId</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>shardState</name></decl></parameter>,
											   <parameter><decl><type><name>int64</name></type> <name>shardLength</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>groupId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>ColocationGroupCreateCommand</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>colocationId</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>shardCount</name></decl></parameter>,
										   <parameter><decl><type><name>int</name></type> <name>replicationFactor</name></decl></parameter>,
										   <parameter><decl><type><name>Oid</name></type> <name>distributionColumnType</name></decl></parameter>,
										   <parameter><decl><type><name>Oid</name></type> <name>distributionColumnCollation</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>ColocationGroupDeleteCommand</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>colocationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>RemoteTypeIdExpression</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typeId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>RemoteCollationIdExpression</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>colocationId</name></decl></parameter>)</parameter_list>;</function_decl>


<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>start_metadata_sync_to_all_nodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>start_metadata_sync_to_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>stop_metadata_sync_to_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>worker_record_sequence_dependency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<comment type="block">/*
 * Functions to modify metadata. Normally modifying metadata requires
 * superuser. However, these functions can be called with superusers
 * or regular users as long as the regular user owns the input object.
 */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>citus_internal_add_partition_metadata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>citus_internal_delete_partition_metadata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>citus_internal_add_shard_metadata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>citus_internal_add_placement_metadata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>citus_internal_update_placement_metadata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>citus_internal_delete_shard_metadata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>citus_internal_update_relation_colocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>citus_internal_add_object_metadata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>citus_internal_add_colocation_metadata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>citus_internal_delete_colocation_metadata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>got_SIGTERM</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>got_SIGALRM</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>METADATA_SYNC_APP_NAME</name></cpp:macro> <cpp:value>"Citus Metadata Sync Daemon"</cpp:value></cpp:define>


<comment type="block">/*
 * start_metadata_sync_to_node function sets hasmetadata column of the given
 * node to true, and then activate node without replicating reference tables.
 */</comment>
<function><type><name>Datum</name></type>
<name>start_metadata_sync_to_node</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>nodeName</name> <init>= <expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>nodePort</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>EnsureSuperUser</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EnsureCoordinator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nodeNameString</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><name>nodeName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ActivateNode</name><argument_list>(<argument><expr><name>nodeNameString</name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>TransactionModifiedNodeMetadata</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * start_metadata_sync_to_all_nodes function sets hasmetadata column of
 * all the primary worker nodes to true, and then activate nodes without
 * replicating reference tables.
 */</comment>
<function><type><name>Datum</name></type>
<name>start_metadata_sync_to_all_nodes</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EnsureSuperUser</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EnsureCoordinator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>workerNodes</name> <init>= <expr><call><name>ActivePrimaryNonCoordinatorNodeList</name><argument_list>(<argument><expr><name>RowShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ActivateNodeList</name><argument_list>(<argument><expr><name>workerNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>TransactionModifiedNodeMetadata</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * SyncNodeMetadataToNode is the internal API for
 * start_metadata_sync_to_node().
 */</comment>
<function><type><name>void</name></type>
<name>SyncNodeMetadataToNode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nodeNameString</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>nodePort</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>escapedNodeName</name> <init>= <expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>nodeNameString</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EnsureCoordinator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EnsureModificationsCanRun</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EnsureSequentialModeMetadataOperations</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><call><name>DistNodeRelationId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><call><name>FindWorkerNode</name><argument_list>(<argument><expr><name>nodeNameString</name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>workerNode</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"you cannot sync metadata to a non-existent node"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"First, add the node with SELECT citus_add_node"</literal>
								<literal type="string">"(%s,%d)"</literal></expr></argument>, <argument><expr><name>escapedNodeName</name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>workerNode</name><operator>-&gt;</operator><name>isActive</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"you cannot sync metadata to an inactive node"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"First, activate the node with "</literal>
								<literal type="string">"SELECT citus_activate_node(%s,%d)"</literal></expr></argument>,
								<argument><expr><name>escapedNodeName</name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>NodeIsCoordinator</name><argument_list>(<argument><expr><name>workerNode</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s:%d is the coordinator and already contains "</literal>
								<literal type="string">"metadata, skipping syncing the metadata"</literal></expr></argument>,
								<argument><expr><name>nodeNameString</name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>UseCoordinatedTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * One would normally expect to set hasmetadata first, and then metadata sync.
	 * However, at this point we do the order reverse.
	 * We first set metadatasynced, and then hasmetadata; since setting columns for
	 * nodes with metadatasynced==false could cause errors.
	 * (See ErrorIfAnyMetadataNodeOutOfSync)
	 * We can safely do that because we are in a coordinated transaction and the changes
	 * are only visible to our own transaction.
	 * If anything goes wrong, we are going to rollback all the changes.
	 */</comment>
	<expr_stmt><expr><name>workerNode</name> <operator>=</operator> <call><name>SetWorkerColumn</name><argument_list>(<argument><expr><name>workerNode</name></expr></argument>, <argument><expr><name>Anum_pg_dist_node_metadatasynced</name></expr></argument>,
								 <argument><expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>workerNode</name> <operator>=</operator> <call><name>SetWorkerColumn</name><argument_list>(<argument><expr><name>workerNode</name></expr></argument>, <argument><expr><name>Anum_pg_dist_node_hasmetadata</name></expr></argument>, <argument><expr><call><name>BoolGetDatum</name><argument_list>(
									 <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NodeIsPrimary</name><argument_list>(<argument><expr><name>workerNode</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If this is a secondary node we can't actually sync metadata to it; we assume
		 * the primary node is receiving metadata.
		 */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* fail if metadata synchronization doesn't succeed */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>raiseInterrupts</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>SyncNodeMetadataSnapshotToNode</name><argument_list>(<argument><expr><name>workerNode</name></expr></argument>, <argument><expr><name>raiseInterrupts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * SyncCitusTableMetadata syncs citus table metadata to worker nodes with metadata.
 * Our definition of metadata includes the shell table and its inter relations with
 * other shell tables, corresponding pg_dist_object, pg_dist_partiton, pg_dist_shard
 * and pg_dist_shard placement entries. This function also propagates the views that
 * depend on the given relation, to the metadata workers.
 */</comment>
<function><type><name>void</name></type>
<name>SyncCitusTableMetadata</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CreateShellTableOnWorkers</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CreateTableMetadataOnWorkers</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CreateInterTableRelationshipOfRelationOnWorkers</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsTableOwnedByExtension</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>relationAddress</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>relationAddress</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MarkObjectDistributed</name><argument_list>(<argument><expr><operator>&amp;</operator><name>relationAddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>CreateDependingViewsOnWorkers</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CreateDependingViewsOnWorkers takes a relationId and creates the views that depend on
 * that relation on workers with metadata. Propagated views are marked as distributed.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CreateDependingViewsOnWorkers</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>views</name> <init>= <expr><call><name>GetDependingViews</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>views</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* no view to propagate */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>SendCommandToWorkersWithMetadata</name><argument_list>(<argument><expr><name>DISABLE_DDL_PROPAGATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>viewOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>viewOid</argument>, <argument>views</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ShouldMarkRelationDistributed</name><argument_list>(<argument><expr><name>viewOid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>viewAddress</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ObjectAddress</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><operator>*</operator><name>viewAddress</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>viewOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>EnsureAllObjectDependenciesExistOnAllNodes</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>viewAddress</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>createViewCommand</name> <init>= <expr><call><name>CreateViewDDLCommand</name><argument_list>(<argument><expr><name>viewOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>alterViewOwnerCommand</name> <init>= <expr><call><name>AlterViewOwnerCommand</name><argument_list>(<argument><expr><name>viewOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>SendCommandToWorkersWithMetadata</name><argument_list>(<argument><expr><name>createViewCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SendCommandToWorkersWithMetadata</name><argument_list>(<argument><expr><name>alterViewOwnerCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MarkObjectDistributed</name><argument_list>(<argument><expr><name>viewAddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>SendCommandToWorkersWithMetadata</name><argument_list>(<argument><expr><name>ENABLE_DDL_PROPAGATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * EnsureSequentialModeMetadataOperations makes sure that the current transaction is
 * already in sequential mode, or can still safely be put in sequential mode,
 * it errors if that is not possible. The error contains information for the user to
 * retry the transaction with sequential mode set from the beginning.
 *
 * Metadata objects (e.g., distributed table on the workers) exists only 1 instance of
 * the type used by potentially multiple other shards/connections. To make sure all
 * shards/connections in the transaction can interact with the metadata needs to be
 * visible on all connections used by the transaction, meaning we can only use 1
 * connection per node.
 */</comment>
<function><type><name>void</name></type>
<name>EnsureSequentialModeMetadataOperations</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsTransactionBlock</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* we do not need to switch to sequential mode if we are not in a transaction */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ParallelQueryExecutedInTransaction</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
							<argument><expr><literal type="string">"cannot execute metadata syncing operation because there was a "</literal>
							<literal type="string">"parallel operation on a distributed table in the "</literal>
							<literal type="string">"transaction"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"When modifying metadata, Citus needs to "</literal>
								  <literal type="string">"perform all operations over a single connection per "</literal>
								  <literal type="string">"node to ensure consistency."</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Try re-running the transaction with "</literal>
								<literal type="string">"\"SET LOCAL citus.multi_shard_modify_mode TO "</literal>
								<literal type="string">"\'sequential\';\""</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"switching to sequential query execution mode"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Metadata synced or stopped syncing. To make "</literal>
							   <literal type="string">"sure subsequent commands see the metadata correctly "</literal>
							   <literal type="string">"we need to make sure to use only one connection for "</literal>
							   <literal type="string">"all future commands"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetLocalMultiShardModifyModeToSequential</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * stop_metadata_sync_to_node function sets the hasmetadata column of the specified node
 * to false in pg_dist_node table, thus indicating that the specified worker node does not
 * receive DDL changes anymore and cannot be used for issuing queries.
 */</comment>
<function><type><name>Datum</name></type>
<name>stop_metadata_sync_to_node</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EnsureCoordinator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EnsureSuperUser</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>nodeName</name> <init>= <expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>nodePort</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>clearMetadata</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nodeNameString</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><name>nodeName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><call><name>DistNodeRelationId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><call><name>FindWorkerNodeAnyCluster</name><argument_list>(<argument><expr><name>nodeNameString</name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>workerNode</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"node (%s,%d) does not exist"</literal></expr></argument>, <argument><expr><name>nodeNameString</name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>NodeIsCoordinator</name><argument_list>(<argument><expr><name>workerNode</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"node (%s,%d) is the coordinator and should have "</literal>
								<literal type="string">"metadata, skipping stopping the metadata sync"</literal></expr></argument>,
								<argument><expr><name>nodeNameString</name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>clearMetadata</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>NodeIsPrimary</name><argument_list>(<argument><expr><name>workerNode</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"dropping metadata on the node (%s,%d)"</literal></expr></argument>,
									<argument><expr><name>nodeNameString</name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>DropMetadataSnapshotOnNode</name><argument_list>(<argument><expr><name>workerNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * If this is a secondary node we can't actually clear metadata from it,
			 * we assume the primary node is cleared.
			 */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"(%s,%d) is a secondary node: to clear the metadata,"</literal>
									<literal type="string">" you should clear metadata from the primary node"</literal></expr></argument>,
									<argument><expr><name>nodeNameString</name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>workerNode</name> <operator>=</operator> <call><name>SetWorkerColumn</name><argument_list>(<argument><expr><name>workerNode</name></expr></argument>, <argument><expr><name>Anum_pg_dist_node_hasmetadata</name></expr></argument>, <argument><expr><call><name>BoolGetDatum</name><argument_list>(
									 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>workerNode</name> <operator>=</operator> <call><name>SetWorkerColumn</name><argument_list>(<argument><expr><name>workerNode</name></expr></argument>, <argument><expr><name>Anum_pg_dist_node_metadatasynced</name></expr></argument>,
								 <argument><expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>TransactionModifiedNodeMetadata</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ClusterHasKnownMetadataWorkers returns true if the node executing the function
 * knows at least one worker with metadata. We do it
 * (a) by checking the node that executes the function is a worker with metadata
 * (b) the coordinator knows at least one worker with metadata.
 */</comment>
<function><type><name>bool</name></type>
<name>ClusterHasKnownMetadataWorkers</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>workerWithMetadata</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCoordinator</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>workerWithMetadata</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>workerWithMetadata</name> <operator>||</operator> <call><name>HasMetadataWorkers</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ShouldSyncUserCommandForObject checks if the user command should be synced to the
 * worker nodes for the given object.
 */</comment>
<function><type><name>bool</name></type>
<name>ShouldSyncUserCommandForObject</name><parameter_list>(<parameter><decl><type><name>ObjectAddress</name></type> <name>objectAddress</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>objectAddress</name><operator>.</operator><name>classId</name></name> <operator>==</operator> <name>RelationRelationId</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>relOid</name> <init>= <expr><name><name>objectAddress</name><operator>.</operator><name>objectId</name></name></expr></init></decl>;</decl_stmt>
		<return>return <expr><call><name>ShouldSyncTableMetadata</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>)</argument_list></call> <operator>||</operator>
			   <call><name>ShouldSyncSequenceMetadata</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>)</argument_list></call> <operator>||</operator>
			   <call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RELKIND_VIEW</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ShouldSyncTableMetadata checks if the metadata of a distributed table should be
 * propagated to metadata workers, i.e. the table is a hash distributed table or
 * reference/citus local table.
 */</comment>
<function><type><name>bool</name></type>
<name>ShouldSyncTableMetadata</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>EnableMetadataSync</name> <operator>||</operator>
		<operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>tableEntry</name> <init>= <expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>hashDistributed</name> <init>= <expr><call><name>IsCitusTableTypeCacheEntry</name><argument_list>(<argument><expr><name>tableEntry</name></expr></argument>, <argument><expr><name>HASH_DISTRIBUTED</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>citusTableWithNoDistKey</name> <init>=
		<expr><call><name>IsCitusTableTypeCacheEntry</name><argument_list>(<argument><expr><name>tableEntry</name></expr></argument>, <argument><expr><name>CITUS_TABLE_WITH_NO_DIST_KEY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>ShouldSyncTableMetadataInternal</name><argument_list>(<argument><expr><name>hashDistributed</name></expr></argument>, <argument><expr><name>citusTableWithNoDistKey</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ShouldSyncTableMetadataViaCatalog checks if the metadata of a distributed table should
 * be propagated to metadata workers, i.e. the table is an MX table or reference table.
 * Tables with streaming replication model (which means RF=1) and hash distribution are
 * considered as MX tables while tables with none distribution are reference tables.
 *
 * ShouldSyncTableMetadataViaCatalog does not use the CitusTableCache and instead reads
 * from catalog tables directly.
 */</comment>
<function><type><name>bool</name></type>
<name>ShouldSyncTableMetadataViaCatalog</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>IsCitusTableViaCatalog</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>char</name></type> <name>partitionMethod</name> <init>= <expr><call><name>PartitionMethodViaCatalog</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>hashDistributed</name> <init>= <expr><name>partitionMethod</name> <operator>==</operator> <name>DISTRIBUTE_BY_HASH</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>citusTableWithNoDistKey</name> <init>= <expr><name>partitionMethod</name> <operator>==</operator> <name>DISTRIBUTE_BY_NONE</name></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>ShouldSyncTableMetadataInternal</name><argument_list>(<argument><expr><name>hashDistributed</name></expr></argument>, <argument><expr><name>citusTableWithNoDistKey</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ShouldSyncTableMetadataInternal decides whether we should sync the metadata for a table
 * based on whether it is a hash distributed table, or a citus table with no distribution
 * key.
 *
 * This function is here to make sure that ShouldSyncTableMetadata and
 * ShouldSyncTableMetadataViaCatalog behaves the same way.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ShouldSyncTableMetadataInternal</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>hashDistributed</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>citusTableWithNoDistKey</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>hashDistributed</name> <operator>||</operator> <name>citusTableWithNoDistKey</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ShouldSyncSequenceMetadata checks if the metadata of a sequence should be
 * propagated to metadata workers, i.e. the sequence is marked as distributed
 */</comment>
<function><type><name>bool</name></type>
<name>ShouldSyncSequenceMetadata</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><operator>(</operator><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RELKIND_SEQUENCE</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>sequenceAddress</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ObjectAddress</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><operator>*</operator><name>sequenceAddress</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>IsAnyObjectDistributed</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>sequenceAddress</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SyncMetadataSnapshotToNode does the following:
 * SyncNodeMetadataSnapshotToNode does the following:
 *  1. Sets the localGroupId on the worker so the worker knows which tuple in
 *     pg_dist_node represents itself.
 *  2. Recreates the node metadata on the given worker.
 * If raiseOnError is true, it errors out if synchronization fails.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>SyncNodeMetadataSnapshotToNode</name><parameter_list>(<parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>raiseOnError</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>currentUser</name> <init>= <expr><call><name>CurrentUserName</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* generate and add the local group id's update query */</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>localGroupIdUpdateCommand</name> <init>= <expr><call><name>LocalGroupIdUpdateCommand</name><argument_list>(<argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* generate the queries which drop the node metadata */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>dropMetadataCommandList</name> <init>= <expr><call><name>NodeMetadataDropCommands</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* generate the queries which create the node metadata from scratch */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>createMetadataCommandList</name> <init>= <expr><call><name>NodeMetadataCreateCommands</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>recreateMetadataSnapshotCommandList</name> <init>= <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>localGroupIdUpdateCommand</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>recreateMetadataSnapshotCommandList</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>recreateMetadataSnapshotCommandList</name></expr></argument>,
													  <argument><expr><name>dropMetadataCommandList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>recreateMetadataSnapshotCommandList</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>recreateMetadataSnapshotCommandList</name></expr></argument>,
													  <argument><expr><name>createMetadataCommandList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Send the snapshot recreation commands in a single remote transaction and
	 * if requested, error out in any kind of failure. Note that it is not
	 * required to send createMetadataSnapshotCommandList in the same transaction
	 * that we send nodeDeleteCommand and nodeInsertCommand commands below.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>raiseOnError</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SendMetadataCommandListToWorkerListInCoordinatedTransaction</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(
																		<argument><expr><name>workerNode</name></expr></argument>)</argument_list></call></expr></argument>,
																	<argument><expr><name>currentUser</name></expr></argument>,
																	<argument><expr><name>recreateMetadataSnapshotCommandList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>success</name> <init>=
			<expr><call><name>SendOptionalMetadataCommandListToWorkerInCoordinatedTransaction</name><argument_list>(
				<argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>, <argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>,
				<argument><expr><name>currentUser</name></expr></argument>, <argument><expr><name>recreateMetadataSnapshotCommandList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<return>return <expr><name>success</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * DropMetadataSnapshotOnNode creates the queries which drop the metadata and sends them
 * to the worker given as parameter.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DropMetadataSnapshotOnNode</name><parameter_list>(<parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>EnsureSequentialModeMetadataOperations</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>userName</name> <init>= <expr><call><name>CurrentUserName</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Detach partitions, break dependencies between sequences and table then
	 * remove shell tables first.
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>dropMetadataCommandList</name> <init>= <expr><call><name>DetachPartitionCommandList</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>dropMetadataCommandList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>dropMetadataCommandList</name></expr></argument>,
									  <argument><expr><name>BREAK_CITUS_TABLE_SEQUENCE_DEPENDENCY_COMMAND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dropMetadataCommandList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>dropMetadataCommandList</name></expr></argument>,
									  <argument><expr><name>REMOVE_ALL_SHELL_TABLES_COMMAND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dropMetadataCommandList</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>dropMetadataCommandList</name></expr></argument>,
										  <argument><expr><call><name>NodeMetadataDropCommands</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dropMetadataCommandList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>dropMetadataCommandList</name></expr></argument>,
									  <argument><expr><call><name>LocalGroupIdUpdateCommand</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* remove all dist table and object/table related metadata afterwards */</comment>
	<expr_stmt><expr><name>dropMetadataCommandList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>dropMetadataCommandList</name></expr></argument>, <argument><expr><name>DELETE_ALL_PARTITIONS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dropMetadataCommandList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>dropMetadataCommandList</name></expr></argument>, <argument><expr><name>DELETE_ALL_SHARDS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dropMetadataCommandList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>dropMetadataCommandList</name></expr></argument>, <argument><expr><name>DELETE_ALL_PLACEMENTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dropMetadataCommandList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>dropMetadataCommandList</name></expr></argument>,
									  <argument><expr><name>DELETE_ALL_DISTRIBUTED_OBJECTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dropMetadataCommandList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>dropMetadataCommandList</name></expr></argument>, <argument><expr><name>DELETE_ALL_COLOCATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>superuser</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SendOptionalMetadataCommandListToWorkerInCoordinatedTransaction</name><argument_list>(
		<argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>,
		<argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>,
		<argument><expr><name>userName</name></expr></argument>,
		<argument><expr><name>dropMetadataCommandList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * NodeMetadataCreateCommands returns list of queries that are
 * required to create the current metadata snapshot of the node that the
 * function is called. The metadata snapshot commands includes the
 * following queries:
 *
 * (i)   Query that populates pg_dist_node table
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>NodeMetadataCreateCommands</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>metadataSnapshotCommandList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>includeNodesFromOtherClusters</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>workerNodeList</name> <init>= <expr><call><name>ReadDistNode</name><argument_list>(<argument><expr><name>includeNodesFromOtherClusters</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* make sure we have deterministic output for our tests */</comment>
	<expr_stmt><expr><name>workerNodeList</name> <operator>=</operator> <call><name>SortList</name><argument_list>(<argument><expr><name>workerNodeList</name></expr></argument>, <argument><expr><name>CompareWorkerNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* generate insert command for pg_dist_node table */</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nodeListInsertCommand</name> <init>= <expr><call><name>NodeListInsertCommand</name><argument_list>(<argument><expr><name>workerNodeList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>metadataSnapshotCommandList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>metadataSnapshotCommandList</name></expr></argument>,
										  <argument><expr><name>nodeListInsertCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>metadataSnapshotCommandList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DistributedObjectMetadataSyncCommandList returns the necessary commands to create
 * pg_dist_object entries on the new node.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>DistributedObjectMetadataSyncCommandList</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>pgDistObjectTup</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>pgDistObjectRel</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><call><name>DistObjectRelationId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>pgDistObjectIndexRel</name> <init>= <expr><call><name>index_open</name><argument_list>(<argument><expr><call><name>DistObjectPrimaryKeyIndexId</name><argument_list>()</argument_list></call></expr></argument>,
											   <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>pgDistObjectDesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pgDistObjectRel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>objectAddressList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>distArgumentIndexList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>colocationIdList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>forceDelegationList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* It is not strictly necessary to read the tuples in order.
	 * However, it is useful to get consistent behavior, both for regression
	 * tests and also in production systems.
	 */</comment>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>pgDistObjectScan</name> <init>= <expr><call><name>systable_beginscan_ordered</name><argument_list>(<argument><expr><name>pgDistObjectRel</name></expr></argument>,
															  <argument><expr><name>pgDistObjectIndexRel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
															  <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>pgDistObjectTup</name> <operator>=</operator> <call><name>systable_getnext_ordered</name><argument_list>(<argument><expr><name>pgDistObjectScan</name></expr></argument>,
																	   <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_dist_object</name></type> <name>pg_dist_object</name> <init>= <expr><operator>(</operator><name>Form_pg_dist_object</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(
			<argument><expr><name>pgDistObjectTup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>address</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ObjectAddress</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ObjectAddressSubSet</name><argument_list>(<argument><expr><operator>*</operator><name>address</name></expr></argument>, <argument><expr><name><name>pg_dist_object</name><operator>-&gt;</operator><name>classid</name></name></expr></argument>, <argument><expr><name><name>pg_dist_object</name><operator>-&gt;</operator><name>objid</name></name></expr></argument>,
							<argument><expr><name><name>pg_dist_object</name><operator>-&gt;</operator><name>objsubid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>bool</name></type> <name>distributionArgumentIndexIsNull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type> <name>distributionArgumentIndexDatum</name> <init>=
			<expr><call><name>heap_getattr</name><argument_list>(<argument><expr><name>pgDistObjectTup</name></expr></argument>,
						 <argument><expr><name>Anum_pg_dist_object_distribution_argument_index</name></expr></argument>,
						 <argument><expr><name>pgDistObjectDesc</name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name>distributionArgumentIndexIsNull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type> <name>distributionArgumentIndex</name> <init>= <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>distributionArgumentIndexDatum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>bool</name></type> <name>colocationIdIsNull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type> <name>colocationIdDatum</name> <init>=
			<expr><call><name>heap_getattr</name><argument_list>(<argument><expr><name>pgDistObjectTup</name></expr></argument>,
						 <argument><expr><name>Anum_pg_dist_object_colocationid</name></expr></argument>,
						 <argument><expr><name>pgDistObjectDesc</name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name>colocationIdIsNull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type> <name>colocationId</name> <init>= <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>colocationIdDatum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>bool</name></type> <name>forceDelegationIsNull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type> <name>forceDelegationDatum</name> <init>=
			<expr><call><name>heap_getattr</name><argument_list>(<argument><expr><name>pgDistObjectTup</name></expr></argument>,
						 <argument><expr><name>Anum_pg_dist_object_force_delegation</name></expr></argument>,
						 <argument><expr><name>pgDistObjectDesc</name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name>forceDelegationIsNull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>forceDelegation</name> <init>= <expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><name>forceDelegationDatum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>objectAddressList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>objectAddressList</name></expr></argument>, <argument><expr><name>address</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>distributionArgumentIndexIsNull</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>distArgumentIndexList</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>distArgumentIndexList</name></expr></argument>,
												<argument><expr><name>INVALID_DISTRIBUTION_ARGUMENT_INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>distArgumentIndexList</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>distArgumentIndexList</name></expr></argument>,
												<argument><expr><name>distributionArgumentIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>colocationIdIsNull</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>colocationIdList</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>colocationIdList</name></expr></argument>,
										   <argument><expr><name>INVALID_COLOCATION_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>colocationIdList</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>colocationIdList</name></expr></argument>, <argument><expr><name>colocationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>forceDelegationIsNull</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>forceDelegationList</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>forceDelegationList</name></expr></argument>, <argument><expr><name>NO_FORCE_PUSHDOWN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>forceDelegationList</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>forceDelegationList</name></expr></argument>, <argument><expr><name>forceDelegation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan_ordered</name><argument_list>(<argument><expr><name>pgDistObjectScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>pgDistObjectIndexRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>pgDistObjectRel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>workerMetadataUpdateCommand</name> <init>=
		<expr><call><name>MarkObjectsDistributedCreateCommand</name><argument_list>(<argument><expr><name>objectAddressList</name></expr></argument>,
											<argument><expr><name>distArgumentIndexList</name></expr></argument>,
											<argument><expr><name>colocationIdList</name></expr></argument>,
											<argument><expr><name>forceDelegationList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commandList</name> <init>= <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>workerMetadataUpdateCommand</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>commandList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CitusTableMetadataCreateCommandList returns the set of commands necessary to
 * create the given distributed table metadata on a worker.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>CitusTableMetadataCreateCommandList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>cacheEntry</name> <init>= <expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commandList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* command to insert pg_dist_partition entry */</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>metadataCommand</name> <init>= <expr><call><name>DistributionCreateCommand</name><argument_list>(<argument><expr><name>cacheEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>commandList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>commandList</name></expr></argument>, <argument><expr><name>metadataCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* commands to insert pg_dist_shard &amp; pg_dist_placement entries */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardIntervalList</name> <init>= <expr><call><name>LoadShardIntervalList</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardMetadataInsertCommandList</name> <init>= <expr><call><name>ShardListInsertCommand</name><argument_list>(<argument><expr><name>shardIntervalList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>commandList</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>commandList</name></expr></argument>, <argument><expr><name>shardMetadataInsertCommandList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>commandList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * NodeMetadataDropCommands returns list of queries that are required to
 * drop all the metadata of the node that are not related to clustered tables.
 * The drop metadata snapshot commands includes the following queries:
 *
 * (i) Queries that delete all the rows from pg_dist_node table
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>NodeMetadataDropCommands</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>dropSnapshotCommandList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>dropSnapshotCommandList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>dropSnapshotCommandList</name></expr></argument>, <argument><expr><name>DELETE_ALL_NODES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>dropSnapshotCommandList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * NodeListInsertCommand generates a single multi-row INSERT command that can be
 * executed to insert the nodes that are in workerNodeList to pg_dist_node table.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>NodeListInsertCommand</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>workerNodeList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>nodeListInsertCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>workerCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>workerNodeList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>processedWorkerNodeCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>primaryRole</name> <init>= <expr><call><name>PrimaryNodeRoleId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* if there are no workers, return NULL */</comment>
	<if_stmt><if>if <condition>(<expr><name>workerCount</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name><name>nodeListInsertCommand</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>primaryRole</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"bad metadata, noderole does not exist"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"you should never see this, please submit "</literal>
								  <literal type="string">"a bug report"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"run ALTER EXTENSION citus UPDATE and try again"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* generate the query without any values yet */</comment>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>nodeListInsertCommand</name></expr></argument>,
					 <argument><expr><literal type="string">"INSERT INTO pg_dist_node (nodeid, groupid, nodename, nodeport, "</literal>
					 <literal type="string">"noderack, hasmetadata, metadatasynced, isactive, noderole, "</literal>
					 <literal type="string">"nodecluster, shouldhaveshards) VALUES "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* iterate over the worker nodes, add the values */</comment>
	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>workerNode</argument>, <argument>workerNodeList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>hasMetadataString</name> <init>= <expr><ternary><condition><expr><name><name>workerNode</name><operator>-&gt;</operator><name>hasMetadata</name></name></expr> ?</condition><then> <expr><literal type="string">"TRUE"</literal></expr> </then><else>: <expr><literal type="string">"FALSE"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>metadataSyncedString</name> <init>= <expr><ternary><condition><expr><name><name>workerNode</name><operator>-&gt;</operator><name>metadataSynced</name></name></expr> ?</condition><then> <expr><literal type="string">"TRUE"</literal></expr> </then><else>: <expr><literal type="string">"FALSE"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>isActiveString</name> <init>= <expr><ternary><condition><expr><name><name>workerNode</name><operator>-&gt;</operator><name>isActive</name></name></expr> ?</condition><then> <expr><literal type="string">"TRUE"</literal></expr> </then><else>: <expr><literal type="string">"FALSE"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>shouldHaveShards</name> <init>= <expr><ternary><condition><expr><name><name>workerNode</name><operator>-&gt;</operator><name>shouldHaveShards</name></name></expr> ?</condition><then> <expr><literal type="string">"TRUE"</literal></expr> </then><else>: <expr><literal type="string">"FALSE"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Datum</name></type> <name>nodeRoleOidDatum</name> <init>= <expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>nodeRole</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type> <name>nodeRoleStringDatum</name> <init>= <expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>enum_out</name></expr></argument>, <argument><expr><name>nodeRoleOidDatum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nodeRoleString</name> <init>= <expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><name>nodeRoleStringDatum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>nodeListInsertCommand</name></expr></argument>,
						 <argument><expr><literal type="string">"(%d, %d, %s, %d, %s, %s, %s, %s, '%s'::noderole, %s, %s)"</literal></expr></argument>,
						 <argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>nodeId</name></name></expr></argument>,
						 <argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>,
						 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>,
						 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerRack</name></name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name>hasMetadataString</name></expr></argument>,
						 <argument><expr><name>metadataSyncedString</name></expr></argument>,
						 <argument><expr><name>isActiveString</name></expr></argument>,
						 <argument><expr><name>nodeRoleString</name></expr></argument>,
						 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>nodeCluster</name></name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name>shouldHaveShards</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>processedWorkerNodeCount</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>processedWorkerNodeCount</name> <operator>!=</operator> <name>workerCount</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>nodeListInsertCommand</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name><name>nodeListInsertCommand</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * MarkObjectsDistributedCreateCommand generates a command that can be executed to
 * insert or update the provided objects into pg_dist_object on a worker node.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>MarkObjectsDistributedCreateCommand</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>addresses</name></decl></parameter>,
									<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>distributionArgumentIndexes</name></decl></parameter>,
									<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colocationIds</name></decl></parameter>,
									<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>forceDelegations</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>insertDistributedObjectsCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>addresses</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>distributionArgumentIndexes</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>distributionArgumentIndexes</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>colocationIds</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>insertDistributedObjectsCommand</name></expr></argument>,
					 <argument><expr><literal type="string">"WITH distributed_object_data(typetext, objnames, "</literal>
					 <literal type="string">"objargs, distargumentindex, colocationid, force_delegation)  AS (VALUES "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>isFirstObject</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>currentObjectCounter</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>currentObjectCounter</name> <operator>&lt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>addresses</name></expr></argument>)</argument_list></call></expr>;</condition>
		 <incr><expr><name>currentObjectCounter</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>address</name> <init>= <expr><call><name>list_nth</name><argument_list>(<argument><expr><name>addresses</name></expr></argument>, <argument><expr><name>currentObjectCounter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>distributionArgumentIndex</name> <init>= <expr><call><name>list_nth_int</name><argument_list>(<argument><expr><name>distributionArgumentIndexes</name></expr></argument>,
													 <argument><expr><name>currentObjectCounter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>colocationId</name> <init>= <expr><call><name>list_nth_int</name><argument_list>(<argument><expr><name>colocationIds</name></expr></argument>, <argument><expr><name>currentObjectCounter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>forceDelegation</name> <init>= <expr><call><name>list_nth_int</name><argument_list>(<argument><expr><name>forceDelegations</name></expr></argument>, <argument><expr><name>currentObjectCounter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>names</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>objectType</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <name>PG_VERSION_14</name></expr></cpp:if>
		<expr_stmt><expr><name>objectType</name> <operator>=</operator> <call><name>getObjectTypeDescription</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>getObjectIdentityParts</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>names</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><name>objectType</name> <operator>=</operator> <call><name>getObjectTypeDescription</name><argument_list>(<argument><expr><name>address</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>getObjectIdentityParts</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>names</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isFirstObject</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>insertDistributedObjectsCommand</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>isFirstObject</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>insertDistributedObjectsCommand</name></expr></argument>,
						 <argument><expr><literal type="string">"(%s, ARRAY["</literal></expr></argument>,
						 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>objectType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>firstInNameLoop</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>name</argument>, <argument>names</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>firstInNameLoop</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>insertDistributedObjectsCommand</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>firstInNameLoop</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>insertDistributedObjectsCommand</name></expr></argument>,
								   <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>insertDistributedObjectsCommand</name></expr></argument>, <argument><expr><literal type="string">"]::text[], ARRAY["</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>firstInArgLoop</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>arg</argument>, <argument>args</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>firstInArgLoop</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>insertDistributedObjectsCommand</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>firstInArgLoop</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>insertDistributedObjectsCommand</name></expr></argument>,
								   <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>insertDistributedObjectsCommand</name></expr></argument>, <argument><expr><literal type="string">"]::text[], "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>insertDistributedObjectsCommand</name></expr></argument>, <argument><expr><literal type="string">"%d, "</literal></expr></argument>,
						 <argument><expr><name>distributionArgumentIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>insertDistributedObjectsCommand</name></expr></argument>, <argument><expr><literal type="string">"%d, "</literal></expr></argument>,
						 <argument><expr><name>colocationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>insertDistributedObjectsCommand</name></expr></argument>, <argument><expr><literal type="string">"%s)"</literal></expr></argument>,
						 <argument><expr><ternary><condition><expr><name>forceDelegation</name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>insertDistributedObjectsCommand</name></expr></argument>, <argument><expr><literal type="string">") "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>insertDistributedObjectsCommand</name></expr></argument>,
					 <argument><expr><literal type="string">"SELECT citus_internal_add_object_metadata("</literal>
					 <literal type="string">"typetext, objnames, objargs, distargumentindex::int, colocationid::int, force_delegation::bool) "</literal>
					 <literal type="string">"FROM distributed_object_data;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>insertDistributedObjectsCommand</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * citus_internal_add_object_metadata is an internal UDF to
 * add a row to pg_dist_object.
 */</comment>
<function><type><name>Datum</name></type>
<name>citus_internal_add_object_metadata</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>textType</name> <init>= <expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>nameArray</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>argsArray</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>distributionArgumentIndex</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>colocationId</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>forceDelegation</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ShouldSkipMetadataChecks</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* this UDF is not allowed for executing as a separate command */</comment>
		<expr_stmt><expr><call><name>EnsureCoordinatorInitiatedOperation</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Ensure given distributionArgumentIndex and colocationId values are
		 * sane. Since we check sanity of object related parameters within
		 * PgGetObjectAddress below, we are not checking them here.
		 */</comment>
		<expr_stmt><expr><call><name>EnsureObjectMetadataIsSane</name><argument_list>(<argument><expr><name>distributionArgumentIndex</name></expr></argument>, <argument><expr><name>colocationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We check the acl/ownership while getting the object address. That
	 * funtion also checks the sanity of given textType, nameArray and
	 * argsArray parameters
	 */</comment>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>objectAddress</name> <init>= <expr><call><name>PgGetObjectAddress</name><argument_list>(<argument><expr><name>textType</name></expr></argument>, <argument><expr><name>nameArray</name></expr></argument>,
													 <argument><expr><name>argsArray</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* First, disable propagation off to not to cause infinite propagation */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>prevDependencyCreationValue</name> <init>= <expr><name>EnableMetadataSync</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>SetLocalEnableMetadataSync</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MarkObjectDistributed</name><argument_list>(<argument><expr><operator>&amp;</operator><name>objectAddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>distributionArgumentIndex</name> <operator>!=</operator> <name>INVALID_DISTRIBUTION_ARGUMENT_INDEX</name> <operator>||</operator>
		<name>colocationId</name> <operator>!=</operator> <name>INVALID_COLOCATION_ID</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>distributionArgumentIndexAddress</name> <init>=
			<expr><ternary><condition><expr><name>distributionArgumentIndex</name> <operator>==</operator> <name>INVALID_DISTRIBUTION_ARGUMENT_INDEX</name></expr> ?</condition><then>
			<expr><name>NULL</name></expr> </then><else>:
			<expr><operator>&amp;</operator><name>distributionArgumentIndex</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>colocationIdAddress</name> <init>=
			<expr><ternary><condition><expr><name>colocationId</name> <operator>==</operator> <name>INVALID_COLOCATION_ID</name></expr> ?</condition><then>
			<expr><name>NULL</name></expr> </then><else>:
			<expr><operator>&amp;</operator><name>colocationId</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>forceDelegationAddress</name> <init>=
			<expr><ternary><condition><expr><name>forceDelegation</name> <operator>==</operator> <name>false</name></expr> ?</condition><then>
			<expr><name>NULL</name></expr> </then><else>:
			<expr><operator>&amp;</operator><name>forceDelegation</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>UpdateFunctionDistributionInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>objectAddress</name></expr></argument>,
									   <argument><expr><name>distributionArgumentIndexAddress</name></expr></argument>,
									   <argument><expr><name>colocationIdAddress</name></expr></argument>,
									   <argument><expr><name>forceDelegationAddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>SetLocalEnableMetadataSync</name><argument_list>(<argument><expr><name>prevDependencyCreationValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * EnsureObjectMetadataIsSane checks whether the distribution argument index and
 * colocation id metadata params for distributed object is sane. You can look
 * PgGetObjectAddress to find checks related to object sanity.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>EnsureObjectMetadataIsSane</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>distributionArgumentIndex</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>colocationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>distributionArgumentIndex</name> <operator>!=</operator> <name>INVALID_DISTRIBUTION_ARGUMENT_INDEX</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>distributionArgumentIndex</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator>
			<name>distributionArgumentIndex</name></expr></argument> &gt;</argument_list></name> <name>FUNC_MAX_ARGS</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"distribution_argument_index must be between"</literal>
								  <literal type="string">" 0 and %d"</literal></expr></argument>, <argument><expr><name>FUNC_MAX_ARGS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>colocationId</name> <operator>!=</operator> <name>INVALID_COLOCATION_ID</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>colocationId</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"colocationId must be a positive number"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * DistributionCreateCommands generates a commands that can be
 * executed to replicate the metadata for a distributed table.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>DistributionCreateCommand</name><parameter_list>(<parameter><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>cacheEntry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>insertDistributionCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>relationId</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>distributionMethod</name> <init>= <expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>partitionMethod</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>qualifiedRelationName</name> <init>=
		<expr><call><name>generate_qualified_relation_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>colocationId</name> <init>= <expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>colocationId</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>replicationModel</name> <init>= <expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>replicationModel</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>tablePartitionKeyNameString</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableTypeCacheEntry</name><argument_list>(<argument><expr><name>cacheEntry</name></expr></argument>, <argument><expr><name>CITUS_TABLE_WITH_NO_DIST_KEY</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>tablePartitionKeyNameString</name></expr></argument>, <argument><expr><literal type="string">"NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>partitionKeyColumnName</name> <init>=
			<expr><call><name>ColumnToColumnName</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>cacheEntry</name><operator>-&gt;</operator><name>partitionColumn</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>tablePartitionKeyNameString</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>,
						 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>partitionKeyColumnName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>insertDistributionCommand</name></expr></argument>,
					 <argument><expr><literal type="string">"SELECT citus_internal_add_partition_metadata "</literal>
					 <literal type="string">"(%s::regclass, '%c', %s, %d, '%c')"</literal></expr></argument>,
					 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>qualifiedRelationName</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name>distributionMethod</name></expr></argument>,
					 <argument><expr><name><name>tablePartitionKeyNameString</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
					 <argument><expr><name>colocationId</name></expr></argument>,
					 <argument><expr><name>replicationModel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>insertDistributionCommand</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DistributionDeleteCommand generates a command that can be executed
 * to drop a distributed table and its metadata on a remote node.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>DistributionDeleteCommand</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>schemaName</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tableName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>deleteDistributionCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>distributedRelationName</name> <init>= <expr><call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>, <argument><expr><name>tableName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>deleteDistributionCommand</name></expr></argument>,
					 <argument><expr><literal type="string">"SELECT worker_drop_distributed_table(%s)"</literal></expr></argument>,
					 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>distributedRelationName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>deleteDistributionCommand</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DistributionDeleteMetadataCommand returns a query to delete pg_dist_partition
 * metadata from a worker node for a given table.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>DistributionDeleteMetadataCommand</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>deleteCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>qualifiedRelationName</name> <init>= <expr><call><name>generate_qualified_relation_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>deleteCommand</name></expr></argument>,
					 <argument><expr><literal type="string">"SELECT pg_catalog.citus_internal_delete_partition_metadata(%s)"</literal></expr></argument>,
					 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>qualifiedRelationName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>deleteCommand</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * TableOwnerResetCommand generates a commands that can be executed
 * to reset the table owner.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>TableOwnerResetCommand</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>ownerResetCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>qualifiedRelationName</name> <init>= <expr><call><name>generate_qualified_relation_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tableOwnerName</name> <init>= <expr><call><name>TableOwner</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>ownerResetCommand</name></expr></argument>,
					 <argument><expr><literal type="string">"ALTER TABLE %s OWNER TO %s"</literal></expr></argument>,
					 <argument><expr><name>qualifiedRelationName</name></expr></argument>,
					 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>tableOwnerName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>ownerResetCommand</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ShardListInsertCommand generates a single command that can be
 * executed to replicate shard and shard placement metadata for the
 * given shard intervals. The function assumes that each shard has a
 * single placement, and asserts this information.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>ShardListInsertCommand</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardIntervalList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commandList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>shardCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>shardIntervalList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* if there are no shards, return empty list */</comment>
	<if_stmt><if>if <condition>(<expr><name>shardCount</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>commandList</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* add placements to insertPlacementCommand */</comment>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>insertPlacementCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>insertPlacementCommand</name></expr></argument>,
					 <argument><expr><literal type="string">"WITH placement_data(shardid, shardstate, "</literal>
					 <literal type="string">"shardlength, groupid, placementid)  AS (VALUES "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>firstPlacementProcessed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>shardInterval</argument>, <argument>shardIntervalList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint64</name></type> <name>shardId</name> <init>= <expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardPlacementList</name> <init>= <expr><call><name>ActiveShardPlacementList</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>placement</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>placement</argument>, <argument>shardPlacementList</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>firstPlacementProcessed</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * As long as this is not the first placement of the first shard,
				 * append the comma.
				 */</comment>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>insertPlacementCommand</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>firstPlacementProcessed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>insertPlacementCommand</name></expr></argument>,
							 <argument><expr><literal type="string">"(%ld, %d, %ld, %d, %ld)"</literal></expr></argument>,
							 <argument><expr><name>shardId</name></expr></argument>,
							 <argument><expr><name><name>placement</name><operator>-&gt;</operator><name>shardState</name></name></expr></argument>,
							 <argument><expr><name><name>placement</name><operator>-&gt;</operator><name>shardLength</name></name></expr></argument>,
							 <argument><expr><name><name>placement</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>,
							 <argument><expr><name><name>placement</name><operator>-&gt;</operator><name>placementId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>insertPlacementCommand</name></expr></argument>, <argument><expr><literal type="string">") "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>insertPlacementCommand</name></expr></argument>,
					 <argument><expr><literal type="string">"SELECT citus_internal_add_placement_metadata("</literal>
					 <literal type="string">"shardid, shardstate, shardlength, groupid, placementid) "</literal>
					 <literal type="string">"FROM placement_data;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* now add shards to insertShardCommand */</comment>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>insertShardCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>insertShardCommand</name></expr></argument>,
					 <argument><expr><literal type="string">"WITH shard_data(relationname, shardid, storagetype, "</literal>
					 <literal type="string">"shardminvalue, shardmaxvalue)  AS (VALUES "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach_ptr</name><argument_list>(<argument>shardInterval</argument>, <argument>shardIntervalList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint64</name></type> <name>shardId</name> <init>= <expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>distributedRelationId</name> <init>= <expr><name><name>shardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>qualifiedRelationName</name> <init>= <expr><call><name>generate_qualified_relation_name</name><argument_list>(
			<argument><expr><name>distributedRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StringInfo</name></type> <name>minHashToken</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StringInfo</name></type> <name>maxHashToken</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>shardInterval</name><operator>-&gt;</operator><name>minValueExists</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>minHashToken</name></expr></argument>, <argument><expr><literal type="string">"'%d'"</literal></expr></argument>, <argument><expr><call><name>DatumGetInt32</name><argument_list>(
								 <argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>minValue</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>minHashToken</name></expr></argument>, <argument><expr><literal type="string">"NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>shardInterval</name><operator>-&gt;</operator><name>maxValueExists</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>maxHashToken</name></expr></argument>, <argument><expr><literal type="string">"'%d'"</literal></expr></argument>, <argument><expr><call><name>DatumGetInt32</name><argument_list>(
								 <argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>maxValue</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>maxHashToken</name></expr></argument>, <argument><expr><literal type="string">"NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>insertShardCommand</name></expr></argument>,
						 <argument><expr><literal type="string">"(%s::regclass, %ld, '%c'::\"char\", %s, %s)"</literal></expr></argument>,
						 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>qualifiedRelationName</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name>shardId</name></expr></argument>,
						 <argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>storageType</name></name></expr></argument>,
						 <argument><expr><name><name>minHashToken</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
						 <argument><expr><name><name>maxHashToken</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>llast</name><argument_list>(<argument><expr><name>shardIntervalList</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>shardInterval</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>insertShardCommand</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>insertShardCommand</name></expr></argument>, <argument><expr><literal type="string">") "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>insertShardCommand</name></expr></argument>,
					 <argument><expr><literal type="string">"SELECT citus_internal_add_shard_metadata(relationname, shardid, "</literal>
					 <literal type="string">"storagetype, shardminvalue, shardmaxvalue) "</literal>
					 <literal type="string">"FROM shard_data;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * There are no active placements for the table, so do not create the
	 * command as it'd lead to syntax error.
	 *
	 * This is normally not an expected situation, however the current
	 * implementation of citus_disable_node allows to disable nodes with
	 * the only active placements. So, for example a single shard/placement
	 * distributed table on a disabled node might trigger zero placement
	 * case.
	 *
	 * TODO: remove this check once citus_disable_node errors out for
	 * the above scenario.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>firstPlacementProcessed</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* first insert shards, than the placements */</comment>
		<expr_stmt><expr><name>commandList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>commandList</name></expr></argument>, <argument><expr><name><name>insertShardCommand</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>commandList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>commandList</name></expr></argument>, <argument><expr><name><name>insertPlacementCommand</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>commandList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ShardListDeleteCommand generates a command list that can be executed to delete
 * shard and shard placement metadata for the given shard.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>ShardDeleteCommandList</name><parameter_list>(<parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type> <name>shardId</name> <init>= <expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>StringInfo</name></type> <name>deleteShardCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>deleteShardCommand</name></expr></argument>,
					 <argument><expr><literal type="string">"SELECT citus_internal_delete_shard_metadata(%ld);"</literal></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name><name>deleteShardCommand</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * NodeDeleteCommand generate a command that can be
 * executed to delete the metadata for a worker node.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>NodeDeleteCommand</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>nodeId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>nodeDeleteCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>nodeDeleteCommand</name></expr></argument>,
					 <argument><expr><literal type="string">"DELETE FROM pg_dist_node "</literal>
					 <literal type="string">"WHERE nodeid = %u"</literal></expr></argument>, <argument><expr><name>nodeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>nodeDeleteCommand</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * NodeStateUpdateCommand generates a command that can be executed to update
 * isactive column of a node in pg_dist_node table.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>NodeStateUpdateCommand</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>nodeId</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isActive</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>nodeStateUpdateCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>isActiveString</name> <init>= <expr><ternary><condition><expr><name>isActive</name></expr> ?</condition><then> <expr><literal type="string">"TRUE"</literal></expr> </then><else>: <expr><literal type="string">"FALSE"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>nodeStateUpdateCommand</name></expr></argument>,
					 <argument><expr><literal type="string">"UPDATE pg_dist_node SET isactive = %s "</literal>
					 <literal type="string">"WHERE nodeid = %u"</literal></expr></argument>, <argument><expr><name>isActiveString</name></expr></argument>, <argument><expr><name>nodeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>nodeStateUpdateCommand</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ShouldHaveShardsUpdateCommand generates a command that can be executed to
 * update the shouldhaveshards column of a node in pg_dist_node table.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>ShouldHaveShardsUpdateCommand</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>nodeId</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>shouldHaveShards</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>nodeStateUpdateCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>shouldHaveShardsString</name> <init>= <expr><ternary><condition><expr><name>shouldHaveShards</name></expr> ?</condition><then> <expr><literal type="string">"TRUE"</literal></expr> </then><else>: <expr><literal type="string">"FALSE"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>nodeStateUpdateCommand</name></expr></argument>,
					 <argument><expr><literal type="string">"UPDATE pg_catalog.pg_dist_node SET shouldhaveshards = %s "</literal>
					 <literal type="string">"WHERE nodeid = %u"</literal></expr></argument>, <argument><expr><name>shouldHaveShardsString</name></expr></argument>, <argument><expr><name>nodeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>nodeStateUpdateCommand</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColocationIdUpdateCommand creates the SQL command to change the colocationId
 * of the table with the given name to the given colocationId in pg_dist_partition
 * table.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>ColocationIdUpdateCommand</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>colocationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>command</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>qualifiedRelationName</name> <init>= <expr><call><name>generate_qualified_relation_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>command</name></expr></argument>,
					 <argument><expr><literal type="string">"SELECT citus_internal_update_relation_colocation(%s::regclass, %d)"</literal></expr></argument>,
					 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>qualifiedRelationName</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>colocationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>command</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PlacementUpsertCommand creates a SQL command for upserting a pg_dist_placment
 * entry with the given properties. In the case of a conflict on placementId, the command
 * updates all properties (excluding the placementId) with the given ones.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>PlacementUpsertCommand</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>placementId</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>shardState</name></decl></parameter>,
					   <parameter><decl><type><name>uint64</name></type> <name>shardLength</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>groupId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>command</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><name>UPSERT_PLACEMENT</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>, <argument><expr><name>shardState</name></expr></argument>, <argument><expr><name>shardLength</name></expr></argument>,
					 <argument><expr><name>groupId</name></expr></argument>, <argument><expr><name>placementId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>command</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * LocalGroupIdUpdateCommand creates the SQL command required to set the local group id
 * of a worker and returns the command in a string.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>LocalGroupIdUpdateCommand</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>groupId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>updateCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>updateCommand</name></expr></argument>, <argument><expr><literal type="string">"UPDATE pg_dist_local_group SET groupid = %d"</literal></expr></argument>,
					 <argument><expr><name>groupId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>updateCommand</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DDLCommandsForSequence returns the DDL commands needs to be run to create the
 * sequence and alter the owner to the given owner name.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>DDLCommandsForSequence</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>sequenceOid</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>ownerName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>sequenceDDLList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sequenceDef</name> <init>= <expr><call><name>pg_get_sequencedef_string</name><argument_list>(<argument><expr><name>sequenceOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>escapedSequenceDef</name> <init>= <expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>sequenceDef</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>wrappedSequenceDef</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>sequenceGrantStmt</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sequenceName</name> <init>= <expr><call><name>generate_qualified_relation_name</name><argument_list>(<argument><expr><name>sequenceOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_sequence</name></type> <name>sequenceData</name> <init>= <expr><call><name>pg_get_sequencedef</name><argument_list>(<argument><expr><name>sequenceOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>sequenceTypeOid</name> <init>= <expr><name><name>sequenceData</name><operator>-&gt;</operator><name>seqtypid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>typeName</name> <init>= <expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>sequenceTypeOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* create schema if needed */</comment>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>wrappedSequenceDef</name></expr></argument>,
					 <argument><expr><name>WORKER_APPLY_SEQUENCE_COMMAND</name></expr></argument>,
					 <argument><expr><name>escapedSequenceDef</name></expr></argument>,
					 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>sequenceGrantStmt</name></expr></argument>,
					 <argument><expr><literal type="string">"ALTER SEQUENCE %s OWNER TO %s"</literal></expr></argument>, <argument><expr><name>sequenceName</name></expr></argument>,
					 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>ownerName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>sequenceDDLList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>sequenceDDLList</name></expr></argument>, <argument><expr><name><name>wrappedSequenceDef</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sequenceDDLList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>sequenceDDLList</name></expr></argument>, <argument><expr><name><name>sequenceGrantStmt</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sequenceDDLList</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>sequenceDDLList</name></expr></argument>, <argument><expr><call><name>GrantOnSequenceDDLCommands</name><argument_list>(
									  <argument><expr><name>sequenceOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>sequenceDDLList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetAttributeTypeOid returns the OID of the type of the attribute of
 * provided relationId that has the provided attnum
 */</comment>
<function><type><name>Oid</name></type>
<name>GetAttributeTypeOid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>resultOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* Grab an appropriate lock on the pg_attribute relation */</comment>
	<decl_stmt><decl><type><name>Relation</name></type> <name>attrel</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Use the index to scan only system attributes of the target relation */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_attribute_attrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_attribute_attnum</name></expr></argument>,
				<argument><expr><name>BTLessEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_INT2LE</name></expr></argument>,
				<argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(<argument><expr><name>attrel</name></expr></argument>, <argument><expr><name>AttributeRelidNumIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>,
										  <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>attributeTuple</name></decl>;</decl_stmt>
	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>attributeTuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>attributeTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>resultOid</name> <operator>=</operator> <name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>attrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>resultOid</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetDependentSequencesWithRelation appends the attnum and id of sequences that
 * have direct (owned sequences) or indirect dependency with the given relationId,
 * to the lists passed as NIL initially.
 * For both cases, we use the intermediate AttrDefault object from pg_depend.
 * If attnum is specified, we only return the sequences related to that
 * attribute of the relationId.
 */</comment>
<function><type><name>void</name></type>
<name>GetDependentSequencesWithRelation</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>seqInfoList</name></decl></parameter>,
								  <parameter><decl><type><name>AttrNumber</name></type> <name>attnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>seqInfoList</name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>attrdefResult</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>attrdefAttnumResult</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tup</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>depRel</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>DependRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_depend_refclassid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_depend_refobjid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>attnum</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
					<argument><expr><name>Anum_pg_depend_refobjsubid</name></expr></argument>,
					<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_INT4EQ</name></expr></argument>,
					<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(<argument><expr><name>depRel</name></expr></argument>, <argument><expr><name>DependReferenceIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
										  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><ternary><condition><expr><name>attnum</name></expr> ?</condition><then> <expr><literal type="number">3</literal></expr> </then><else>: <expr><literal type="number">2</literal></expr></else></ternary></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_depend</name></type> <name>deprec</name> <init>= <expr><operator>(</operator><name>Form_pg_depend</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>deprec</name><operator>-&gt;</operator><name>classid</name></name> <operator>==</operator> <name>AttrDefaultRelationId</name> <operator>&amp;&amp;</operator>
			<name><name>deprec</name><operator>-&gt;</operator><name>objsubid</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<name><name>deprec</name><operator>-&gt;</operator><name>refobjsubid</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<name><name>deprec</name><operator>-&gt;</operator><name>deptype</name></name> <operator>==</operator> <name>DEPENDENCY_AUTO</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We are going to generate corresponding SequenceInfo
			 * in the following loop.
			 */</comment>
			<expr_stmt><expr><name>attrdefResult</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>attrdefResult</name></expr></argument>, <argument><expr><name><name>deprec</name><operator>-&gt;</operator><name>objid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>attrdefAttnumResult</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>attrdefAttnumResult</name></expr></argument>, <argument><expr><name><name>deprec</name><operator>-&gt;</operator><name>refobjsubid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>deprec</name><operator>-&gt;</operator><name>deptype</name></name> <operator>==</operator> <name>DEPENDENCY_AUTO</name> <operator>&amp;&amp;</operator>
				 <name><name>deprec</name><operator>-&gt;</operator><name>refobjsubid</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				 <name><name>deprec</name><operator>-&gt;</operator><name>classid</name></name> <operator>==</operator> <name>RelationRelationId</name> <operator>&amp;&amp;</operator>
				 <call><name>get_rel_relkind</name><argument_list>(<argument><expr><name><name>deprec</name><operator>-&gt;</operator><name>objid</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RELKIND_SEQUENCE</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SequenceInfo</name> <modifier>*</modifier></type><name>seqInfo</name> <init>= <expr><operator>(</operator><name>SequenceInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SequenceInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>seqInfo</name><operator>-&gt;</operator><name>sequenceOid</name></name> <operator>=</operator> <name><name>deprec</name><operator>-&gt;</operator><name>objid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>seqInfo</name><operator>-&gt;</operator><name>attributeNumber</name></name> <operator>=</operator> <name><name>deprec</name><operator>-&gt;</operator><name>refobjsubid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>seqInfo</name><operator>-&gt;</operator><name>isNextValDefault</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<expr_stmt><expr><operator>*</operator><name>seqInfoList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>seqInfoList</name></expr></argument>, <argument><expr><name>seqInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>depRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>AttrNumber</name></type> <name>attrdefAttnum</name> <init>= <expr><name>InvalidAttrNumber</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>attrdefOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>forboth_int_oid</name><argument_list>(<argument>attrdefAttnum</argument>, <argument>attrdefAttnumResult</argument>, <argument>attrdefOid</argument>, <argument>attrdefResult</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>sequencesFromAttrDef</name> <init>= <expr><call><name>GetSequencesFromAttrDef</name><argument_list>(<argument><expr><name>attrdefOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* to simplify and eliminate cases like "DEFAULT nextval('..') - nextval('..')" */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>sequencesFromAttrDef</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
								<argument><expr><literal type="string">"More than one sequence in a column default"</literal>
								<literal type="string">" is not supported for distribution "</literal>
								<literal type="string">"or for adding local tables to metadata"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>sequencesFromAttrDef</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SequenceInfo</name> <modifier>*</modifier></type><name>seqInfo</name> <init>= <expr><operator>(</operator><name>SequenceInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SequenceInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>seqInfo</name><operator>-&gt;</operator><name>sequenceOid</name></name> <operator>=</operator> <call><name>linitial_oid</name><argument_list>(<argument><expr><name>sequencesFromAttrDef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>seqInfo</name><operator>-&gt;</operator><name>attributeNumber</name></name> <operator>=</operator> <name>attrdefAttnum</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>seqInfo</name><operator>-&gt;</operator><name>isNextValDefault</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<expr_stmt><expr><operator>*</operator><name>seqInfoList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>seqInfoList</name></expr></argument>, <argument><expr><name>seqInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * GetSequencesFromAttrDef returns a list of sequence OIDs that have
 * dependency with the given attrdefOid in pg_depend
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>GetSequencesFromAttrDef</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>attrdefOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>sequencesResult</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tup</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>depRel</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>DependRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_depend_classid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>AttrDefaultRelationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_depend_objid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>attrdefOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(<argument><expr><name>depRel</name></expr></argument>, <argument><expr><name>DependDependerIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
										  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_depend</name></type> <name>deprec</name> <init>= <expr><operator>(</operator><name>Form_pg_depend</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>deprec</name><operator>-&gt;</operator><name>refclassid</name></name> <operator>==</operator> <name>RelationRelationId</name> <operator>&amp;&amp;</operator>
			<name><name>deprec</name><operator>-&gt;</operator><name>deptype</name></name> <operator>==</operator> <name>DEPENDENCY_NORMAL</name> <operator>&amp;&amp;</operator>
			<call><name>get_rel_relkind</name><argument_list>(<argument><expr><name><name>deprec</name><operator>-&gt;</operator><name>refobjid</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RELKIND_SEQUENCE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>sequencesResult</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>sequencesResult</name></expr></argument>, <argument><expr><name><name>deprec</name><operator>-&gt;</operator><name>refobjid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>depRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>sequencesResult</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetDependentFunctionsWithRelation returns the dependent functions for the
 * given relation id.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>GetDependentFunctionsWithRelation</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>referencingObjects</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>functionOids</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tup</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>depRel</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>DependRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_depend_refclassid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_depend_refobjid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(<argument><expr><name>depRel</name></expr></argument>, <argument><expr><name>DependReferenceIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
										  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_depend</name></type> <name>deprec</name> <init>= <expr><operator>(</operator><name>Form_pg_depend</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * objsubid is nonzero only for table columns and zero for anything else.
		 * Since we are trying to find a dependency from the column of a table to
		 * function we've added deprec-&gt;refobjsubid != 0 check.
		 *
		 * We are following DEPENDENCY_AUTO for dependencies via column and
		 * DEPENDENCY_NORMAL anything else. Since only procedure dependencies
		 * for those dependencies will be obtained in GetFunctionDependenciesForObjects
		 * following both dependency types are not harmful.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>deprec</name><operator>-&gt;</operator><name>refobjsubid</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>deprec</name><operator>-&gt;</operator><name>deptype</name></name> <operator>==</operator> <name>DEPENDENCY_AUTO</name><operator>)</operator> <operator>||</operator>
			<name><name>deprec</name><operator>-&gt;</operator><name>deptype</name></name> <operator>==</operator> <name>DEPENDENCY_NORMAL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>refAddress</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ObjectAddress</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>ObjectAddressSubSet</name><argument_list>(<argument><expr><operator>*</operator><name>refAddress</name></expr></argument>, <argument><expr><name><name>deprec</name><operator>-&gt;</operator><name>classid</name></name></expr></argument>,
								<argument><expr><name><name>deprec</name><operator>-&gt;</operator><name>objid</name></name></expr></argument>,
								<argument><expr><name><name>deprec</name><operator>-&gt;</operator><name>objsubid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>referencingObjects</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>referencingObjects</name></expr></argument>, <argument><expr><name>refAddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>depRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>referencingObject</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>referencingObject</argument>, <argument>referencingObjects</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>functionOids</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>functionOids</name></expr></argument>,
								   <argument><expr><call><name>GetFunctionDependenciesForObjects</name><argument_list>(<argument><expr><name>referencingObject</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>functionOids</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetFunctionDependenciesForObjects returns a list of function OIDs that have
 * dependency with the given object
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>GetFunctionDependenciesForObjects</name><parameter_list>(<parameter><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>objectAddress</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>functionOids</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tup</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>depRel</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>DependRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_depend_classid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>objectAddress</name><operator>-&gt;</operator><name>classId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_depend_objid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>objectAddress</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_depend_objsubid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>objectAddress</name><operator>-&gt;</operator><name>objectSubId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(<argument><expr><name>depRel</name></expr></argument>, <argument><expr><name>DependDependerIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
										  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_depend</name></type> <name>deprec</name> <init>= <expr><operator>(</operator><name>Form_pg_depend</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>deprec</name><operator>-&gt;</operator><name>refclassid</name></name> <operator>==</operator> <name>ProcedureRelationId</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>functionOids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>functionOids</name></expr></argument>, <argument><expr><name><name>deprec</name><operator>-&gt;</operator><name>refobjid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>depRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>functionOids</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SequenceDependencyCommandList generates commands to record the dependency
 * of sequences on tables on the worker. This dependency does not exist by
 * default since the sequences and table are created separately, but it is
 * necessary to ensure that the sequence is dropped when the table is
 * dropped.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>SequenceDependencyCommandList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>sequenceCommandList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>columnNameList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>sequenceIdList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ExtractDefaultColumnsAndOwnedSequences</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>columnNameList</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sequenceIdList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>columnName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>sequenceId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>forboth_ptr_oid</name><argument_list>(<argument>columnName</argument>, <argument>columnNameList</argument>, <argument>sequenceId</argument>, <argument>sequenceIdList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>sequenceId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * ExtractDefaultColumnsAndOwnedSequences returns entries for all columns,
			 * but with 0 sequence ID unless there is default nextval(..).
			 */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sequenceDependencyCommand</name> <init>=
			<expr><call><name>CreateSequenceDependencyCommand</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>sequenceId</name></expr></argument>, <argument><expr><name>columnName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>sequenceCommandList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>sequenceCommandList</name></expr></argument>,
									  <argument><expr><call><name>makeTableDDLCommandString</name><argument_list>(
										  <argument><expr><name>sequenceDependencyCommand</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>sequenceCommandList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateSequenceDependencyCommand generates a query string for calling
 * worker_record_sequence_dependency on the worker to recreate a sequence-&gt;table
 * dependency.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>CreateSequenceDependencyCommand</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>sequenceId</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>columnName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>generate_qualified_relation_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sequenceName</name> <init>= <expr><call><name>generate_qualified_relation_name</name><argument_list>(<argument><expr><name>sequenceId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>StringInfo</name></type> <name>sequenceDependencyCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>sequenceDependencyCommand</name></expr></argument>,
					 <argument><expr><literal type="string">"SELECT pg_catalog.worker_record_sequence_dependency"</literal>
					 <literal type="string">"(%s::regclass,%s::regclass,%s)"</literal></expr></argument>,
					 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>sequenceName</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>relationName</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>columnName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>sequenceDependencyCommand</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * worker_record_sequence_dependency records the fact that the sequence depends on
 * the table in pg_depend, such that it will be automatically dropped.
 */</comment>
<function><type><name>Datum</name></type>
<name>worker_record_sequence_dependency</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>sequenceOid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationOid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Name</name></type> <name>columnName</name> <init>= <expr><call><name>PG_GETARG_NAME</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>columnNameStr</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>columnName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* lookup column definition */</comment>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>columnTuple</name> <init>= <expr><call><name>SearchSysCacheAttName</name><argument_list>(<argument><expr><name>relationOid</name></expr></argument>, <argument><expr><name>columnNameStr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>columnTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" does not exist"</literal></expr></argument>,
							   <argument><expr><name>columnNameStr</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>columnForm</name> <init>= <expr><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>columnTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>columnForm</name><operator>-&gt;</operator><name>attnum</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot create dependency on system column \"%s\""</literal></expr></argument>,
							   <argument><expr><name>columnNameStr</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>sequenceAddr</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>classId</name> <operator>=</operator> <name>RelationRelationId</name></expr>,
		<expr><operator>.</operator><name>objectId</name> <operator>=</operator> <name>sequenceOid</name></expr>,
		<expr><operator>.</operator><name>objectSubId</name> <operator>=</operator> <literal type="number">0</literal></expr>
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>relationAddr</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>classId</name> <operator>=</operator> <name>RelationRelationId</name></expr>,
		<expr><operator>.</operator><name>objectId</name> <operator>=</operator> <name>relationOid</name></expr>,
		<expr><operator>.</operator><name>objectSubId</name> <operator>=</operator> <name><name>columnForm</name><operator>-&gt;</operator><name>attnum</name></name></expr>
	}</block></expr></init></decl>;</decl_stmt>


	<expr_stmt><expr><call><name>EnsureTableOwner</name><argument_list>(<argument><expr><name>sequenceOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EnsureTableOwner</name><argument_list>(<argument><expr><name>relationOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* dependency from sequence to table */</comment>
	<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sequenceAddr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>relationAddr</name></expr></argument>, <argument><expr><name>DEPENDENCY_AUTO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>columnTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CreateSchemaDDLCommand returns a "CREATE SCHEMA..." SQL string for creating the given
 * schema if not exists and with proper authorization.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>CreateSchemaDDLCommand</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>schemaId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>schemaName</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>schemaId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>StringInfo</name></type> <name>schemaNameDef</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>quotedSchemaName</name> <init>= <expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ownerName</name> <init>= <expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>SchemaOwnerName</name><argument_list>(<argument><expr><name>schemaId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>schemaNameDef</name></expr></argument>, <argument><expr><name>CREATE_SCHEMA_COMMAND</name></expr></argument>, <argument><expr><name>quotedSchemaName</name></expr></argument>, <argument><expr><name>ownerName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>schemaNameDef</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GrantOnSchemaDDLCommands creates a list of ddl command for replicating the permissions
 * of roles on schemas.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>GrantOnSchemaDDLCommands</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>schemaOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>schemaTuple</name> <init>= <expr><call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>NAMESPACEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>schemaOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isNull</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>aclDatum</name> <init>= <expr><call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>NAMESPACEOID</name></expr></argument>, <argument><expr><name>schemaTuple</name></expr></argument>, <argument><expr><name>Anum_pg_namespace_nspacl</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>schemaTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><name>Acl</name> <modifier>*</modifier></type><name>acl</name> <init>= <expr><call><name>DatumGetAclPCopy</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclItem</name> <modifier>*</modifier></type><name>aclDat</name> <init>= <expr><call><name>ACL_DAT</name><argument_list>(<argument><expr><name>acl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>aclNum</name> <init>= <expr><call><name>ACL_NUM</name><argument_list>(<argument><expr><name>acl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commands</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>schemaTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>aclNum</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>commands</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>commands</name></expr></argument>,
							   <argument><expr><call><name>GenerateGrantOnSchemaQueriesFromAclItem</name><argument_list>(
								   <argument><expr><name>schemaOid</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name><name>aclDat</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>commands</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GenerateGrantOnSchemaQueryFromACLItem generates a query string for replicating a users permissions
 * on a schema.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>GenerateGrantOnSchemaQueriesFromAclItem</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>schemaOid</name></decl></parameter>, <parameter><decl><type><name>AclItem</name> <modifier>*</modifier></type><name>aclItem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AclMode</name></type> <name>permissions</name> <init>= <expr><call><name>ACLITEM_GET_PRIVS</name><argument_list>(<argument><expr><operator>*</operator><name>aclItem</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>ACL_ALL_RIGHTS_SCHEMA</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclMode</name></type> <name>grants</name> <init>= <expr><call><name>ACLITEM_GET_GOPTIONS</name><argument_list>(<argument><expr><operator>*</operator><name>aclItem</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>ACL_ALL_RIGHTS_SCHEMA</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * seems unlikely but we check if there is a grant option in the list without the actual permission
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>grants</name> <operator>&amp;</operator> <name>ACL_USAGE</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>permissions</name> <operator>&amp;</operator> <name>ACL_USAGE</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>grants</name> <operator>&amp;</operator> <name>ACL_CREATE</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>permissions</name> <operator>&amp;</operator> <name>ACL_CREATE</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>granteeOid</name> <init>= <expr><name><name>aclItem</name><operator>-&gt;</operator><name>ai_grantee</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>queries</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>queries</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>queries</name></expr></argument>, <argument><expr><call><name>GenerateSetRoleQuery</name><argument_list>(<argument><expr><name><name>aclItem</name><operator>-&gt;</operator><name>ai_grantor</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>permissions</name> <operator>&amp;</operator> <name>ACL_USAGE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>query</name> <init>= <expr><call><name>DeparseTreeNode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>GenerateGrantStmtForRights</name><argument_list>(
										  <argument><expr><name>OBJECT_SCHEMA</name></expr></argument>, <argument><expr><name>granteeOid</name></expr></argument>, <argument><expr><name>schemaOid</name></expr></argument>, <argument><expr><literal type="string">"USAGE"</literal></expr></argument>,
										  <argument><expr><name>grants</name> <operator>&amp;</operator> <name>ACL_USAGE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>queries</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>queries</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>permissions</name> <operator>&amp;</operator> <name>ACL_CREATE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>query</name> <init>= <expr><call><name>DeparseTreeNode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>GenerateGrantStmtForRights</name><argument_list>(
										  <argument><expr><name>OBJECT_SCHEMA</name></expr></argument>, <argument><expr><name>granteeOid</name></expr></argument>, <argument><expr><name>schemaOid</name></expr></argument>, <argument><expr><literal type="string">"CREATE"</literal></expr></argument>,
										  <argument><expr><name>grants</name> <operator>&amp;</operator> <name>ACL_CREATE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>queries</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>queries</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>queries</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>queries</name></expr></argument>, <argument><expr><literal type="string">"RESET ROLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>queries</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GenerateGrantStmtForRights is the function for creating GrantStmt's for all
 * types of objects that are supported. It takes parameters to fill a GrantStmt's
 * fields and returns the GrantStmt.
 * The field `objects` of GrantStmt doesn't have a common structure for all types.
 * Make sure you have added your object type to GetObjectsForGrantStmt.
 */</comment>
<function><type><specifier>static</specifier> <name>GrantStmt</name> <modifier>*</modifier></type>
<name>GenerateGrantStmtForRights</name><parameter_list>(<parameter><decl><type><name>ObjectType</name></type> <name>objectType</name></decl></parameter>,
						   <parameter><decl><type><name>Oid</name></type> <name>roleOid</name></decl></parameter>,
						   <parameter><decl><type><name>Oid</name></type> <name>objectId</name></decl></parameter>,
						   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>permission</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name></type> <name>withGrantOption</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GrantStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>GrantStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>is_grant</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>targtype</name></name> <operator>=</operator> <name>ACL_TARGET_OBJECT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name> <operator>=</operator> <name>objectType</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>objects</name></name> <operator>=</operator> <call><name>GetObjectsForGrantStmt</name><argument_list>(<argument><expr><name>objectType</name></expr></argument>, <argument><expr><name>objectId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>privileges</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>GetAccessPrivObjectForGrantStmt</name><argument_list>(<argument><expr><name>permission</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>grantees</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>GetRoleSpecObjectForUser</name><argument_list>(<argument><expr><name>roleOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>grant_option</name></name> <operator>=</operator> <name>withGrantOption</name></expr>;</expr_stmt>

	<return>return <expr><name>stmt</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetObjectsForGrantStmt takes an object type and object id and returns the 'objects'
 * field to be used when creating GrantStmt. We have only one object here (the one with
 * the oid = objectId) but we pass it into the GrantStmt as a list with one element,
 * as GrantStmt-&gt;objects field is actually a list.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>GetObjectsForGrantStmt</name><parameter_list>(<parameter><decl><type><name>ObjectType</name></type> <name>objectType</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>objectId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>objectType</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* supported object types */</comment>
		<case>case <expr><name>OBJECT_SCHEMA</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>objectId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block>

		<comment type="block">/* enterprise supported object types */</comment>
		<case>case <expr><name>OBJECT_FUNCTION</name></expr>:</case>
		<case>case <expr><name>OBJECT_AGGREGATE</name></expr>:</case>
		<case>case <expr><name>OBJECT_PROCEDURE</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ObjectWithArgs</name> <modifier>*</modifier></type><name>owa</name> <init>= <expr><call><name>ObjectWithArgsFromOid</name><argument_list>(<argument><expr><name>objectId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>owa</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>OBJECT_FDW</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ForeignDataWrapper</name> <modifier>*</modifier></type><name>fdw</name> <init>= <expr><call><name>GetForeignDataWrapper</name><argument_list>(<argument><expr><name>objectId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name><name>fdw</name><operator>-&gt;</operator><name>fdwname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>OBJECT_FOREIGN_SERVER</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ForeignServer</name> <modifier>*</modifier></type><name>server</name> <init>= <expr><call><name>GetForeignServer</name><argument_list>(<argument><expr><name>objectId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name><name>server</name><operator>-&gt;</operator><name>servername</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>OBJECT_SEQUENCE</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type> <name>namespaceOid</name> <init>= <expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>objectId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>sequence</name> <init>= <expr><call><name>makeRangeVar</name><argument_list>(<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>namespaceOid</name></expr></argument>)</argument_list></call></expr></argument>,
											  <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>objectId</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>sequence</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block>

		<default>default:</default>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unsupported object type for GRANT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></switch>

	<return>return <expr><name>NIL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GrantOnFunctionDDLCommands creates a list of ddl command for replicating the permissions
 * of roles on distributed functions.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>GrantOnFunctionDDLCommands</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>functionOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>proctup</name> <init>= <expr><call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>functionOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>isNull</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>aclDatum</name> <init>= <expr><call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><name>proctup</name></expr></argument>, <argument><expr><name>Anum_pg_proc_proacl</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Acl</name> <modifier>*</modifier></type><name>acl</name> <init>= <expr><call><name>DatumGetAclPCopy</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclItem</name> <modifier>*</modifier></type><name>aclDat</name> <init>= <expr><call><name>ACL_DAT</name><argument_list>(<argument><expr><name>acl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>aclNum</name> <init>= <expr><call><name>ACL_NUM</name><argument_list>(<argument><expr><name>acl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commands</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>aclNum</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>commands</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>commands</name></expr></argument>,
							   <argument><expr><call><name>GenerateGrantOnFunctionQueriesFromAclItem</name><argument_list>(
								   <argument><expr><name>functionOid</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name><name>aclDat</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>commands</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GrantOnForeignServerDDLCommands creates a list of ddl command for replicating the
 * permissions of roles on distributed foreign servers.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>GrantOnForeignServerDDLCommands</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>serverId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>servertup</name> <init>= <expr><call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>FOREIGNSERVEROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>serverId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>isNull</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>aclDatum</name> <init>= <expr><call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>FOREIGNSERVEROID</name></expr></argument>, <argument><expr><name>servertup</name></expr></argument>,
									 <argument><expr><name>Anum_pg_foreign_server_srvacl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>servertup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Acl</name> <modifier>*</modifier></type><name>aclEntry</name> <init>= <expr><call><name>DatumGetAclPCopy</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclItem</name> <modifier>*</modifier></type><name>privileges</name> <init>= <expr><call><name>ACL_DAT</name><argument_list>(<argument><expr><name>aclEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>numberOfPrivsGranted</name> <init>= <expr><call><name>ACL_NUM</name><argument_list>(<argument><expr><name>aclEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commands</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>servertup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numberOfPrivsGranted</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>commands</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>commands</name></expr></argument>,
							   <argument><expr><call><name>GenerateGrantOnForeignServerQueriesFromAclItem</name><argument_list>(
								   <argument><expr><name>serverId</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name><name>privileges</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>commands</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GenerateGrantOnForeignServerQueriesFromAclItem generates a query string for
 * replicating a users permissions on a foreign server.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>GenerateGrantOnForeignServerQueriesFromAclItem</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>serverId</name></decl></parameter>, <parameter><decl><type><name>AclItem</name> <modifier>*</modifier></type><name>aclItem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* privileges to be granted */</comment>
	<decl_stmt><decl><type><name>AclMode</name></type> <name>permissions</name> <init>= <expr><call><name>ACLITEM_GET_PRIVS</name><argument_list>(<argument><expr><operator>*</operator><name>aclItem</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>ACL_ALL_RIGHTS_FOREIGN_SERVER</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* WITH GRANT OPTION clause */</comment>
	<decl_stmt><decl><type><name>AclMode</name></type> <name>grants</name> <init>= <expr><call><name>ACLITEM_GET_GOPTIONS</name><argument_list>(<argument><expr><operator>*</operator><name>aclItem</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>ACL_ALL_RIGHTS_FOREIGN_SERVER</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * seems unlikely but we check if there is a grant option in the list without the actual permission
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>grants</name> <operator>&amp;</operator> <name>ACL_USAGE</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>permissions</name> <operator>&amp;</operator> <name>ACL_USAGE</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>granteeOid</name> <init>= <expr><name><name>aclItem</name><operator>-&gt;</operator><name>ai_grantee</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>queries</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* switch to the role which had granted acl */</comment>
	<expr_stmt><expr><name>queries</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>queries</name></expr></argument>, <argument><expr><call><name>GenerateSetRoleQuery</name><argument_list>(<argument><expr><name><name>aclItem</name><operator>-&gt;</operator><name>ai_grantor</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* generate the GRANT stmt that will be executed by the grantor role */</comment>
	<if_stmt><if>if <condition>(<expr><name>permissions</name> <operator>&amp;</operator> <name>ACL_USAGE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>query</name> <init>= <expr><call><name>DeparseTreeNode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>GenerateGrantStmtForRights</name><argument_list>(
										  <argument><expr><name>OBJECT_FOREIGN_SERVER</name></expr></argument>, <argument><expr><name>granteeOid</name></expr></argument>, <argument><expr><name>serverId</name></expr></argument>,
										  <argument><expr><literal type="string">"USAGE"</literal></expr></argument>, <argument><expr><name>grants</name> <operator>&amp;</operator> <name>ACL_USAGE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>queries</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>queries</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* reset the role back */</comment>
	<expr_stmt><expr><name>queries</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>queries</name></expr></argument>, <argument><expr><literal type="string">"RESET ROLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>queries</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GenerateGrantOnFunctionQueryFromACLItem generates a query string for replicating a users permissions
 * on a distributed function.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>GenerateGrantOnFunctionQueriesFromAclItem</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>functionOid</name></decl></parameter>, <parameter><decl><type><name>AclItem</name> <modifier>*</modifier></type><name>aclItem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AclMode</name></type> <name>permissions</name> <init>= <expr><call><name>ACLITEM_GET_PRIVS</name><argument_list>(<argument><expr><operator>*</operator><name>aclItem</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>ACL_ALL_RIGHTS_FUNCTION</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclMode</name></type> <name>grants</name> <init>= <expr><call><name>ACLITEM_GET_GOPTIONS</name><argument_list>(<argument><expr><operator>*</operator><name>aclItem</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>ACL_ALL_RIGHTS_FUNCTION</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * seems unlikely but we check if there is a grant option in the list without the actual permission
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>grants</name> <operator>&amp;</operator> <name>ACL_EXECUTE</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>permissions</name> <operator>&amp;</operator> <name>ACL_EXECUTE</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>granteeOid</name> <init>= <expr><name><name>aclItem</name><operator>-&gt;</operator><name>ai_grantee</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>queries</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>queries</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>queries</name></expr></argument>, <argument><expr><call><name>GenerateSetRoleQuery</name><argument_list>(<argument><expr><name><name>aclItem</name><operator>-&gt;</operator><name>ai_grantor</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>permissions</name> <operator>&amp;</operator> <name>ACL_EXECUTE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type> <name>prokind</name> <init>= <expr><call><name>get_func_prokind</name><argument_list>(<argument><expr><name>functionOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ObjectType</name></type> <name>objectType</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>prokind</name> <operator>==</operator> <name>PROKIND_FUNCTION</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>objectType</name> <operator>=</operator> <name>OBJECT_FUNCTION</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>prokind</name> <operator>==</operator> <name>PROKIND_PROCEDURE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>objectType</name> <operator>=</operator> <name>OBJECT_PROCEDURE</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>prokind</name> <operator>==</operator> <name>PROKIND_AGGREGATE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>objectType</name> <operator>=</operator> <name>OBJECT_AGGREGATE</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unsupported prokind"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"GRANT commands on procedures are propagated only "</literal>
									  <literal type="string">"for procedures, functions, and aggregates."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>query</name> <init>= <expr><call><name>DeparseTreeNode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>GenerateGrantStmtForRights</name><argument_list>(
										  <argument><expr><name>objectType</name></expr></argument>, <argument><expr><name>granteeOid</name></expr></argument>, <argument><expr><name>functionOid</name></expr></argument>, <argument><expr><literal type="string">"EXECUTE"</literal></expr></argument>,
										  <argument><expr><name>grants</name> <operator>&amp;</operator> <name>ACL_EXECUTE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>queries</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>queries</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>queries</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>queries</name></expr></argument>, <argument><expr><literal type="string">"RESET ROLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>queries</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GenerateGrantOnFDWQueriesFromAclItem generates a query string for
 * replicating a users permissions on a foreign data wrapper.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>GenerateGrantOnFDWQueriesFromAclItem</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>FDWId</name></decl></parameter>, <parameter><decl><type><name>AclItem</name> <modifier>*</modifier></type><name>aclItem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* privileges to be granted */</comment>
	<decl_stmt><decl><type><name>AclMode</name></type> <name>permissions</name> <init>= <expr><call><name>ACLITEM_GET_PRIVS</name><argument_list>(<argument><expr><operator>*</operator><name>aclItem</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>ACL_ALL_RIGHTS_FDW</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* WITH GRANT OPTION clause */</comment>
	<decl_stmt><decl><type><name>AclMode</name></type> <name>grants</name> <init>= <expr><call><name>ACLITEM_GET_GOPTIONS</name><argument_list>(<argument><expr><operator>*</operator><name>aclItem</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>ACL_ALL_RIGHTS_FDW</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * seems unlikely but we check if there is a grant option in the list without the actual permission
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>grants</name> <operator>&amp;</operator> <name>ACL_USAGE</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>permissions</name> <operator>&amp;</operator> <name>ACL_USAGE</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>granteeOid</name> <init>= <expr><name><name>aclItem</name><operator>-&gt;</operator><name>ai_grantee</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>queries</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* switch to the role which had granted acl */</comment>
	<expr_stmt><expr><name>queries</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>queries</name></expr></argument>, <argument><expr><call><name>GenerateSetRoleQuery</name><argument_list>(<argument><expr><name><name>aclItem</name><operator>-&gt;</operator><name>ai_grantor</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* generate the GRANT stmt that will be executed by the grantor role */</comment>
	<if_stmt><if>if <condition>(<expr><name>permissions</name> <operator>&amp;</operator> <name>ACL_USAGE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>query</name> <init>= <expr><call><name>DeparseTreeNode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>GenerateGrantStmtForRights</name><argument_list>(
										  <argument><expr><name>OBJECT_FDW</name></expr></argument>, <argument><expr><name>granteeOid</name></expr></argument>, <argument><expr><name>FDWId</name></expr></argument>, <argument><expr><literal type="string">"USAGE"</literal></expr></argument>,
										  <argument><expr><name>grants</name> <operator>&amp;</operator> <name>ACL_USAGE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>queries</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>queries</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* reset the role back */</comment>
	<expr_stmt><expr><name>queries</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>queries</name></expr></argument>, <argument><expr><literal type="string">"RESET ROLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>queries</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetAccessPrivObjectForGrantStmt creates an AccessPriv object for the given permission.
 * It will be used when creating GrantStmt objects.
 */</comment>
<function><type><specifier>static</specifier> <name>AccessPriv</name> <modifier>*</modifier></type>
<name>GetAccessPrivObjectForGrantStmt</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>permission</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AccessPriv</name> <modifier>*</modifier></type><name>accessPriv</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>AccessPriv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>accessPriv</name><operator>-&gt;</operator><name>priv_name</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>permission</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>accessPriv</name><operator>-&gt;</operator><name>cols</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<return>return <expr><name>accessPriv</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GrantOnSequenceDDLCommands creates a list of ddl command for replicating the permissions
 * of roles on distributed sequences.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>GrantOnSequenceDDLCommands</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>sequenceOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>seqtup</name> <init>= <expr><call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>sequenceOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isNull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>aclDatum</name> <init>= <expr><call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><name>seqtup</name></expr></argument>, <argument><expr><name>Anum_pg_class_relacl</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>seqtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Acl</name> <modifier>*</modifier></type><name>acl</name> <init>= <expr><call><name>DatumGetAclPCopy</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclItem</name> <modifier>*</modifier></type><name>aclDat</name> <init>= <expr><call><name>ACL_DAT</name><argument_list>(<argument><expr><name>acl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>aclNum</name> <init>= <expr><call><name>ACL_NUM</name><argument_list>(<argument><expr><name>acl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commands</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>seqtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>aclNum</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>commands</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>commands</name></expr></argument>,
							   <argument><expr><call><name>GenerateGrantOnSequenceQueriesFromAclItem</name><argument_list>(
								   <argument><expr><name>sequenceOid</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name><name>aclDat</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>commands</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GenerateGrantOnSequenceQueriesFromAclItem generates a query string for replicating a users permissions
 * on a distributed sequence.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>GenerateGrantOnSequenceQueriesFromAclItem</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>sequenceOid</name></decl></parameter>, <parameter><decl><type><name>AclItem</name> <modifier>*</modifier></type><name>aclItem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AclMode</name></type> <name>permissions</name> <init>= <expr><call><name>ACLITEM_GET_PRIVS</name><argument_list>(<argument><expr><operator>*</operator><name>aclItem</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>ACL_ALL_RIGHTS_SEQUENCE</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclMode</name></type> <name>grants</name> <init>= <expr><call><name>ACLITEM_GET_GOPTIONS</name><argument_list>(<argument><expr><operator>*</operator><name>aclItem</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>ACL_ALL_RIGHTS_SEQUENCE</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * seems unlikely but we check if there is a grant option in the list without the actual permission
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>grants</name> <operator>&amp;</operator> <name>ACL_USAGE</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>permissions</name> <operator>&amp;</operator> <name>ACL_USAGE</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>grants</name> <operator>&amp;</operator> <name>ACL_SELECT</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>permissions</name> <operator>&amp;</operator> <name>ACL_SELECT</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>grants</name> <operator>&amp;</operator> <name>ACL_UPDATE</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>permissions</name> <operator>&amp;</operator> <name>ACL_UPDATE</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>granteeOid</name> <init>= <expr><name><name>aclItem</name><operator>-&gt;</operator><name>ai_grantee</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>queries</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>queries</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>queries</name></expr></argument>, <argument><expr><call><name>GenerateSetRoleQuery</name><argument_list>(<argument><expr><name><name>aclItem</name><operator>-&gt;</operator><name>ai_grantor</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>permissions</name> <operator>&amp;</operator> <name>ACL_USAGE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>query</name> <init>= <expr><call><name>DeparseTreeNode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>GenerateGrantStmtForRights</name><argument_list>(
										  <argument><expr><name>OBJECT_SEQUENCE</name></expr></argument>, <argument><expr><name>granteeOid</name></expr></argument>, <argument><expr><name>sequenceOid</name></expr></argument>,
										  <argument><expr><literal type="string">"USAGE"</literal></expr></argument>, <argument><expr><name>grants</name> <operator>&amp;</operator> <name>ACL_USAGE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>queries</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>queries</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>permissions</name> <operator>&amp;</operator> <name>ACL_SELECT</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>query</name> <init>= <expr><call><name>DeparseTreeNode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>GenerateGrantStmtForRights</name><argument_list>(
										  <argument><expr><name>OBJECT_SEQUENCE</name></expr></argument>, <argument><expr><name>granteeOid</name></expr></argument>, <argument><expr><name>sequenceOid</name></expr></argument>,
										  <argument><expr><literal type="string">"SELECT"</literal></expr></argument>, <argument><expr><name>grants</name> <operator>&amp;</operator> <name>ACL_SELECT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>queries</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>queries</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>permissions</name> <operator>&amp;</operator> <name>ACL_UPDATE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>query</name> <init>= <expr><call><name>DeparseTreeNode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>GenerateGrantStmtForRights</name><argument_list>(
										  <argument><expr><name>OBJECT_SEQUENCE</name></expr></argument>, <argument><expr><name>granteeOid</name></expr></argument>, <argument><expr><name>sequenceOid</name></expr></argument>,
										  <argument><expr><literal type="string">"UPDATE"</literal></expr></argument>, <argument><expr><name>grants</name> <operator>&amp;</operator> <name>ACL_UPDATE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>queries</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>queries</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>queries</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>queries</name></expr></argument>, <argument><expr><literal type="string">"RESET ROLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>queries</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SetLocalEnableMetadataSync sets the enable_metadata_sync locally
 */</comment>
<function><type><name>void</name></type>
<name>SetLocalEnableMetadataSync</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>set_config_option</name><argument_list>(<argument><expr><literal type="string">"citus.enable_metadata_sync"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>state</name> <operator>==</operator> <name>true</name></expr> ?</condition><then> <expr><literal type="string">"on"</literal></expr> </then><else>: <expr><literal type="string">"off"</literal></expr></else></ternary></expr></argument>,
					  <argument><expr><operator>(</operator><ternary><condition><expr><call><name>superuser</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name>PGC_SUSET</name></expr> </then><else>: <expr><name>PGC_USERSET</name></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><name>PGC_S_SESSION</name></expr></argument>,
					  <argument><expr><name>GUC_ACTION_LOCAL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>GenerateSetRoleQuery</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>roleOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>buf</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"SET ROLE %s"</literal></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>GetUserNameFromId</name><argument_list>(<argument><expr><name>roleOid</name></expr></argument>,
																			<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>buf</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * TruncateTriggerCreateCommand creates a SQL query calling worker_create_truncate_trigger
 * function, which creates the truncate trigger on the worker.
 */</comment>
<function><type><name>TableDDLCommand</name> <modifier>*</modifier></type>
<name>TruncateTriggerCreateCommand</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>triggerCreateCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tableName</name> <init>= <expr><call><name>generate_qualified_relation_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>triggerCreateCommand</name></expr></argument>,
					 <argument><expr><literal type="string">"SELECT worker_create_truncate_trigger(%s)"</literal></expr></argument>,
					 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>tableName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>TableDDLCommand</name> <modifier>*</modifier></type><name>triggerDDLCommand</name> <init>= <expr><call><name>makeTableDDLCommandString</name><argument_list>(
		<argument><expr><name><name>triggerCreateCommand</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>triggerDDLCommand</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SchemaOwnerName returns the name of the owner of the specified schema.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>SchemaOwnerName</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>objectId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>ownerId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name> <init>= <expr><call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>NAMESPACEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>objectId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>ownerId</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_namespace</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>nspowner</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>ownerId</name> <operator>=</operator> <call><name>GetUserId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ownerName</name> <init>= <expr><call><name>GetUserNameFromId</name><argument_list>(<argument><expr><name>ownerId</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ownerName</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * HasMetadataWorkers returns true if any of the workers in the cluster has its
 * hasmetadata column set to true, which happens when start_metadata_sync_to_node
 * command is run.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>HasMetadataWorkers</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>workerNodeList</name> <init>= <expr><call><name>ActiveReadableNonCoordinatorNodeList</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>workerNode</argument>, <argument>workerNodeList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>workerNode</name><operator>-&gt;</operator><name>hasMetadata</name></name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateInterTableRelationshipOfRelationOnWorkers create inter table relationship
 * for the the given relation id on each worker node with metadata.
 */</comment>
<function><type><name>void</name></type>
<name>CreateInterTableRelationshipOfRelationOnWorkers</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* if the table is owned by an extension we don't create */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>tableOwnedByExtension</name> <init>= <expr><call><name>IsTableOwnedByExtension</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>tableOwnedByExtension</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commandList</name> <init>=
		<expr><call><name>InterTableRelationshipOfRelationCommandList</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* prevent recursive propagation */</comment>
	<expr_stmt><expr><call><name>SendCommandToWorkersWithMetadata</name><argument_list>(<argument><expr><name>DISABLE_DDL_PROPAGATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>command</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>command</argument>, <argument>commandList</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SendCommandToWorkersWithMetadata</name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * InterTableRelationshipOfRelationCommandList returns the command list to create
 * inter table relationship for the given relation.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>InterTableRelationshipOfRelationCommandList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* commands to create foreign key constraints */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commandList</name> <init>= <expr><call><name>GetReferencingForeignConstaintCommands</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* commands to create partitioning hierarchy */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PartitionTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>alterTableAttachPartitionCommands</name> <init>=
			<expr><call><name>GenerateAlterTableAttachPartitionCommand</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>commandList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>commandList</name></expr></argument>, <argument><expr><name>alterTableAttachPartitionCommands</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>commandList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateShellTableOnWorkers creates the shell table on each worker node with metadata
 * including sequence dependency and truncate triggers.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CreateShellTableOnWorkers</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IsTableOwnedByExtension</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commandList</name> <init>= <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>DISABLE_DDL_PROPAGATION</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>IncludeSequenceDefaults</name></type> <name>includeSequenceDefaults</name> <init>= <expr><name>WORKER_NEXTVAL_SEQUENCE_DEFAULTS</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>creatingShellTableOnRemoteNode</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>tableDDLCommands</name> <init>= <expr><call><name>GetFullTableCreationCommands</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>,
														  <argument><expr><name>includeSequenceDefaults</name></expr></argument>,
														  <argument><expr><name>creatingShellTableOnRemoteNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>TableDDLCommand</name> <modifier>*</modifier></type><name>tableDDLCommand</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>tableDDLCommand</argument>, <argument>tableDDLCommands</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>CitusIsA</name><argument_list>(<argument><expr><name>tableDDLCommand</name></expr></argument>, <argument><expr><name>TableDDLCommand</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>commandList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>commandList</name></expr></argument>, <argument><expr><call><name>GetTableDDLCommand</name><argument_list>(<argument><expr><name>tableDDLCommand</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>command</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>command</argument>, <argument>commandList</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SendCommandToWorkersWithMetadata</name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * CreateTableMetadataOnWorkers creates the list of commands needed to create the
 * metadata of the given distributed table and sends these commands to all metadata
 * workers i.e. workers with hasmetadata=true. Before sending the commands, in order
 * to prevent recursive propagation, DDL propagation on workers are disabled with a
 * `SET citus.enable_ddl_propagation TO off;` command.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CreateTableMetadataOnWorkers</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commandList</name> <init>= <expr><call><name>CitusTableMetadataCreateCommandList</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* prevent recursive propagation */</comment>
	<expr_stmt><expr><call><name>SendCommandToWorkersWithMetadata</name><argument_list>(<argument><expr><name>DISABLE_DDL_PROPAGATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* send the commands one by one */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>command</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>command</argument>, <argument>commandList</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SendCommandToWorkersWithMetadata</name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * DetachPartitionCommandList returns list of DETACH commands to detach partitions
 * of all distributed tables. This function is used for detaching partitions in MX
 * workers before DROPping distributed partitioned tables in them. Thus, we are
 * disabling DDL propagation to the beginning of the commands (we are also enabling
 * DDL propagation at the end of command list to swtich back to original state). As
 * an extra step, if there are no partitions to DETACH, this function simply returns
 * empty list to not disable/enable DDL propagation for nothing.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>DetachPartitionCommandList</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>detachPartitionCommandList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>distributedTableList</name> <init>= <expr><call><name>CitusTableList</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* we iterate over all distributed partitioned tables and DETACH their partitions */</comment>
	<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>cacheEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>cacheEntry</argument>, <argument>distributedTableList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PartitionedTable</name><argument_list>(<argument><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>partitionList</name> <init>= <expr><call><name>PartitionList</name><argument_list>(<argument><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>detachCommands</name> <init>=
			<expr><call><name>GenerateDetachPartitionCommandRelationIdList</name><argument_list>(<argument><expr><name>partitionList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>detachPartitionCommandList</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>detachPartitionCommandList</name></expr></argument>,
												 <argument><expr><name>detachCommands</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>detachPartitionCommandList</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>detachPartitionCommandList</name> <operator>=</operator>
		<call><name>lcons</name><argument_list>(<argument><expr><name>DISABLE_DDL_PROPAGATION</name></expr></argument>, <argument><expr><name>detachPartitionCommandList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We probably do not need this but as an extra precaution, we are enabling
	 * DDL propagation to switch back to original state.
	 */</comment>
	<expr_stmt><expr><name>detachPartitionCommandList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>detachPartitionCommandList</name></expr></argument>,
										 <argument><expr><name>ENABLE_DDL_PROPAGATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>detachPartitionCommandList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SyncNodeMetadataToNodesOptional tries recreating the metadata
 * snapshot in the metadata workers that are out of sync.
 * Returns the result of synchronization.
 *
 * This function must be called within coordinated transaction
 * since updates on the pg_dist_node metadata must be rollbacked if anything
 * goes wrong.
 */</comment>
<function><type><specifier>static</specifier> <name>NodeMetadataSyncResult</name></type>
<name>SyncNodeMetadataToNodesOptional</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NodeMetadataSyncResult</name></type> <name>result</name> <init>= <expr><name>NODE_METADATA_SYNC_SUCCESS</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCoordinator</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NODE_METADATA_SYNC_SUCCESS</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Request a RowExclusiveLock so we don't run concurrently with other
	 * functions updating pg_dist_node, but allow concurrency with functions
	 * which are just reading from pg_dist_node.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ConditionalLockRelationOid</name><argument_list>(<argument><expr><call><name>DistNodeRelationId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NODE_METADATA_SYNC_FAILED_LOCK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>syncedWorkerList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>workerList</name> <init>= <expr><call><name>ActivePrimaryNonCoordinatorNodeList</name><argument_list>(<argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>workerNode</argument>, <argument>workerList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>workerNode</name><operator>-&gt;</operator><name>hasMetadata</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>workerNode</name><operator>-&gt;</operator><name>metadataSynced</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type> <name>raiseInterrupts</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SyncNodeMetadataSnapshotToNode</name><argument_list>(<argument><expr><name>workerNode</name></expr></argument>, <argument><expr><name>raiseInterrupts</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failed to sync metadata to %s:%d"</literal></expr></argument>,
										 <argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>,
										 <argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NODE_METADATA_SYNC_FAILED_SYNC</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* we add successfully synced nodes to set metadatasynced column later */</comment>
				<expr_stmt><expr><name>syncedWorkerList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>syncedWorkerList</name></expr></argument>, <argument><expr><name>workerNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<macro><name>foreach_ptr</name><argument_list>(<argument>workerNode</argument>, <argument>syncedWorkerList</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SetWorkerColumnOptional</name><argument_list>(<argument><expr><name>workerNode</name></expr></argument>, <argument><expr><name>Anum_pg_dist_node_metadatasynced</name></expr></argument>,
								<argument><expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* we fetch the same node again to check if it's synced or not */</comment>
		<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>nodeUpdated</name> <init>= <expr><call><name>FindWorkerNode</name><argument_list>(<argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>,
												 <argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>nodeUpdated</name><operator>-&gt;</operator><name>metadataSynced</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* set the result to FAILED to trigger the sync again */</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NODE_METADATA_SYNC_FAILED_SYNC</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SyncNodeMetadataToNodes recreates the node metadata snapshot in all the
 * metadata workers.
 *
 * This function runs within a coordinated transaction since updates on
 * the pg_dist_node metadata must be rollbacked if anything
 * goes wrong.
 */</comment>
<function><type><name>void</name></type>
<name>SyncNodeMetadataToNodes</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>EnsureCoordinator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Request a RowExclusiveLock so we don't run concurrently with other
	 * functions updating pg_dist_node, but allow concurrency with functions
	 * which are just reading from pg_dist_node.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ConditionalLockRelationOid</name><argument_list>(<argument><expr><call><name>DistNodeRelationId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot sync metadata because a concurrent "</literal>
							   <literal type="string">"metadata syncing operation is in progress"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>workerList</name> <init>= <expr><call><name>ActivePrimaryNonCoordinatorNodeList</name><argument_list>(<argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>workerNode</argument>, <argument>workerList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>workerNode</name><operator>-&gt;</operator><name>hasMetadata</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>SetWorkerColumnLocalOnly</name><argument_list>(<argument><expr><name>workerNode</name></expr></argument>, <argument><expr><name>Anum_pg_dist_node_metadatasynced</name></expr></argument>,
									 <argument><expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<decl_stmt><decl><type><name>bool</name></type> <name>raiseOnError</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>SyncNodeMetadataSnapshotToNode</name><argument_list>(<argument><expr><name>workerNode</name></expr></argument>, <argument><expr><name>raiseOnError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * SyncNodeMetadataToNodesMain is the main function for syncing node metadata to
 * MX nodes. It retries until success and then exits.
 */</comment>
<function><type><name>void</name></type>
<name>SyncNodeMetadataToNodesMain</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>main_arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>databaseOid</name> <init>= <expr><call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name>main_arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* extension owner is passed via bgw_extra */</comment>
	<decl_stmt><decl><type><name>Oid</name></type> <name>extensionOwner</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>memcpy_s</name><argument_list>(<argument><expr><operator>&amp;</operator><name>extensionOwner</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>extensionOwner</name></expr></argument>)</argument_list></sizeof></expr></argument>,
			 <argument><expr><name><name>MyBgworkerEntry</name><operator>-&gt;</operator><name>bgw_extra</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>, <argument><expr><name>MetadataSyncSigTermHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGALRM</name></expr></argument>, <argument><expr><name>MetadataSyncSigAlrmHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BackgroundWorkerUnblockSignals</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* connect to database, after that we can actually access catalogs */</comment>
	<expr_stmt><expr><call><name>BackgroundWorkerInitializeConnectionByOid</name><argument_list>(<argument><expr><name>databaseOid</name></expr></argument>, <argument><expr><name>extensionOwner</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* make worker recognizable in pg_stat_activity */</comment>
	<expr_stmt><expr><call><name>pgstat_report_appname</name><argument_list>(<argument><expr><name>METADATA_SYNC_APP_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>syncedAllNodes</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><operator>!</operator><name>syncedAllNodes</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>InvalidateMetadataSystemCache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Some functions in ruleutils.c, which we use to get the DDL for
		 * metadata propagation, require an active snapshot.
		 */</comment>
		<expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>LockCitusExtension</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not lock the citus extension, "</literal>
									<literal type="string">"skipping metadata sync"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>CitusHasBeenLoaded</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>UseCoordinatedTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<decl_stmt><decl><type><name>NodeMetadataSyncResult</name></type> <name>result</name> <init>= <expr><call><name>SyncNodeMetadataToNodesOptional</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>syncedAllNodes</name> <operator>=</operator> <operator>(</operator><name>result</name> <operator>==</operator> <name>NODE_METADATA_SYNC_SUCCESS</name><operator>)</operator></expr>;</expr_stmt>

			<comment type="block">/* we use LISTEN/NOTIFY to wait for metadata syncing in tests */</comment>
			<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>NODE_METADATA_SYNC_FAILED_LOCK</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Async_Notify</name><argument_list>(<argument><expr><name>METADATA_SYNC_CHANNEL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ProcessCompletedNotifies</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>syncedAllNodes</name></expr>)</condition>
		<block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If backend is cancelled (e.g. bacause of distributed deadlock),
		 * CHECK_FOR_INTERRUPTS() will raise a cancellation error which will
		 * result in exit(1).
		 */</comment>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * SIGTERM is used for when maintenance daemon tries to clean-up
		 * metadata sync daemons spawned by terminated maintenance daemons.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>got_SIGTERM</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * SIGALRM is used for testing purposes and it simulates an error in metadata
		 * sync daemon.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>got_SIGALRM</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Error in metadata sync daemon"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><name>MetadataSyncRetryInterval</name> <operator>*</operator> <literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>


<comment type="block">/*
 * MetadataSyncSigTermHandler set a flag to request termination of metadata
 * sync daemon.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>MetadataSyncSigTermHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>got_SIGTERM</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>MyProc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>procLatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * MetadataSyncSigAlrmHandler set a flag to request error at metadata
 * sync daemon. This is used for testing purposes.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>MetadataSyncSigAlrmHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>got_SIGALRM</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>MyProc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>procLatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * SpawnSyncNodeMetadataToNodes starts a background worker which runs node metadata
 * sync. On success it returns workers' handle. Otherwise it returns NULL.
 */</comment>
<function><type><name>BackgroundWorkerHandle</name> <modifier>*</modifier></type>
<name>SpawnSyncNodeMetadataToNodes</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>database</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>extensionOwner</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BackgroundWorker</name></type> <name>worker</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BackgroundWorkerHandle</name> <modifier>*</modifier></type><name>handle</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Configure a worker. */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>worker</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>worker</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SafeSnprintf</name><argument_list>(<argument><expr><name><name>worker</name><operator>.</operator><name>bgw_name</name></name></expr></argument>, <argument><expr><name>BGW_MAXLEN</name></expr></argument>,
				 <argument><expr><literal type="string">"Citus Metadata Sync: %u/%u"</literal></expr></argument>,
				 <argument><expr><name>database</name></expr></argument>, <argument><expr><name>extensionOwner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>worker</name><operator>.</operator><name>bgw_flags</name></name> <operator>=</operator>
		<name>BGWORKER_SHMEM_ACCESS</name> <operator>|</operator> <name>BGWORKER_BACKEND_DATABASE_CONNECTION</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>worker</name><operator>.</operator><name>bgw_start_time</name></name> <operator>=</operator> <name>BgWorkerStart_ConsistentState</name></expr>;</expr_stmt>

	<comment type="block">/* don't restart, we manage restarts from maintenance daemon */</comment>
	<expr_stmt><expr><name><name>worker</name><operator>.</operator><name>bgw_restart_time</name></name> <operator>=</operator> <name>BGW_NEVER_RESTART</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strcpy_s</name><argument_list>(<argument><expr><name><name>worker</name><operator>.</operator><name>bgw_library_name</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>worker</name><operator>.</operator><name>bgw_library_name</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"citus"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strcpy_s</name><argument_list>(<argument><expr><name><name>worker</name><operator>.</operator><name>bgw_function_name</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>worker</name><operator>.</operator><name>bgw_library_name</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,
			 <argument><expr><literal type="string">"SyncNodeMetadataToNodesMain"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>worker</name><operator>.</operator><name>bgw_main_arg</name></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy_s</name><argument_list>(<argument><expr><name><name>worker</name><operator>.</operator><name>bgw_extra</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>worker</name><operator>.</operator><name>bgw_extra</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>extensionOwner</name></expr></argument>,
			 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>worker</name><operator>.</operator><name>bgw_notify_pid</name></name> <operator>=</operator> <name>MyProcPid</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RegisterDynamicBackgroundWorker</name><argument_list>(<argument><expr><operator>&amp;</operator><name>worker</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>handle</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>pid_t</name></type> <name>pid</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>WaitForBackgroundWorkerStartup</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>handle</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SignalMetadataSyncDaemon signals metadata sync daemons belonging to
 * the given database.
 */</comment>
<function><type><name>void</name></type>
<name>SignalMetadataSyncDaemon</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>database</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sig</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>backendCount</name> <init>= <expr><call><name>pgstat_fetch_stat_numbackends</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>backend</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>backend</name> <operator>&lt;=</operator> <name>backendCount</name></expr>;</condition> <incr><expr><name>backend</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>LocalPgBackendStatus</name> <modifier>*</modifier></type><name>localBeEntry</name> <init>= <expr><call><name>pgstat_fetch_stat_local_beentry</name><argument_list>(<argument><expr><name>backend</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>localBeEntry</name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>PgBackendStatus</name> <modifier>*</modifier></type><name>beStatus</name> <init>= <expr><operator>&amp;</operator><name><name>localBeEntry</name><operator>-&gt;</operator><name>backendStatus</name></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>beStatus</name><operator>-&gt;</operator><name>st_databaseid</name></name> <operator>==</operator> <name>database</name> <operator>&amp;&amp;</operator>
			<call><name>strncmp</name><argument_list>(<argument><expr><name><name>beStatus</name><operator>-&gt;</operator><name>st_appname</name></name></expr></argument>, <argument><expr><name>METADATA_SYNC_APP_NAME</name></expr></argument>, <argument><expr><name>BGW_MAXLEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>kill</name><argument_list>(<argument><expr><name><name>beStatus</name><operator>-&gt;</operator><name>st_procpid</name></name></expr></argument>, <argument><expr><name>sig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>


<comment type="block">/*
 * ShouldInitiateMetadataSync returns if metadata sync daemon should be initiated.
 * It sets lockFailure to true if pg_dist_node lock couldn't be acquired for the
 * check.
 */</comment>
<function><type><name>bool</name></type>
<name>ShouldInitiateMetadataSync</name><parameter_list>(<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>lockFailure</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCoordinator</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>lockFailure</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>distNodeOid</name> <init>= <expr><call><name>DistNodeRelationId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ConditionalLockRelationOid</name><argument_list>(<argument><expr><name>distNodeOid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>lockFailure</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>shouldSyncMetadata</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>workerList</name> <init>= <expr><call><name>ActivePrimaryNonCoordinatorNodeList</name><argument_list>(<argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>workerNode</argument>, <argument>workerList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>workerNode</name><operator>-&gt;</operator><name>hasMetadata</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>workerNode</name><operator>-&gt;</operator><name>metadataSynced</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>shouldSyncMetadata</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>UnlockRelationOid</name><argument_list>(<argument><expr><name>distNodeOid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>lockFailure</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<return>return <expr><name>shouldSyncMetadata</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * citus_internal_add_partition_metadata is an internal UDF to
 * add a row to pg_dist_partition.
 */</comment>
<function><type><name>Datum</name></type>
<name>citus_internal_add_partition_metadata</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_ENSURE_ARGNOTNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"relation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_ENSURE_ARGNOTNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"distribution method"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>distributionMethod</name> <init>= <expr><call><name>PG_GETARG_CHAR</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_ENSURE_ARGNOTNULL</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"Colocation ID"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>colocationId</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_ENSURE_ARGNOTNULL</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"replication model"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>replicationModel</name> <init>= <expr><call><name>PG_GETARG_CHAR</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>distributionColumnText</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>distributionColumnString</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>distributionColumnVar</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* this flag is only valid for citus local tables, so set it to false */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>autoConverted</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* only owner of the table (or superuser) is allowed to add the Citus metadata */</comment>
	<expr_stmt><expr><call><name>EnsureTableOwner</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* we want to serialize all the metadata changes to this table */</comment>
	<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>distributionColumnText</name> <operator>=</operator> <call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>distributionColumnString</name> <operator>=</operator> <call><name>text_to_cstring</name><argument_list>(<argument><expr><name>distributionColumnText</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>distributionColumnVar</name> <operator>=</operator>
			<call><name>BuildDistributionKeyFromColumnName</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>distributionColumnString</name></expr></argument>,
											   <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>distributionColumnVar</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ShouldSkipMetadataChecks</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* this UDF is not allowed allowed for executing as a separate command */</comment>
		<expr_stmt><expr><call><name>EnsureCoordinatorInitiatedOperation</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>distributionMethod</name> <operator>==</operator> <name>DISTRIBUTE_BY_NONE</name> <operator>&amp;&amp;</operator> <name>distributionColumnVar</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Reference or local tables cannot have "</literal>
								   <literal type="string">"distribution columns"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>distributionMethod</name> <operator>!=</operator> <name>DISTRIBUTE_BY_NONE</name> <operator>&amp;&amp;</operator>
				 <name>distributionColumnVar</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Distribution column cannot be NULL for "</literal>
								   <literal type="string">"relation \"%s\""</literal></expr></argument>, <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Even if the table owner is a malicious user and the partition
		 * metadata is not sane, the user can only affect its own tables.
		 * Given that the user is owner of the table, we should allow.
		 */</comment>
		<expr_stmt><expr><call><name>EnsurePartitionMetadataIsSane</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>distributionMethod</name></expr></argument>, <argument><expr><name>colocationId</name></expr></argument>,
									  <argument><expr><name>replicationModel</name></expr></argument>, <argument><expr><name>distributionColumnVar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>InsertIntoPgDistPartition</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>distributionMethod</name></expr></argument>, <argument><expr><name>distributionColumnVar</name></expr></argument>,
							  <argument><expr><name>colocationId</name></expr></argument>, <argument><expr><name>replicationModel</name></expr></argument>, <argument><expr><name>autoConverted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * EnsurePartitionMetadataIsSane ensures that the input values are safe
 * for inserting into pg_dist_partition metadata.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>EnsurePartitionMetadataIsSane</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>distributionMethod</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>colocationId</name></decl></parameter>,
							  <parameter><decl><type><name>char</name></type> <name>replicationModel</name></decl></parameter>, <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>distributionColumnVar</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>distributionMethod</name> <operator>==</operator> <name>DISTRIBUTE_BY_HASH</name> <operator>||</operator>
		  <name>distributionMethod</name> <operator>==</operator> <name>DISTRIBUTE_BY_NONE</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Metadata syncing is only allowed for hash, reference "</literal>
							   <literal type="string">"and local tables:%c"</literal></expr></argument>, <argument><expr><name>distributionMethod</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>colocationId</name> <operator>&lt;</operator> <name>INVALID_COLOCATION_ID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Metadata syncing is only allowed for valid "</literal>
							   <literal type="string">"colocation id values."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>colocationId</name> <operator>!=</operator> <name>INVALID_COLOCATION_ID</name> <operator>&amp;&amp;</operator>
			 <name>distributionMethod</name> <operator>==</operator> <name>DISTRIBUTE_BY_HASH</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>targetColocatedTableList</name> <init>=
			<expr><call><name>ColocationGroupTableList</name><argument_list>(<argument><expr><name>colocationId</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If we have any colocated hash tables, ensure if they share the
		 * same distribution key properties.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>targetColocatedTableList</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type> <name>targetRelationId</name> <init>= <expr><call><name>linitial_oid</name><argument_list>(<argument><expr><name>targetColocatedTableList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>EnsureColumnTypeEquality</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>targetRelationId</name></expr></argument>, <argument><expr><name>distributionColumnVar</name></expr></argument>,
									 <argument><expr><call><name>DistPartitionKeyOrError</name><argument_list>(<argument><expr><name>targetRelationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>


	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>replicationModel</name> <operator>==</operator> <name>REPLICATION_MODEL_2PC</name> <operator>||</operator>
		  <name>replicationModel</name> <operator>==</operator> <name>REPLICATION_MODEL_STREAMING</name> <operator>||</operator>
		  <name>replicationModel</name> <operator>==</operator> <name>REPLICATION_MODEL_COORDINATOR</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Metadata syncing is only allowed for "</literal>
							   <literal type="string">"known replication models."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>distributionMethod</name> <operator>==</operator> <name>DISTRIBUTE_BY_NONE</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><operator>(</operator><name>replicationModel</name> <operator>==</operator> <name>REPLICATION_MODEL_STREAMING</name> <operator>||</operator>
		  <name>replicationModel</name> <operator>==</operator> <name>REPLICATION_MODEL_2PC</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Local or references tables can only have '%c' or '%c' "</literal>
							   <literal type="string">"as the replication model."</literal></expr></argument>,
							   <argument><expr><name>REPLICATION_MODEL_STREAMING</name></expr></argument>, <argument><expr><name>REPLICATION_MODEL_2PC</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * citus_internal_delete_partition_metadata is an internal UDF to
 * delete a row in pg_dist_partition.
 */</comment>
<function><type><name>Datum</name></type>
<name>citus_internal_delete_partition_metadata</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_ENSURE_ARGNOTNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"relation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* only owner of the table (or superuser) is allowed to add the Citus metadata */</comment>
	<expr_stmt><expr><call><name>EnsureTableOwner</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* we want to serialize all the metadata changes to this table */</comment>
	<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ShouldSkipMetadataChecks</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>EnsureCoordinatorInitiatedOperation</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>DeletePartitionRow</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * citus_internal_add_shard_metadata is an internal UDF to
 * add a row to pg_dist_shard.
 */</comment>
<function><type><name>Datum</name></type>
<name>citus_internal_add_shard_metadata</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_ENSURE_ARGNOTNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"relation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_ENSURE_ARGNOTNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"shard id"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>shardId</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_ENSURE_ARGNOTNULL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"storage type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>storageType</name> <init>= <expr><call><name>PG_GETARG_CHAR</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>shardMinValue</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>shardMinValue</name> <operator>=</operator> <call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>shardMaxValue</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>shardMaxValue</name> <operator>=</operator> <call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* only owner of the table (or superuser) is allowed to add the Citus metadata */</comment>
	<expr_stmt><expr><call><name>EnsureTableOwner</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* we want to serialize all the metadata changes to this table */</comment>
	<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ShouldSkipMetadataChecks</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* this UDF is not allowed allowed for executing as a separate command */</comment>
		<expr_stmt><expr><call><name>EnsureCoordinatorInitiatedOperation</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Even if the table owner is a malicious user and the shard metadata is
		 * not sane, the user can only affect its own tables. Given that the
		 * user is owner of the table, we should allow.
		 */</comment>
		<expr_stmt><expr><call><name>EnsureShardMetadataIsSane</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>, <argument><expr><name>storageType</name></expr></argument>, <argument><expr><name>shardMinValue</name></expr></argument>,
								  <argument><expr><name>shardMaxValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>InsertShardRow</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>, <argument><expr><name>storageType</name></expr></argument>, <argument><expr><name>shardMinValue</name></expr></argument>, <argument><expr><name>shardMaxValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * EnsureCoordinatorInitiatedOperation is a helper function which ensures that
 * the execution is initiated by the coordinator on a worker node.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>EnsureCoordinatorInitiatedOperation</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We are restricting the operation to only MX workers with the local group id
	 * check. The other two checks are to ensure that the operation is initiated
	 * by the coordinator.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>IsCitusInternalBackend</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>IsRebalancerInternalBackend</name><argument_list>()</argument_list></call><operator>)</operator> <operator>||</operator>
		<operator>!</operator><call><name>MyBackendIsInDisributedTransaction</name><argument_list>()</argument_list></call> <operator>||</operator>
		<call><name>GetLocalGroupId</name><argument_list>()</argument_list></call> <operator>==</operator> <name>COORDINATOR_GROUP_ID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"This is an internal Citus function can only be "</literal>
							   <literal type="string">"used in a distributed transaction"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * EnsureShardMetadataIsSane ensures that the input values are safe
 * for inserting into pg_dist_shard metadata.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>EnsureShardMetadataIsSane</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>shardId</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>storageType</name></decl></parameter>,
						  <parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>shardMinValue</name></decl></parameter>, <parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>shardMaxValue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>shardId</name> <operator>&lt;=</operator> <name>INVALID_SHARD_ID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Invalid shard id: %ld"</literal></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>storageType</name> <operator>==</operator> <name>SHARD_STORAGE_TABLE</name> <operator>||</operator>
		  <name>storageType</name> <operator>==</operator> <name>SHARD_STORAGE_FOREIGN</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Invalid shard storage type: %c"</literal></expr></argument>, <argument><expr><name>storageType</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>char</name></type> <name>partitionMethod</name> <init>= <expr><call><name>PartitionMethodViaCatalog</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>partitionMethod</name> <operator>==</operator> <name>DISTRIBUTE_BY_INVALID</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* connection from the coordinator operating on a shard */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"The relation \"%s\" does not have a valid "</literal>
							   <literal type="string">"entry in pg_dist_partition."</literal></expr></argument>,
							   <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><operator>(</operator><name>partitionMethod</name> <operator>==</operator> <name>DISTRIBUTE_BY_HASH</name> <operator>||</operator>
			   <name>partitionMethod</name> <operator>==</operator> <name>DISTRIBUTE_BY_NONE</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* connection from the coordinator operating on a shard */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Metadata syncing is only allowed for hash, "</literal>
							   <literal type="string">"reference and local tables: %c"</literal></expr></argument>, <argument><expr><name>partitionMethod</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>distShardTupleList</name> <init>= <expr><call><name>LookupDistShardTuples</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>partitionMethod</name> <operator>==</operator> <name>DISTRIBUTE_BY_NONE</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>shardMinValue</name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <name>shardMaxValue</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Shards of reference or local table \"%s\" should "</literal>
								   <literal type="string">"have NULL shard ranges"</literal></expr></argument>, <argument><expr><name>relationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>distShardTupleList</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s\" has already at least one shard, "</literal>
								   <literal type="string">"adding more is not allowed"</literal></expr></argument>, <argument><expr><name>relationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>partitionMethod</name> <operator>==</operator> <name>DISTRIBUTE_BY_HASH</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>shardMinValue</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>shardMaxValue</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Shards of has distributed table  \"%s\" "</literal>
								   <literal type="string">"cannot have NULL shard ranges"</literal></expr></argument>, <argument><expr><name>relationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>shardMinValueString</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><name>shardMinValue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>shardMaxValueString</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><name>shardMaxValue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* pg_strtoint32 does the syntax and out of bound checks for us */</comment>
		<decl_stmt><decl><type><name>int32</name></type> <name>shardMinValueInt</name> <init>= <expr><call><name>pg_strtoint32</name><argument_list>(<argument><expr><name>shardMinValueString</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type> <name>shardMaxValueInt</name> <init>= <expr><call><name>pg_strtoint32</name><argument_list>(<argument><expr><name>shardMaxValueString</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>shardMinValueInt</name> <operator>&gt;</operator> <name>shardMaxValueInt</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"shardMinValue=%d is greater than "</literal>
								   <literal type="string">"shardMaxValue=%d for table \"%s\", which is "</literal>
								   <literal type="string">"not allowed"</literal></expr></argument>, <argument><expr><name>shardMinValueInt</name></expr></argument>,
								   <argument><expr><name>shardMaxValueInt</name></expr></argument>, <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * We are only dealing with hash distributed tables, that's why we
		 * can hard code data type and typemod.
		 */</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>intervalTypeId</name> <init>= <expr><name>INT4OID</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>intervalTypeMod</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Relation</name></type> <name>distShardRelation</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><call><name>DistShardRelationId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleDesc</name></type> <name>distShardTupleDesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>distShardRelation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>shardIntervalCompareFunction</name> <init>=
			<expr><call><name>GetFunctionInfo</name><argument_list>(<argument><expr><name>intervalTypeId</name></expr></argument>, <argument><expr><name>BTREE_AM_OID</name></expr></argument>, <argument><expr><name>BTORDER_PROC</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>HeapTuple</name></type> <name>shardTuple</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>shardTuple</argument>, <argument>distShardTupleList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>=
				<expr><call><name>TupleToShardInterval</name><argument_list>(<argument><expr><name>shardTuple</name></expr></argument>, <argument><expr><name>distShardTupleDesc</name></expr></argument>,
									 <argument><expr><name>intervalTypeId</name></expr></argument>, <argument><expr><name>intervalTypeMod</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>Datum</name></type> <name>firstMin</name> <init>= <expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>shardMinValueInt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type> <name>firstMax</name> <init>= <expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>shardMaxValueInt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type> <name>secondMin</name> <init>= <expr><name><name>shardInterval</name><operator>-&gt;</operator><name>minValue</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type> <name>secondMax</name> <init>= <expr><name><name>shardInterval</name><operator>-&gt;</operator><name>maxValue</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type> <name>collationId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * This is an unexpected case as we are reading the metadata, which has
			 * already been verified for being not NULL. Still, lets be extra
			 * cautious to avoid any crashes.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>shardInterval</name><operator>-&gt;</operator><name>minValueExists</name></name> <operator>||</operator> <operator>!</operator><name><name>shardInterval</name><operator>-&gt;</operator><name>maxValueExists</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Shards of has distributed table  \"%s\" "</literal>
									   <literal type="string">"cannot have NULL shard ranges"</literal></expr></argument>, <argument><expr><name>relationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>ShardIntervalsOverlapWithParams</name><argument_list>(<argument><expr><name>firstMin</name></expr></argument>, <argument><expr><name>firstMax</name></expr></argument>, <argument><expr><name>secondMin</name></expr></argument>, <argument><expr><name>secondMax</name></expr></argument>,
												<argument><expr><name>shardIntervalCompareFunction</name></expr></argument>,
												<argument><expr><name>collationId</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Shard intervals overlap for table \"%s\": "</literal>
									   <literal type="string">"%ld and %ld"</literal></expr></argument>, <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><name>shardId</name></expr></argument>, <argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>distShardRelation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * citus_internal_add_placement_metadata is an internal UDF to
 * add a row to pg_dist_placement.
 */</comment>
<function><type><name>Datum</name></type>
<name>citus_internal_add_placement_metadata</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int64</name></type> <name>shardId</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>shardState</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>shardLength</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>groupId</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>placementId</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>missingOk</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>LookupShardRelationFromCatalog</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* only owner of the table is allowed to modify the metadata */</comment>
	<expr_stmt><expr><call><name>EnsureTableOwner</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* we want to serialize all the metadata changes to this table */</comment>
	<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ShouldSkipMetadataChecks</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* this UDF is not allowed allowed for executing as a separate command */</comment>
		<expr_stmt><expr><call><name>EnsureCoordinatorInitiatedOperation</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Even if the table owner is a malicious user, as long as the shard placements
		 * fit into basic requirements of Citus metadata, the user can only affect its
		 * own tables. Given that the user is owner of the table, we should allow.
		 */</comment>
		<expr_stmt><expr><call><name>EnsureShardPlacementMetadataIsSane</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>, <argument><expr><name>placementId</name></expr></argument>, <argument><expr><name>shardState</name></expr></argument>,
										   <argument><expr><name>shardLength</name></expr></argument>, <argument><expr><name>groupId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>InsertShardPlacementRow</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>, <argument><expr><name>placementId</name></expr></argument>, <argument><expr><name>shardState</name></expr></argument>, <argument><expr><name>shardLength</name></expr></argument>, <argument><expr><name>groupId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * EnsureShardPlacementMetadataIsSane ensures if the input parameters for
 * the shard placement metadata is sane.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>EnsureShardPlacementMetadataIsSane</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>shardId</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>placementId</name></decl></parameter>,
								   <parameter><decl><type><name>int32</name></type> <name>shardState</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>shardLength</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>groupId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* we have just read the metadata, so we are sure that the shard exists */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ShardExists</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>placementId</name> <operator>&lt;=</operator> <name>INVALID_PLACEMENT_ID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Shard placement has invalid placement id "</literal>
							   <literal type="string">"(%ld) for shard(%ld)"</literal></expr></argument>, <argument><expr><name>placementId</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>shardState</name> <operator>!=</operator> <name>SHARD_STATE_ACTIVE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Invalid shard state: %d"</literal></expr></argument>, <argument><expr><name>shardState</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>nodeIsInMetadata</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>=
		<expr><call><name>PrimaryNodeForGroup</name><argument_list>(<argument><expr><name>groupId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nodeIsInMetadata</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>workerNode</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Node with group id %d for shard placement "</literal>
							   <literal type="string">"%ld does not exist"</literal></expr></argument>, <argument><expr><name>groupId</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ShouldSkipMetadataChecks returns true if the current user is allowed to
 * make any
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ShouldSkipMetadataChecks</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>EnableManualMetadataChangesForUser</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * EnableManualMetadataChangesForUser is a GUC which
		 * can be changed by a super user. We use this GUC as
		 * a safety belt in case the current metadata checks are
		 * too restrictive and the operator can allow users to skip
		 * the checks.
		 */</comment>

		<comment type="block">/*
		 * Make sure that the user exists, and print it to prevent any
		 * optimization skipping the get_role_oid call.
		 */</comment>
		<decl_stmt><decl><type><name>bool</name></type> <name>missingOK</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>allowedUserId</name> <init>= <expr><call><name>get_role_oid</name><argument_list>(<argument><expr><name>EnableManualMetadataChangesForUser</name></expr></argument>, <argument><expr><name>missingOK</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>allowedUserId</name> <operator>==</operator> <call><name>GetUserId</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * citus_internal_update_placement_metadata is an internal UDF to
 * update a row in pg_dist_placement.
 */</comment>
<function><type><name>Datum</name></type>
<name>citus_internal_update_placement_metadata</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int64</name></type> <name>shardId</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>sourceGroupId</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>targetGroupId</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>placement</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ShouldSkipMetadataChecks</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* this UDF is not allowed allowed for executing as a separate command */</comment>
		<expr_stmt><expr><call><name>EnsureCoordinatorInitiatedOperation</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ShardExists</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Shard id does not exists: %ld"</literal></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>bool</name></type> <name>missingOk</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>EnsureShardOwner</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * This function ensures that the source group exists hence we
		 * call it from this code-block.
		 */</comment>
		<expr_stmt><expr><name>placement</name> <operator>=</operator> <call><name>ActiveShardPlacementOnGroup</name><argument_list>(<argument><expr><name>sourceGroupId</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>bool</name></type> <name>nodeIsInMetadata</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>=
			<expr><call><name>PrimaryNodeForGroup</name><argument_list>(<argument><expr><name>targetGroupId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nodeIsInMetadata</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>workerNode</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Node with group id %d for shard placement "</literal>
								   <literal type="string">"%ld does not exist"</literal></expr></argument>, <argument><expr><name>targetGroupId</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>placement</name> <operator>=</operator> <call><name>ActiveShardPlacementOnGroup</name><argument_list>(<argument><expr><name>sourceGroupId</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Updating pg_dist_placement ensures that the node with targetGroupId
	 * exists and this is the only placement on that group.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>placement</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Active placement for shard %ld is not "</literal>
							   <literal type="string">"found on group:%d"</literal></expr></argument>, <argument><expr><name>shardId</name></expr></argument>, <argument><expr><name>targetGroupId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>UpdatePlacementGroupId</name><argument_list>(<argument><expr><name><name>placement</name><operator>-&gt;</operator><name>placementId</name></name></expr></argument>, <argument><expr><name>targetGroupId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * citus_internal_delete_shard_metadata is an internal UDF to
 * delete a row in pg_dist_shard and corresponding placement rows
 * from pg_dist_shard_placement.
 */</comment>
<function><type><name>Datum</name></type>
<name>citus_internal_delete_shard_metadata</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int64</name></type> <name>shardId</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ShouldSkipMetadataChecks</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* this UDF is not allowed allowed for executing as a separate command */</comment>
		<expr_stmt><expr><call><name>EnsureCoordinatorInitiatedOperation</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ShardExists</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Shard id does not exists: %ld"</literal></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>bool</name></type> <name>missingOk</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>EnsureShardOwner</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardPlacementList</name> <init>= <expr><call><name>ShardPlacementListIncludingOrphanedPlacements</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>shardPlacement</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>shardPlacement</argument>, <argument>shardPlacementList</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>DeleteShardPlacementRow</name><argument_list>(<argument><expr><name><name>shardPlacement</name><operator>-&gt;</operator><name>placementId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>DeleteShardRow</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * citus_internal_update_relation_colocation is an internal UDF to
 * delete a row in pg_dist_shard and corresponding placement rows
 * from pg_dist_shard_placement.
 */</comment>
<function><type><name>Datum</name></type>
<name>citus_internal_update_relation_colocation</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>targetColocationId</name> <init>= <expr><call><name>PG_GETARG_UINT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>EnsureTableOwner</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ShouldSkipMetadataChecks</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* this UDF is not allowed allowed for executing as a separate command */</comment>
		<expr_stmt><expr><call><name>EnsureCoordinatorInitiatedOperation</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* ensure that the table is in pg_dist_partition */</comment>
		<decl_stmt><decl><type><name>char</name></type> <name>partitionMethod</name> <init>= <expr><call><name>PartitionMethodViaCatalog</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>partitionMethod</name> <operator>==</operator> <name>DISTRIBUTE_BY_INVALID</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* connection from the coordinator operating on a shard */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"The relation \"%s\" does not have a valid "</literal>
								   <literal type="string">"entry in pg_dist_partition."</literal></expr></argument>,
								   <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>partitionMethod</name> <operator>!=</operator> <name>DISTRIBUTE_BY_HASH</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* connection from the coordinator operating on a shard */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Updating colocation ids are only allowed for hash "</literal>
								   <literal type="string">"distributed tables: %c"</literal></expr></argument>, <argument><expr><name>partitionMethod</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>targetColocatedTableList</name> <init>=
			<expr><call><name>ColocationGroupTableList</name><argument_list>(<argument><expr><name>targetColocationId</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>targetColocatedTableList</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* the table is colocated with none, so nothing to check */</comment>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type> <name>targetRelationId</name> <init>= <expr><call><name>linitial_oid</name><argument_list>(<argument><expr><name>targetColocatedTableList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>ErrorIfShardPlacementsNotColocated</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>targetRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CheckReplicationModel</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>targetRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CheckDistributionColumnType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>targetRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>localOnly</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>UpdateRelationColocationGroup</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>targetColocationId</name></expr></argument>, <argument><expr><name>localOnly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * citus_internal_add_colocation_metadata is an internal UDF to
 * add a row to pg_dist_colocation.
 */</comment>
<function><type><name>Datum</name></type>
<name>citus_internal_add_colocation_metadata</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EnsureSuperUser</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>colocationId</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>shardCount</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>replicationFactor</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distributionColumnType</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distributionColumnCollation</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ShouldSkipMetadataChecks</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* this UDF is not allowed allowed for executing as a separate command */</comment>
		<expr_stmt><expr><call><name>EnsureCoordinatorInitiatedOperation</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>InsertColocationGroupLocally</name><argument_list>(<argument><expr><name>colocationId</name></expr></argument>, <argument><expr><name>shardCount</name></expr></argument>, <argument><expr><name>replicationFactor</name></expr></argument>,
								 <argument><expr><name>distributionColumnType</name></expr></argument>, <argument><expr><name>distributionColumnCollation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * citus_internal_delete_colocation_metadata is an internal UDF to
 * delte row from pg_dist_colocation.
 */</comment>
<function><type><name>Datum</name></type>
<name>citus_internal_delete_colocation_metadata</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EnsureSuperUser</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>colocationId</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ShouldSkipMetadataChecks</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* this UDF is not allowed allowed for executing as a separate command */</comment>
		<expr_stmt><expr><call><name>EnsureCoordinatorInitiatedOperation</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>DeleteColocationGroupLocally</name><argument_list>(<argument><expr><name>colocationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * SyncNewColocationGroup synchronizes a new pg_dist_colocation entry to a worker.
 */</comment>
<function><type><name>void</name></type>
<name>SyncNewColocationGroupToNodes</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>colocationId</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>shardCount</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>replicationFactor</name></decl></parameter>,
							  <parameter><decl><type><name>Oid</name></type> <name>distributionColumnType</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>distributionColumnCollation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>command</name> <init>= <expr><call><name>ColocationGroupCreateCommand</name><argument_list>(<argument><expr><name>colocationId</name></expr></argument>, <argument><expr><name>shardCount</name></expr></argument>,
												 <argument><expr><name>replicationFactor</name></expr></argument>,
												 <argument><expr><name>distributionColumnType</name></expr></argument>,
												 <argument><expr><name>distributionColumnCollation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We require superuser for all pg_dist_colocation operations because we have
	 * no reasonable way of restricting access.
	 */</comment>
	<expr_stmt><expr><call><name>SendCommandToWorkersWithMetadataViaSuperUser</name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ColocationGroupCreateCommand returns a command for creating a colocation group.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>ColocationGroupCreateCommand</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>colocationId</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>shardCount</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>replicationFactor</name></decl></parameter>,
							 <parameter><decl><type><name>Oid</name></type> <name>distributionColumnType</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>distributionColumnCollation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>insertColocationCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>insertColocationCommand</name></expr></argument>,
					 <argument><expr><literal type="string">"SELECT pg_catalog.citus_internal_add_colocation_metadata("</literal>
					 <literal type="string">"%d, %d, %d, %s, %s)"</literal></expr></argument>,
					 <argument><expr><name>colocationId</name></expr></argument>,
					 <argument><expr><name>shardCount</name></expr></argument>,
					 <argument><expr><name>replicationFactor</name></expr></argument>,
					 <argument><expr><call><name>RemoteTypeIdExpression</name><argument_list>(<argument><expr><name>distributionColumnType</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>RemoteCollationIdExpression</name><argument_list>(<argument><expr><name>distributionColumnCollation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>insertColocationCommand</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RemoteTypeIdExpression returns an expression in text form that can
 * be used to obtain the OID of a type on a different node when included
 * in a query string.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>RemoteTypeIdExpression</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typeId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* by default, use 0 (InvalidOid) */</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>expression</name> <init>= <expr><literal type="string">"0"</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* we also have pg_dist_colocation entries for reference tables */</comment>
	<if_stmt><if>if <condition>(<expr><name>typeId</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>typeName</name> <init>= <expr><call><name>format_type_extended</name><argument_list>(<argument><expr><name>typeId</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
											  <argument><expr><name>FORMAT_TYPE_FORCE_QUALIFY</name> <operator>|</operator>
											  <name>FORMAT_TYPE_ALLOW_INVALID</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* format_type_extended returns ??? in case of an unknown type */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>, <argument><expr><literal type="string">"???"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>StringInfo</name></type> <name>regtypeExpression</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>regtypeExpression</name></expr></argument>,
							 <argument><expr><literal type="string">"%s::regtype"</literal></expr></argument>,
							 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>expression</name> <operator>=</operator> <name><name>regtypeExpression</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>expression</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RemoteCollationIdExpression returns an expression in text form that can
 * be used to obtain the OID of a collation on a different node when included
 * in a query string.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>RemoteCollationIdExpression</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>colocationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* by default, use 0 (InvalidOid) */</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>expression</name> <init>= <expr><literal type="string">"0"</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>colocationId</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type> <name>collationIdDatum</name> <init>= <expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>colocationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type> <name>collationTuple</name> <init>= <expr><call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>COLLOID</name></expr></argument>, <argument><expr><name>collationIdDatum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>collationTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Form_pg_collation</name></type> <name>collationform</name> <init>=
				<expr><operator>(</operator><name>Form_pg_collation</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>collationTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>collationName</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>collationform</name><operator>-&gt;</operator><name>collname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>collationSchemaName</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>collationform</name><operator>-&gt;</operator><name>collnamespace</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>qualifiedCollationName</name> <init>= <expr><call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name>collationSchemaName</name></expr></argument>,
																	  <argument><expr><name>collationName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>StringInfo</name></type> <name>regcollationExpression</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>regcollationExpression</name></expr></argument>,
							 <argument><expr><literal type="string">"%s::regcollation"</literal></expr></argument>,
							 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>qualifiedCollationName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>expression</name> <operator>=</operator> <name><name>regcollationExpression</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>collationTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>expression</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SyncDeleteColocationGroupToNodes deletes a pg_dist_colocation record from workers.
 */</comment>
<function><type><name>void</name></type>
<name>SyncDeleteColocationGroupToNodes</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>colocationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>command</name> <init>= <expr><call><name>ColocationGroupDeleteCommand</name><argument_list>(<argument><expr><name>colocationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We require superuser for all pg_dist_colocation operations because we have
	 * no reasonable way of restricting access.
	 */</comment>
	<expr_stmt><expr><call><name>SendCommandToWorkersWithMetadataViaSuperUser</name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ColocationGroupDeleteCommand returns a command for deleting a colocation group.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>ColocationGroupDeleteCommand</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>colocationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>deleteColocationCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>deleteColocationCommand</name></expr></argument>,
					 <argument><expr><literal type="string">"SELECT pg_catalog.citus_internal_delete_colocation_metadata(%d)"</literal></expr></argument>,
					 <argument><expr><name>colocationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>deleteColocationCommand</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColocationGroupCreateCommandList returns the full list of commands for syncing
 * pg_dist_colocation.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>ColocationGroupCreateCommandList</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>hasColocations</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>StringInfo</name></type> <name>colocationGroupCreateCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>colocationGroupCreateCommand</name></expr></argument>,
					 <argument><expr><literal type="string">"WITH colocation_group_data (colocationid, shardcount, "</literal>
					 <literal type="string">"replicationfactor, distributioncolumntype, "</literal>
					 <literal type="string">"distributioncolumncollationname, "</literal>
					 <literal type="string">"distributioncolumncollationschema)  AS (VALUES "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>pgDistColocation</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><call><name>DistColocationRelationId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>colocationIdIndexRel</name> <init>= <expr><call><name>index_open</name><argument_list>(<argument><expr><call><name>DistColocationIndexId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * It is not strictly necessary to read the tuples in order.
	 * However, it is useful to get consistent behavior, both for regression
	 * tests and also in production systems.
	 */</comment>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scanDescriptor</name> <init>=
		<expr><call><name>systable_beginscan_ordered</name><argument_list>(<argument><expr><name>pgDistColocation</name></expr></argument>, <argument><expr><name>colocationIdIndexRel</name></expr></argument>,
								   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>colocationTuple</name> <init>= <expr><call><name>systable_getnext_ordered</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>,
														 <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>colocationTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>hasColocations</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>colocationGroupCreateCommand</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>hasColocations</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>Form_pg_dist_colocation</name></type> <name>colocationForm</name> <init>=
			<expr><operator>(</operator><name>Form_pg_dist_colocation</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>colocationTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>colocationGroupCreateCommand</name></expr></argument>,
						 <argument><expr><literal type="string">"(%d, %d, %d, %s, "</literal></expr></argument>,
						 <argument><expr><name><name>colocationForm</name><operator>-&gt;</operator><name>colocationid</name></name></expr></argument>,
						 <argument><expr><name><name>colocationForm</name><operator>-&gt;</operator><name>shardcount</name></name></expr></argument>,
						 <argument><expr><name><name>colocationForm</name><operator>-&gt;</operator><name>replicationfactor</name></name></expr></argument>,
						 <argument><expr><call><name>RemoteTypeIdExpression</name><argument_list>(<argument><expr><name><name>colocationForm</name><operator>-&gt;</operator><name>distributioncolumntype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * For collations, include the names in the VALUES section and then
		 * join with pg_collation.
		 */</comment>
		<decl_stmt><decl><type><name>Oid</name></type> <name>distributionColumCollation</name> <init>= <expr><name><name>colocationForm</name><operator>-&gt;</operator><name>distributioncolumncollation</name></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>distributionColumCollation</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type> <name>collationIdDatum</name> <init>= <expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>distributionColumCollation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>HeapTuple</name></type> <name>collationTuple</name> <init>= <expr><call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>COLLOID</name></expr></argument>, <argument><expr><name>collationIdDatum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>collationTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Form_pg_collation</name></type> <name>collationform</name> <init>=
					<expr><operator>(</operator><name>Form_pg_collation</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>collationTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>collationName</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>collationform</name><operator>-&gt;</operator><name>collname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>collationSchemaName</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(
					<argument><expr><name><name>collationform</name><operator>-&gt;</operator><name>collnamespace</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>colocationGroupCreateCommand</name></expr></argument>,
								 <argument><expr><literal type="string">"%s, %s)"</literal></expr></argument>,
								 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>collationName</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>collationSchemaName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>collationTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>colocationGroupCreateCommand</name></expr></argument>,
								 <argument><expr><literal type="string">"NULL, NULL)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>colocationGroupCreateCommand</name></expr></argument>,
							 <argument><expr><literal type="string">"NULL, NULL)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>colocationTuple</name> <operator>=</operator> <call><name>systable_getnext_ordered</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan_ordered</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>colocationIdIndexRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pgDistColocation</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>hasColocations</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>colocationGroupCreateCommand</name></expr></argument>,
					 <argument><expr><literal type="string">") SELECT pg_catalog.citus_internal_add_colocation_metadata("</literal>
					 <literal type="string">"colocationid, shardcount, replicationfactor, "</literal>
					 <literal type="string">"distributioncolumntype, coalesce(c.oid, 0)) "</literal>
					 <literal type="string">"FROM colocation_group_data d LEFT JOIN pg_collation c "</literal>
					 <literal type="string">"ON (d.distributioncolumncollationname = c.collname "</literal>
					 <literal type="string">"AND d.distributioncolumncollationschema::regnamespace"</literal>
					 <literal type="string">" = c.collnamespace)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name><name>colocationGroupCreateCommand</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
