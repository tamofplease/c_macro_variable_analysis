<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/builded_projects/citus/src/backend/distributed/metadata/node_metadata.c"><comment type="block">/*
 * node_metadata.c
 *	  Functions that operate on pg_dist_node
 *
 * Copyright (c) Citus Data, Inc.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/plancache.h"</cpp:file></cpp:include>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/skey.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/skey.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tupmacs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/sequence.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_acquire_lock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_safe_lib.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/colocation_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands/utility_hook.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/connection_management.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/maintenanced.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/coordinator_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata/distobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_sync.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_join_order.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_router_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_dist_node.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/reference_table_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/remote_commands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/resource_lock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shardinterval_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_partitioning_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shared_connection_stats.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/string_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata/pg_dist_object.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/transaction_recovery.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/version_compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_manager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_transaction.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/stringinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/postmaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relcache.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INVALID_GROUP_ID</name></cpp:macro> <cpp:value>-1</cpp:value></cpp:define>

<comment type="block">/* default group size */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>GroupSize</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* config variable managed via guc.c */</comment>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>CurrentCluster</name> <init>= <expr><literal type="string">"default"</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* did current transaction modify pg_dist_node? */</comment>
<decl_stmt><decl><type><name>bool</name></type> <name>TransactionModifiedNodeMetadata</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>EnableMetadataSync</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<typedef>typedef <type><struct>struct <name>NodeMetadata</name>
<block>{
	<decl_stmt><decl><type><name>int32</name></type> <name>groupId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nodeRack</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>hasMetadata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>metadataSynced</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isActive</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>nodeRole</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>shouldHaveShards</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nodeCluster</name></decl>;</decl_stmt>
}</block></struct></type> <name>NodeMetadata</name>;</typedef>

<comment type="block">/* local function forward declarations */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RemoveNodeFromCluster</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>nodeName</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>nodePort</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ErrorIfNodeContainsNonRemovablePlacements</name><parameter_list>(<parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>PlacementHasActivePlacementOnAnotherGroup</name><parameter_list>(<parameter><decl><type><name>GroupShardPlacement</name>
													  <modifier>*</modifier></type><name>sourcePlacement</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>AddNodeMetadata</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>nodeName</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>nodePort</name></decl></parameter>, <parameter><decl><type><name>NodeMetadata</name>
						   <modifier>*</modifier></type><name>nodeMetadata</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nodeAlreadyExists</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>WorkerNode</name> <modifier>*</modifier></type> <name>SetNodeState</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>nodeName</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>nodePort</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isActive</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HeapTuple</name></type> <name>GetNodeTuple</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nodeName</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>nodePort</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int32</name></type> <name>GetNextGroupId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>GetNextNodeId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>InsertPlaceholderCoordinatorRecord</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>InsertNodeRow</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nodeid</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>nodename</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>nodeport</name></decl></parameter>, <parameter><decl><type><name>NodeMetadata</name>
						  <modifier>*</modifier></type><name>nodeMetadata</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DeleteNodeRow</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>nodename</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>nodeport</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SyncDistributedObjectsToNodeList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>workerNodeList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>UpdateLocalGroupIdOnNode</name><parameter_list>(<parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SyncPgDistTableMetadataToNodeList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>nodeList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>InterTableRelationshipCommandList</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>BlockDistributedQueriesOnMetadataNodes</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>WorkerNode</name> <modifier>*</modifier></type> <name>TupleToWorkerNode</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>heapTuple</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>PropagateNodeWideObjectsCommandList</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>WorkerNode</name> <modifier>*</modifier></type> <name>ModifiableWorkerNode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nodeName</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>nodePort</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>NodeIsLocal</name><parameter_list>(<parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>worker</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SetLockTimeoutLocally</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>lock_cooldown</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>UpdateNodeLocation</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>nodeId</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>newNodeName</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>newNodePort</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>UnsetMetadataSyncedForAllWorkers</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>GetMetadataSyncCommandToSetNodeColumn</name><parameter_list>(<parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name></decl></parameter>,
													<parameter><decl><type><name>int</name></type> <name>columnIndex</name></decl></parameter>,
													<parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>NodeHasmetadataUpdateCommand</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>nodeId</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>hasMetadata</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>NodeMetadataSyncedUpdateCommand</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>nodeId</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>metadataSynced</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ErrorIfCoordinatorMetadataSetFalse</name><parameter_list>(<parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>,
											   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>field</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>WorkerNode</name> <modifier>*</modifier></type> <name>SetShouldHaveShards</name><parameter_list>(<parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>shouldHaveShards</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RemoveOldShardPlacementForNodeGroup</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>groupId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>FindCoordinatorNodeId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>WorkerNode</name> <modifier>*</modifier></type> <name>FindNodeAnyClusterByNodeId</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>nodeId</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* declarations for dynamic loading */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>citus_set_coordinator_host</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>citus_add_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>master_add_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>citus_add_inactive_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>master_add_inactive_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>citus_add_secondary_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>master_add_secondary_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>citus_set_node_property</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>master_set_node_property</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>citus_remove_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>master_remove_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>citus_disable_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>master_disable_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>citus_activate_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>master_activate_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>citus_update_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>master_update_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>get_shard_id_for_distribution_column</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>citus_nodename_for_nodeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>citus_nodeport_for_nodeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>citus_coordinator_nodeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>citus_is_coordinator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<comment type="block">/*
 * DefaultNodeMetadata creates a NodeMetadata struct with the fields set to
 * sane defaults, e.g. nodeRack = WORKER_DEFAULT_RACK.
 */</comment>
<function><type><specifier>static</specifier> <name>NodeMetadata</name></type>
<name>DefaultNodeMetadata</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NodeMetadata</name></type> <name>nodeMetadata</name></decl>;</decl_stmt>

	<comment type="block">/* ensure uninitialized padding doesn't escape the function */</comment>
	<expr_stmt><expr><call><name>memset_struct_0</name><argument_list>(<argument><expr><name>nodeMetadata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nodeMetadata</name><operator>.</operator><name>nodeRack</name></name> <operator>=</operator> <name>WORKER_DEFAULT_RACK</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nodeMetadata</name><operator>.</operator><name>shouldHaveShards</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nodeMetadata</name><operator>.</operator><name>groupId</name></name> <operator>=</operator> <name>INVALID_GROUP_ID</name></expr>;</expr_stmt>

	<return>return <expr><name>nodeMetadata</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * citus_set_coordinator_host configures the hostname and port through which worker
 * nodes can connect to the coordinator.
 */</comment>
<function><type><name>Datum</name></type>
<name>citus_set_coordinator_host</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>nodeName</name> <init>= <expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>nodePort</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nodeNameString</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><name>nodeName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>NodeMetadata</name></type> <name>nodeMetadata</name> <init>= <expr><call><name>DefaultNodeMetadata</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>nodeMetadata</name><operator>.</operator><name>groupId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nodeMetadata</name><operator>.</operator><name>shouldHaveShards</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nodeMetadata</name><operator>.</operator><name>nodeRole</name></name> <operator>=</operator> <call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Name</name></type> <name>nodeClusterName</name> <init>= <expr><call><name>PG_GETARG_NAME</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>nodeMetadata</name><operator>.</operator><name>nodeCluster</name></name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>nodeClusterName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>isCoordinatorInMetadata</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>coordinatorNode</name> <init>= <expr><call><name>PrimaryNodeForGroup</name><argument_list>(<argument><expr><name>COORDINATOR_GROUP_ID</name></expr></argument>,
													  <argument><expr><operator>&amp;</operator><name>isCoordinatorInMetadata</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isCoordinatorInMetadata</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>nodeAlreadyExists</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* add the coordinator to pg_dist_node if it was not already added */</comment>
		<expr_stmt><expr><call><name>AddNodeMetadata</name><argument_list>(<argument><expr><name>nodeNameString</name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nodeMetadata</name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name>nodeAlreadyExists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* we just checked */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>nodeAlreadyExists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * since AddNodeMetadata takes an exclusive lock on pg_dist_node, we
		 * do not need to worry about concurrent changes (e.g. deletion) and
		 * can proceed to update immediately.
		 */</comment>

		<expr_stmt><expr><call><name>UpdateNodeLocation</name><argument_list>(<argument><expr><name><name>coordinatorNode</name><operator>-&gt;</operator><name>nodeId</name></name></expr></argument>, <argument><expr><name>nodeNameString</name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* clear cached plans that have the old host/port */</comment>
		<expr_stmt><expr><call><name>ResetPlanCache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>TransactionModifiedNodeMetadata</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * citus_add_node function adds a new node to the cluster and returns its id. It also
 * replicates all reference tables to the new node.
 */</comment>
<function><type><name>Datum</name></type>
<name>citus_add_node</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>nodeName</name> <init>= <expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>nodePort</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nodeNameString</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><name>nodeName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>NodeMetadata</name></type> <name>nodeMetadata</name> <init>= <expr><call><name>DefaultNodeMetadata</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>nodeAlreadyExists</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>nodeMetadata</name><operator>.</operator><name>groupId</name></name> <operator>=</operator> <call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * During tests this function is called before nodeRole and nodeCluster have been
	 * created.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PG_NARGS</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">3</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>nodeMetadata</name><operator>.</operator><name>nodeRole</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nodeMetadata</name><operator>.</operator><name>nodeCluster</name></name> <operator>=</operator> <literal type="string">"default"</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>Name</name></type> <name>nodeClusterName</name> <init>= <expr><call><name>PG_GETARG_NAME</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>nodeMetadata</name><operator>.</operator><name>nodeCluster</name></name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>nodeClusterName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>nodeMetadata</name><operator>.</operator><name>nodeRole</name></name> <operator>=</operator> <call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>nodeMetadata</name><operator>.</operator><name>groupId</name></name> <operator>==</operator> <name>COORDINATOR_GROUP_ID</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* by default, we add the coordinator without shards */</comment>
		<expr_stmt><expr><name><name>nodeMetadata</name><operator>.</operator><name>shouldHaveShards</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>nodeId</name> <init>= <expr><call><name>AddNodeMetadata</name><argument_list>(<argument><expr><name>nodeNameString</name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nodeMetadata</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>nodeAlreadyExists</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>TransactionModifiedNodeMetadata</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * After adding new node, if the node did not already exist, we will activate
	 * the node. This means we will replicate all reference tables to the new
	 * node.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>nodeAlreadyExists</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><call><name>FindWorkerNodeAnyCluster</name><argument_list>(<argument><expr><name>nodeNameString</name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If the worker is not marked as a coordinator, check that
		 * the node is not trying to add itself
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>workerNode</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<name><name>workerNode</name><operator>-&gt;</operator><name>groupId</name></name> <operator>!=</operator> <name>COORDINATOR_GROUP_ID</name> <operator>&amp;&amp;</operator>
			<name><name>workerNode</name><operator>-&gt;</operator><name>nodeRole</name></name> <operator>!=</operator> <call><name>SecondaryNodeRoleId</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>IsWorkerTheCurrentNode</name><argument_list>(<argument><expr><name>workerNode</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Node cannot add itself as a worker."</literal></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errhint</name><argument_list>(
								<argument><expr><literal type="string">"Add the node as a coordinator by using: "</literal>
								<literal type="string">"SELECT citus_set_coordinator_host('%s', %d);"</literal></expr></argument>,
								<argument><expr><name>nodeNameString</name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ActivateNode</name><argument_list>(<argument><expr><name>nodeNameString</name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><name>nodeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * master_add_node is a wrapper function for old UDF name.
 */</comment>
<function><type><name>Datum</name></type>
<name>master_add_node</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>citus_add_node</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * citus_add_inactive_node function adds a new node to the cluster as inactive node
 * and returns id of the newly added node. It does not replicate reference
 * tables to the new node, it only adds new node to the pg_dist_node table.
 */</comment>
<function><type><name>Datum</name></type>
<name>citus_add_inactive_node</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>nodeName</name> <init>= <expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>nodePort</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nodeNameString</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><name>nodeName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Name</name></type> <name>nodeClusterName</name> <init>= <expr><call><name>PG_GETARG_NAME</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>NodeMetadata</name></type> <name>nodeMetadata</name> <init>= <expr><call><name>DefaultNodeMetadata</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>nodeAlreadyExists</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>nodeMetadata</name><operator>.</operator><name>groupId</name></name> <operator>=</operator> <call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nodeMetadata</name><operator>.</operator><name>nodeRole</name></name> <operator>=</operator> <call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nodeMetadata</name><operator>.</operator><name>nodeCluster</name></name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>nodeClusterName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>nodeMetadata</name><operator>.</operator><name>groupId</name></name> <operator>==</operator> <name>COORDINATOR_GROUP_ID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"coordinator node cannot be added as inactive node"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>nodeId</name> <init>= <expr><call><name>AddNodeMetadata</name><argument_list>(<argument><expr><name>nodeNameString</name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nodeMetadata</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>nodeAlreadyExists</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>TransactionModifiedNodeMetadata</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><name>nodeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * master_add_inactive_node is a wrapper function for old UDF name.
 */</comment>
<function><type><name>Datum</name></type>
<name>master_add_inactive_node</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>citus_add_inactive_node</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * citus_add_secondary_node adds a new secondary node to the cluster. It accepts as
 * arguments the primary node it should share a group with.
 */</comment>
<function><type><name>Datum</name></type>
<name>citus_add_secondary_node</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>nodeName</name> <init>= <expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>nodePort</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nodeNameString</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><name>nodeName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>primaryName</name> <init>= <expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>primaryPort</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>primaryNameString</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><name>primaryName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Name</name></type> <name>nodeClusterName</name> <init>= <expr><call><name>PG_GETARG_NAME</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NodeMetadata</name></type> <name>nodeMetadata</name> <init>= <expr><call><name>DefaultNodeMetadata</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>nodeAlreadyExists</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>nodeMetadata</name><operator>.</operator><name>groupId</name></name> <operator>=</operator> <call><name>GroupForNode</name><argument_list>(<argument><expr><name>primaryNameString</name></expr></argument>, <argument><expr><name>primaryPort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nodeMetadata</name><operator>.</operator><name>nodeCluster</name></name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>nodeClusterName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nodeMetadata</name><operator>.</operator><name>nodeRole</name></name> <operator>=</operator> <call><name>SecondaryNodeRoleId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nodeMetadata</name><operator>.</operator><name>isActive</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>nodeId</name> <init>= <expr><call><name>AddNodeMetadata</name><argument_list>(<argument><expr><name>nodeNameString</name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nodeMetadata</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>nodeAlreadyExists</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>TransactionModifiedNodeMetadata</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><name>nodeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * master_add_secondary_node is a wrapper function for old UDF name.
 */</comment>
<function><type><name>Datum</name></type>
<name>master_add_secondary_node</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>citus_add_secondary_node</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * citus_remove_node function removes the provided node from the pg_dist_node table of
 * the master node and all nodes with metadata.
 * The call to the citus_remove_node should be done by the super user and the specified
 * node should not have any active placements.
 * This function also deletes all reference table placements belong to the given node from
 * pg_dist_placement, but it does not drop actual placement at the node. In the case of
 * re-adding the node, citus_add_node first drops and re-creates the reference tables.
 */</comment>
<function><type><name>Datum</name></type>
<name>citus_remove_node</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>nodeNameText</name> <init>= <expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>nodePort</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>RemoveNodeFromCluster</name><argument_list>(<argument><expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><name>nodeNameText</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>TransactionModifiedNodeMetadata</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * master_remove_node is a wrapper function for old UDF name.
 */</comment>
<function><type><name>Datum</name></type>
<name>master_remove_node</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>citus_remove_node</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * citus_disable_node function sets isactive value of the provided node as inactive at
 * coordinator and all nodes with metadata regardless of the node having an active shard
 * placement.
 *
 * The call to the citus_disable_node must be done by the super user.
 *
 * This function also deletes all reference table placements belong to the given node
 * from pg_dist_placement, but it does not drop actual placement at the node. In the case
 * of re-activating the node, citus_add_node first drops and re-creates the reference
 * tables.
 */</comment>
<function><type><name>Datum</name></type>
<name>citus_disable_node</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>nodeNameText</name> <init>= <expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>nodePort</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>synchronousDisableNode</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nodeName</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><name>nodeNameText</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><call><name>ModifiableWorkerNode</name><argument_list>(<argument><expr><name>nodeName</name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* there is no concept of invalid coordinator */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>isActive</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ErrorIfCoordinatorMetadataSetFalse</name><argument_list>(<argument><expr><name>workerNode</name></expr></argument>, <argument><expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>isActive</name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><literal type="string">"isactive"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>firstWorkerNode</name> <init>= <expr><call><name>GetFirstPrimaryWorkerNode</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>disablingFirstNode</name> <init>=
		<expr><operator>(</operator><name>firstWorkerNode</name> <operator>&amp;&amp;</operator> <name><name>firstWorkerNode</name><operator>-&gt;</operator><name>nodeId</name></name> <operator>==</operator> <name><name>workerNode</name><operator>-&gt;</operator><name>nodeId</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>disablingFirstNode</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>synchronousDisableNode</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We sync metadata async and optionally in the background worker,
		 * it would mean that some nodes might get the updates while other
		 * not. And, if the node metadata that is changing is the first
		 * worker node, the problem gets nasty. We serialize modifications
		 * to replicated tables by acquiring locks on the first worker node.
		 *
		 * If some nodes get the metadata changes and some do not, they'd be
		 * acquiring the locks on different nodes. Hence, having the
		 * possibility of diverged shard placements for the same shard.
		 *
		 * To prevent that, we currently do not allow disabling the first
		 * worker node unless it is explicitly opted synchronous.
		 */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"disabling the first worker node in the "</literal>
							   <literal type="string">"metadata is not allowed"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You can force disabling node, SELECT "</literal>
								<literal type="string">"citus_disable_node('%s', %d, "</literal>
								<literal type="string">"synchronous:=true);"</literal></expr></argument>, <argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>,
								<argument><expr><name>nodePort</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Citus uses the first worker node in the "</literal>
								  <literal type="string">"metadata for certain internal operations when "</literal>
								  <literal type="string">"replicated tables are modified. Synchronous mode "</literal>
								  <literal type="string">"ensures that all nodes have the same view of the "</literal>
								  <literal type="string">"first worker node, which is used for certain "</literal>
								  <literal type="string">"locking operations."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * First, locally mark the node as inactive. We'll later trigger background
	 * worker to sync the metadata changes to the relevant nodes.
	 */</comment>
	<expr_stmt><expr><name>workerNode</name> <operator>=</operator>
		<call><name>SetWorkerColumnLocalOnly</name><argument_list>(<argument><expr><name>workerNode</name></expr></argument>,
								 <argument><expr><name>Anum_pg_dist_node_isactive</name></expr></argument>,
								 <argument><expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>isActive</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>NodeIsPrimary</name><argument_list>(<argument><expr><name>workerNode</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We do not allow disabling nodes if it contains any
		 * primary placement that is the "only" active placement
		 * for any given shard.
		 */</comment>
		<expr_stmt><expr><call><name>ErrorIfNodeContainsNonRemovablePlacements</name><argument_list>(<argument><expr><name>workerNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>TransactionModifiedNodeMetadata</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>synchronousDisableNode</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The user might pick between sync vs async options.
		 *      - Pros for the sync option:
		 *          (a) the changes become visible on the cluster immediately
		 *          (b) even if the first worker node is disabled, there is no
		 *              risk of divergence of the placements of replicated shards
		 *      - Cons for the sync options:
		 *          (a) Does not work within 2PC transaction (e.g., BEGIN;
		 *              citus_disable_node(); PREPARE TRANSACTION ...);
		 *          (b) If there are multiple node failures (e.g., one another node
		 *              than the current node being disabled), the sync option would
		 *              fail because it'd try to sync the metadata changes to a node
		 *              that is not up and running.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>firstWorkerNode</name> <operator>&amp;&amp;</operator> <name><name>firstWorkerNode</name><operator>-&gt;</operator><name>nodeId</name></name> <operator>==</operator> <name><name>workerNode</name><operator>-&gt;</operator><name>nodeId</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We cannot let any modification query on a replicated table to run
			 * concurrently with citus_disable_node() on the first worker node. If
			 * we let that, some worker nodes might calculate FirstWorkerNode()
			 * different than others. See LockShardListResourcesOnFirstWorker()
			 * for the details.
			 */</comment>
			<expr_stmt><expr><call><name>BlockDistributedQueriesOnMetadataNodes</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>SyncNodeMetadataToNodes</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>UnsetMetadataSyncedForAllWorkers</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We have not propagated the node metadata changes yet, make sure that all the
		 * active nodes get the metadata updates. We defer this operation to the
		 * background worker to make it possible disabling nodes when multiple nodes
		 * are down.
		 *
		 * Note that the active placements reside on the active nodes. Hence, when
		 * Citus finds active placements, it filters out the placements that are on
		 * the disabled nodes. That's why, we don't have to change/sync placement
		 * metadata at this point. Instead, we defer that to citus_activate_node()
		 * where we expect all nodes up and running.
		 */</comment>

		<expr_stmt><expr><call><name>TriggerNodeMetadataSyncOnCommit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * BlockDistributedQueriesOnMetadataNodes blocks all the modification queries on
 * all nodes. Hence, should be used with caution.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>BlockDistributedQueriesOnMetadataNodes</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* first, block on the coordinator */</comment>
	<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><call><name>DistNodeRelationId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Note that we might re-design this lock to be more granular than
	 * pg_dist_node, scoping only for modifications on the replicated
	 * tables. However, we currently do not have any such mechanism and
	 * given that citus_disable_node() runs instantly, it seems acceptable
	 * to block reads (or modifications on non-replicated tables) for
	 * a while.
	 */</comment>

	<comment type="block">/* only superuser can disable node */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>superuser</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SendCommandToWorkersWithMetadata</name><argument_list>(
		<argument><expr><literal type="string">"LOCK TABLE pg_catalog.pg_dist_node IN EXCLUSIVE MODE;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * master_disable_node is a wrapper function for old UDF name.
 */</comment>
<function><type><name>Datum</name></type>
<name>master_disable_node</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>citus_disable_node</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * citus_set_node_property sets a property of the node
 */</comment>
<function><type><name>Datum</name></type>
<name>citus_set_node_property</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>nodeNameText</name> <init>= <expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>nodePort</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>propertyText</name> <init>= <expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>value</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><call><name>ModifiableWorkerNode</name><argument_list>(<argument><expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><name>nodeNameText</name></expr></argument>)</argument_list></call></expr></argument>,
												  <argument><expr><name>nodePort</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><name>propertyText</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"shouldhaveshards"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SetShouldHaveShards</name><argument_list>(<argument><expr><name>workerNode</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
							<argument><expr><literal type="string">"only the 'shouldhaveshards' property can be set using this function"</literal></expr></argument>
							)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>TransactionModifiedNodeMetadata</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * master_set_node_property is a wrapper function for old UDF name.
 */</comment>
<function><type><name>Datum</name></type>
<name>master_set_node_property</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>citus_set_node_property</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * InterTableRelationshipCommandList returns the command list to
 * set up the multiple integrations including
 *
 * (i) Foreign keys
 * (ii) Partionining hierarchy
 *
 * for each citus table.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>InterTableRelationshipCommandList</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>distributedTableList</name> <init>= <expr><call><name>CitusTableList</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>propagatedTableList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>multipleTableIntegrationCommandList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>cacheEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>cacheEntry</argument>, <argument>distributedTableList</argument>)</argument_list></macro>
	<block>{<block_content>
		<comment type="block">/*
		 * Skip foreign key and partition creation when we shouldn't need to sync
		 * tablem metadata or the Citus table is owned by an extension.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>ShouldSyncTableMetadata</name><argument_list>(<argument><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>IsTableOwnedByExtension</name><argument_list>(<argument><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>propagatedTableList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>propagatedTableList</name></expr></argument>, <argument><expr><name>cacheEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<macro><name>foreach_ptr</name><argument_list>(<argument>cacheEntry</argument>, <argument>propagatedTableList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>relationId</name></name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commandListForRelation</name> <init>=
			<expr><call><name>InterTableRelationshipOfRelationCommandList</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>multipleTableIntegrationCommandList</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(
			<argument><expr><name>multipleTableIntegrationCommandList</name></expr></argument>,
			<argument><expr><name>commandListForRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name>multipleTableIntegrationCommandList</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>DISABLE_DDL_PROPAGATION</name></expr></argument>,
												<argument><expr><name>multipleTableIntegrationCommandList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>multipleTableIntegrationCommandList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>multipleTableIntegrationCommandList</name></expr></argument>,
												  <argument><expr><name>ENABLE_DDL_PROPAGATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>multipleTableIntegrationCommandList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PgDistTableMetadataSyncCommandList returns the command list to sync the pg_dist_*
 * (except pg_dist_node) metadata. We call them as table metadata.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>PgDistTableMetadataSyncCommandList</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>distributedTableList</name> <init>= <expr><call><name>CitusTableList</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>propagatedTableList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>metadataSnapshotCommandList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* create the list of tables whose metadata will be created */</comment>
	<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>cacheEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>cacheEntry</argument>, <argument>distributedTableList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>ShouldSyncTableMetadata</name><argument_list>(<argument><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>propagatedTableList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>propagatedTableList</name></expr></argument>, <argument><expr><name>cacheEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* remove all dist table and object related metadata first */</comment>
	<expr_stmt><expr><name>metadataSnapshotCommandList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>metadataSnapshotCommandList</name></expr></argument>,
										  <argument><expr><name>DELETE_ALL_PARTITIONS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>metadataSnapshotCommandList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>metadataSnapshotCommandList</name></expr></argument>, <argument><expr><name>DELETE_ALL_SHARDS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>metadataSnapshotCommandList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>metadataSnapshotCommandList</name></expr></argument>,
										  <argument><expr><name>DELETE_ALL_PLACEMENTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>metadataSnapshotCommandList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>metadataSnapshotCommandList</name></expr></argument>,
										  <argument><expr><name>DELETE_ALL_DISTRIBUTED_OBJECTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>metadataSnapshotCommandList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>metadataSnapshotCommandList</name></expr></argument>,
										  <argument><expr><name>DELETE_ALL_COLOCATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* create pg_dist_partition, pg_dist_shard and pg_dist_placement entries */</comment>
	<macro><name>foreach_ptr</name><argument_list>(<argument>cacheEntry</argument>, <argument>propagatedTableList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>tableMetadataCreateCommandList</name> <init>=
			<expr><call><name>CitusTableMetadataCreateCommandList</name><argument_list>(<argument><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>metadataSnapshotCommandList</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>metadataSnapshotCommandList</name></expr></argument>,
												  <argument><expr><name>tableMetadataCreateCommandList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* commands to insert pg_dist_colocation entries */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>colocationGroupSyncCommandList</name> <init>= <expr><call><name>ColocationGroupCreateCommandList</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>metadataSnapshotCommandList</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>metadataSnapshotCommandList</name></expr></argument>,
											  <argument><expr><name>colocationGroupSyncCommandList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>distributedObjectSyncCommandList</name> <init>= <expr><call><name>DistributedObjectMetadataSyncCommandList</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>metadataSnapshotCommandList</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>metadataSnapshotCommandList</name></expr></argument>,
											  <argument><expr><name>distributedObjectSyncCommandList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>metadataSnapshotCommandList</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>DISABLE_DDL_PROPAGATION</name></expr></argument>,
										<argument><expr><name>metadataSnapshotCommandList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>metadataSnapshotCommandList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>metadataSnapshotCommandList</name></expr></argument>,
										  <argument><expr><name>ENABLE_DDL_PROPAGATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>metadataSnapshotCommandList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PropagateNodeWideObjectsCommandList is called during node activation to
 * propagate any object that should be propagated for every node. These are
 * generally not linked to any distributed object but change system wide behaviour.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>PropagateNodeWideObjectsCommandList</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<comment type="block">/* collect all commands */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>ddlCommands</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>EnableAlterRoleSetPropagation</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Get commands for database and postgres wide settings. Since these settings are not
		 * linked to any role that can be distributed we need to distribute them seperately
		 */</comment>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>alterRoleSetCommands</name> <init>= <expr><call><name>GenerateAlterRoleSetCommandForRole</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>ddlCommands</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>ddlCommands</name></expr></argument>, <argument><expr><name>alterRoleSetCommands</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>ddlCommands</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* if there are command wrap them in enable_ddl_propagation off */</comment>
		<expr_stmt><expr><name>ddlCommands</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>DISABLE_DDL_PROPAGATION</name></expr></argument>, <argument><expr><name>ddlCommands</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ddlCommands</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>ddlCommands</name></expr></argument>, <argument><expr><name>ENABLE_DDL_PROPAGATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>ddlCommands</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SyncDistributedObjectsCommandList returns commands to sync object dependencies
 * to the given worker node. To be idempotent, it first drops the ones required to be
 * dropped.
 *
 * Object dependencies include:
 *
 * - All dependencies (e.g., types, schemas, sequences)
 * - All shell distributed tables
 * - Inter relation between those shell tables
 * - Node wide objects
 *
 * We also update the local group id here, as handling sequence dependencies
 * requires it.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>SyncDistributedObjectsCommandList</name><parameter_list>(<parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commandList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Propagate node wide objects. It includes only roles for now.
	 */</comment>
	<expr_stmt><expr><name>commandList</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>commandList</name></expr></argument>, <argument><expr><call><name>PropagateNodeWideObjectsCommandList</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Detach partitions, break dependencies between sequences and table then
	 * remove shell tables first.
	 */</comment>
	<expr_stmt><expr><name>commandList</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>commandList</name></expr></argument>, <argument><expr><call><name>DetachPartitionCommandList</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>commandList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>commandList</name></expr></argument>, <argument><expr><name>BREAK_CITUS_TABLE_SEQUENCE_DEPENDENCY_COMMAND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>commandList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>commandList</name></expr></argument>, <argument><expr><name>REMOVE_ALL_SHELL_TABLES_COMMAND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Replicate all objects of the pg_dist_object to the remote node.
	 */</comment>
	<expr_stmt><expr><name>commandList</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>commandList</name></expr></argument>, <argument><expr><call><name>ReplicateAllObjectsToNodeCommandList</name><argument_list>(
								  <argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>, <argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * After creating each table, handle the inter table relationship between
	 * those tables.
	 */</comment>
	<expr_stmt><expr><name>commandList</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>commandList</name></expr></argument>, <argument><expr><call><name>InterTableRelationshipCommandList</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>commandList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SyncDistributedObjectsToNodeList sync the distributed objects to the node. It includes
 * - All dependencies (e.g., types, schemas, sequences)
 * - All shell distributed table
 * - Inter relation between those shell tables
 *
 * Note that we do not create the distributed dependencies on the coordinator
 * since all the dependencies should be present in the coordinator already.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SyncDistributedObjectsToNodeList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>workerNodeList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>workerNodesToSync</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>workerNode</argument>, <argument>workerNodeList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>NodeIsCoordinator</name><argument_list>(<argument><expr><name>workerNode</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* coordinator has all the objects */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NodeIsPrimary</name><argument_list>(<argument><expr><name>workerNode</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* secondary nodes gets the objects from their primaries via replication */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>workerNodesToSync</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>workerNodesToSync</name></expr></argument>, <argument><expr><name>workerNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>workerNodesToSync</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>EnsureSequentialModeMetadataOperations</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ShouldPropagate</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commandList</name> <init>= <expr><call><name>SyncDistributedObjectsCommandList</name><argument_list>(<argument><expr><name>workerNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* send commands to new workers, the current user should be a superuser */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>superuser</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SendMetadataCommandListToWorkerListInCoordinatedTransaction</name><argument_list>(
		<argument><expr><name>workerNodesToSync</name></expr></argument>,
		<argument><expr><call><name>CurrentUserName</name><argument_list>()</argument_list></call></expr></argument>,
		<argument><expr><name>commandList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * UpdateLocalGroupIdOnNode updates local group id on node.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>UpdateLocalGroupIdOnNode</name><parameter_list>(<parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>NodeIsPrimary</name><argument_list>(<argument><expr><name>workerNode</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>NodeIsCoordinator</name><argument_list>(<argument><expr><name>workerNode</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commandList</name> <init>= <expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>LocalGroupIdUpdateCommand</name><argument_list>(<argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* send commands to new workers, the current user should be a superuser */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>superuser</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SendMetadataCommandListToWorkerListInCoordinatedTransaction</name><argument_list>(
			<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>workerNode</name></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><call><name>CurrentUserName</name><argument_list>()</argument_list></call></expr></argument>,
			<argument><expr><name>commandList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * SyncPgDistTableMetadataToNodeList syncs the pg_dist_partition, pg_dist_shard
 * pg_dist_placement and pg_dist_object metadata entries.
 *
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SyncPgDistTableMetadataToNodeList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>nodeList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* send commands to new workers, the current user should be a superuser */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>superuser</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>nodesWithMetadata</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>workerNode</argument>, <argument>nodeList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>NodeIsPrimary</name><argument_list>(<argument><expr><name>workerNode</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>NodeIsCoordinator</name><argument_list>(<argument><expr><name>workerNode</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>nodesWithMetadata</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>nodesWithMetadata</name></expr></argument>, <argument><expr><name>workerNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>nodesWithMetadata</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>syncPgDistMetadataCommandList</name> <init>= <expr><call><name>PgDistTableMetadataSyncCommandList</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>SendMetadataCommandListToWorkerListInCoordinatedTransaction</name><argument_list>(
		<argument><expr><name>nodesWithMetadata</name></expr></argument>,
		<argument><expr><call><name>CurrentUserName</name><argument_list>()</argument_list></call></expr></argument>,
		<argument><expr><name>syncPgDistMetadataCommandList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ModifiableWorkerNode gets the requested WorkerNode and also gets locks
 * required for modifying it. This fails if the node does not exist.
 */</comment>
<function><type><specifier>static</specifier> <name>WorkerNode</name> <modifier>*</modifier></type>
<name>ModifiableWorkerNode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nodeName</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>nodePort</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EnsureCoordinator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* take an exclusive lock on pg_dist_node to serialize pg_dist_node changes */</comment>
	<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><call><name>DistNodeRelationId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><call><name>FindWorkerNodeAnyCluster</name><argument_list>(<argument><expr><name>nodeName</name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>workerNode</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"node at \"%s:%u\" does not exist"</literal></expr></argument>, <argument><expr><name>nodeName</name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>workerNode</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * citus_activate_node UDF activates the given node. It sets the node's isactive
 * value to active and replicates all reference tables to that node.
 */</comment>
<function><type><name>Datum</name></type>
<name>citus_activate_node</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>nodeNameText</name> <init>= <expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>nodePort</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><call><name>ModifiableWorkerNode</name><argument_list>(<argument><expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><name>nodeNameText</name></expr></argument>)</argument_list></call></expr></argument>,
												  <argument><expr><name>nodePort</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ActivateNode</name><argument_list>(<argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>, <argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>TransactionModifiedNodeMetadata</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>nodeId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * master_activate_node is a wrapper function for old UDF name.
 */</comment>
<function><type><name>Datum</name></type>
<name>master_activate_node</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>citus_activate_node</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GroupForNode returns the group which a given node belongs to.
 *
 * It only works if the requested node is a part of CurrentCluster.
 */</comment>
<function><type><name>uint32</name></type>
<name>GroupForNode</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>nodeName</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nodePort</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><call><name>FindWorkerNode</name><argument_list>(<argument><expr><name>nodeName</name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>workerNode</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"node at \"%s:%u\" does not exist"</literal></expr></argument>, <argument><expr><name>nodeName</name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>workerNode</name><operator>-&gt;</operator><name>groupId</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * NodeIsPrimaryAndRemote returns whether the argument represents the remote
 * primary node.
 */</comment>
<function><type><name>bool</name></type>
<name>NodeIsPrimaryAndRemote</name><parameter_list>(<parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>worker</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>NodeIsPrimary</name><argument_list>(<argument><expr><name>worker</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>NodeIsLocal</name><argument_list>(<argument><expr><name>worker</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * NodeIsPrimary returns whether the argument represents a primary node.
 */</comment>
<function><type><name>bool</name></type>
<name>NodeIsPrimary</name><parameter_list>(<parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>worker</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>primaryRole</name> <init>= <expr><call><name>PrimaryNodeRoleId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* if nodeRole does not yet exist, all nodes are primary nodes */</comment>
	<if_stmt><if>if <condition>(<expr><name>primaryRole</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>worker</name><operator>-&gt;</operator><name>nodeRole</name></name> <operator>==</operator> <name>primaryRole</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * NodeIsLocal returns whether the argument represents the local node.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>NodeIsLocal</name><parameter_list>(<parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>worker</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>worker</name><operator>-&gt;</operator><name>groupId</name></name> <operator>==</operator> <call><name>GetLocalGroupId</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * NodeIsSecondary returns whether the argument represents a secondary node.
 */</comment>
<function><type><name>bool</name></type>
<name>NodeIsSecondary</name><parameter_list>(<parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>worker</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>secondaryRole</name> <init>= <expr><call><name>SecondaryNodeRoleId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* if nodeRole does not yet exist, all nodes are primary nodes */</comment>
	<if_stmt><if>if <condition>(<expr><name>secondaryRole</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>worker</name><operator>-&gt;</operator><name>nodeRole</name></name> <operator>==</operator> <name>secondaryRole</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * NodeIsReadable returns whether we're allowed to send SELECT queries to this
 * node.
 */</comment>
<function><type><name>bool</name></type>
<name>NodeIsReadable</name><parameter_list>(<parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>ReadFromSecondaries</name> <operator>==</operator> <name>USE_SECONDARY_NODES_NEVER</name> <operator>&amp;&amp;</operator>
		<call><name>NodeIsPrimary</name><argument_list>(<argument><expr><name>workerNode</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>ReadFromSecondaries</name> <operator>==</operator> <name>USE_SECONDARY_NODES_ALWAYS</name> <operator>&amp;&amp;</operator>
		<call><name>NodeIsSecondary</name><argument_list>(<argument><expr><name>workerNode</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PrimaryNodeForGroup returns the (unique) primary in the specified group.
 *
 * If there are any nodes in the requested group and groupContainsNodes is not NULL
 * it will set the bool groupContainsNodes references to true.
 */</comment>
<function><type><name>WorkerNode</name> <modifier>*</modifier></type>
<name>PrimaryNodeForGroup</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>groupId</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>groupContainsNodes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>workerNodeHash</name> <init>= <expr><call><name>GetWorkerNodeHash</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>workerNodeHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>workerNode</name> <operator>=</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int32</name></type> <name>workerNodeGroupId</name> <init>= <expr><name><name>workerNode</name><operator>-&gt;</operator><name>groupId</name></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>workerNodeGroupId</name> <operator>!=</operator> <name>groupId</name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>groupContainsNodes</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>groupContainsNodes</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>NodeIsPrimary</name><argument_list>(<argument><expr><name>workerNode</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>hash_seq_term</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>workerNode</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ActivateNodeList iterates over the nodeList and activates the nodes.
 * Some part of the node activation is done parallel across the nodes,
 * such as syncing the metadata. However, reference table replication is
 * done one by one across nodes.
 */</comment>
<function><type><name>void</name></type>
<name>ActivateNodeList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>nodeList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We currently require the object propagation to happen via superuser,
	 * see #5139. While activating a node, we sync both metadata and object
	 * propagation.
	 *
	 * In order to have a fully transactional semantics with add/activate
	 * node operations, we require superuser. Note that for creating
	 * non-owned objects, we already require a superuser connection.
	 * By ensuring the current user to be a superuser, we can guarantee
	 * to send all commands within the same remote transaction.
	 */</comment>
	<expr_stmt><expr><call><name>EnsureSuperUser</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* take an exclusive lock on pg_dist_node to serialize pg_dist_node changes */</comment>
	<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><call><name>DistNodeRelationId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>nodeToSyncMetadata</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>node</argument>, <argument>nodeList</argument>)</argument_list></macro>
	<block>{<block_content>
		<comment type="block">/*
		 * First, locally mark the node is active, if everything goes well,
		 * we are going to sync this information to all the metadata nodes.
		 */</comment>
		<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>=
			<expr><call><name>FindWorkerNodeAnyCluster</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>workerNode</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"node at \"%s:%u\" does not exist"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>,
								   <argument><expr><name><name>node</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* both nodes should be the same */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>nodeId</name></name> <operator>==</operator> <name><name>node</name><operator>-&gt;</operator><name>nodeId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Delete existing reference and replicated table placements on the
		 * given groupId if the group has been disabled earlier (e.g., isActive
		 * set to false).
		 *
		 * Sync the metadata changes to all existing metadata nodes irrespective
		 * of the current nodes' metadata sync state. We expect all nodes up
		 * and running when another node is activated.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>workerNode</name><operator>-&gt;</operator><name>isActive</name></name> <operator>&amp;&amp;</operator> <call><name>NodeIsPrimary</name><argument_list>(<argument><expr><name>workerNode</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type> <name>localOnly</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>DeleteAllReplicatedTablePlacementsFromNodeGroup</name><argument_list>(<argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>,
															<argument><expr><name>localOnly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>workerNode</name> <operator>=</operator>
			<call><name>SetWorkerColumnLocalOnly</name><argument_list>(<argument><expr><name>workerNode</name></expr></argument>, <argument><expr><name>Anum_pg_dist_node_isactive</name></expr></argument>,
									 <argument><expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* TODO: Once all tests will be enabled for MX, we can remove sync by default check */</comment>
		<decl_stmt><decl><type><name>bool</name></type> <name>syncMetadata</name> <init>= <expr><name>EnableMetadataSync</name> <operator>&amp;&amp;</operator> <call><name>NodeIsPrimary</name><argument_list>(<argument><expr><name>workerNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>syncMetadata</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We are going to sync the metadata anyway in this transaction, so do
			 * not fail just because the current metadata is not synced.
			 */</comment>
			<expr_stmt><expr><call><name>SetWorkerColumn</name><argument_list>(<argument><expr><name>workerNode</name></expr></argument>, <argument><expr><name>Anum_pg_dist_node_metadatasynced</name></expr></argument>,
							<argument><expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Update local group id first, as object dependency logic requires to have
			 * updated local group id.
			 */</comment>
			<expr_stmt><expr><call><name>UpdateLocalGroupIdOnNode</name><argument_list>(<argument><expr><name>workerNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>nodeToSyncMetadata</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>nodeToSyncMetadata</name></expr></argument>, <argument><expr><name>workerNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Sync distributed objects first. We must sync distributed objects before
	 * replicating reference tables to the remote node, as reference tables may
	 * need such objects.
	 */</comment>
	<expr_stmt><expr><call><name>SyncDistributedObjectsToNodeList</name><argument_list>(<argument><expr><name>nodeToSyncMetadata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Sync node metadata. We must sync node metadata before syncing table
	 * related pg_dist_xxx metadata. Since table related metadata requires
	 * to have right pg_dist_node entries.
	 */</comment>
	<macro><name>foreach_ptr</name><argument_list>(<argument>node</argument>, <argument>nodeToSyncMetadata</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SyncNodeMetadataToNode</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * As the last step, sync the table related metadata to the remote node.
	 * We must handle it as the last step because of limitations shared with
	 * above comments.
	 */</comment>
	<expr_stmt><expr><call><name>SyncPgDistTableMetadataToNodeList</name><argument_list>(<argument><expr><name>nodeToSyncMetadata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach_ptr</name><argument_list>(<argument>node</argument>, <argument>nodeList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>isActive</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* finally, let all other active metadata nodes to learn about this change */</comment>
		<expr_stmt><expr><call><name>SetNodeState</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>, <argument><expr><name>isActive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * ActivateNode activates the node with nodeName and nodePort. Currently, activation
 * includes only replicating the reference tables and setting isactive column of the
 * given node.
 */</comment>
<function><type><name>int</name></type>
<name>ActivateNode</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>nodeName</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nodePort</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>isActive</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><call><name>ModifiableWorkerNode</name><argument_list>(<argument><expr><name>nodeName</name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ActivateNodeList</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>workerNode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* finally, let all other active metadata nodes to learn about this change */</comment>
	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>newWorkerNode</name> <init>= <expr><call><name>SetNodeState</name><argument_list>(<argument><expr><name>nodeName</name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>, <argument><expr><name>isActive</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>newWorkerNode</name><operator>-&gt;</operator><name>nodeId</name></name> <operator>==</operator> <name><name>workerNode</name><operator>-&gt;</operator><name>nodeId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>newWorkerNode</name><operator>-&gt;</operator><name>nodeId</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * citus_update_node moves the requested node to a different nodename and nodeport. It
 * locks to ensure no queries are running concurrently; and is intended for customers who
 * are running their own failover solution.
 */</comment>
<function><type><name>Datum</name></type>
<name>citus_update_node</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int32</name></type> <name>nodeId</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>newNodeName</name> <init>= <expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>newNodePort</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * force is used when an update needs to happen regardless of conflicting locks. This
	 * feature is important to force the update during a failover due to failure, eg. by
	 * a high-availability system such as pg_auto_failover. The strategy is to start a
	 * background worker that actively cancels backends holding conflicting locks with
	 * this backend.
	 *
	 * Defaults to false
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>force</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>lock_cooldown</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>newNodeNameString</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><name>newNodeName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>placementList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BackgroundWorkerHandle</name> <modifier>*</modifier></type><name>handle</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNodeWithSameAddress</name> <init>= <expr><call><name>FindWorkerNodeAnyCluster</name><argument_list>(<argument><expr><name>newNodeNameString</name></expr></argument>,
																	 <argument><expr><name>newNodePort</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>workerNodeWithSameAddress</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* a node with the given hostname and port already exists in the metadata */</comment>

		<if_stmt><if>if <condition>(<expr><name><name>workerNodeWithSameAddress</name><operator>-&gt;</operator><name>nodeId</name></name> <operator>==</operator> <name>nodeId</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* it's the node itself, meaning this is a noop update */</comment>
			<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"there is already another node with the specified "</literal>
								   <literal type="string">"hostname and port"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><call><name>FindNodeAnyClusterByNodeId</name><argument_list>(<argument><expr><name>nodeId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>workerNode</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NO_DATA_FOUND</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"node %u not found"</literal></expr></argument>, <argument><expr><name>nodeId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>


	<comment type="block">/*
	 * If the node is a primary node we block reads and writes.
	 *
	 * This lock has two purposes:
	 *
	 * - Ensure buggy code in Citus doesn't cause failures when the
	 *   nodename/nodeport of a node changes mid-query
	 *
	 * - Provide fencing during failover, after this function returns all
	 *   connections will use the new node location.
	 *
	 * Drawback:
	 *
	 * - This function blocks until all previous queries have finished. This
	 *   means that long-running queries will prevent failover.
	 *
	 *   In case of node failure said long-running queries will fail in the end
	 *   anyway as they will be unable to commit successfully on the failed
	 *   machine. To cause quick failure of these queries use force =&gt; true
	 *   during the invocation of citus_update_node to terminate conflicting
	 *   backends proactively.
	 *
	 * It might be worth blocking reads to a secondary for the same reasons,
	 * though we currently only query secondaries on follower clusters
	 * where these locks will have no effect.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>NodeIsPrimary</name><argument_list>(<argument><expr><name>workerNode</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * before acquiring the locks check if we want a background worker to help us to
		 * aggressively obtain the locks.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>force</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>handle</name> <operator>=</operator> <call><name>StartLockAcquireHelperBackgroundWorker</name><argument_list>(<argument><expr><name>MyProcPid</name></expr></argument>, <argument><expr><name>lock_cooldown</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>handle</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * We failed to start a background worker, which probably means that we exceeded
				 * max_worker_processes, and this is unlikely to be resolved by retrying. We do not want
				 * to repeatedly throw an error because if citus_update_node is called to complete a
				 * failover then finishing is the only way to bring the cluster back up. Therefore we
				 * give up on killing other backends and simply wait for the lock. We do set
				 * lock_timeout to lock_cooldown, because we don't want to wait forever to get a lock.
				 */</comment>
				<expr_stmt><expr><call><name>SetLockTimeoutLocally</name><argument_list>(<argument><expr><name>lock_cooldown</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
									  <argument><expr><literal type="string">"could not start background worker to kill backends with conflicting"</literal>
									  <literal type="string">" locks to force the update. Degrading to acquiring locks "</literal>
									  <literal type="string">"with a lock time out."</literal></expr></argument>)</argument_list></call><operator>,</operator>
								  <call><name>errhint</name><argument_list>(
									  <argument><expr><literal type="string">"Increasing max_worker_processes might help."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>placementList</name> <operator>=</operator> <call><name>AllShardPlacementsOnNodeGroup</name><argument_list>(<argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LockShardsInPlacementListMetadata</name><argument_list>(<argument><expr><name>placementList</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * if we have planned statements such as prepared statements, we should clear the cache so that
	 * the planned cache doesn't return the old nodename/nodepost.
	 */</comment>
	<expr_stmt><expr><call><name>ResetPlanCache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>UpdateNodeLocation</name><argument_list>(<argument><expr><name>nodeId</name></expr></argument>, <argument><expr><name>newNodeNameString</name></expr></argument>, <argument><expr><name>newNodePort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* we should be able to find the new node from the metadata */</comment>
	<expr_stmt><expr><name>workerNode</name> <operator>=</operator> <call><name>FindWorkerNodeAnyCluster</name><argument_list>(<argument><expr><name>newNodeNameString</name></expr></argument>, <argument><expr><name>newNodePort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>nodeId</name></name> <operator>==</operator> <name>nodeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Propagate the updated pg_dist_node entry to all metadata workers.
	 * citus-ha uses citus_update_node() in a prepared transaction, and
	 * we don't support coordinated prepared transactions, so we cannot
	 * propagate the changes to the worker nodes here. Instead we mark
	 * all metadata nodes as not-synced and ask maintenanced to do the
	 * propagation.
	 *
	 * It is possible that maintenance daemon does the first resync too
	 * early, but that's fine, since this will start a retry loop with
	 * 5 second intervals until sync is complete.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>UnsetMetadataSyncedForAllWorkers</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>TriggerNodeMetadataSyncOnCommit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>handle</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * this will be called on memory context cleanup as well, if the worker has been
		 * terminated already this will be a noop
		 */</comment>
		<expr_stmt><expr><call><name>TerminateBackgroundWorker</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>TransactionModifiedNodeMetadata</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * master_update_node is a wrapper function for old UDF name.
 */</comment>
<function><type><name>Datum</name></type>
<name>master_update_node</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>citus_update_node</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SetLockTimeoutLocally sets the lock_timeout to the given value.
 * This setting is local.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SetLockTimeoutLocally</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>lockCooldown</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>set_config_option</name><argument_list>(<argument><expr><literal type="string">"lock_timeout"</literal></expr></argument>, <argument><expr><call><name>ConvertIntToString</name><argument_list>(<argument><expr><name>lockCooldown</name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><operator>(</operator><ternary><condition><expr><call><name>superuser</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name>PGC_SUSET</name></expr> </then><else>: <expr><name>PGC_USERSET</name></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><name>PGC_S_SESSION</name></expr></argument>,
					  <argument><expr><name>GUC_ACTION_LOCAL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>UpdateNodeLocation</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>nodeId</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>newNodeName</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>newNodePort</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>indexOK</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scanKey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name><name>values</name><index>[<expr><name>Natts_pg_dist_node</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name><name>isnull</name><index>[<expr><name>Natts_pg_dist_node</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name><name>replace</name><index>[<expr><name>Natts_pg_dist_node</name></expr>]</index></name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>pgDistNode</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><call><name>DistNodeRelationId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pgDistNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_pg_dist_node_nodeid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_INT4EQ</name></expr></argument>, <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>nodeId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scanDescriptor</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pgDistNode</name></expr></argument>, <argument><expr><call><name>DistNodeNodeIdIndexId</name><argument_list>()</argument_list></call></expr></argument>,
													<argument><expr><name>indexOK</name></expr></argument>,
													<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>scanKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>heapTuple</name> <init>= <expr><call><name>systable_getnext</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not find valid entry for node \"%s:%d\""</literal></expr></argument>,
							   <argument><expr><name>newNodeName</name></expr></argument>, <argument><expr><name>newNodePort</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>replace</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>replace</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_dist_node_nodeport</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>newNodePort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>isnull</name><index>[<expr><name>Anum_pg_dist_node_nodeport</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>replace</name><index>[<expr><name>Anum_pg_dist_node_nodeport</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_dist_node_nodename</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>newNodeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>isnull</name><index>[<expr><name>Anum_pg_dist_node_nodename</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>replace</name><index>[<expr><name>Anum_pg_dist_node_nodename</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>heapTuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>, <argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>replace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>pgDistNode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>heapTuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CitusInvalidateRelcacheByRelid</name><argument_list>(<argument><expr><call><name>DistNodeRelationId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pgDistNode</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * get_shard_id_for_distribution_column function takes a distributed table name and a
 * distribution value then returns shard id of the shard which belongs to given table and
 * contains given value. This function only works for hash distributed tables.
 */</comment>
<function><type><name>Datum</name></type>
<name>get_shard_id_for_distribution_column</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * To have optional parameter as NULL, we defined this UDF as not strict, therefore
	 * we need to check all parameters for NULL values.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation cannot be NULL"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>EnsureTablePermissions</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>ACL_SELECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation is not distributed"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>CITUS_TABLE_WITH_NO_DIST_KEY</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardIntervalList</name> <init>= <expr><call><name>LoadShardIntervalList</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>shardIntervalList</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>shardInterval</name> <operator>=</operator> <operator>(</operator><name>ShardInterval</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>shardIntervalList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>HASH_DISTRIBUTED</name></expr></argument>)</argument_list></call> <operator>||</operator>
			 <call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>RANGE_DISTRIBUTED</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>cacheEntry</name> <init>= <expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* if given table is not reference table, distributionValue cannot be NULL */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"distribution value cannot be NULL for tables other "</literal>
								   <literal type="string">"than reference tables."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>Datum</name></type> <name>inputDatum</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>inputDataType</name> <init>= <expr><call><name>get_fn_expr_argtype</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>distributionValueString</name> <init>= <expr><call><name>DatumToString</name><argument_list>(<argument><expr><name>inputDatum</name></expr></argument>, <argument><expr><name>inputDataType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>distributionColumn</name> <init>= <expr><call><name>DistPartitionKeyOrError</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>distributionDataType</name> <init>= <expr><name><name>distributionColumn</name><operator>-&gt;</operator><name>vartype</name></name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Datum</name></type> <name>distributionValueDatum</name> <init>= <expr><call><name>StringToDatum</name><argument_list>(<argument><expr><name>distributionValueString</name></expr></argument>,
													 <argument><expr><name>distributionDataType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>shardInterval</name> <operator>=</operator> <call><name>FindShardInterval</name><argument_list>(<argument><expr><name>distributionValueDatum</name></expr></argument>, <argument><expr><name>cacheEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"finding shard id of given distribution value is only "</literal>
							   <literal type="string">"supported for hash partitioned tables, range partitioned "</literal>
							   <literal type="string">"tables and reference tables."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>shardInterval</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * citus_nodename_for_nodeid returns the node name for the node with given node id
 */</comment>
<function><type><name>Datum</name></type>
<name>citus_nodename_for_nodeid</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>nodeId</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>FindNodeAnyClusterByNodeId</name><argument_list>(<argument><expr><name>nodeId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * citus_nodeport_for_nodeid returns the node port for the node with given node id
 */</comment>
<function><type><name>Datum</name></type>
<name>citus_nodeport_for_nodeid</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>nodeId</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>FindNodeAnyClusterByNodeId</name><argument_list>(<argument><expr><name>nodeId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * citus_coordinator_nodeid returns the node id of the coordinator node
 */</comment>
<function><type><name>Datum</name></type>
<name>citus_coordinator_nodeid</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>coordinatorNodeId</name> <init>= <expr><call><name>FindCoordinatorNodeId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>coordinatorNodeId</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><name>coordinatorNodeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * citus_is_coordinator returns whether the current node is a coordinator.
 * We consider the node a coordinator if its group ID is 0 and it has
 * pg_dist_node entries (only group ID 0 could indicate a worker without
 * metadata).
 */</comment>
<function><type><name>Datum</name></type>
<name>citus_is_coordinator</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>isCoordinator</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>GetLocalGroupId</name><argument_list>()</argument_list></call> <operator>==</operator> <name>COORDINATOR_GROUP_ID</name> <operator>&amp;&amp;</operator>
		<call><name>ActiveReadableNodeCount</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>isCoordinator</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>isCoordinator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * FindWorkerNode searches over the worker nodes and returns the workerNode
 * if it already exists. Else, the function returns NULL.
 */</comment>
<function><type><name>WorkerNode</name> <modifier>*</modifier></type>
<name>FindWorkerNode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nodeName</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>nodePort</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>workerNodeHash</name> <init>= <expr><call><name>GetWorkerNodeHash</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>handleFound</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>searchedNode</name> <init>= <expr><operator>(</operator><name>WorkerNode</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WorkerNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>searchedNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>, <argument><expr><name>nodeName</name></expr></argument>, <argument><expr><name>WORKER_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>searchedNode</name><operator>-&gt;</operator><name>workerPort</name></name> <operator>=</operator> <name>nodePort</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>hashKey</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>searchedNode</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>cachedWorkerNode</name> <init>= <expr><operator>(</operator><name>WorkerNode</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>workerNodeHash</name></expr></argument>, <argument><expr><name>hashKey</name></expr></argument>,
															  <argument><expr><name>HASH_FIND</name></expr></argument>,
															  <argument><expr><operator>&amp;</operator><name>handleFound</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>handleFound</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><operator>(</operator><name>WorkerNode</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WorkerNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><operator>*</operator><name>workerNode</name> <operator>=</operator> <operator>*</operator><name>cachedWorkerNode</name></expr>;</expr_stmt>
		<return>return <expr><name>workerNode</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FindWorkerNode searches over the worker nodes and returns the workerNode
 * if it exists otherwise it errors out.
 */</comment>
<function><type><name>WorkerNode</name> <modifier>*</modifier></type>
<name>FindWorkerNodeOrError</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nodeName</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>nodePort</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>FindWorkerNode</name><argument_list>(<argument><expr><name>nodeName</name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NO_DATA_FOUND</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"node %s:%d not found"</literal></expr></argument>, <argument><expr><name>nodeName</name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FindWorkerNodeAnyCluster returns the workerNode no matter which cluster it is a part
 * of. FindWorkerNodes, like almost every other function, acts as if nodes in other
 * clusters do not exist.
 */</comment>
<function><type><name>WorkerNode</name> <modifier>*</modifier></type>
<name>FindWorkerNodeAnyCluster</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nodeName</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>nodePort</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>pgDistNode</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><call><name>DistNodeRelationId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pgDistNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>heapTuple</name> <init>= <expr><call><name>GetNodeTuple</name><argument_list>(<argument><expr><name>nodeName</name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>heapTuple</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>workerNode</name> <operator>=</operator> <call><name>TupleToWorkerNode</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pgDistNode</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>workerNode</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FindNodeAnyClusterByNodeId searches pg_dist_node and returns the node with
 * the nodeId. If the node can't be found returns NULL.
 */</comment>
<function><type><specifier>static</specifier> <name>WorkerNode</name> <modifier>*</modifier></type>
<name>FindNodeAnyClusterByNodeId</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>nodeId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>includeNodesFromOtherClusters</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>nodeList</name> <init>= <expr><call><name>ReadDistNode</name><argument_list>(<argument><expr><name>includeNodesFromOtherClusters</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach_ptr</name><argument_list>(<argument>node</argument>, <argument>nodeList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>nodeId</name></name> <operator>==</operator> <name>nodeId</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>node</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FindNodeWithNodeId searches pg_dist_node and returns the node with the nodeId.
 * If the node cannot be found this functions errors.
 */</comment>
<function><type><name>WorkerNode</name> <modifier>*</modifier></type>
<name>FindNodeWithNodeId</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nodeId</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missingOk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>nodeList</name> <init>= <expr><call><name>ActiveReadableNodeList</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach_ptr</name><argument_list>(<argument>node</argument>, <argument>nodeList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>nodeId</name></name> <operator>==</operator> <name>nodeId</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>node</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* there isn't any node with nodeId in pg_dist_node */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>missingOk</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"node with node id %d could not be found"</literal></expr></argument>, <argument><expr><name>nodeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FindCoordinatorNodeId returns the node id of the coordinator node
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>FindCoordinatorNodeId</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>includeNodesFromOtherClusters</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>nodeList</name> <init>= <expr><call><name>ReadDistNode</name><argument_list>(<argument><expr><name>includeNodesFromOtherClusters</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach_ptr</name><argument_list>(<argument>node</argument>, <argument>nodeList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>NodeIsCoordinator</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name><name>node</name><operator>-&gt;</operator><name>nodeId</name></name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ReadDistNode iterates over pg_dist_node table, converts each row
 * into its memory representation (i.e., WorkerNode) and adds them into
 * a list. Lastly, the list is returned to the caller.
 *
 * It skips nodes which are not in the current clusters unless requested to do otherwise
 * by includeNodesFromOtherClusters.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>ReadDistNode</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>includeNodesFromOtherClusters</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scanKey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>scanKeyCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>workerNodeList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>pgDistNode</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><call><name>DistNodeRelationId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scanDescriptor</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pgDistNode</name></expr></argument>,
													<argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
													<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>scanKeyCount</name></expr></argument>, <argument><expr><name>scanKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pgDistNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>heapTuple</name> <init>= <expr><call><name>systable_getnext</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><call><name>TupleToWorkerNode</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>includeNodesFromOtherClusters</name> <operator>||</operator>
			<call><name>strncmp</name><argument_list>(<argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>nodeCluster</name></name></expr></argument>, <argument><expr><name>CurrentCluster</name></expr></argument>, <argument><expr><name>WORKER_LENGTH</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* the coordinator acts as if it never sees nodes not in its cluster */</comment>
			<expr_stmt><expr><name>workerNodeList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>workerNodeList</name></expr></argument>, <argument><expr><name>workerNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>heapTuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pgDistNode</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>workerNodeList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RemoveNodeFromCluster removes the provided node from the pg_dist_node table of
 * the master node and all nodes with metadata.
 * The call to the master_remove_node should be done by the super user. If there are
 * active shard placements on the node; the function errors out.
 * This function also deletes all reference table placements belong to the given node from
 * pg_dist_placement, but it does not drop actual placement at the node. It also
 * modifies replication factor of the colocation group of reference tables, so that
 * replication factor will be equal to worker count.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RemoveNodeFromCluster</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>nodeName</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>nodePort</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><call><name>ModifiableWorkerNode</name><argument_list>(<argument><expr><name>nodeName</name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>NodeIsPrimary</name><argument_list>(<argument><expr><name>workerNode</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ErrorIfNodeContainsNonRemovablePlacements</name><argument_list>(<argument><expr><name>workerNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Delete reference table placements so they are not taken into account
		 * for the check if there are placements after this.
		 */</comment>
		<decl_stmt><decl><type><name>bool</name></type> <name>localOnly</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>DeleteAllReplicatedTablePlacementsFromNodeGroup</name><argument_list>(<argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>,
														<argument><expr><name>localOnly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Secondary nodes are read-only, never 2PC is used.
		 * Hence, no items can be inserted to pg_dist_transaction
		 * for secondary nodes.
		 */</comment>
		<expr_stmt><expr><call><name>DeleteWorkerTransactions</name><argument_list>(<argument><expr><name>workerNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>DeleteNodeRow</name><argument_list>(<argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>RemoveOldShardPlacementForNodeGroup</name><argument_list>(<argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* make sure we don't have any lingering session lifespan connections */</comment>
	<expr_stmt><expr><call><name>CloseNodeConnectionsAfterTransaction</name><argument_list>(<argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>EnableMetadataSync</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nodeDeleteCommand</name> <init>= <expr><call><name>NodeDeleteCommand</name><argument_list>(<argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>nodeId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>SendCommandToWorkersWithMetadata</name><argument_list>(<argument><expr><name>nodeDeleteCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ErrorIfNodeContainsNonRemovablePlacements throws an error if the input node
 * contains at least one placement on the node that is the last active
 * placement.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ErrorIfNodeContainsNonRemovablePlacements</name><parameter_list>(<parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type> <name>groupId</name> <init>= <expr><name><name>workerNode</name><operator>-&gt;</operator><name>groupId</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardPlacements</name> <init>= <expr><call><name>AllShardPlacementsOnNodeGroup</name><argument_list>(<argument><expr><name>groupId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GroupShardPlacement</name> <modifier>*</modifier></type><name>placement</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>placement</argument>, <argument>shardPlacements</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PlacementHasActivePlacementOnAnotherGroup</name><argument_list>(<argument><expr><name>placement</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>RelationIdForShard</name><argument_list>(<argument><expr><name><name>placement</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>qualifiedRelationName</name> <init>= <expr><call><name>generate_qualified_relation_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot remove or disable the node "</literal>
								   <literal type="string">"%s:%d because because it contains "</literal>
								   <literal type="string">"the only shard placement for "</literal>
								   <literal type="string">"shard "</literal> <name>UINT64_FORMAT</name></expr></argument>, <argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>,
								   <argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>, <argument><expr><name><name>placement</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"One of the table(s) that prevents the operation "</literal>
									  <literal type="string">"complete successfully is %s"</literal></expr></argument>,
									  <argument><expr><name>qualifiedRelationName</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"To proceed, either drop the tables or use "</literal>
									<literal type="string">"undistribute_table() function to convert "</literal>
									<literal type="string">"them to local tables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * PlacementHasActivePlacementOnAnotherGroup returns true if there is at least
 * one more active placement of the input sourcePlacement on another group.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>PlacementHasActivePlacementOnAnotherGroup</name><parameter_list>(<parameter><decl><type><name>GroupShardPlacement</name> <modifier>*</modifier></type><name>sourcePlacement</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type> <name>shardId</name> <init>= <expr><name><name>sourcePlacement</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>activePlacementList</name> <init>= <expr><call><name>ActiveShardPlacementList</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>foundActivePlacementOnAnotherGroup</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>activePlacement</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>activePlacement</argument>, <argument>activePlacementList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>activePlacement</name><operator>-&gt;</operator><name>groupId</name></name> <operator>!=</operator> <name><name>sourcePlacement</name><operator>-&gt;</operator><name>groupId</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>foundActivePlacementOnAnotherGroup</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>foundActivePlacementOnAnotherGroup</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RemoveOldShardPlacementForNodeGroup removes all old shard placements
 * for the given node group from pg_dist_placement.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RemoveOldShardPlacementForNodeGroup</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>groupId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Prevent concurrent deferred drop
	 */</comment>
	<expr_stmt><expr><call><name>LockPlacementCleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardPlacementsOnNode</name> <init>= <expr><call><name>AllShardPlacementsOnNodeGroup</name><argument_list>(<argument><expr><name>groupId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GroupShardPlacement</name> <modifier>*</modifier></type><name>placement</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>placement</argument>, <argument>shardPlacementsOnNode</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>placement</name><operator>-&gt;</operator><name>shardState</name></name> <operator>==</operator> <name>SHARD_STATE_TO_DELETE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>DeleteShardPlacementRow</name><argument_list>(<argument><expr><name><name>placement</name><operator>-&gt;</operator><name>placementId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/* CountPrimariesWithMetadata returns the number of primary nodes which have metadata. */</comment>
<function><type><name>uint32</name></type>
<name>CountPrimariesWithMetadata</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>primariesWithMetadata</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>workerNodeHash</name> <init>= <expr><call><name>GetWorkerNodeHash</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>workerNodeHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>workerNode</name> <operator>=</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>workerNode</name><operator>-&gt;</operator><name>hasMetadata</name></name> <operator>&amp;&amp;</operator> <call><name>NodeIsPrimary</name><argument_list>(<argument><expr><name>workerNode</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>primariesWithMetadata</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>primariesWithMetadata</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AddNodeMetadata checks the given node information and adds the specified node to the
 * pg_dist_node table of the master and workers with metadata.
 * If the node already exists, the function returns the id of the node.
 * If not, the following procedure is followed while adding a node: If the groupId is not
 * explicitly given by the user, the function picks the group that the new node should
 * be in with respect to GroupSize. Then, the new node is inserted into the local
 * pg_dist_node as well as the nodes with hasmetadata=true.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>AddNodeMetadata</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>nodeName</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>nodePort</name></decl></parameter>,
				<parameter><decl><type><name>NodeMetadata</name> <modifier>*</modifier></type><name>nodeMetadata</name></decl></parameter>,
				<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nodeAlreadyExists</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>EnsureCoordinator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>nodeAlreadyExists</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><call><name>FindWorkerNodeAnyCluster</name><argument_list>(<argument><expr><name>nodeName</name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>workerNode</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* return early without holding locks when the node already exists */</comment>
		<expr_stmt><expr><operator>*</operator><name>nodeAlreadyExists</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<return>return <expr><name><name>workerNode</name><operator>-&gt;</operator><name>nodeId</name></name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We are going to change pg_dist_node, prevent any concurrent reads that
	 * are not tolerant to concurrent node addition by taking an exclusive
	 * lock (conflicts with all but AccessShareLock).
	 *
	 * We may want to relax or have more fine-grained locking in the future
	 * to allow users to add multiple nodes concurrently.
	 */</comment>
	<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><call><name>DistNodeRelationId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* recheck in case 2 node additions pass the first check concurrently */</comment>
	<expr_stmt><expr><name>workerNode</name> <operator>=</operator> <call><name>FindWorkerNodeAnyCluster</name><argument_list>(<argument><expr><name>nodeName</name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>workerNode</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>nodeAlreadyExists</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<return>return <expr><name><name>workerNode</name><operator>-&gt;</operator><name>nodeId</name></name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>nodeMetadata</name><operator>-&gt;</operator><name>groupId</name></name> <operator>!=</operator> <name>COORDINATOR_GROUP_ID</name> <operator>&amp;&amp;</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name>nodeName</name></expr></argument>, <argument><expr><literal type="string">"localhost"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * User tries to add a worker with a non-localhost address. If the coordinator
		 * is added with "localhost" as well, the worker won't be able to connect.
		 */</comment>

		<decl_stmt><decl><type><name>bool</name></type> <name>isCoordinatorInMetadata</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>coordinatorNode</name> <init>= <expr><call><name>PrimaryNodeForGroup</name><argument_list>(<argument><expr><name>COORDINATOR_GROUP_ID</name></expr></argument>,
														  <argument><expr><operator>&amp;</operator><name>isCoordinatorInMetadata</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>isCoordinatorInMetadata</name> <operator>&amp;&amp;</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>coordinatorNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>, <argument><expr><literal type="string">"localhost"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot add a worker node when the coordinator "</literal>
								   <literal type="string">"hostname is set to localhost"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Worker nodes need to be able to connect to the "</literal>
									  <literal type="string">"coordinator to transfer data."</literal></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use SELECT citus_set_coordinator_host('&lt;hostname&gt;') "</literal>
									<literal type="string">"to configure the coordinator hostname"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * When adding the first worker when the coordinator has shard placements,
	 * print a notice on how to drain the coordinator.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>nodeMetadata</name><operator>-&gt;</operator><name>groupId</name></name> <operator>!=</operator> <name>COORDINATOR_GROUP_ID</name> <operator>&amp;&amp;</operator> <call><name>CoordinatorAddedAsWorkerNode</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>ActivePrimaryNonCoordinatorNodeCount</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<call><name>NodeGroupHasShardPlacements</name><argument_list>(<argument><expr><name>COORDINATOR_GROUP_ID</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>coordinator</name> <init>= <expr><call><name>CoordinatorNodeIfAddedAsWorkerOrError</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"shards are still on the coordinator after adding the "</literal>
								<literal type="string">"new node"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use SELECT rebalance_table_shards(); to balance "</literal>
								 <literal type="string">"shards data between workers and coordinator or "</literal>
								 <literal type="string">"SELECT citus_drain_node(%s,%d); to permanently "</literal>
								 <literal type="string">"move shards away from the coordinator."</literal></expr></argument>,
								 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name><name>coordinator</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name><name>coordinator</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* user lets Citus to decide on the group that the newly added node should be in */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>nodeMetadata</name><operator>-&gt;</operator><name>groupId</name></name> <operator>==</operator> <name>INVALID_GROUP_ID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>nodeMetadata</name><operator>-&gt;</operator><name>groupId</name></name> <operator>=</operator> <call><name>GetNextGroupId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>nodeMetadata</name><operator>-&gt;</operator><name>groupId</name></name> <operator>==</operator> <name>COORDINATOR_GROUP_ID</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Coordinator has always the authoritative metadata, reflect this
		 * fact in the pg_dist_node.
		 */</comment>
		<expr_stmt><expr><name><name>nodeMetadata</name><operator>-&gt;</operator><name>hasMetadata</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nodeMetadata</name><operator>-&gt;</operator><name>metadataSynced</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * There is no concept of "inactive" coordinator, so hard code it.
		 */</comment>
		<expr_stmt><expr><name><name>nodeMetadata</name><operator>-&gt;</operator><name>isActive</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* if nodeRole hasn't been added yet there's a constraint for one-node-per-group */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>nodeMetadata</name><operator>-&gt;</operator><name>nodeRole</name></name> <operator>!=</operator> <name>InvalidOid</name> <operator>&amp;&amp;</operator> <name><name>nodeMetadata</name><operator>-&gt;</operator><name>nodeRole</name></name> <operator>==</operator>
		<call><name>PrimaryNodeRoleId</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>existingPrimaryNode</name> <init>= <expr><call><name>PrimaryNodeForGroup</name><argument_list>(<argument><expr><name><name>nodeMetadata</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>,
															  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>existingPrimaryNode</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"group %d already has a primary node"</literal></expr></argument>,
								   <argument><expr><name><name>nodeMetadata</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>nodeMetadata</name><operator>-&gt;</operator><name>nodeRole</name></name> <operator>==</operator> <call><name>PrimaryNodeRoleId</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>nodeMetadata</name><operator>-&gt;</operator><name>nodeCluster</name></name></expr></argument>,
					<argument><expr><name>WORKER_DEFAULT_CLUSTER</name></expr></argument>,
					<argument><expr><name>WORKER_LENGTH</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"primaries must be added to the default cluster"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* generate the new node id from the sequence */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>nextNodeIdInt</name> <init>= <expr><call><name>GetNextNodeId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>InsertNodeRow</name><argument_list>(<argument><expr><name>nextNodeIdInt</name></expr></argument>, <argument><expr><name>nodeName</name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>, <argument><expr><name>nodeMetadata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>workerNode</name> <operator>=</operator> <call><name>FindWorkerNodeAnyCluster</name><argument_list>(<argument><expr><name>nodeName</name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>EnableMetadataSync</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* send the delete command to all primary nodes with metadata */</comment>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nodeDeleteCommand</name> <init>= <expr><call><name>NodeDeleteCommand</name><argument_list>(<argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>nodeId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>SendCommandToWorkersWithMetadata</name><argument_list>(<argument><expr><name>nodeDeleteCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* finally prepare the insert command and send it to all primary nodes */</comment>
		<decl_stmt><decl><type><name>uint32</name></type> <name>primariesWithMetadata</name> <init>= <expr><call><name>CountPrimariesWithMetadata</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>primariesWithMetadata</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>workerNodeList</name> <init>= <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>workerNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nodeInsertCommand</name> <init>= <expr><call><name>NodeListInsertCommand</name><argument_list>(<argument><expr><name>workerNodeList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>SendCommandToWorkersWithMetadata</name><argument_list>(<argument><expr><name>nodeInsertCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>workerNode</name><operator>-&gt;</operator><name>nodeId</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SetWorkerColumn function sets the column with the specified index
 * on the worker in pg_dist_node, by calling SetWorkerColumnLocalOnly.
 * It also sends the same command for node update to other metadata nodes.
 * If anything fails during the transaction, we rollback it.
 * Returns the new worker node after the modification.
 */</comment>
<function><type><name>WorkerNode</name> <modifier>*</modifier></type>
<name>SetWorkerColumn</name><parameter_list>(<parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>columnIndex</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>workerNode</name> <operator>=</operator> <call><name>SetWorkerColumnLocalOnly</name><argument_list>(<argument><expr><name>workerNode</name></expr></argument>, <argument><expr><name>columnIndex</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>EnableMetadataSync</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>metadataSyncCommand</name> <init>=
			<expr><call><name>GetMetadataSyncCommandToSetNodeColumn</name><argument_list>(<argument><expr><name>workerNode</name></expr></argument>, <argument><expr><name>columnIndex</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>SendCommandToWorkersWithMetadata</name><argument_list>(<argument><expr><name>metadataSyncCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>workerNode</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SetWorkerColumnOptional function sets the column with the specified index
 * on the worker in pg_dist_node, by calling SetWorkerColumnLocalOnly.
 * It also sends the same command optionally for node update to other metadata nodes,
 * meaning that failures are ignored. Returns the new worker node after the modification.
 */</comment>
<function><type><name>WorkerNode</name> <modifier>*</modifier></type>
<name>SetWorkerColumnOptional</name><parameter_list>(<parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>columnIndex</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>metadataSyncCommand</name> <init>= <expr><call><name>GetMetadataSyncCommandToSetNodeColumn</name><argument_list>(<argument><expr><name>workerNode</name></expr></argument>,
																	  <argument><expr><name>columnIndex</name></expr></argument>,
																	  <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>workerNodeList</name> <init>= <expr><call><name>TargetWorkerSetNodeList</name><argument_list>(<argument><expr><name>NON_COORDINATOR_METADATA_NODES</name></expr></argument>,
												   <argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* open connections in parallel */</comment>
	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>worker</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>worker</argument>, <argument>workerNodeList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>success</name> <init>= <expr><call><name>SendOptionalMetadataCommandListToWorkerInCoordinatedTransaction</name><argument_list>(
			<argument><expr><name><name>worker</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>, <argument><expr><name><name>worker</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>,
			<argument><expr><call><name>CurrentUserName</name><argument_list>()</argument_list></call></expr></argument>,
			<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>metadataSyncCommand</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* metadata out of sync, mark the worker as not synced */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Updating the metadata of the node %s:%d "</literal>
									 <literal type="string">"is failed on node %s:%d. "</literal>
									 <literal type="string">"Metadata on %s:%d is marked as out of sync."</literal></expr></argument>,
									 <argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>, <argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>,
									 <argument><expr><name><name>worker</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>, <argument><expr><name><name>worker</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>,
									 <argument><expr><name><name>worker</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>, <argument><expr><name><name>worker</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>SetWorkerColumnLocalOnly</name><argument_list>(<argument><expr><name>worker</name></expr></argument>, <argument><expr><name>Anum_pg_dist_node_metadatasynced</name></expr></argument>,
									 <argument><expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>workerNode</name><operator>-&gt;</operator><name>nodeId</name></name> <operator>==</operator> <name><name>worker</name><operator>-&gt;</operator><name>nodeId</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If this is the node we want to update and it is updated succesfully,
			 * then we can safely update the flag on the coordinator as well.
			 */</comment>
			<expr_stmt><expr><call><name>SetWorkerColumnLocalOnly</name><argument_list>(<argument><expr><name>workerNode</name></expr></argument>, <argument><expr><name>columnIndex</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><call><name>FindWorkerNode</name><argument_list>(<argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>, <argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SetWorkerColumnLocalOnly function sets the column with the specified index
 * (see pg_dist_node.h) on the worker in pg_dist_node.
 * It returns the new worker node after the modification.
 */</comment>
<function><type><name>WorkerNode</name> <modifier>*</modifier></type>
<name>SetWorkerColumnLocalOnly</name><parameter_list>(<parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>columnIndex</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>pgDistNode</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><call><name>DistNodeRelationId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pgDistNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>heapTuple</name> <init>= <expr><call><name>GetNodeTuple</name><argument_list>(<argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>, <argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Datum</name></type> <name><name>values</name><index>[<expr><name>Natts_pg_dist_node</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name><name>isnull</name><index>[<expr><name>Natts_pg_dist_node</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name><name>replace</name><index>[<expr><name>Natts_pg_dist_node</name></expr>]</index></name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>heapTuple</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not find valid entry for node \"%s:%d\""</literal></expr></argument>,
							   <argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>, <argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>replace</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>replace</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>columnIndex</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>isnull</name><index>[<expr><name>columnIndex</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>replace</name><index>[<expr><name>columnIndex</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>heapTuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>, <argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>replace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>pgDistNode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>heapTuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CitusInvalidateRelcacheByRelid</name><argument_list>(<argument><expr><call><name>DistNodeRelationId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>newWorkerNode</name> <init>= <expr><call><name>TupleToWorkerNode</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pgDistNode</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>newWorkerNode</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetMetadataSyncCommandToSetNodeColumn checks if the given workerNode and value is
 * valid or not. Then it returns the necessary metadata sync command as a string.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>GetMetadataSyncCommandToSetNodeColumn</name><parameter_list>(<parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>columnIndex</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type>
									  <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>metadataSyncCommand</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>columnIndex</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>Anum_pg_dist_node_hasmetadata</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ErrorIfCoordinatorMetadataSetFalse</name><argument_list>(<argument><expr><name>workerNode</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="string">"hasmetadata"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>metadataSyncCommand</name> <operator>=</operator> <call><name>NodeHasmetadataUpdateCommand</name><argument_list>(<argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>nodeId</name></name></expr></argument>,
															   <argument><expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>Anum_pg_dist_node_isactive</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ErrorIfCoordinatorMetadataSetFalse</name><argument_list>(<argument><expr><name>workerNode</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="string">"isactive"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>metadataSyncCommand</name> <operator>=</operator> <call><name>NodeStateUpdateCommand</name><argument_list>(<argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>nodeId</name></name></expr></argument>,
														 <argument><expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>Anum_pg_dist_node_shouldhaveshards</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><name>metadataSyncCommand</name> <operator>=</operator> <call><name>ShouldHaveShardsUpdateCommand</name><argument_list>(<argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>nodeId</name></name></expr></argument>,
																<argument><expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>Anum_pg_dist_node_metadatasynced</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ErrorIfCoordinatorMetadataSetFalse</name><argument_list>(<argument><expr><name>workerNode</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="string">"metadatasynced"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>metadataSyncCommand</name> <operator>=</operator> <call><name>NodeMetadataSyncedUpdateCommand</name><argument_list>(<argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>nodeId</name></name></expr></argument>,
																  <argument><expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<default>default:</default>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not find valid entry for node \"%s:%d\""</literal></expr></argument>,
								   <argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>, <argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></switch>

	<return>return <expr><name>metadataSyncCommand</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * NodeHasmetadataUpdateCommand generates and returns a SQL UPDATE command
 * that updates the hasmetada column of pg_dist_node, for the given nodeid.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>NodeHasmetadataUpdateCommand</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>nodeId</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>hasMetadata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>updateCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>hasMetadataString</name> <init>= <expr><ternary><condition><expr><name>hasMetadata</name></expr> ?</condition><then> <expr><literal type="string">"TRUE"</literal></expr> </then><else>: <expr><literal type="string">"FALSE"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>updateCommand</name></expr></argument>,
					 <argument><expr><literal type="string">"UPDATE pg_dist_node SET hasmetadata = %s "</literal>
					 <literal type="string">"WHERE nodeid = %u"</literal></expr></argument>,
					 <argument><expr><name>hasMetadataString</name></expr></argument>, <argument><expr><name>nodeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>updateCommand</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * NodeMetadataSyncedUpdateCommand generates and returns a SQL UPDATE command
 * that updates the metadataSynced column of pg_dist_node, for the given nodeid.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>NodeMetadataSyncedUpdateCommand</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>nodeId</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>metadataSynced</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>updateCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>hasMetadataString</name> <init>= <expr><ternary><condition><expr><name>metadataSynced</name></expr> ?</condition><then> <expr><literal type="string">"TRUE"</literal></expr> </then><else>: <expr><literal type="string">"FALSE"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>updateCommand</name></expr></argument>,
					 <argument><expr><literal type="string">"UPDATE pg_dist_node SET metadatasynced = %s "</literal>
					 <literal type="string">"WHERE nodeid = %u"</literal></expr></argument>,
					 <argument><expr><name>hasMetadataString</name></expr></argument>, <argument><expr><name>nodeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>updateCommand</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ErrorIfCoordinatorMetadataSetFalse throws an error if the input node
 * is the coordinator and the value is false.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ErrorIfCoordinatorMetadataSetFalse</name><parameter_list>(<parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>field</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>valueBool</name> <init>= <expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>valueBool</name> <operator>&amp;&amp;</operator> <name><name>workerNode</name><operator>-&gt;</operator><name>groupId</name></name> <operator>==</operator> <name>COORDINATOR_GROUP_ID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot change \"%s\" field of the "</literal>
							   <literal type="string">"coordinator node"</literal></expr></argument>, <argument><expr><name>field</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * SetShouldHaveShards function sets the shouldhaveshards column of the
 * specified worker in pg_dist_node. also propagates this to other metadata nodes.
 * It returns the new worker node after the modification.
 */</comment>
<function><type><specifier>static</specifier> <name>WorkerNode</name> <modifier>*</modifier></type>
<name>SetShouldHaveShards</name><parameter_list>(<parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>shouldHaveShards</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>SetWorkerColumn</name><argument_list>(<argument><expr><name>workerNode</name></expr></argument>, <argument><expr><name>Anum_pg_dist_node_shouldhaveshards</name></expr></argument>, <argument><expr><call><name>BoolGetDatum</name><argument_list>(
							   <argument><expr><name>shouldHaveShards</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SetNodeState function sets the isactive column of the specified worker in
 * pg_dist_node to isActive. Also propagates this to other metadata nodes.
 * It returns the new worker node after the modification.
 */</comment>
<function><type><specifier>static</specifier> <name>WorkerNode</name> <modifier>*</modifier></type>
<name>SetNodeState</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>nodeName</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nodePort</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isActive</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><call><name>FindWorkerNodeAnyCluster</name><argument_list>(<argument><expr><name>nodeName</name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>SetWorkerColumn</name><argument_list>(<argument><expr><name>workerNode</name></expr></argument>, <argument><expr><name>Anum_pg_dist_node_isactive</name></expr></argument>, <argument><expr><call><name>BoolGetDatum</name><argument_list>(
							   <argument><expr><name>isActive</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetNodeTuple function returns the heap tuple of given nodeName and nodePort. If the
 * node is not found this function returns NULL.
 *
 * This function may return worker nodes from other clusters.
 */</comment>
<function><type><specifier>static</specifier> <name>HeapTuple</name></type>
<name>GetNodeTuple</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nodeName</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>nodePort</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>pgDistNode</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><call><name>DistNodeRelationId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>scanKeyCount</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>indexOK</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scanKey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>nodeTuple</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_pg_dist_node_nodename</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_TEXTEQ</name></expr></argument>, <argument><expr><call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>nodeName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanKey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_pg_dist_node_nodeport</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_INT4EQ</name></expr></argument>, <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>nodePort</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scanDescriptor</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pgDistNode</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>indexOK</name></expr></argument>,
													<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>scanKeyCount</name></expr></argument>, <argument><expr><name>scanKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>heapTuple</name> <init>= <expr><call><name>systable_getnext</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>nodeTuple</name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pgDistNode</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>nodeTuple</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetNextGroupId allocates and returns a unique groupId for the group
 * to be created. This allocation occurs both in shared memory and in write
 * ahead logs; writing to logs avoids the risk of having groupId collisions.
 *
 * Please note that the caller is still responsible for finalizing node data
 * and the groupId with the master node. Further note that this function relies
 * on an internal sequence created in initdb to generate unique identifiers.
 */</comment>
<function><type><name>int32</name></type>
<name>GetNextGroupId</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>sequenceName</name> <init>= <expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name>GROUPID_SEQUENCE_NAME</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>sequenceId</name> <init>= <expr><call><name>ResolveRelationId</name><argument_list>(<argument><expr><name>sequenceName</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>sequenceIdDatum</name> <init>= <expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>sequenceId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>savedUserId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>savedSecurityContext</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>GetUserIdAndSecContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>savedUserId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>savedSecurityContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetUserIdAndSecContext</name><argument_list>(<argument><expr><call><name>CitusExtensionOwner</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>SECURITY_LOCAL_USERID_CHANGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* generate new and unique shardId from sequence */</comment>
	<decl_stmt><decl><type><name>Datum</name></type> <name>groupIdDatum</name> <init>= <expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>nextval_oid</name></expr></argument>, <argument><expr><name>sequenceIdDatum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SetUserIdAndSecContext</name><argument_list>(<argument><expr><name>savedUserId</name></expr></argument>, <argument><expr><name>savedSecurityContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int32</name></type> <name>groupId</name> <init>= <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>groupIdDatum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>groupId</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetNextNodeId allocates and returns a unique nodeId for the node
 * to be added. This allocation occurs both in shared memory and in write
 * ahead logs; writing to logs avoids the risk of having nodeId collisions.
 *
 * Please note that the caller is still responsible for finalizing node data
 * and the nodeId with the master node. Further note that this function relies
 * on an internal sequence created in initdb to generate unique identifiers.
 */</comment>
<function><type><name>int</name></type>
<name>GetNextNodeId</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>sequenceName</name> <init>= <expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name>NODEID_SEQUENCE_NAME</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>sequenceId</name> <init>= <expr><call><name>ResolveRelationId</name><argument_list>(<argument><expr><name>sequenceName</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>sequenceIdDatum</name> <init>= <expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>sequenceId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>savedUserId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>savedSecurityContext</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>GetUserIdAndSecContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>savedUserId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>savedSecurityContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetUserIdAndSecContext</name><argument_list>(<argument><expr><call><name>CitusExtensionOwner</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>SECURITY_LOCAL_USERID_CHANGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* generate new and unique shardId from sequence */</comment>
	<decl_stmt><decl><type><name>Datum</name></type> <name>nextNodeIdDatum</name> <init>= <expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>nextval_oid</name></expr></argument>, <argument><expr><name>sequenceIdDatum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SetUserIdAndSecContext</name><argument_list>(<argument><expr><name>savedUserId</name></expr></argument>, <argument><expr><name>savedSecurityContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>nextNodeId</name> <init>= <expr><call><name>DatumGetUInt32</name><argument_list>(<argument><expr><name>nextNodeIdDatum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>nextNodeId</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * EnsureCoordinator checks if the current node is the coordinator. If it does not,
 * the function errors out.
 */</comment>
<function><type><name>void</name></type>
<name>EnsureCoordinator</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type> <name>localGroupId</name> <init>= <expr><call><name>GetLocalGroupId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>localGroupId</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"operation is not allowed on this node"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Connect to the coordinator and run it again."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * EnsureCoordinatorIsInMetadata checks whether the coordinator is added to the
 * metadata, which is required for many operations.
 */</comment>
<function><type><name>void</name></type>
<name>EnsureCoordinatorIsInMetadata</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>isCoordinatorInMetadata</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PrimaryNodeForGroup</name><argument_list>(<argument><expr><name>COORDINATOR_GROUP_ID</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isCoordinatorInMetadata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isCoordinatorInMetadata</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"coordinator is not added to the metadata"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use SELECT citus_set_coordinator_host('&lt;hostname&gt;') "</literal>
								<literal type="string">"to configure the coordinator hostname"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * InsertCoordinatorIfClusterEmpty can be used to ensure Citus tables can be
 * created even on a node that has just performed CREATE EXTENSION citus;
 */</comment>
<function><type><name>void</name></type>
<name>InsertCoordinatorIfClusterEmpty</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* prevent concurrent node additions */</comment>
	<decl_stmt><decl><type><name>Relation</name></type> <name>pgDistNode</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><call><name>DistNodeRelationId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>RowShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HasAnyNodes</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * create_distributed_table being called for the first time and there are
		 * no pg_dist_node records. Add a record for the coordinator.
		 */</comment>
		<expr_stmt><expr><call><name>InsertPlaceholderCoordinatorRecord</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We release the lock, if InsertPlaceholderCoordinatorRecord was called
	 * we already have a strong (RowExclusive) lock.
	 */</comment>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pgDistNode</name></expr></argument>, <argument><expr><name>RowShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * InsertPlaceholderCoordinatorRecord inserts a placeholder record for the coordinator
 * to be able to create distributed tables on a single node.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>InsertPlaceholderCoordinatorRecord</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NodeMetadata</name></type> <name>nodeMetadata</name> <init>= <expr><call><name>DefaultNodeMetadata</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>nodeMetadata</name><operator>.</operator><name>groupId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nodeMetadata</name><operator>.</operator><name>shouldHaveShards</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nodeMetadata</name><operator>.</operator><name>nodeRole</name></name> <operator>=</operator> <call><name>PrimaryNodeRoleId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nodeMetadata</name><operator>.</operator><name>nodeCluster</name></name> <operator>=</operator> <literal type="string">"default"</literal></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>nodeAlreadyExists</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* as long as there is a single node, localhost should be ok */</comment>
	<expr_stmt><expr><call><name>AddNodeMetadata</name><argument_list>(<argument><expr><name>LocalHostName</name></expr></argument>, <argument><expr><name>PostPortNumber</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nodeMetadata</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nodeAlreadyExists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * InsertNodeRow opens the node system catalog, and inserts a new row with the
 * given values into that system catalog.
 *
 * NOTE: If you call this function you probably need to have taken a
 * ShareRowExclusiveLock then checked that you're not adding a second primary to
 * an existing group. If you don't it's possible for the metadata to become inconsistent.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>InsertNodeRow</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nodeid</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>nodeName</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>nodePort</name></decl></parameter>, <parameter><decl><type><name>NodeMetadata</name> <modifier>*</modifier></type><name>nodeMetadata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type> <name><name>values</name><index>[<expr><name>Natts_pg_dist_node</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name><name>isNulls</name><index>[<expr><name>Natts_pg_dist_node</name></expr>]</index></name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Datum</name></type> <name>nodeClusterStringDatum</name> <init>= <expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name><name>nodeMetadata</name><operator>-&gt;</operator><name>nodeCluster</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>nodeClusterNameDatum</name> <init>= <expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>namein</name></expr></argument>, <argument><expr><name>nodeClusterStringDatum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* form new shard tuple */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>isNulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>isNulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_dist_node_nodeid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>UInt32GetDatum</name><argument_list>(<argument><expr><name>nodeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_dist_node_groupid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>nodeMetadata</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_dist_node_nodename</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>nodeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_dist_node_nodeport</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>UInt32GetDatum</name><argument_list>(<argument><expr><name>nodePort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_dist_node_noderack</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>nodeMetadata</name><operator>-&gt;</operator><name>nodeRack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_dist_node_hasmetadata</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>nodeMetadata</name><operator>-&gt;</operator><name>hasMetadata</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_dist_node_metadatasynced</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(
		<argument><expr><name><name>nodeMetadata</name><operator>-&gt;</operator><name>metadataSynced</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_dist_node_isactive</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>nodeMetadata</name><operator>-&gt;</operator><name>isActive</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_dist_node_noderole</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>nodeMetadata</name><operator>-&gt;</operator><name>nodeRole</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_dist_node_nodecluster</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>nodeClusterNameDatum</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_dist_node_shouldhaveshards</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(
		<argument><expr><name><name>nodeMetadata</name><operator>-&gt;</operator><name>shouldHaveShards</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>pgDistNode</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><call><name>DistNodeRelationId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pgDistNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>heapTuple</name> <init>= <expr><call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isNulls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CatalogTupleInsert</name><argument_list>(<argument><expr><name>pgDistNode</name></expr></argument>, <argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CitusInvalidateRelcacheByRelid</name><argument_list>(<argument><expr><call><name>DistNodeRelationId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* increment the counter so that next command can see the row */</comment>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* close relation */</comment>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pgDistNode</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * DeleteNodeRow removes the requested row from pg_dist_node table if it exists.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DeleteNodeRow</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>nodeName</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>nodePort</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>scanKeyCount</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>indexOK</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scanKey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>pgDistNode</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><call><name>DistNodeRelationId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * simple_heap_delete() expects that the caller has at least an
	 * AccessShareLock on primary key index.
	 *
	 * XXX: This does not seem required, do we really need to acquire this lock?
	 * Postgres doesn't acquire such locks on indexes before deleting catalog tuples.
	 * Linking here the reasons we added this lock acquirement:
	 * https://github.com/citusdata/citus/pull/2851#discussion_r306569462
	 * https://github.com/citusdata/citus/pull/2855#discussion_r313628554
	 * https://github.com/citusdata/citus/issues/1890
	 */</comment>
	<decl_stmt><decl><type><name>Relation</name></type> <name>replicaIndex</name> <init>= <expr><call><name>index_open</name><argument_list>(<argument><expr><call><name>RelationGetPrimaryKeyIndex</name><argument_list>(<argument><expr><name>pgDistNode</name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_pg_dist_node_nodename</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_TEXTEQ</name></expr></argument>, <argument><expr><call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>nodeName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanKey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_pg_dist_node_nodeport</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_INT4EQ</name></expr></argument>, <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>nodePort</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>heapScan</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pgDistNode</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>indexOK</name></expr></argument>,
											  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>scanKeyCount</name></expr></argument>, <argument><expr><name>scanKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>heapTuple</name> <init>= <expr><call><name>systable_getnext</name><argument_list>(<argument><expr><name>heapScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not find valid entry for node \"%s:%d\""</literal></expr></argument>,
							   <argument><expr><name>nodeName</name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>simple_heap_delete</name><argument_list>(<argument><expr><name>pgDistNode</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>heapTuple</name><operator>-&gt;</operator><name>t_self</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>heapScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* ensure future commands don't use the node we just removed */</comment>
	<expr_stmt><expr><call><name>CitusInvalidateRelcacheByRelid</name><argument_list>(<argument><expr><call><name>DistNodeRelationId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* increment the counter so that next command won't see the row */</comment>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>replicaIndex</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pgDistNode</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * TupleToWorkerNode takes in a heap tuple from pg_dist_node, and
 * converts this tuple to an equivalent struct in memory. The function assumes
 * the caller already has locks on the tuple, and doesn't perform any locking.
 */</comment>
<function><type><specifier>static</specifier> <name>WorkerNode</name> <modifier>*</modifier></type>
<name>TupleToWorkerNode</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>heapTuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type> <name><name>datumArray</name><index>[<expr><name>Natts_pg_dist_node</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name><name>isNullArray</name><index>[<expr><name>Natts_pg_dist_node</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>HeapTupleHasNulls</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * This function can be called before "ALTER TABLE ... ADD COLUMN nodecluster ...",
	 * therefore heap_deform_tuple() won't set the isNullArray for this column. We
	 * initialize it true to be safe in that case.
	 */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>isNullArray</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>isNullArray</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We use heap_deform_tuple() instead of heap_getattr() to expand tuple
	 * to contain missing values when ALTER TABLE ADD COLUMN happens.
	 */</comment>
	<expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>, <argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><name>datumArray</name></expr></argument>, <argument><expr><name>isNullArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nodeName</name> <init>= <expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><name><name>datumArray</name><index>[<expr><name>Anum_pg_dist_node_nodename</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nodeRack</name> <init>= <expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><name><name>datumArray</name><index>[<expr><name>Anum_pg_dist_node_noderack</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><operator>(</operator><name>WorkerNode</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WorkerNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>workerNode</name><operator>-&gt;</operator><name>nodeId</name></name> <operator>=</operator> <call><name>DatumGetUInt32</name><argument_list>(<argument><expr><name><name>datumArray</name><index>[<expr><name>Anum_pg_dist_node_nodeid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerPort</name></name> <operator>=</operator> <call><name>DatumGetUInt32</name><argument_list>(<argument><expr><name><name>datumArray</name><index>[<expr><name>Anum_pg_dist_node_nodeport</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>workerNode</name><operator>-&gt;</operator><name>groupId</name></name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>datumArray</name><index>[<expr><name>Anum_pg_dist_node_groupid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>, <argument><expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>nodeName</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>WORKER_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerRack</name></name></expr></argument>, <argument><expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>nodeRack</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>WORKER_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>workerNode</name><operator>-&gt;</operator><name>hasMetadata</name></name> <operator>=</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><name><name>datumArray</name><index>[<expr><name>Anum_pg_dist_node_hasmetadata</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>workerNode</name><operator>-&gt;</operator><name>metadataSynced</name></name> <operator>=</operator>
		<call><name>DatumGetBool</name><argument_list>(<argument><expr><name><name>datumArray</name><index>[<expr><name>Anum_pg_dist_node_metadatasynced</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>workerNode</name><operator>-&gt;</operator><name>isActive</name></name> <operator>=</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><name><name>datumArray</name><index>[<expr><name>Anum_pg_dist_node_isactive</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>workerNode</name><operator>-&gt;</operator><name>nodeRole</name></name> <operator>=</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name><name>datumArray</name><index>[<expr><name>Anum_pg_dist_node_noderole</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>workerNode</name><operator>-&gt;</operator><name>shouldHaveShards</name></name> <operator>=</operator> <call><name>DatumGetBool</name><argument_list>(
		<argument><expr><name><name>datumArray</name><index>[<expr><name>Anum_pg_dist_node_shouldhaveshards</name> <operator>-</operator>
				   <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * nodecluster column can be missing. In the case of extension creation/upgrade,
	 * master_initialize_node_metadata function is called before the nodecluster
	 * column is added to pg_dist_node table.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>isNullArray</name><index>[<expr><name>Anum_pg_dist_node_nodecluster</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Name</name></type> <name>nodeClusterName</name> <init>=
			<expr><call><name>DatumGetName</name><argument_list>(<argument><expr><name><name>datumArray</name><index>[<expr><name>Anum_pg_dist_node_nodecluster</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nodeClusterString</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>nodeClusterName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>nodeCluster</name></name></expr></argument>, <argument><expr><name>nodeClusterString</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>workerNode</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * StringToDatum transforms a string representation into a Datum.
 */</comment>
<function><type><name>Datum</name></type>
<name>StringToDatum</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>inputString</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>dataType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>typIoFunc</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>typIoParam</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>typeModifier</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>getTypeInputInfo</name><argument_list>(<argument><expr><name>dataType</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typIoFunc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typIoParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>getBaseTypeAndTypmod</name><argument_list>(<argument><expr><name>dataType</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typeModifier</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Datum</name></type> <name>datum</name> <init>= <expr><call><name>OidInputFunctionCall</name><argument_list>(<argument><expr><name>typIoFunc</name></expr></argument>, <argument><expr><name>inputString</name></expr></argument>, <argument><expr><name>typIoParam</name></expr></argument>, <argument><expr><name>typeModifier</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>datum</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DatumToString returns the string representation of the given datum.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>DatumToString</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>datum</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>dataType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>typIoFunc</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>typIsVarlena</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name>dataType</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typIoFunc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typIsVarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>outputString</name> <init>= <expr><call><name>OidOutputFunctionCall</name><argument_list>(<argument><expr><name>typIoFunc</name></expr></argument>, <argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>outputString</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * UnsetMetadataSyncedForAllWorkers sets the metadatasynced column of all metadata
 * worker nodes to false. It returns true if it updated at least a node.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>UnsetMetadataSyncedForAllWorkers</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>updatedAtLeastOne</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scanKey</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>scanKeyCount</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>indexOK</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Concurrent citus_update_node() calls might iterate and try to update
	 * pg_dist_node in different orders. To protect against deadlock, we
	 * get an exclusive lock here.
	 */</comment>
	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><call><name>DistNodeRelationId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_pg_dist_node_hasmetadata</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_BOOLEQ</name></expr></argument>, <argument><expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanKey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_pg_dist_node_metadatasynced</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_BOOLEQ</name></expr></argument>, <argument><expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* coordinator always has the up to date metadata */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanKey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_pg_dist_node_groupid</name></expr></argument>,
				<argument><expr><name>BTGreaterStrategyNumber</name></expr></argument>, <argument><expr><name>F_INT4GT</name></expr></argument>,
				<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>COORDINATOR_GROUP_ID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>CatalogIndexState</name></type> <name>indstate</name> <init>= <expr><call><name>CatalogOpenIndexes</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scanDescriptor</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(<argument><expr><name>relation</name></expr></argument>,
													<argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>indexOK</name></expr></argument>,
													<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>scanKeyCount</name></expr></argument>, <argument><expr><name>scanKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>heapTuple</name> <init>= <expr><call><name>systable_getnext</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>updatedAtLeastOne</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type> <name><name>values</name><index>[<expr><name>Natts_pg_dist_node</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name><name>isnull</name><index>[<expr><name>Natts_pg_dist_node</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name><name>replace</name><index>[<expr><name>Natts_pg_dist_node</name></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>replace</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>replace</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>isnull</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_dist_node_metadatasynced</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>replace</name><index>[<expr><name>Anum_pg_dist_node_metadatasynced</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>HeapTuple</name></type> <name>newHeapTuple</name> <init>= <expr><call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>, <argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><name>values</name></expr></argument>,
												   <argument><expr><name>isnull</name></expr></argument>,
												   <argument><expr><name>replace</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CatalogTupleUpdateWithInfo</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newHeapTuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>newHeapTuple</name></expr></argument>,
								   <argument><expr><name>indstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>newHeapTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>heapTuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CatalogCloseIndexes</name><argument_list>(<argument><expr><name>indstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>updatedAtLeastOne</name></expr>;</return>
</block_content>}</block></function>
</unit>
