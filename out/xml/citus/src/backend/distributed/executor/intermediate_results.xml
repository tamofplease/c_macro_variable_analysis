<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/builded_projects/citus/src/backend/distributed/executor/intermediate_results.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * intermediate_results.c
 *   Functions for writing and reading intermediate results.
 *
 * Copyright (c) Citus Data, Inc.
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-fe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_enum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/copy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands/multi_copy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/connection_management.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/error_codes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/intermediate_results.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/remote_commands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/transmit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/transaction_identifier.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/tuplestore.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/utils/array_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/utils/directory.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/version_compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/parsenodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/primnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>


<decl_stmt><decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>CreatedResultsDirectories</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>


<comment type="block">/* CopyDestReceiver can be used to stream results into a distributed table */</comment>
<typedef>typedef <type><struct>struct <name>RemoteFileDestReceiver</name>
<block>{
	<comment type="block">/* public DestReceiver interface */</comment>
	<decl_stmt><decl><type><name>DestReceiver</name></type> <name>pub</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>resultId</name></decl>;</decl_stmt>

	<comment type="block">/* descriptor of the tuples that are sent to the worker */</comment>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name></decl>;</decl_stmt>

	<comment type="block">/* EState for per-tuple memory allocation */</comment>
	<decl_stmt><decl><type><name>EState</name> <modifier>*</modifier></type><name>executorState</name></decl>;</decl_stmt>

	<comment type="block">/* MemoryContext for DestReceiver session */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>memoryContext</name></decl>;</decl_stmt>

	<comment type="block">/* worker nodes to send data to */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>initialNodeList</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>connectionList</name></decl>;</decl_stmt>

	<comment type="block">/* whether to write to a local file */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>writeLocalFile</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FileCompat</name></type> <name>fileCompat</name></decl>;</decl_stmt>

	<comment type="block">/* state on how to copy out data types */</comment>
	<decl_stmt><decl><type><name>CopyOutState</name></type> <name>copyOutState</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>columnOutputFunctions</name></decl>;</decl_stmt>

	<comment type="block">/* statistics */</comment>
	<decl_stmt><decl><type><name>uint64</name></type> <name>tuplesSent</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>bytesSent</name></decl>;</decl_stmt>
}</block></struct></type> <name>RemoteFileDestReceiver</name>;</typedef>

<comment type="block">/* Enumeration to track one copy query's status on the client */</comment>
<typedef>typedef <type><enum>enum <name>CopyStatus</name>
<block>{
	<decl><name>CLIENT_INVALID_COPY</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
	<decl><name>CLIENT_COPY_MORE</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
	<decl><name>CLIENT_COPY_FAILED</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>,
	<decl><name>CLIENT_COPY_DONE</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>
}</block></enum></type> <name>CopyStatus</name>;</typedef>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RemoteFileDestReceiverStartup</name><parameter_list>(<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>operation</name></decl></parameter>,
										  <parameter><decl><type><name>TupleDesc</name></type> <name>inputTupleDescriptor</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>PrepareIntermediateResultBroadcast</name><parameter_list>(<parameter><decl><type><name>RemoteFileDestReceiver</name> <modifier>*</modifier></type><name>resultDest</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>StringInfo</name></type> <name>ConstructCopyResultStatement</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>resultId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>RemoteFileDestReceiverReceive</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>BroadcastCopyData</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>dataBuffer</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>connectionList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SendCopyDataOverConnection</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>dataBuffer</name></decl></parameter>,
									   <parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RemoteFileDestReceiverShutdown</name><parameter_list>(<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>destReceiver</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RemoteFileDestReceiverDestroy</name><parameter_list>(<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>destReceiver</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>IntermediateResultsDirectory</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReadIntermediateResultsIntoFuncOutput</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>,
												  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>copyFormat</name></decl></parameter>,
												  <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>resultIdArray</name></decl></parameter>,
												  <parameter><decl><type><name>int</name></type> <name>resultCount</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint64</name></type> <name>FetchRemoteIntermediateResult</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>resultId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>CopyStatus</name></type> <name>CopyDataFromConnection</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>,
										 <parameter><decl><type><name>FileCompat</name> <modifier>*</modifier></type><name>fileCompat</name></decl></parameter>,
										 <parameter><decl><type><name>uint64</name> <modifier>*</modifier></type><name>bytesReceived</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* exports for SQL callable functions */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>read_intermediate_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>read_intermediate_result_array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>broadcast_intermediate_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>create_intermediate_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>fetch_intermediate_results</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<comment type="block">/*
 * broadcast_intermediate_result executes a query and streams the results
 * into a file on all workers.
 */</comment>
<function><type><name>Datum</name></type>
<name>broadcast_intermediate_result</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>resultIdText</name> <init>= <expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>resultIdString</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><name>resultIdText</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>queryText</name> <init>= <expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>queryString</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><name>queryText</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>writeLocalFile</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParamListInfo</name></type> <name>paramListInfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Make sure that this transaction has a distributed transaction ID.
	 *
	 * Intermediate results will be stored in a directory that is derived
	 * from the distributed transaction ID.
	 */</comment>
	<expr_stmt><expr><call><name>UseCoordinatedTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>nodeList</name> <init>= <expr><call><name>ActivePrimaryNonCoordinatorNodeList</name><argument_list>(<argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name> <init>= <expr><call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RemoteFileDestReceiver</name> <modifier>*</modifier></type><name>resultDest</name> <init>=
		<expr><operator>(</operator><name>RemoteFileDestReceiver</name> <operator>*</operator><operator>)</operator> <call><name>CreateRemoteFileDestReceiver</name><argument_list>(<argument><expr><name>resultIdString</name></expr></argument>,
																<argument><expr><name>estate</name></expr></argument>,
																<argument><expr><name>nodeList</name></expr></argument>,
																<argument><expr><name>writeLocalFile</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ExecuteQueryStringIntoDestReceiver</name><argument_list>(<argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>paramListInfo</name></expr></argument>,
									   <argument><expr><operator>(</operator><name>DestReceiver</name> <operator>*</operator><operator>)</operator> <name>resultDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><name><name>resultDest</name><operator>-&gt;</operator><name>tuplesSent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * create_intermediate_result executes a query and writes the results
 * into a local file.
 */</comment>
<function><type><name>Datum</name></type>
<name>create_intermediate_result</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>resultIdText</name> <init>= <expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>resultIdString</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><name>resultIdText</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>queryText</name> <init>= <expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>queryString</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><name>queryText</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>nodeList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>writeLocalFile</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParamListInfo</name></type> <name>paramListInfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Make sure that this transaction has a distributed transaction ID.
	 *
	 * Intermediate results will be stored in a directory that is derived
	 * from the distributed transaction ID.
	 */</comment>
	<expr_stmt><expr><call><name>UseCoordinatedTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name> <init>= <expr><call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RemoteFileDestReceiver</name> <modifier>*</modifier></type><name>resultDest</name> <init>=
		<expr><operator>(</operator><name>RemoteFileDestReceiver</name> <operator>*</operator><operator>)</operator> <call><name>CreateRemoteFileDestReceiver</name><argument_list>(<argument><expr><name>resultIdString</name></expr></argument>,
																<argument><expr><name>estate</name></expr></argument>,
																<argument><expr><name>nodeList</name></expr></argument>,
																<argument><expr><name>writeLocalFile</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ExecuteQueryStringIntoDestReceiver</name><argument_list>(<argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>paramListInfo</name></expr></argument>,
									   <argument><expr><operator>(</operator><name>DestReceiver</name> <operator>*</operator><operator>)</operator> <name>resultDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><name><name>resultDest</name><operator>-&gt;</operator><name>tuplesSent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CreateRemoteFileDestReceiver creates a DestReceiver that streams results
 * to a set of worker nodes. If the scope of the intermediate result is a
 * distributed transaction, then it's up to the caller to ensure that a
 * coordinated transaction is started prior to using the DestReceiver.
 */</comment>
<function><type><name>DestReceiver</name> <modifier>*</modifier></type>
<name>CreateRemoteFileDestReceiver</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>resultId</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>executorState</name></decl></parameter>,
							 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>initialNodeList</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>writeLocalFile</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RemoteFileDestReceiver</name> <modifier>*</modifier></type><name>resultDest</name> <init>= <expr><operator>(</operator><name>RemoteFileDestReceiver</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(
		<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RemoteFileDestReceiver</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* set up the DestReceiver function pointers */</comment>
	<expr_stmt><expr><name><name>resultDest</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>receiveSlot</name></name> <operator>=</operator> <name>RemoteFileDestReceiverReceive</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultDest</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>rStartup</name></name> <operator>=</operator> <name>RemoteFileDestReceiverStartup</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultDest</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>rShutdown</name></name> <operator>=</operator> <name>RemoteFileDestReceiverShutdown</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultDest</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>rDestroy</name></name> <operator>=</operator> <name>RemoteFileDestReceiverDestroy</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultDest</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>mydest</name></name> <operator>=</operator> <name>DestCopyOut</name></expr>;</expr_stmt>

	<comment type="block">/* set up output parameters */</comment>
	<expr_stmt><expr><name><name>resultDest</name><operator>-&gt;</operator><name>resultId</name></name> <operator>=</operator> <name>resultId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultDest</name><operator>-&gt;</operator><name>executorState</name></name> <operator>=</operator> <name>executorState</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultDest</name><operator>-&gt;</operator><name>initialNodeList</name></name> <operator>=</operator> <name>initialNodeList</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultDest</name><operator>-&gt;</operator><name>memoryContext</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultDest</name><operator>-&gt;</operator><name>writeLocalFile</name></name> <operator>=</operator> <name>writeLocalFile</name></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>DestReceiver</name> <operator>*</operator><operator>)</operator> <name>resultDest</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RemoteFileDestReceiverBytesSent returns number of bytes sent per remote worker.
 */</comment>
<function><type><name>uint64</name></type>
<name>RemoteFileDestReceiverBytesSent</name><parameter_list>(<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>destReceiver</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RemoteFileDestReceiver</name> <modifier>*</modifier></type><name>remoteDestReceiver</name> <init>= <expr><operator>(</operator><name>RemoteFileDestReceiver</name> <operator>*</operator><operator>)</operator> <name>destReceiver</name></expr></init></decl>;</decl_stmt>
	<return>return <expr><name><name>remoteDestReceiver</name><operator>-&gt;</operator><name>bytesSent</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RemoteFileDestReceiverStartup implements the rStartup interface of
 * RemoteFileDestReceiver. It opens connections to the nodes in initialNodeList,
 * and sends the COPY command on all connections.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RemoteFileDestReceiverStartup</name><parameter_list>(<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>operation</name></decl></parameter>,
							  <parameter><decl><type><name>TupleDesc</name></type> <name>inputTupleDescriptor</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RemoteFileDestReceiver</name> <modifier>*</modifier></type><name>resultDest</name> <init>= <expr><operator>(</operator><name>RemoteFileDestReceiver</name> <operator>*</operator><operator>)</operator> <name>dest</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>delimiterCharacter</name> <init>= <expr><literal type="string">"\t"</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nullPrintCharacter</name> <init>= <expr><literal type="string">"\\N"</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>resultDest</name><operator>-&gt;</operator><name>tupleDescriptor</name></name> <operator>=</operator> <name>inputTupleDescriptor</name></expr>;</expr_stmt>

	<comment type="block">/* define how tuples will be serialised */</comment>
	<decl_stmt><decl><type><name>CopyOutState</name></type> <name>copyOutState</name> <init>= <expr><operator>(</operator><name>CopyOutState</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CopyOutStateData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>copyOutState</name><operator>-&gt;</operator><name>delim</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>delimiterCharacter</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>copyOutState</name><operator>-&gt;</operator><name>null_print</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>nullPrintCharacter</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>copyOutState</name><operator>-&gt;</operator><name>null_print_client</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>nullPrintCharacter</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>copyOutState</name><operator>-&gt;</operator><name>binary</name></name> <operator>=</operator> <call><name>CanUseBinaryCopyFormat</name><argument_list>(<argument><expr><name>inputTupleDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>copyOutState</name><operator>-&gt;</operator><name>fe_msgbuf</name></name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>copyOutState</name><operator>-&gt;</operator><name>rowcontext</name></name> <operator>=</operator> <call><name>GetPerTupleMemoryContext</name><argument_list>(<argument><expr><name><name>resultDest</name><operator>-&gt;</operator><name>executorState</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultDest</name><operator>-&gt;</operator><name>copyOutState</name></name> <operator>=</operator> <name>copyOutState</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>resultDest</name><operator>-&gt;</operator><name>columnOutputFunctions</name></name> <operator>=</operator> <call><name>ColumnOutputFunctions</name><argument_list>(<argument><expr><name>inputTupleDescriptor</name></expr></argument>,
															  <argument><expr><name><name>copyOutState</name><operator>-&gt;</operator><name>binary</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * PrepareIntermediateResultBroadcast gets a RemoteFileDestReceiver and does
 * the necessary initilizations including initiating the remote connections
 * and creating the local file, which is necessary (it might be both).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>PrepareIntermediateResultBroadcast</name><parameter_list>(<parameter><decl><type><name>RemoteFileDestReceiver</name> <modifier>*</modifier></type><name>resultDest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>initialNodeList</name> <init>= <expr><name><name>resultDest</name><operator>-&gt;</operator><name>initialNodeList</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>resultId</name> <init>= <expr><name><name>resultDest</name><operator>-&gt;</operator><name>resultId</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>connectionList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CopyOutState</name></type> <name>copyOutState</name> <init>= <expr><name><name>resultDest</name><operator>-&gt;</operator><name>copyOutState</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>resultDest</name><operator>-&gt;</operator><name>writeLocalFile</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>fileFlags</name> <init>= <expr><operator>(</operator><name>O_APPEND</name> <operator>|</operator> <name>O_CREAT</name> <operator>|</operator> <name>O_RDWR</name> <operator>|</operator> <name>O_TRUNC</name> <operator>|</operator> <name>PG_BINARY</name><operator>)</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>fileMode</name> <init>= <expr><operator>(</operator><name>S_IRUSR</name> <operator>|</operator> <name>S_IWUSR</name><operator>)</operator></expr></init></decl>;</decl_stmt>

		<comment type="block">/* make sure the directory exists */</comment>
		<expr_stmt><expr><call><name>CreateIntermediateResultsDirectory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fileName</name> <init>= <expr><call><name>QueryResultFileName</name><argument_list>(<argument><expr><name>resultId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>resultDest</name><operator>-&gt;</operator><name>fileCompat</name></name> <operator>=</operator> <call><name>FileCompatFromFileStart</name><argument_list>(<argument><expr><call><name>FileOpenForTransmit</name><argument_list>(<argument><expr><name>fileName</name></expr></argument>,
																			 <argument><expr><name>fileFlags</name></expr></argument>,
																			 <argument><expr><name>fileMode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>workerNode</argument>, <argument>initialNodeList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nodeName</name> <init>= <expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>nodePort</name> <init>= <expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><call><name>StartNodeConnection</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr><name>nodeName</name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ClaimConnectionExclusively</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MarkRemoteTransactionCritical</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>connectionList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>connectionList</name></expr></argument>, <argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>FinishConnectionListEstablishment</name><argument_list>(<argument><expr><name>connectionList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* must open transaction blocks to use intermediate results */</comment>
	<expr_stmt><expr><call><name>RemoteTransactionsBeginIfNecessary</name><argument_list>(<argument><expr><name>connectionList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>connection</argument>, <argument>connectionList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>StringInfo</name></type> <name>copyCommand</name> <init>= <expr><call><name>ConstructCopyResultStatement</name><argument_list>(<argument><expr><name>resultId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>bool</name></type> <name>querySent</name> <init>= <expr><call><name>SendRemoteCommand</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name><name>copyCommand</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>querySent</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ReportConnectionError</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<macro><name>foreach_ptr</name><argument_list>(<argument>connection</argument>, <argument>connectionList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>raiseInterrupts</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>GetRemoteCommandResult</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>raiseInterrupts</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COPY_IN</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ReportResultError</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name><name>copyOutState</name><operator>-&gt;</operator><name>binary</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* send headers when using binary encoding */</comment>
		<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><name><name>copyOutState</name><operator>-&gt;</operator><name>fe_msgbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AppendCopyBinaryHeaders</name><argument_list>(<argument><expr><name>copyOutState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>BroadcastCopyData</name><argument_list>(<argument><expr><name><name>copyOutState</name><operator>-&gt;</operator><name>fe_msgbuf</name></name></expr></argument>, <argument><expr><name>connectionList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>resultDest</name><operator>-&gt;</operator><name>writeLocalFile</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>WriteToLocalFile</name><argument_list>(<argument><expr><name><name>copyOutState</name><operator>-&gt;</operator><name>fe_msgbuf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>resultDest</name><operator>-&gt;</operator><name>fileCompat</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>resultDest</name><operator>-&gt;</operator><name>connectionList</name></name> <operator>=</operator> <name>connectionList</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ConstructCopyResultStatement constructs the text of a COPY statement
 * for copying into a result file.
 */</comment>
<function><type><specifier>static</specifier> <name>StringInfo</name></type>
<name>ConstructCopyResultStatement</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>resultId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>command</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><literal type="string">"COPY \"%s\" FROM STDIN WITH (format result)"</literal></expr></argument>,
					 <argument><expr><name>resultId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>command</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RemoteFileDestReceiverReceive implements the receiveSlot function of
 * RemoteFileDestReceiver. It takes a TupleTableSlot and sends the contents to
 * all worker nodes.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>RemoteFileDestReceiverReceive</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RemoteFileDestReceiver</name> <modifier>*</modifier></type><name>resultDest</name> <init>= <expr><operator>(</operator><name>RemoteFileDestReceiver</name> <operator>*</operator><operator>)</operator> <name>dest</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>resultDest</name><operator>-&gt;</operator><name>tuplesSent</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 *  We get the first tuple, lets initialize the remote connections
		 *  and/or the local file.
		 */</comment>
		<expr_stmt><expr><call><name>PrepareIntermediateResultBroadcast</name><argument_list>(<argument><expr><name>resultDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name> <init>= <expr><name><name>resultDest</name><operator>-&gt;</operator><name>tupleDescriptor</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>connectionList</name> <init>= <expr><name><name>resultDest</name><operator>-&gt;</operator><name>connectionList</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CopyOutState</name></type> <name>copyOutState</name> <init>= <expr><name><name>resultDest</name><operator>-&gt;</operator><name>copyOutState</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>columnOutputFunctions</name> <init>= <expr><name><name>resultDest</name><operator>-&gt;</operator><name>columnOutputFunctions</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>StringInfo</name></type> <name>copyData</name> <init>= <expr><name><name>copyOutState</name><operator>-&gt;</operator><name>fe_msgbuf</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>EState</name> <modifier>*</modifier></type><name>executorState</name> <init>= <expr><name><name>resultDest</name><operator>-&gt;</operator><name>executorState</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>executorTupleContext</name> <init>= <expr><call><name>GetPerTupleMemoryContext</name><argument_list>(<argument><expr><name>executorState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>executorTupleContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>slot_getallattrs</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>columnValues</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>columnNulls</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><name>copyData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* construct row in COPY format */</comment>
	<expr_stmt><expr><call><name>AppendCopyRowData</name><argument_list>(<argument><expr><name>columnValues</name></expr></argument>, <argument><expr><name>columnNulls</name></expr></argument>, <argument><expr><name>tupleDescriptor</name></expr></argument>,
					  <argument><expr><name>copyOutState</name></expr></argument>, <argument><expr><name>columnOutputFunctions</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* send row to nodes */</comment>
	<expr_stmt><expr><call><name>BroadcastCopyData</name><argument_list>(<argument><expr><name>copyData</name></expr></argument>, <argument><expr><name>connectionList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* write to local file (if applicable) */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>resultDest</name><operator>-&gt;</operator><name>writeLocalFile</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>WriteToLocalFile</name><argument_list>(<argument><expr><name><name>copyOutState</name><operator>-&gt;</operator><name>fe_msgbuf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>resultDest</name><operator>-&gt;</operator><name>fileCompat</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>resultDest</name><operator>-&gt;</operator><name>tuplesSent</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultDest</name><operator>-&gt;</operator><name>bytesSent</name></name> <operator>+=</operator> <name><name>copyData</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ResetPerTupleExprContext</name><argument_list>(<argument><expr><name>executorState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * WriteToLocalResultsFile writes the bytes in a StringInfo to a local file.
 */</comment>
<function><type><name>void</name></type>
<name>WriteToLocalFile</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>copyData</name></decl></parameter>, <parameter><decl><type><name>FileCompat</name> <modifier>*</modifier></type><name>fileCompat</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>bytesWritten</name> <init>= <expr><call><name>FileWriteCompat</name><argument_list>(<argument><expr><name>fileCompat</name></expr></argument>, <argument><expr><name><name>copyData</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
									   <argument><expr><name><name>copyData</name><operator>-&gt;</operator><name>len</name></name></expr></argument>,
									   <argument><expr><name>PG_WAIT_IO</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>bytesWritten</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not append to file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * RemoteFileDestReceiverShutdown implements the rShutdown interface of
 * RemoteFileDestReceiver. It ends the COPY on all the open connections and closes
 * the relation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RemoteFileDestReceiverShutdown</name><parameter_list>(<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>destReceiver</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RemoteFileDestReceiver</name> <modifier>*</modifier></type><name>resultDest</name> <init>= <expr><operator>(</operator><name>RemoteFileDestReceiver</name> <operator>*</operator><operator>)</operator> <name>destReceiver</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>resultDest</name><operator>-&gt;</operator><name>tuplesSent</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 *  We have not received any tuples (when the intermediate result
		 *  returns zero rows). Still, we want to create the necessary
		 *  intermediate result files even if they are empty, as the query
		 *  execution requires the files to be present.
		 */</comment>
		<expr_stmt><expr><call><name>PrepareIntermediateResultBroadcast</name><argument_list>(<argument><expr><name>resultDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>connectionList</name> <init>= <expr><name><name>resultDest</name><operator>-&gt;</operator><name>connectionList</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CopyOutState</name></type> <name>copyOutState</name> <init>= <expr><name><name>resultDest</name><operator>-&gt;</operator><name>copyOutState</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>copyOutState</name><operator>-&gt;</operator><name>binary</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* send footers when using binary encoding */</comment>
		<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><name><name>copyOutState</name><operator>-&gt;</operator><name>fe_msgbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AppendCopyBinaryFooters</name><argument_list>(<argument><expr><name>copyOutState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>BroadcastCopyData</name><argument_list>(<argument><expr><name><name>copyOutState</name><operator>-&gt;</operator><name>fe_msgbuf</name></name></expr></argument>, <argument><expr><name>connectionList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>resultDest</name><operator>-&gt;</operator><name>writeLocalFile</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>WriteToLocalFile</name><argument_list>(<argument><expr><name><name>copyOutState</name><operator>-&gt;</operator><name>fe_msgbuf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>resultDest</name><operator>-&gt;</operator><name>fileCompat</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* close the COPY input */</comment>
	<expr_stmt><expr><call><name>EndRemoteCopy</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>connectionList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>resultDest</name><operator>-&gt;</operator><name>writeLocalFile</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>FileClose</name><argument_list>(<argument><expr><name><name>resultDest</name><operator>-&gt;</operator><name>fileCompat</name><operator>.</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * BroadcastCopyData sends copy data to all connections in a list.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>BroadcastCopyData</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>dataBuffer</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>connectionList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>connection</argument>, <argument>connectionList</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SendCopyDataOverConnection</name><argument_list>(<argument><expr><name>dataBuffer</name></expr></argument>, <argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * SendCopyDataOverConnection sends serialized COPY data over the given
 * connection.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SendCopyDataOverConnection</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>dataBuffer</name></decl></parameter>, <parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PutRemoteCopyData</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name><name>dataBuffer</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>dataBuffer</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReportConnectionError</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * RemoteFileDestReceiverDestroy frees memory allocated as part of the
 * RemoteFileDestReceiver and closes file descriptors.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RemoteFileDestReceiverDestroy</name><parameter_list>(<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>destReceiver</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RemoteFileDestReceiver</name> <modifier>*</modifier></type><name>resultDest</name> <init>= <expr><operator>(</operator><name>RemoteFileDestReceiver</name> <operator>*</operator><operator>)</operator> <name>destReceiver</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>resultDest</name><operator>-&gt;</operator><name>copyOutState</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>resultDest</name><operator>-&gt;</operator><name>copyOutState</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>resultDest</name><operator>-&gt;</operator><name>columnOutputFunctions</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>resultDest</name><operator>-&gt;</operator><name>columnOutputFunctions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>resultDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * SendQueryResultViaCopy is called when a COPY "resultid" TO STDOUT
 * WITH (format result) command is received from the client. The
 * contents of the file are sent directly to the client.
 */</comment>
<function><type><name>void</name></type>
<name>SendQueryResultViaCopy</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>resultId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>resultFileName</name> <init>= <expr><call><name>QueryResultFileName</name><argument_list>(<argument><expr><name>resultId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SendRegularFile</name><argument_list>(<argument><expr><name>resultFileName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ReceiveQueryResultViaCopy is called when a COPY "resultid" FROM
 * STDIN WITH (format result) command is received from the client.
 * The command is followed by the raw copy data stream, which is
 * redirected to a file.
 *
 * File names are automatically prefixed with the user OID. Users
 * are only allowed to read query results from their own directory.
 */</comment>
<function><type><name>void</name></type>
<name>ReceiveQueryResultViaCopy</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>resultId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CreateIntermediateResultsDirectory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>resultFileName</name> <init>= <expr><call><name>QueryResultFileName</name><argument_list>(<argument><expr><name>resultId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>RedirectCopyDataToRegularFile</name><argument_list>(<argument><expr><name>resultFileName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CreateIntermediateResultsDirectory creates the intermediate result
 * directory for the current transaction if it does not exist and ensures
 * that the directory is removed at the end of the transaction.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>CreateIntermediateResultsDirectory</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>resultDirectory</name> <init>= <expr><call><name>IntermediateResultsDirectory</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>makeOK</name> <init>= <expr><call><name>mkdir</name><argument_list>(<argument><expr><name>resultDirectory</name></expr></argument>, <argument><expr><name>S_IRWXU</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>makeOK</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EEXIST</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* someone else beat us to it, that's ok */</comment>
			<return>return <expr><name>resultDirectory</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create intermediate results directory "</literal>
							   <literal type="string">"\"%s\": %m"</literal></expr></argument>,
							   <argument><expr><name>resultDirectory</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>CreatedResultsDirectories</name> <operator>=</operator>
		<call><name>lappend</name><argument_list>(<argument><expr><name>CreatedResultsDirectories</name></expr></argument>, <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>resultDirectory</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>resultDirectory</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * QueryResultFileName returns the file name in which to store
 * an intermediate result with the given key in the per transaction
 * result directory.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>QueryResultFileName</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>resultId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>resultFileName</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>resultDirectory</name> <init>= <expr><call><name>IntermediateResultsDirectory</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>checkChar</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>resultId</name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init>;</init> <condition><expr><operator>*</operator><name>checkChar</name></expr>;</condition> <incr><expr><name>checkChar</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><operator>*</operator><name>checkChar</name> <operator>&gt;=</operator> <literal type="char">'a'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>checkChar</name> <operator>&lt;=</operator> <literal type="char">'z'</literal><operator>)</operator> <operator>||</operator>
			  <operator>(</operator><operator>*</operator><name>checkChar</name> <operator>&gt;=</operator> <literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>checkChar</name> <operator>&lt;=</operator> <literal type="char">'Z'</literal><operator>)</operator> <operator>||</operator>
			  <operator>(</operator><operator>*</operator><name>checkChar</name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>checkChar</name> <operator>&lt;=</operator> <literal type="char">'9'</literal><operator>)</operator> <operator>||</operator>
			  <operator>(</operator><operator>*</operator><name>checkChar</name> <operator>==</operator> <literal type="char">'_'</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><operator>*</operator><name>checkChar</name> <operator>==</operator> <literal type="char">'-'</literal><operator>)</operator><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_NAME</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"result key \"%s\" contains invalid character"</literal></expr></argument>,
								   <argument><expr><name>resultId</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Result keys may only contain letters, numbers, "</literal>
									<literal type="string">"underscores and hyphens."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>resultFileName</name></expr></argument>, <argument><expr><literal type="string">"%s/%s.data"</literal></expr></argument>,
					 <argument><expr><name>resultDirectory</name></expr></argument>, <argument><expr><name>resultId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>resultFileName</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IntermediateResultsDirectory returns the directory to use for a query result
 * file with a particular key. The filename includes the user OID, such
 * that users can never read each other's files.
 *
 * In a distributed transaction, the directory has the form:
 * base/pgsql_job_cache/&lt;user id&gt;_&lt;coordinator node id&gt;_&lt;transaction number&gt;/
 *
 * In a non-distributed transaction, the directory has the form:
 * base/pgsql_job_cache/&lt;user id&gt;_&lt;process id&gt;/
 *
 * The latter form can be used for testing COPY ... WITH (format result) without
 * assigning a distributed transaction ID.
 *
 * The pgsql_job_cache directory is emptied on restart in case of failure.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>IntermediateResultsDirectory</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>resultFileName</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>userId</name> <init>= <expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DistributedTransactionId</name> <modifier>*</modifier></type><name>transactionId</name> <init>= <expr><call><name>GetCurrentDistributedTransactionId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>initiatorNodeIdentifier</name> <init>= <expr><name><name>transactionId</name><operator>-&gt;</operator><name>initiatorNodeIdentifier</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>transactionNumber</name> <init>= <expr><name><name>transactionId</name><operator>-&gt;</operator><name>transactionNumber</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>transactionNumber</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>resultFileName</name></expr></argument>, <argument><expr><literal type="string">"base/"</literal> <name>PG_JOB_CACHE_DIR</name> <literal type="string">"/%u_%u_%lu"</literal></expr></argument>,
						 <argument><expr><name>userId</name></expr></argument>, <argument><expr><name>initiatorNodeIdentifier</name></expr></argument>, <argument><expr><name>transactionNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>resultFileName</name></expr></argument>, <argument><expr><literal type="string">"base/"</literal> <name>PG_JOB_CACHE_DIR</name> <literal type="string">"/%u_%u"</literal></expr></argument>,
						 <argument><expr><name>userId</name></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name><name>resultFileName</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RemoveIntermediateResultsDirectories removes the intermediate result directory
 * for the current distributed transaction, if any was created.
 */</comment>
<function><type><name>void</name></type>
<name>RemoveIntermediateResultsDirectories</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>directoryElement</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>directoryElement</argument>, <argument>CreatedResultsDirectories</argument>)</argument_list></macro>
	<block>{<block_content>
		<comment type="block">/*
		 * The shared directory is renamed before deleting it. Otherwise it
		 * would be possible for another backend to write a file, while we are
		 * deleting the directory. Since rename is atomic by POSIX standards
		 * that's not possible. The current PID is included in the new
		 * filename, so there can be no collisions with other backends.
		 */</comment>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sharedName</name> <init>= <expr><name>directoryElement</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StringInfo</name></type> <name>privateName</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>privateName</name></expr></argument>, <argument><expr><literal type="string">"%s.removed-by-%d"</literal></expr></argument>, <argument><expr><name>sharedName</name></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>rename</name><argument_list>(<argument><expr><name>sharedName</name></expr></argument>, <argument><expr><name><name>privateName</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(
						 <argument><expr><literal type="string">"could not rename intermediate results directory \"%s\" to \"%s\": %m"</literal></expr></argument>,
						 <argument><expr><name>sharedName</name></expr></argument>, <argument><expr><name><name>privateName</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* rename failed for some reason, we do a best effort removal of
			 * the shared directory */</comment>

			<expr_stmt><expr><call><name>PathNameDeleteTemporaryDir</name><argument_list>(<argument><expr><name>sharedName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>PathNameDeleteTemporaryDir</name><argument_list>(<argument><expr><name><name>privateName</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/* cleanup */</comment>
	<expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name>CreatedResultsDirectories</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>CreatedResultsDirectories</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * IntermediateResultSize returns the file size of the intermediate result
 * or -1 if the file does not exist.
 */</comment>
<function><type><name>int64</name></type>
<name>IntermediateResultSize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>resultId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>fileStat</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>resultFileName</name> <init>= <expr><call><name>QueryResultFileName</name><argument_list>(<argument><expr><name>resultId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>statOK</name> <init>= <expr><call><name>stat</name><argument_list>(<argument><expr><name>resultFileName</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fileStat</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>statOK</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><operator>(</operator><name>int64</name><operator>)</operator> <name><name>fileStat</name><operator>.</operator><name>st_size</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * read_intermediate_result is a UDF that returns a COPY-formatted intermediate
 * result file as a set of records. The file is parsed according to the columns
 * definition list specified by the user, e.g.:
 *
 * SELECT * FROM read_intermediate_result('foo', 'csv') AS (a int, b int)
 *
 * The file is read from the directory returned by IntermediateResultsDirectory,
 * which includes the user ID.
 *
 * read_intermediate_result is a volatile function because it cannot be
 * evaluated until execution time, but for distributed planning purposes we can
 * treat it in the same way as immutable functions and reference tables, since
 * we know it will return the same result on all nodes.
 */</comment>
<function><type><name>Datum</name></type>
<name>read_intermediate_result</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Datum</name></type> <name>resultId</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>copyFormatOidDatum</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>copyFormatLabelDatum</name> <init>= <expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>enum_out</name></expr></argument>, <argument><expr><name>copyFormatOidDatum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>copyFormatLabel</name> <init>= <expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><name>copyFormatLabelDatum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ReadIntermediateResultsIntoFuncOutput</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>copyFormatLabel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>resultId</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * read_intermediate_result_array returns the set of records in a set of given
 * COPY-formatted intermediate result files.
 *
 * The usage and semantics of this is same as read_intermediate_result(), except
 * that its first argument is an array of result ids.
 */</comment>
<function><type><name>Datum</name></type>
<name>read_intermediate_result_array</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>resultIdObject</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>copyFormatOidDatum</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Datum</name></type> <name>copyFormatLabelDatum</name> <init>= <expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>enum_out</name></expr></argument>, <argument><expr><name>copyFormatOidDatum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>copyFormatLabel</name> <init>= <expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><name>copyFormatLabelDatum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int32</name></type> <name>resultCount</name> <init>= <expr><call><name>ArrayGetNItems</name><argument_list>(<argument><expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>resultIdObject</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ARR_DIMS</name><argument_list>(
										   <argument><expr><name>resultIdObject</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>resultIdArray</name> <init>= <expr><call><name>DeconstructArrayObject</name><argument_list>(<argument><expr><name>resultIdObject</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ReadIntermediateResultsIntoFuncOutput</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>copyFormatLabel</name></expr></argument>,
										  <argument><expr><name>resultIdArray</name></expr></argument>, <argument><expr><name>resultCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ReadIntermediateResultsIntoFuncOutput reads the given result files and stores
 * them at the function's output tuple store. Errors out if any of the result files
 * don't exist.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReadIntermediateResultsIntoFuncOutput</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>copyFormat</name></decl></parameter>,
									  <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>resultIdArray</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>resultCount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tupleStore</name> <init>= <expr><call><name>SetupTuplestore</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupleDescriptor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>resultIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>resultIndex</name> <operator>&lt;</operator> <name>resultCount</name></expr>;</condition> <incr><expr><name>resultIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>resultId</name> <init>= <expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name><name>resultIdArray</name><index>[<expr><name>resultIndex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>resultFileName</name> <init>= <expr><call><name>QueryResultFileName</name><argument_list>(<argument><expr><name>resultId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>fileStat</name></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>int</name></type> <name>statOK</name> <init>= <expr><call><name>stat</name><argument_list>(<argument><expr><name>resultFileName</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fileStat</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>statOK</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * When the file does not exist, it could mean two different things.
			 * First -- and a lot more common -- case is that a failure happened
			 * in a concurrent backend on the same distributed transaction. And,
			 * one of the backends in that transaction has already been roll
			 * backed, which has already removed the file. If we throw an error
			 * here, the user might see this error instead of the actual error
			 * message. Instead, we prefer to WARN the user and pretend that the
			 * file has no data in it. In the end, the user would see the actual
			 * error message for the failure.
			 *
			 * Second, in case of any bugs in intermediate result broadcasts,
			 * we could try to read a non-existing file. That is most likely
			 * to happen during development.
			 */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CITUS_INTERMEDIATE_RESULT_NOT_FOUND</name></expr></argument>)</argument_list></call><operator>,</operator>
							  <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Query could not find the intermediate result file "</literal>
									 <literal type="string">"\"%s\", it was mostly likely deleted due to an "</literal>
									 <literal type="string">"error in a parallel process within the same "</literal>
									 <literal type="string">"distributed transaction"</literal></expr></argument>, <argument><expr><name>resultId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ReadFileIntoTupleStore</name><argument_list>(<argument><expr><name>resultFileName</name></expr></argument>, <argument><expr><name>copyFormat</name></expr></argument>, <argument><expr><name>tupleDescriptor</name></expr></argument>,
								   <argument><expr><name>tupleStore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>


<comment type="block">/*
 * fetch_intermediate_results fetches a set of intermediate results defined in an
 * array of result IDs from a remote node and writes them to a local intermediate
 * result with the same ID.
 */</comment>
<function><type><name>Datum</name></type>
<name>fetch_intermediate_results</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>resultIdObject</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>resultIdArray</name> <init>= <expr><call><name>DeconstructArrayObject</name><argument_list>(<argument><expr><name>resultIdObject</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>resultCount</name> <init>= <expr><call><name>ArrayObjectCount</name><argument_list>(<argument><expr><name>resultIdObject</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>remoteHostText</name> <init>= <expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>remoteHost</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><name>remoteHostText</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>remotePort</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>connectionFlags</name> <init>= <expr><name>FORCE_NEW_CONNECTION</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>resultIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>totalBytesWritten</name> <init>= <expr><literal type="number">0L</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>resultCount</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsMultiStatementTransaction</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"fetch_intermediate_results can only be used in a "</literal>
							   <literal type="string">"distributed transaction"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Make sure that this transaction has a distributed transaction ID.
	 *
	 * Intermediate results will be stored in a directory that is derived
	 * from the distributed transaction ID.
	 */</comment>
	<expr_stmt><expr><call><name>EnsureDistributedTransactionId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><call><name>GetNodeConnection</name><argument_list>(<argument><expr><name>connectionFlags</name></expr></argument>, <argument><expr><name>remoteHost</name></expr></argument>,
													<argument><expr><name>remotePort</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PQstatus</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CONNECTION_OK</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot connect to %s:%d to fetch intermediate results"</literal></expr></argument>,
							   <argument><expr><name>remoteHost</name></expr></argument>, <argument><expr><name>remotePort</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>StringInfo</name></type> <name>beginAndSetXactId</name> <init>= <expr><call><name>BeginAndSetDistributedTransactionIdCommand</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ExecuteCriticalRemoteCommand</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name><name>beginAndSetXactId</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CreateIntermediateResultsDirectory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>resultIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>resultIndex</name> <operator>&lt;</operator> <name>resultCount</name></expr>;</condition> <incr><expr><name>resultIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>resultId</name> <init>= <expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name><name>resultIdArray</name><index>[<expr><name>resultIndex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>totalBytesWritten</name> <operator>+=</operator> <call><name>FetchRemoteIntermediateResult</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>resultId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>ExecuteCriticalRemoteCommand</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><literal type="string">"END"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CloseConnection</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><name>totalBytesWritten</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * FetchRemoteIntermediateResult fetches a remote intermediate result over
 * the given connection.
 */</comment>
<function><type><specifier>static</specifier> <name>uint64</name></type>
<name>FetchRemoteIntermediateResult</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>resultId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>localPath</name> <init>= <expr><call><name>QueryResultFileName</name><argument_list>(<argument><expr><name>resultId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>fileStat</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>statOK</name> <init>= <expr><call><name>stat</name><argument_list>(<argument><expr><name>localPath</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fileStat</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>statOK</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * File exists, most likely because we are trying to fetch a
		 * a file from a node to itself. Skip doing work.
		 */</comment>
		<return>return <expr><name><name>fileStat</name><operator>.</operator><name>st_size</name></name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>uint64</name></type> <name>totalBytesWritten</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>StringInfo</name></type> <name>copyCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>fileFlags</name> <init>= <expr><operator>(</operator><name>O_APPEND</name> <operator>|</operator> <name>O_CREAT</name> <operator>|</operator> <name>O_RDWR</name> <operator>|</operator> <name>O_TRUNC</name> <operator>|</operator> <name>PG_BINARY</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>fileMode</name> <init>= <expr><operator>(</operator><name>S_IRUSR</name> <operator>|</operator> <name>S_IWUSR</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>pgConn</name> <init>= <expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>socket</name> <init>= <expr><call><name>PQsocket</name><argument_list>(<argument><expr><name>pgConn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>raiseErrors</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>copyCommand</name></expr></argument>, <argument><expr><literal type="string">"COPY \"%s\" TO STDOUT WITH (format result)"</literal></expr></argument>,
					 <argument><expr><name>resultId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SendRemoteCommand</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name><name>copyCommand</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReportConnectionError</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>GetRemoteCommandResult</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>raiseErrors</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COPY_OUT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReportResultError</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>File</name></type> <name>fileDesc</name> <init>= <expr><call><name>FileOpenForTransmit</name><argument_list>(<argument><expr><name>localPath</name></expr></argument>, <argument><expr><name>fileFlags</name></expr></argument>, <argument><expr><name>fileMode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FileCompat</name></type> <name>fileCompat</name> <init>= <expr><call><name>FileCompatFromFileStart</name><argument_list>(<argument><expr><name>fileDesc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>waitFlags</name> <init>= <expr><name>WL_SOCKET_READABLE</name> <operator>|</operator> <name>WL_POSTMASTER_DEATH</name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>CopyStatus</name></type> <name>copyStatus</name> <init>= <expr><call><name>CopyDataFromConnection</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fileCompat</name></expr></argument>,
													   <argument><expr><operator>&amp;</operator><name>totalBytesWritten</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>copyStatus</name> <operator>==</operator> <name>CLIENT_COPY_FAILED</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failed to read result \"%s\" from node %s:%d"</literal></expr></argument>,
								   <argument><expr><name>resultId</name></expr></argument>, <argument><expr><name><name>connection</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>, <argument><expr><name><name>connection</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>copyStatus</name> <operator>==</operator> <name>CLIENT_COPY_DONE</name></expr>)</condition>
		<block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>copyStatus</name> <operator>==</operator> <name>CLIENT_COPY_MORE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>WaitLatchOrSocket</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>, <argument><expr><name>waitFlags</name></expr></argument>, <argument><expr><name>socket</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>PG_WAIT_EXTENSION</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&amp;</operator> <name>WL_POSTMASTER_DEATH</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"postmaster was shut down, exiting"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&amp;</operator> <name>WL_LATCH_SET</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>FileClose</name><argument_list>(<argument><expr><name>fileDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ClearResults</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>raiseErrors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>totalBytesWritten</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CopyDataFromConnection reads a row of copy data from connection and writes it
 * to the given file.
 */</comment>
<function><type><specifier>static</specifier> <name>CopyStatus</name></type>
<name>CopyDataFromConnection</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>, <parameter><decl><type><name>FileCompat</name> <modifier>*</modifier></type><name>fileCompat</name></decl></parameter>,
					   <parameter><decl><type><name>uint64</name> <modifier>*</modifier></type><name>bytesReceived</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Consume input to handle the case where previous copy operation might have
	 * received zero bytes.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>consumed</name> <init>= <expr><call><name>PQconsumeInput</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>consumed</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>CLIENT_COPY_FAILED</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* receive copy data message in an asynchronous manner */</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>receiveBuffer</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>asynchronous</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>receiveLength</name> <init>= <expr><call><name>PQgetCopyData</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>receiveBuffer</name></expr></argument>, <argument><expr><name>asynchronous</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><name>receiveLength</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* received copy data; append these data to file */</comment>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>int</name></type> <name>bytesWritten</name> <init>= <expr><call><name>FileWriteCompat</name><argument_list>(<argument><expr><name>fileCompat</name></expr></argument>, <argument><expr><name>receiveBuffer</name></expr></argument>,
										   <argument><expr><name>receiveLength</name></expr></argument>, <argument><expr><name>PG_WAIT_IO</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>bytesWritten</name> <operator>!=</operator> <name>receiveLength</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not append to file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><operator>*</operator><name>bytesReceived</name> <operator>+=</operator> <name>receiveLength</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PQfreemem</name><argument_list>(<argument><expr><name>receiveBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>receiveLength</name> <operator>=</operator> <call><name>PQgetCopyData</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>receiveBuffer</name></expr></argument>, <argument><expr><name>asynchronous</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>receiveLength</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* we cannot read more data without blocking */</comment>
		<return>return <expr><name>CLIENT_COPY_MORE</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>receiveLength</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* received copy done message */</comment>
		<decl_stmt><decl><type><name>bool</name></type> <name>raiseInterrupts</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>GetRemoteCommandResult</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>raiseInterrupts</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ExecStatusType</name></type> <name>resultStatus</name> <init>= <expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CopyStatus</name></type> <name>copyStatus</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>resultStatus</name> <operator>==</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>copyStatus</name> <operator>=</operator> <name>CLIENT_COPY_DONE</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>copyStatus</name> <operator>=</operator> <name>CLIENT_COPY_FAILED</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ReportResultError</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>WARNING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ForgetResults</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>copyStatus</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>receiveLength</name> <operator>==</operator> <operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReportConnectionError</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>WARNING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>CLIENT_COPY_FAILED</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
</unit>
