<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/builded_projects/citus/src/backend/distributed/executor/distributed_intermediate_results.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * distributed_intermediate_results.c
 *   Functions for reading and writing distributed intermediate results.
 *
 * Copyright (c), Citus Data, Inc.
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_version_constants.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"port.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tupdesc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/deparse_shard_query.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/intermediate_results.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_physical_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/transaction_management.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/tuple_destination.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/tuplestore.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/pquery.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>


<comment type="block">/*
 * PartitioningTupleDest is internal representation of a TupleDestination
 * which consumes queries constructed in WrapTasksForPartitioning.
 */</comment>
<typedef>typedef <type><struct>struct <name>PartitioningTupleDest</name>
<block>{
	<decl_stmt><decl><type><name>TupleDestination</name></type> <name>pub</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>targetRelation</name></decl>;</decl_stmt>

	<comment type="block">/* MemoryContext in which we add new fragments */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>fragmentContext</name></decl>;</decl_stmt>

	<comment type="block">/* list of DistributedResultFragment pointer */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>fragmentList</name></decl>;</decl_stmt>

	<comment type="block">/* what do tuples look like */</comment>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl>;</decl_stmt>
}</block></struct></type> <name>PartitioningTupleDest</name>;</typedef>


<comment type="block">/* forward declarations of local functions */</comment>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>WrapTasksForPartitioning</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>resultIdPrefix</name></decl></parameter>,
									   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>selectTaskList</name></decl></parameter>,
									   <parameter><decl><type><name>int</name></type> <name>partitionColumnIndex</name></decl></parameter>,
									   <parameter><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>targetRelation</name></decl></parameter>,
									   <parameter><decl><type><name>bool</name></type> <name>binaryFormat</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>ExecutePartitionTaskList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>partitionTaskList</name></decl></parameter>,
									   <parameter><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>targetRelation</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PartitioningTupleDest</name> <modifier>*</modifier></type> <name>CreatePartitioningTupleDest</name><parameter_list>(
	<parameter><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>targetRelation</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>PartitioningTupleDestPutTuple</name><parameter_list>(<parameter><decl><type><name>TupleDestination</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name></decl></parameter>,
										  <parameter><decl><type><name>int</name></type> <name>placementIndex</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>queryNumber</name></decl></parameter>,
										  <parameter><decl><type><name>HeapTuple</name></type> <name>heapTuple</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>tupleLibpqSize</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleDesc</name></type> <name>PartitioningTupleDestTupleDescForQuery</name><parameter_list>(<parameter><decl><type><name>TupleDestination</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><name>int</name></type>
														<name>queryNumber</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>SourceShardPrefix</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>resultPrefix</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>DistributedResultFragment</name> <modifier>*</modifier></type> <name>TupleToDistributedResultFragment</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>heapTuple</name></decl></parameter>,
																	<parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>,
																	<parameter><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type>
																	<name>targetRelation</name></decl></parameter>,
																	<parameter><decl><type><name>uint32</name></type> <name>sourceNodeId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecuteSelectTasksIntoTupleDest</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name></decl></parameter>,
											<parameter><decl><type><name>TupleDestination</name> <modifier>*</modifier></type><name>tupleDestination</name></decl></parameter>,
											<parameter><decl><type><name>bool</name></type> <name>errorOnAnyFailure</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier><modifier>*</modifier></type> <name>ColocateFragmentsWithRelation</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>fragmentList</name></decl></parameter>,
											 <parameter><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>targetRelation</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>ColocationTransfers</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>fragmentList</name></decl></parameter>,
								  <parameter><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>targetRelation</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>FragmentTransferTaskList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>fragmentListTransfers</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecuteFetchTaskList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>fetchTaskList</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * RedistributeTaskListResults partitions the results of given task list using
 * shard ranges and partition method of given targetRelation, and then colocates
 * the result files with shards.
 *
 * If a shard has a replication factor &gt; 1, corresponding result files are copied
 * to all nodes containing that shard.
 *
 * returnValue[shardIndex] is list of cstrings each of which is a resultId which
 * correspond to targetRelation-&gt;sortedShardIntervalArray[shardIndex].
 *
 * partitionColumnIndex determines the column in the selectTaskList to use for
 * partitioning.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type>
<name>RedistributeTaskListResults</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>resultIdPrefix</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>selectTaskList</name></decl></parameter>,
							<parameter><decl><type><name>int</name></type> <name>partitionColumnIndex</name></decl></parameter>,
							<parameter><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>targetRelation</name></decl></parameter>,
							<parameter><decl><type><name>bool</name></type> <name>binaryFormat</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Make sure that this transaction has a distributed transaction ID.
	 *
	 * Intermediate results will be stored in a directory that is derived
	 * from the distributed transaction ID.
	 */</comment>
	<expr_stmt><expr><call><name>UseCoordinatedTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>fragmentList</name> <init>= <expr><call><name>PartitionTasklistResults</name><argument_list>(<argument><expr><name>resultIdPrefix</name></expr></argument>, <argument><expr><name>selectTaskList</name></expr></argument>,
												  <argument><expr><name>partitionColumnIndex</name></expr></argument>,
												  <argument><expr><name>targetRelation</name></expr></argument>, <argument><expr><name>binaryFormat</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>ColocateFragmentsWithRelation</name><argument_list>(<argument><expr><name>fragmentList</name></expr></argument>, <argument><expr><name>targetRelation</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PartitionTasklistResults executes the given task list, and partitions results
 * of each task based on targetRelation's distribution method and intervals.
 * Each of the result partitions are stored in the node where task was executed,
 * and are named as $resultIdPrefix_from_$sourceShardId_to_$targetShardIndex.
 *
 * Result is list of DistributedResultFragment, each of which represents a
 * partition of results. Empty results are omitted. Therefore, if we have N tasks
 * and target relation has M shards, we will have NxM-(number of empty results)
 * fragments.
 *
 * partitionColumnIndex determines the column in the selectTaskList to use for
 * partitioning.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>PartitionTasklistResults</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>resultIdPrefix</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>selectTaskList</name></decl></parameter>,
						 <parameter><decl><type><name>int</name></type> <name>partitionColumnIndex</name></decl></parameter>,
						 <parameter><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>targetRelation</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>binaryFormat</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCitusTableTypeCacheEntry</name><argument_list>(<argument><expr><name>targetRelation</name></expr></argument>, <argument><expr><name>HASH_DISTRIBUTED</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>IsCitusTableTypeCacheEntry</name><argument_list>(<argument><expr><name>targetRelation</name></expr></argument>, <argument><expr><name>RANGE_DISTRIBUTED</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"repartitioning results of a tasklist is only supported "</literal>
							   <literal type="string">"when target relation is hash or range partitioned."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Make sure that this transaction has a distributed transaction ID.
	 *
	 * Intermediate results will be stored in a directory that is derived
	 * from the distributed transaction ID.
	 */</comment>
	<expr_stmt><expr><call><name>UseCoordinatedTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>selectTaskList</name> <operator>=</operator> <call><name>WrapTasksForPartitioning</name><argument_list>(<argument><expr><name>resultIdPrefix</name></expr></argument>, <argument><expr><name>selectTaskList</name></expr></argument>,
											  <argument><expr><name>partitionColumnIndex</name></expr></argument>, <argument><expr><name>targetRelation</name></expr></argument>,
											  <argument><expr><name>binaryFormat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>ExecutePartitionTaskList</name><argument_list>(<argument><expr><name>selectTaskList</name></expr></argument>, <argument><expr><name>targetRelation</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * WrapTasksForPartitioning wraps the query for each of the tasks by a call
 * to worker_partition_query_result(). Target list of the wrapped query should
 * match the tuple descriptor in ExecutePartitionTaskList().
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>WrapTasksForPartitioning</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>resultIdPrefix</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>selectTaskList</name></decl></parameter>,
						 <parameter><decl><type><name>int</name></type> <name>partitionColumnIndex</name></decl></parameter>,
						 <parameter><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>targetRelation</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>binaryFormat</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>wrappedTaskList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier><modifier>*</modifier></type><name>shardIntervalArray</name> <init>= <expr><name><name>targetRelation</name><operator>-&gt;</operator><name>sortedShardIntervalArray</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>shardCount</name> <init>= <expr><name><name>targetRelation</name><operator>-&gt;</operator><name>shardIntervalArrayLength</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>minValueArray</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>maxValueArray</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>partitionColumn</name> <init>= <expr><name><name>targetRelation</name><operator>-&gt;</operator><name>partitionColumn</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>intervalTypeId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>intervalTypeMod</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>intervalTypeOutFunc</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>intervalTypeVarlena</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>GetIntervalTypeInfo</name><argument_list>(<argument><expr><name><name>targetRelation</name><operator>-&gt;</operator><name>partitionMethod</name></name></expr></argument>, <argument><expr><name>partitionColumn</name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name>intervalTypeId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>intervalTypeMod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name>intervalTypeId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>intervalTypeOutFunc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>intervalTypeVarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ShardMinMaxValueArrays</name><argument_list>(<argument><expr><name>shardIntervalArray</name></expr></argument>, <argument><expr><name>shardCount</name></expr></argument>, <argument><expr><name>intervalTypeOutFunc</name></expr></argument>,
						   <argument><expr><operator>&amp;</operator><name>minValueArray</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>maxValueArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>minValuesString</name> <init>= <expr><call><name>ArrayObjectToString</name><argument_list>(<argument><expr><name>minValueArray</name></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>,
													 <argument><expr><name>intervalTypeMod</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>maxValuesString</name> <init>= <expr><call><name>ArrayObjectToString</name><argument_list>(<argument><expr><name>maxValueArray</name></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>,
													 <argument><expr><name>intervalTypeMod</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>selectTask</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>selectTask</argument>, <argument>selectTaskList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>taskPrefix</name> <init>= <expr><call><name>SourceShardPrefix</name><argument_list>(<argument><expr><name>resultIdPrefix</name></expr></argument>, <argument><expr><name><name>selectTask</name><operator>-&gt;</operator><name>anchorShardId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>partitionMethodString</name> <init>= <expr><ternary><condition><expr><name><name>targetRelation</name><operator>-&gt;</operator><name>partitionMethod</name></name> <operator>==</operator> <literal type="char">'h'</literal></expr> ?</condition><then>
									  <expr><literal type="string">"hash"</literal></expr> </then><else>: <expr><literal type="string">"range"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>binaryFormatString</name> <init>= <expr><ternary><condition><expr><name>binaryFormat</name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>wrappedSelectTask</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>selectTask</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>StringInfo</name></type> <name>wrappedQuery</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>wrappedQuery</name></expr></argument>,
						 <argument><expr><literal type="string">"SELECT partition_index"</literal>
						 <literal type="string">", %s || '_' || partition_index::text "</literal>
						 <literal type="string">", rows_written "</literal>
						 <literal type="string">"FROM worker_partition_query_result"</literal>
						 <literal type="string">"(%s,%s,%d,%s,%s,%s,%s) WHERE rows_written &gt; 0"</literal></expr></argument>,
						 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>taskPrefix</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>taskPrefix</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><call><name>TaskQueryString</name><argument_list>(<argument><expr><name>selectTask</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name>partitionColumnIndex</name></expr></argument>,
						 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>partitionMethodString</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name><name>minValuesString</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>maxValuesString</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
						 <argument><expr><name>binaryFormatString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SetTaskQueryString</name><argument_list>(<argument><expr><name>wrappedSelectTask</name></expr></argument>, <argument><expr><name><name>wrappedQuery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>wrappedTaskList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>wrappedTaskList</name></expr></argument>, <argument><expr><name>wrappedSelectTask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>wrappedTaskList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreatePartitioningTupleDest creates a TupleDestination which consumes results of
 * tasks constructed in WrapTasksForPartitioning.
 */</comment>
<function><type><specifier>static</specifier> <name>PartitioningTupleDest</name> <modifier>*</modifier></type>
<name>CreatePartitioningTupleDest</name><parameter_list>(<parameter><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>targetRelation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>resultColumnCount</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name> <init>= <expr><call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><name>resultColumnCount</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"partition_index"</literal></expr></argument>,
					   <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"result_id"</literal></expr></argument>,
					   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"rows_written"</literal></expr></argument>,
					   <argument><expr><name>INT8OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<decl_stmt><decl><type><name>PartitioningTupleDest</name> <modifier>*</modifier></type><name>tupleDest</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PartitioningTupleDest</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>tupleDest</name><operator>-&gt;</operator><name>targetRelation</name></name> <operator>=</operator> <name>targetRelation</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tupleDest</name><operator>-&gt;</operator><name>tupleDesc</name></name> <operator>=</operator> <name>tupleDescriptor</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tupleDest</name><operator>-&gt;</operator><name>fragmentContext</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tupleDest</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>putTuple</name></name> <operator>=</operator> <name>PartitioningTupleDestPutTuple</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tupleDest</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>tupleDescForQuery</name></name> <operator>=</operator>
		<name>PartitioningTupleDestTupleDescForQuery</name></expr>;</expr_stmt>

	<return>return <expr><name>tupleDest</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PartitioningTupleDestPutTuple implements TupleDestination-&gt;putTuple for
 * PartitioningTupleDest.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>PartitioningTupleDestPutTuple</name><parameter_list>(<parameter><decl><type><name>TupleDestination</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name></decl></parameter>,
							  <parameter><decl><type><name>int</name></type> <name>placementIndex</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>queryNumber</name></decl></parameter>,
							  <parameter><decl><type><name>HeapTuple</name></type> <name>heapTuple</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>tupleLibpqSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PartitioningTupleDest</name> <modifier>*</modifier></type><name>tupleDest</name> <init>= <expr><operator>(</operator><name>PartitioningTupleDest</name> <operator>*</operator><operator>)</operator> <name>self</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>placement</name> <init>= <expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>task</name><operator>-&gt;</operator><name>taskPlacementList</name></name></expr></argument>, <argument><expr><name>placementIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We may be deep inside a nested execution, make sure we can use the
	 * fragment list at the top.
	 */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>tupleDest</name><operator>-&gt;</operator><name>fragmentContext</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>DistributedResultFragment</name> <modifier>*</modifier></type><name>fragment</name> <init>=
		<expr><call><name>TupleToDistributedResultFragment</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>, <argument><expr><name><name>tupleDest</name><operator>-&gt;</operator><name>tupleDesc</name></name></expr></argument>,
										 <argument><expr><name><name>tupleDest</name><operator>-&gt;</operator><name>targetRelation</name></name></expr></argument>,
										 <argument><expr><name><name>placement</name><operator>-&gt;</operator><name>nodeId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>tupleDest</name><operator>-&gt;</operator><name>fragmentList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>tupleDest</name><operator>-&gt;</operator><name>fragmentList</name></name></expr></argument>, <argument><expr><name>fragment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * PartitioningTupleDestTupleDescForQuery implements TupleDestination-&gt;TupleDescForQuery
 * for PartitioningTupleDest.
 */</comment>
<function><type><specifier>static</specifier> <name>TupleDesc</name></type>
<name>PartitioningTupleDestTupleDescForQuery</name><parameter_list>(<parameter><decl><type><name>TupleDestination</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>queryNumber</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>queryNumber</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>PartitioningTupleDest</name> <modifier>*</modifier></type><name>tupleDest</name> <init>= <expr><operator>(</operator><name>PartitioningTupleDest</name> <operator>*</operator><operator>)</operator> <name>self</name></expr></init></decl>;</decl_stmt>

	<return>return <expr><name><name>tupleDest</name><operator>-&gt;</operator><name>tupleDesc</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SourceShardPrefix returns result id prefix for partitions which have the
 * given anchor shard id.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>SourceShardPrefix</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>resultPrefix</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>taskPrefix</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>taskPrefix</name></expr></argument>, <argument><expr><literal type="string">"%s_from_"</literal> <name>UINT64_FORMAT</name> <literal type="string">"_to"</literal></expr></argument>, <argument><expr><name>resultPrefix</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>taskPrefix</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ShardMinMaxValueArrays returns min values and max values of given shard
 * intervals. Returned arrays are text arrays.
 */</comment>
<function><type><name>void</name></type>
<name>ShardMinMaxValueArrays</name><parameter_list>(<parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier><modifier>*</modifier></type><name>shardIntervalArray</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>shardCount</name></decl></parameter>,
					   <parameter><decl><type><name>Oid</name></type> <name>intervalTypeOutFunc</name></decl></parameter>, <parameter><decl><type><name>ArrayType</name> <modifier>*</modifier><modifier>*</modifier></type><name>minValueArray</name></decl></parameter>,
					   <parameter><decl><type><name>ArrayType</name> <modifier>*</modifier><modifier>*</modifier></type><name>maxValueArray</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>minValues</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><name>shardCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>minValueNulls</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><name>shardCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>maxValues</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><name>shardCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>maxValueNulls</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><name>shardCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>shardIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>shardIndex</name> <operator>&lt;</operator> <name>shardCount</name></expr>;</condition> <incr><expr><name>shardIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>minValueNulls</name><index>[<expr><name>shardIndex</name></expr>]</index></name> <operator>=</operator> <operator>!</operator><name><name>shardIntervalArray</name><index>[<expr><name>shardIndex</name></expr>]</index></name><operator>-&gt;</operator><name>minValueExists</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>maxValueNulls</name><index>[<expr><name>shardIndex</name></expr>]</index></name> <operator>=</operator> <operator>!</operator><name><name>shardIntervalArray</name><index>[<expr><name>shardIndex</name></expr>]</index></name><operator>-&gt;</operator><name>maxValueExists</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>minValueNulls</name><index>[<expr><name>shardIndex</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type> <name>minValue</name> <init>= <expr><name><name>shardIntervalArray</name><index>[<expr><name>shardIndex</name></expr>]</index></name><operator>-&gt;</operator><name>minValue</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>minValueStr</name> <init>= <expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>OidFunctionCall1</name><argument_list>(<argument><expr><name>intervalTypeOutFunc</name></expr></argument>,
																 <argument><expr><name>minValue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>minValues</name><index>[<expr><name>shardIndex</name></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>minValueStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>maxValueNulls</name><index>[<expr><name>shardIndex</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type> <name>maxValue</name> <init>= <expr><name><name>shardIntervalArray</name><index>[<expr><name>shardIndex</name></expr>]</index></name><operator>-&gt;</operator><name>maxValue</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>maxValueStr</name> <init>= <expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>OidFunctionCall1</name><argument_list>(<argument><expr><name>intervalTypeOutFunc</name></expr></argument>,
																 <argument><expr><name>maxValue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>maxValues</name><index>[<expr><name>shardIndex</name></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>maxValueStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><operator>*</operator><name>minValueArray</name> <operator>=</operator> <call><name>CreateArrayFromDatums</name><argument_list>(<argument><expr><name>minValues</name></expr></argument>, <argument><expr><name>minValueNulls</name></expr></argument>, <argument><expr><name>shardCount</name></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>maxValueArray</name> <operator>=</operator> <call><name>CreateArrayFromDatums</name><argument_list>(<argument><expr><name>maxValues</name></expr></argument>, <argument><expr><name>maxValueNulls</name></expr></argument>, <argument><expr><name>shardCount</name></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CreateArrayFromDatums creates an array consisting of given values and nulls.
 */</comment>
<function><type><name>ArrayType</name> <modifier>*</modifier></type>
<name>CreateArrayFromDatums</name><parameter_list>(<parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>datumArray</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nullsArray</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>datumCount</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typeId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>typeByValue</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>typeAlignment</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type> <name>typeLength</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name><name>dimensions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{ <expr><name>datumCount</name></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name><name>lowerbounds</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">1</literal></expr> }</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>get_typlenbyvalalign</name><argument_list>(<argument><expr><name>typeId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typeLength</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typeByValue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typeAlignment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>datumArrayObject</name> <init>= <expr><call><name>construct_md_array</name><argument_list>(<argument><expr><name>datumArray</name></expr></argument>, <argument><expr><name>nullsArray</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
													 <argument><expr><name>dimensions</name></expr></argument>,
													 <argument><expr><name>lowerbounds</name></expr></argument>, <argument><expr><name>typeId</name></expr></argument>, <argument><expr><name>typeLength</name></expr></argument>,
													 <argument><expr><name>typeByValue</name></expr></argument>, <argument><expr><name>typeAlignment</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>datumArrayObject</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExecutePartitionTaskList executes the queries formed in WrapTasksForPartitioning(),
 * and returns its results as a list of DistributedResultFragment.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>ExecutePartitionTaskList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name></decl></parameter>, <parameter><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>targetRelation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PartitioningTupleDest</name> <modifier>*</modifier></type><name>tupleDest</name> <init>= <expr><call><name>CreatePartitioningTupleDest</name><argument_list>(<argument><expr><name>targetRelation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>errorOnAnyFailure</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ExecuteSelectTasksIntoTupleDest</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>, <argument><expr><operator>(</operator><name>TupleDestination</name> <operator>*</operator><operator>)</operator> <name>tupleDest</name></expr></argument>,
									<argument><expr><name>errorOnAnyFailure</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>tupleDest</name><operator>-&gt;</operator><name>fragmentList</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * TupleToDistributedResultFragment converts a tuple returned by the query in
 * WrapTasksForPartitioning() to a DistributedResultFragment.
 */</comment>
<function><type><specifier>static</specifier> <name>DistributedResultFragment</name> <modifier>*</modifier></type>
<name>TupleToDistributedResultFragment</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>,
								 <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>,
								 <parameter><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>targetRelation</name></decl></parameter>,
								 <parameter><decl><type><name>uint32</name></type> <name>sourceNodeId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>isNull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>targetShardIndex</name> <init>= <expr><call><name>DatumGetUInt32</name><argument_list>(<argument><expr><call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>resultId</name> <init>= <expr><call><name>DatumGetTextP</name><argument_list>(<argument><expr><call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>rowCount</name> <init>= <expr><call><name>DatumGetInt64</name><argument_list>(<argument><expr><call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>targetShardIndex</name> <operator>&lt;</operator> <name><name>targetRelation</name><operator>-&gt;</operator><name>shardIntervalArrayLength</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>=
		<expr><name><name>targetRelation</name><operator>-&gt;</operator><name>sortedShardIntervalArray</name><index>[<expr><name>targetShardIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>DistributedResultFragment</name> <modifier>*</modifier></type><name>distributedResultFragment</name> <init>=
		<expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DistributedResultFragment</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>distributedResultFragment</name><operator>-&gt;</operator><name>nodeId</name></name> <operator>=</operator> <name>sourceNodeId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>distributedResultFragment</name><operator>-&gt;</operator><name>targetShardIndex</name></name> <operator>=</operator> <name>targetShardIndex</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>distributedResultFragment</name><operator>-&gt;</operator><name>targetShardId</name></name> <operator>=</operator> <name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>distributedResultFragment</name><operator>-&gt;</operator><name>resultId</name></name> <operator>=</operator> <call><name>text_to_cstring</name><argument_list>(<argument><expr><name>resultId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>distributedResultFragment</name><operator>-&gt;</operator><name>rowCount</name></name> <operator>=</operator> <name>rowCount</name></expr>;</expr_stmt>

	<return>return <expr><name>distributedResultFragment</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExecuteSelectTasksIntoTupleDest executes the given tasks and forwards its result
 * to the given destination.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecuteSelectTasksIntoTupleDest</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name></decl></parameter>, <parameter><decl><type><name>TupleDestination</name> <modifier>*</modifier></type><name>tupleDestination</name></decl></parameter>,
								<parameter><decl><type><name>bool</name></type> <name>errorOnAnyFailure</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>expectResults</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>targetPoolSize</name> <init>= <expr><name>MaxAdaptiveExecutorPoolSize</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionProperties</name></type> <name>xactProperties</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>errorOnAnyFailure</name> <operator>=</operator> <name>errorOnAnyFailure</name></expr>,
		<expr><operator>.</operator><name>useRemoteTransactionBlocks</name> <operator>=</operator> <name>TRANSACTION_BLOCKS_REQUIRED</name></expr>,
		<expr><operator>.</operator><name>requires2PC</name> <operator>=</operator> <name>false</name></expr>
	}</block></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>localExecutionSupported</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExecutionParams</name> <modifier>*</modifier></type><name>executionParams</name> <init>= <expr><call><name>CreateBasicExecutionParams</name><argument_list>(
		<argument><expr><name>ROW_MODIFY_READONLY</name></expr></argument>, <argument><expr><name>taskList</name></expr></argument>, <argument><expr><name>targetPoolSize</name></expr></argument>, <argument><expr><name>localExecutionSupported</name></expr></argument>
		)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>executionParams</name><operator>-&gt;</operator><name>tupleDestination</name></name> <operator>=</operator> <name>tupleDestination</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>executionParams</name><operator>-&gt;</operator><name>xactProperties</name></name> <operator>=</operator> <name>xactProperties</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>executionParams</name><operator>-&gt;</operator><name>expectResults</name></name> <operator>=</operator> <name>expectResults</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecuteTaskListExtended</name><argument_list>(<argument><expr><name>executionParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ColocateFragmentsWithRelation moves the fragments in the cluster so they are
 * colocated with the shards of target relation. These transfers are done by
 * calls to fetch_intermediate_results() between nodes.
 *
 * returnValue[shardIndex] is list of result Ids that are colocated with
 * targetRelation-&gt;sortedShardIntervalArray[shardIndex] after fetch tasks are
 * done.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier><modifier>*</modifier></type>
<name>ColocateFragmentsWithRelation</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>fragmentList</name></decl></parameter>, <parameter><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>targetRelation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>fragmentListTransfers</name> <init>= <expr><call><name>ColocationTransfers</name><argument_list>(<argument><expr><name>fragmentList</name></expr></argument>, <argument><expr><name>targetRelation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>fragmentTransferTaskList</name> <init>= <expr><call><name>FragmentTransferTaskList</name><argument_list>(<argument><expr><name>fragmentListTransfers</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ExecuteFetchTaskList</name><argument_list>(<argument><expr><name>fragmentTransferTaskList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>shardCount</name> <init>= <expr><name><name>targetRelation</name><operator>-&gt;</operator><name>shardIntervalArrayLength</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>shardResultIdList</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><name>shardCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>DistributedResultFragment</name> <modifier>*</modifier></type><name>sourceFragment</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>sourceFragment</argument>, <argument>fragmentList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>shardIndex</name> <init>= <expr><name><name>sourceFragment</name><operator>-&gt;</operator><name>targetShardIndex</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>shardIndex</name> <operator>&lt;</operator> <name>shardCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shardResultIdList</name><index>[<expr><name>shardIndex</name></expr>]</index></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>shardResultIdList</name><index>[<expr><name>shardIndex</name></expr>]</index></name></expr></argument>,
												<argument><expr><name><name>sourceFragment</name><operator>-&gt;</operator><name>resultId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>shardResultIdList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColocationTransfers returns a list of transfers to colocate given fragments with
 * shards of the target relation. These transfers also take into account replicated
 * target relations. This prunes away transfers with same source and target
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>ColocationTransfers</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>fragmentList</name></decl></parameter>, <parameter><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>targetRelation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASHCTL</name></type> <name>transferHashInfo</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>transferHashInfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HASHCTL</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>transferHashInfo</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>NodePair</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>transferHashInfo</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>NodeToNodeFragmentsTransfer</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>transferHashInfo</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>transferHash</name> <init>= <expr><call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"Fragment Transfer Hash"</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>transferHashInfo</name></expr></argument>,
									 <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_CONTEXT</name> <operator>|</operator> <name>HASH_BLOBS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>DistributedResultFragment</name> <modifier>*</modifier></type><name>fragment</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>fragment</argument>, <argument>fragmentList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>placementList</name> <init>= <expr><call><name>ActiveShardPlacementList</name><argument_list>(<argument><expr><name><name>fragment</name><operator>-&gt;</operator><name>targetShardId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>placement</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>placement</argument>, <argument>placementList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>NodePair</name></type> <name>transferKey</name> <init>= <expr><block>{
				<expr><operator>.</operator><name>sourceNodeId</name> <operator>=</operator> <name><name>fragment</name><operator>-&gt;</operator><name>nodeId</name></name></expr>,
				<expr><operator>.</operator><name>targetNodeId</name> <operator>=</operator> <name><name>placement</name><operator>-&gt;</operator><name>nodeId</name></name></expr>
			}</block></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>transferKey</name><operator>.</operator><name>sourceNodeId</name></name> <operator>==</operator> <name><name>transferKey</name><operator>.</operator><name>targetNodeId</name></name></expr>)</condition>
			<block>{<block_content>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<decl_stmt><decl><type><name>bool</name></type> <name>foundInCache</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>NodeToNodeFragmentsTransfer</name> <modifier>*</modifier></type><name>fragmentListTransfer</name> <init>=
				<expr><call><name>hash_search</name><argument_list>(<argument><expr><name>transferHash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>transferKey</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>foundInCache</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>foundInCache</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>fragmentListTransfer</name><operator>-&gt;</operator><name>nodes</name></name> <operator>=</operator> <name>transferKey</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>fragmentListTransfer</name><operator>-&gt;</operator><name>fragmentList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name><name>fragmentListTransfer</name><operator>-&gt;</operator><name>fragmentList</name></name> <operator>=</operator>
				<call><name>lappend</name><argument_list>(<argument><expr><name><name>fragmentListTransfer</name><operator>-&gt;</operator><name>fragmentList</name></name></expr></argument>, <argument><expr><name>fragment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>fragmentListTransfers</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NodeToNodeFragmentsTransfer</name> <modifier>*</modifier></type><name>transfer</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>hashSeqStatus</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hashSeqStatus</name></expr></argument>, <argument><expr><name>transferHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>transfer</name> <operator>=</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hashSeqStatus</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>fragmentListTransfers</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>fragmentListTransfers</name></expr></argument>, <argument><expr><name>transfer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>fragmentListTransfers</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FragmentTransferTaskList returns a list of tasks which performs the given list of
 * transfers. Each of the transfers are done by a SQL call to fetch_intermediate_results.
 * See QueryStringForFragmentsTransfer for how the query is constructed.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>FragmentTransferTaskList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>fragmentListTransfers</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>fetchTaskList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>NodeToNodeFragmentsTransfer</name> <modifier>*</modifier></type><name>fragmentsTransfer</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>fragmentsTransfer</argument>, <argument>fragmentListTransfers</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type> <name>targetNodeId</name> <init>= <expr><name><name>fragmentsTransfer</name><operator>-&gt;</operator><name>nodes</name><operator>.</operator><name>targetNodeId</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* these should have already been pruned away in ColocationTransfers */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>targetNodeId</name> <operator>!=</operator> <name><name>fragmentsTransfer</name><operator>-&gt;</operator><name>nodes</name><operator>.</operator><name>sourceNodeId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><call><name>LookupNodeByNodeIdOrError</name><argument_list>(<argument><expr><name>targetNodeId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>targetPlacement</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>ShardPlacement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>SetPlacementNodeMetadata</name><argument_list>(<argument><expr><name>targetPlacement</name></expr></argument>, <argument><expr><name>workerNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>Task</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>taskType</name></name> <operator>=</operator> <name>READ_TASK</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SetTaskQueryString</name><argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><call><name>QueryStringForFragmentsTransfer</name><argument_list>(<argument><expr><name>fragmentsTransfer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>taskPlacementList</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>targetPlacement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>fetchTaskList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>fetchTaskList</name></expr></argument>, <argument><expr><name>task</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>fetchTaskList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * QueryStringForFragmentsTransfer returns a query which fetches distributed
 * result fragments from source node to target node. See the structure of
 * NodeToNodeFragmentsTransfer for details of how these are decided.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>QueryStringForFragmentsTransfer</name><parameter_list>(<parameter><decl><type><name>NodeToNodeFragmentsTransfer</name> <modifier>*</modifier></type><name>fragmentsTransfer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>queryString</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>fragmentNamesArrayString</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>fragmentCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NodePair</name> <modifier>*</modifier></type><name>nodePair</name> <init>= <expr><operator>&amp;</operator><name><name>fragmentsTransfer</name><operator>-&gt;</operator><name>nodes</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>sourceNode</name> <init>= <expr><call><name>LookupNodeByNodeIdOrError</name><argument_list>(<argument><expr><name><name>nodePair</name><operator>-&gt;</operator><name>sourceNodeId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>fragmentNamesArrayString</name></expr></argument>, <argument><expr><literal type="string">"ARRAY["</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>DistributedResultFragment</name> <modifier>*</modifier></type><name>fragment</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>fragment</argument>, <argument>fragmentsTransfer-&gt;fragmentList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fragmentName</name> <init>= <expr><name><name>fragment</name><operator>-&gt;</operator><name>resultId</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>fragmentCount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>fragmentNamesArrayString</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>fragmentNamesArrayString</name></expr></argument>,
							   <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>fragmentName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>fragmentCount</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>fragmentNamesArrayString</name></expr></argument>, <argument><expr><literal type="string">"]::text[]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>queryString</name></expr></argument>,
					 <argument><expr><literal type="string">"SELECT bytes FROM fetch_intermediate_results(%s,%s,%d) bytes"</literal></expr></argument>,
					 <argument><expr><name><name>fragmentNamesArrayString</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
					 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name><name>sourceNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name><name>sourceNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"fetch task on %s:%d: %s"</literal></expr></argument>, <argument><expr><name><name>sourceNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>,
							<argument><expr><name><name>sourceNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>, <argument><expr><name><name>queryString</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>queryString</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExecuteFetchTaskList executes a list of fetch_intermediate_results() tasks.
 * It ignores the byte_count result of the fetch_intermediate_results() calls.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecuteFetchTaskList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>resultColumnCount</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>resultDescriptor</name> <init>= <expr><call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><name>resultColumnCount</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>resultDescriptor</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"byte_count"</literal></expr></argument>, <argument><expr><name>INT8OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>TupleDestination</name> <modifier>*</modifier></type><name>tupleDestination</name> <init>= <expr><call><name>CreateTupleDestNone</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>errorOnAnyFailure</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ExecuteSelectTasksIntoTupleDest</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>, <argument><expr><name>tupleDestination</name></expr></argument>, <argument><expr><name>errorOnAnyFailure</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
