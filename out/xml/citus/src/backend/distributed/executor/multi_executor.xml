<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/builded_projects/citus/src/backend/distributed/executor/multi_executor.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * multi_executor.c
 *
 * Entrypoint into distributed query execution.
 *
 * Copyright (c) Citus Data, Inc.
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_version_constants.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_class.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/backend_data.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_custom_scan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands/multi_copy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands/utility_hook.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/function_call_delegation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/insert_select_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/insert_select_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/local_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/coordinator_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/combine_query_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/distributed_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_router_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_server_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/relation_access_tracking.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/resource_lock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/transaction_management.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/version_compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_shard_visibility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/function_call_delegation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/execdebug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/copy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/execnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_oper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/dest.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/pquery.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgrprotos.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>


<comment type="block">/*
 * Controls the connection type for multi shard modifications, DDLs
 * TRUNCATE and multi-shard SELECT queries.
 */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>MultiShardConnectionType</name> <init>= <expr><name>PARALLEL_CONNECTION</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>WritableStandbyCoordinator</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>AllowModificationsFromWorkersToReplicatedTables</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Controlled by the GUC citus.skip_constraint_validation
 */</comment>
<decl_stmt><decl><type><name>bool</name></type> <name>SkipConstraintValidation</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Setting that controls whether distributed queries should be
 * allowed within a task execution.
 */</comment>
<decl_stmt><decl><type><name>bool</name></type> <name>AllowNestedDistributedExecution</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Pointer to bound parameters of the current ongoing call to ExecutorRun.
 * If executor is not running, then this value is meaningless.
 */</comment>
<decl_stmt><decl><type><name>ParamListInfo</name></type> <name>executorBoundParams</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>


<comment type="block">/* sort the returning to get consistent outputs, used only for testing */</comment>
<decl_stmt><decl><type><name>bool</name></type> <name>SortReturning</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * How many nested executors have we started? This can happen for SQL
 * UDF calls. The outer query starts an executor, then postgres opens
 * another executor to run the SQL UDF.
 */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>ExecutorLevel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<comment type="block">/* local function forward declarations */</comment>
<function_decl><type><specifier>static</specifier> <name>Relation</name></type> <name>StubRelation</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>GetObjectTypeString</name><parameter_list>(<parameter><decl><type><name>ObjectType</name></type> <name>objType</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>AlterTableConstraintCheck</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>FindCitusCustomScanStates</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planState</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>CitusCustomScanStateWalker</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planState</name></decl></parameter>,
									   <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>citusCustomScanStates</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsTaskExecutionAllowed</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isRemote</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>InLocalTaskExecutionOnShard</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>MaybeInRemoteTaskExecution</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>InTrigger</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * CitusExecutorStart is the ExecutorStart_hook that gets called when
 * Postgres prepares for execution or EXPLAIN.
 */</comment>
<function><type><name>void</name></type>
<name>CitusExecutorStart</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>plannedStmt</name> <init>= <expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We cannot modify XactReadOnly on Windows because it is not
	 * declared with PGDLLIMPORT.
	 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<if_stmt><if>if <condition>(<expr><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>WritableStandbyCoordinator</name> <operator>&amp;&amp;</operator>
		<call><name>IsCitusPlan</name><argument_list>(<argument><expr><name><name>plannedStmt</name><operator>-&gt;</operator><name>planTree</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<comment type="block">/*
			 * To enable writes from a hot standby we cheat our way through
			 * the checks in standard_ExecutorStart by temporarily setting
			 * XactReadOnly to false.
			 */</comment>
			<expr_stmt><expr><name>XactReadOnly</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>standard_ExecutorStart</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>XactReadOnly</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<expr_stmt><expr><name>XactReadOnly</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<block>{<block_content>
		<expr_stmt><expr><call><name>standard_ExecutorStart</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CitusExecutorRun is the ExecutorRun_hook that gets called when postgres
 * executes a query.
 */</comment>
<function><type><name>void</name></type>
<name>CitusExecutorRun</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>,
				 <parameter><decl><type><name>ScanDirection</name></type> <name>direction</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>execute_once</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name> <init>= <expr><name><name>queryDesc</name><operator>-&gt;</operator><name>dest</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ParamListInfo</name></type> <name>savedBoundParams</name> <init>= <expr><name>executorBoundParams</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Save a pointer to query params so UDFs can access them by calling
	 * ExecutorBoundParams().
	 */</comment>
	<expr_stmt><expr><name>executorBoundParams</name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>params</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We do some potentially time consuming operations our self now before we hand of
	 * control to postgres' executor. To make sure that time spent is accurately measured
	 * we remove the totaltime instrumentation from the queryDesc. Instead we will start
	 * and stop the instrumentation of the total time and put it back on the queryDesc
	 * before returning (or rethrowing) from this function.
	 */</comment>
	<decl_stmt><decl><type><name>Instrumentation</name> <modifier>*</modifier><specifier>volatile</specifier></type> <name>totalTime</name> <init>= <expr><name><name>queryDesc</name><operator>-&gt;</operator><name>totaltime</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>totaltime</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name>ExecutorLevel</name><operator>++</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>totalTime</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>InstrStartNode</name><argument_list>(<argument><expr><name>totalTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Disable execution of ALTER TABLE constraint validation queries. These
		 * constraints will be validated in worker nodes, so running these queries
		 * from the coordinator would be redundant.
		 *
		 * For example, ALTER TABLE ... ATTACH PARTITION checks that the new
		 * partition doesn't violate constraints of the parent table, which
		 * might involve running some SELECT queries.
		 *
		 * Ideally we'd completely skip these checks in the coordinator, but we don't
		 * have any means to tell postgres to skip the checks. So the best we can do is
		 * to not execute the queries and return an empty result set, as if this table has
		 * no rows, so no constraints will be violated.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>AlterTableConstraintCheck</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<comment type="block">/* start and shutdown tuple receiver to simulate empty result */</comment>
			<expr_stmt><expr><call><name><name>dest</name><operator>-&gt;</operator><name>rStartup</name></name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>dest</name></name></expr></argument>, <argument><expr><name>CMD_SELECT</name></expr></argument>, <argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>tupDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name><name>dest</name><operator>-&gt;</operator><name>rShutdown</name></name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* switch into per-query memory context before calling PreExecScan */</comment>
			<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(
				<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Call PreExecScan for all citus custom scan nodes prior to starting the
			 * postgres exec scan to give some citus scan nodes some time to initialize
			 * state that would be too late if it were to initialize when the first tuple
			 * would need to return.
			 */</comment>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>citusCustomScanStates</name> <init>= <expr><call><name>FindCitusCustomScanStates</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>planstate</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>CitusScanState</name> <modifier>*</modifier></type><name>citusScanState</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<macro><name>foreach_ptr</name><argument_list>(<argument>citusScanState</argument>, <argument>citusCustomScanStates</argument>)</argument_list></macro>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>citusScanState</name><operator>-&gt;</operator><name>PreExecScan</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name><name>citusScanState</name><operator>-&gt;</operator><name>PreExecScan</name></name><argument_list>(<argument><expr><name>citusScanState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>

			<comment type="block">/* postgres will switch here again and will restore back on its own */</comment>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>standard_ExecutorRun</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>direction</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>execute_once</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>totalTime</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>InstrStopNode</name><argument_list>(<argument><expr><name>totalTime</name></expr></argument>, <argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>totaltime</name></name> <operator>=</operator> <name>totalTime</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>executorBoundParams</name> <operator>=</operator> <name>savedBoundParams</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ExecutorLevel</name><operator>--</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>ExecutorLevel</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>PlannerLevel</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We are leaving Citus code so no one should have any references to
			 * cache entries. Release them now to not hold onto memory in long
			 * transactions.
			 */</comment>
			<expr_stmt><expr><call><name>CitusTableCacheFlushInvalidatedEntries</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>InTopLevelDelegatedFunctionCall</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Within a 2PC, when a function is delegated to a remote node, we pin
		 * the distribution argument as the shard key for all the SQL in the
		 * function's block. The restriction is imposed to not to access other
		 * nodes from the current node, and violate the transactional integrity
		 * of the 2PC. Now that the query is ending, reset the shard key to NULL.
		 */</comment>
		<expr_stmt><expr><call><name>CheckAndResetAllowedShardKeyValueIfNeeded</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>totalTime</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>totaltime</name></name> <operator>=</operator> <name>totalTime</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>executorBoundParams</name> <operator>=</operator> <name>savedBoundParams</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ExecutorLevel</name><operator>--</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>ExecutorLevel</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>PlannerLevel</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>InTopLevelDelegatedFunctionCall</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * In case of an exception, reset the pinned shard-key, for more
		 * details see the function header.
		 */</comment>
		<expr_stmt><expr><call><name>CheckAndResetAllowedShardKeyValueIfNeeded</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * FindCitusCustomScanStates returns a list of all citus custom scan states in it.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>FindCitusCustomScanStates</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planState</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>citusCustomScanStates</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>CitusCustomScanStateWalker</name><argument_list>(<argument><expr><name>planState</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>citusCustomScanStates</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>citusCustomScanStates</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CitusCustomScanStateWalker walks a planState tree structure and adds all
 * CitusCustomState nodes to the list passed by reference as the second argument.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>CitusCustomScanStateWalker</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planState</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>citusCustomScanStates</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IsCitusCustomState</name><argument_list>(<argument><expr><name>planState</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CitusScanState</name> <modifier>*</modifier></type><name>css</name> <init>= <expr><operator>(</operator><name>CitusScanState</name> <operator>*</operator><operator>)</operator> <name>planState</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><operator>*</operator><name>citusCustomScanStates</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>citusCustomScanStates</name></expr></argument>, <argument><expr><name>css</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* breaks the walking of this tree */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>planstate_tree_walker</name><argument_list>(<argument><expr><name>planState</name></expr></argument>, <argument><expr><name>CitusCustomScanStateWalker</name></expr></argument>,
								 <argument><expr><name>citusCustomScanStates</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ReturnTupleFromTuplestore reads the next tuple from the tuple store of the
 * given Citus scan node and returns it. It returns null if all tuples are read
 * from the tuple store.
 */</comment>
<function><type><name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ReturnTupleFromTuplestore</name><parameter_list>(<parameter><decl><type><name>CitusScanState</name> <modifier>*</modifier></type><name>scanState</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tupleStore</name> <init>= <expr><name><name>scanState</name><operator>-&gt;</operator><name>tuplestorestate</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>forwardScanDirection</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>tupleStore</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>EState</name> <modifier>*</modifier></type><name>executorState</name> <init>= <expr><call><name>ScanStateGetExecutorState</name><argument_list>(<argument><expr><name>scanState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanDirection</name></type> <name>scanDirection</name> <init>= <expr><name><name>executorState</name><operator>-&gt;</operator><name>es_direction</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ScanDirectionIsValid</name><argument_list>(<argument><expr><name>scanDirection</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ScanDirectionIsBackward</name><argument_list>(<argument><expr><name>scanDirection</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>forwardScanDirection</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>qual</name> <init>= <expr><name><name>scanState</name><operator>-&gt;</operator><name>customScanState</name><operator>.</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>qual</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ProjectionInfo</name> <modifier>*</modifier></type><name>projInfo</name> <init>= <expr><name><name>scanState</name><operator>-&gt;</operator><name>customScanState</name><operator>.</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ProjInfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>scanState</name><operator>-&gt;</operator><name>customScanState</name><operator>.</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>qual</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>projInfo</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* no quals, nor projections return directly from the tuple store. */</comment>
		<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><name><name>scanState</name><operator>-&gt;</operator><name>customScanState</name><operator>.</operator><name>ss</name><operator>.</operator><name>ss_ScanTupleSlot</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>tuplestore_gettupleslot</name><argument_list>(<argument><expr><name>tupleStore</name></expr></argument>, <argument><expr><name>forwardScanDirection</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>slot</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * If there is a very selective qual on the Citus Scan node we might block
		 * interrupts for a longer time if we would not check for interrupts in this loop
		 */</comment>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Reset per-tuple memory context to free any expression evaluation
		 * storage allocated in the previous tuple cycle.
		 */</comment>
		<expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><name><name>scanState</name><operator>-&gt;</operator><name>customScanState</name><operator>.</operator><name>ss</name><operator>.</operator><name>ss_ScanTupleSlot</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>tuplestore_gettupleslot</name><argument_list>(<argument><expr><name>tupleStore</name></expr></argument>, <argument><expr><name>forwardScanDirection</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * When the tuple is null we have reached the end of the tuplestore. We will
			 * return a null tuple, however, depending on the existence of a projection we
			 * need to either return the scan tuple or the projected tuple.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>projInfo</name></expr>)</condition>
			<block>{<block_content>
				<return>return <expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>projInfo</name><operator>-&gt;</operator><name>pi_state</name><operator>.</operator><name>resultslot</name></name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<return>return <expr><name>slot</name></expr>;</return>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* place the current tuple into the expr context */</comment>
		<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecQual</name><argument_list>(<argument><expr><name>qual</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* skip nodes that do not satisfy the qual (filter) */</comment>
			<expr_stmt><expr><call><name>InstrCountFiltered1</name><argument_list>(<argument><expr><name>scanState</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* found a satisfactory scan tuple */</comment>
		<if_stmt><if>if <condition>(<expr><name>projInfo</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Form a projection tuple, store it in the result tuple slot and return it.
			 * ExecProj works on the ecxt_scantuple on the context stored earlier.
			 */</comment>
			<return>return <expr><call><name>ExecProject</name><argument_list>(<argument><expr><name>projInfo</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Here, we aren't projecting, so just return scan tuple */</comment>
			<return>return <expr><name>slot</name></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>


<comment type="block">/*
 * ReadFileIntoTupleStore parses the records in a COPY-formatted file according
 * according to the given tuple descriptor and stores the records in a tuple
 * store.
 */</comment>
<function><type><name>void</name></type>
<name>ReadFileIntoTupleStore</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>fileName</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>copyFormat</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name></decl></parameter>,
					   <parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tupstore</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Trick BeginCopyFrom into using our tuple descriptor by pretending it belongs
	 * to a relation.
	 */</comment>
	<decl_stmt><decl><type><name>Relation</name></type> <name>stubRelation</name> <init>= <expr><call><name>StubRelation</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>EState</name> <modifier>*</modifier></type><name>executorState</name> <init>= <expr><call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>executorTupleContext</name> <init>= <expr><call><name>GetPerTupleMemoryContext</name><argument_list>(<argument><expr><name>executorState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>executorExpressionContext</name> <init>= <expr><call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>executorState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>columnCount</name> <init>= <expr><name><name>tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>columnValues</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><name>columnCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>columnNulls</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><name>columnCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>copyOptions</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>location</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* "unknown" token location */</comment>
	<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>copyOption</name> <init>= <expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"format"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeString</name><argument_list>(<argument><expr><name>copyFormat</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>copyOptions</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>copyOptions</name></expr></argument>, <argument><expr><name>copyOption</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>CopyFromState</name></type> <name>copyState</name> <init>= <expr><call><name>BeginCopyFrom_compat</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>stubRelation</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
												   <argument><expr><name>fileName</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
												   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>copyOptions</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ResetPerTupleExprContext</name><argument_list>(<argument><expr><name>executorState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>executorTupleContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>bool</name></type> <name>nextRowFound</name> <init>= <expr><call><name>NextCopyFrom</name><argument_list>(<argument><expr><name>copyState</name></expr></argument>, <argument><expr><name>executorExpressionContext</name></expr></argument>,
										 <argument><expr><name>columnValues</name></expr></argument>, <argument><expr><name>columnNulls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>nextRowFound</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>tuplestore_putvalues</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>, <argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><name>columnValues</name></expr></argument>, <argument><expr><name>columnNulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>EndCopyFrom</name><argument_list>(<argument><expr><name>copyState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>columnValues</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>columnNulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * SortTupleStore gets a CitusScanState and sorts the tuplestore by all the
 * entries in the target entry list, starting from the first one and
 * ending with the last entry.
 *
 * The sorting is done in ASC order.
 */</comment>
<function><type><name>void</name></type>
<name>SortTupleStore</name><parameter_list>(<parameter><decl><type><name>CitusScanState</name> <modifier>*</modifier></type><name>scanState</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name> <init>= <expr><call><name>ScanStateGetTupleDescriptor</name><argument_list>(<argument><expr><name>scanState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tupleStore</name> <init>= <expr><name><name>scanState</name><operator>-&gt;</operator><name>tuplestorestate</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name> <init>= <expr><name><name>scanState</name><operator>-&gt;</operator><name>customScanState</name><operator>.</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>expectedColumnCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>targetList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Convert list-ish representation to arrays wanted by executor */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>numberOfSortKeys</name> <init>= <expr><name>expectedColumnCount</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>sortColIdx</name> <init>= <expr><operator>(</operator><name>AttrNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numberOfSortKeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>sortOperators</name> <init>= <expr><operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numberOfSortKeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>collations</name> <init>= <expr><operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numberOfSortKeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>nullsFirst</name> <init>= <expr><operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numberOfSortKeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>sortKeyIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Iterate on the returning target list and generate the necessary information
	 * for sorting the tuples.
	 */</comment>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>returningEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>returningEntry</argument>, <argument>targetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>sortop</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* determine the sortop, we don't need anything else */</comment>
		<expr_stmt><expr><call><name>get_sort_group_operators</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>returningEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>sortop</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>sortColIdx</name><index>[<expr><name>sortKeyIndex</name></expr>]</index></name> <operator>=</operator> <name>sortKeyIndex</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sortOperators</name><index>[<expr><name>sortKeyIndex</name></expr>]</index></name> <operator>=</operator> <name>sortop</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>collations</name><index>[<expr><name>sortKeyIndex</name></expr>]</index></name> <operator>=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>returningEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nullsFirst</name><index>[<expr><name>sortKeyIndex</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>sortKeyIndex</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<decl_stmt><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>tuplesortstate</name> <init>=
		<expr><call><name>tuplesort_begin_heap</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><name>numberOfSortKeys</name></expr></argument>, <argument><expr><name>sortColIdx</name></expr></argument>, <argument><expr><name>sortOperators</name></expr></argument>,
							 <argument><expr><name>collations</name></expr></argument>, <argument><expr><name>nullsFirst</name></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><call><name>ReturnTupleFromTuplestore</name><argument_list>(<argument><expr><name>scanState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* tuplesort_puttupleslot copies the slot into sort context */</comment>
		<expr_stmt><expr><call><name>tuplesort_puttupleslot</name><argument_list>(<argument><expr><name>tuplesortstate</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* perform the actual sort operation */</comment>
	<expr_stmt><expr><call><name>tuplesort_performsort</name><argument_list>(<argument><expr><name>tuplesortstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Truncate the existing tupleStore, because we'll fill it back
	 * from the sorted tuplestore.
	 */</comment>
	<expr_stmt><expr><call><name>tuplestore_clear</name><argument_list>(<argument><expr><name>tupleStore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* iterate over all the sorted tuples, add them to original tuplestore */</comment>
	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>newSlot</name> <init>= <expr><call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>,
														   <argument><expr><operator>&amp;</operator><name>TTSOpsMinimalTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><call><name>tuplesort_gettupleslot</name><argument_list>(<argument><expr><name>tuplesortstate</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>newSlot</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
		<block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* tuplesort_puttupleslot copies the slot into the tupleStore context */</comment>
		<expr_stmt><expr><call><name>tuplestore_puttupleslot</name><argument_list>(<argument><expr><name>tupleStore</name></expr></argument>, <argument><expr><name>newSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>tuplestore_rescan</name><argument_list>(<argument><expr><name><name>scanState</name><operator>-&gt;</operator><name>tuplestorestate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* terminate the sort, clear unnecessary resources */</comment>
	<expr_stmt><expr><call><name>tuplesort_end</name><argument_list>(<argument><expr><name>tuplesortstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * StubRelation creates a stub Relation from the given tuple descriptor.
 * To be able to use copy.c, we need a Relation descriptor. As there is no
 * relation corresponding to the data loaded from workers, we need to fake one.
 * We just need the bare minimal set of fields accessed by BeginCopyFrom().
 */</comment>
<function><type><specifier>static</specifier> <name>Relation</name></type>
<name>StubRelation</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>stubRelation</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RelationData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>stubRelation</name><operator>-&gt;</operator><name>rd_att</name></name> <operator>=</operator> <name>tupleDescriptor</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stubRelation</name><operator>-&gt;</operator><name>rd_rel</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FormData_pg_class</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stubRelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>=</operator> <name>RELKIND_RELATION</name></expr>;</expr_stmt>

	<return>return <expr><name>stubRelation</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExecuteQueryStringIntoDestReceiver plans and executes a query and sends results
 * to the given DestReceiver.
 */</comment>
<function><type><name>void</name></type>
<name>ExecuteQueryStringIntoDestReceiver</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>, <parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>,
								   <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name> <init>= <expr><call><name>ParseQueryString</name><argument_list>(<argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ExecuteQueryIntoDestReceiver</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ParseQuery parses query string and returns a Query struct.
 */</comment>
<function><type><name>Query</name> <modifier>*</modifier></type>
<name>ParseQueryString</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>paramOids</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numParams</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RawStmt</name> <modifier>*</modifier></type><name>rawStmt</name> <init>= <expr><operator>(</operator><name>RawStmt</name> <operator>*</operator><operator>)</operator> <call><name>ParseTreeRawStmt</name><argument_list>(<argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* rewrite the parsed RawStmt to produce a Query */</comment>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name> <init>= <expr><call><name>RewriteRawQueryStmt</name><argument_list>(<argument><expr><name>rawStmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>paramOids</name></expr></argument>, <argument><expr><name>numParams</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>query</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RewriteRawQueryStmt rewrites the given parsed RawStmt according to the other
 * parameters and returns a Query struct.
 */</comment>
<function><type><name>Query</name> <modifier>*</modifier></type>
<name>RewriteRawQueryStmt</name><parameter_list>(<parameter><decl><type><name>RawStmt</name> <modifier>*</modifier></type><name>rawStmt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>paramOids</name></decl></parameter>, <parameter><decl><type><name>int</name></type>
					<name>numParams</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>queryTreeList</name> <init>=
		<expr><call><name>pg_analyze_and_rewrite_fixedparams</name><argument_list>(<argument><expr><name>rawStmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>paramOids</name></expr></argument>, <argument><expr><name>numParams</name></expr></argument>,
										   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>queryTreeList</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"can only execute a single query"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>queryTreeList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>query</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExecuteQueryIntoDestReceiver plans and executes a query and sends results to the given
 * DestReceiver.
 */</comment>
<function><type><name>void</name></type>
<name>ExecuteQueryIntoDestReceiver</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>, <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>cursorOptions</name> <init>= <expr><name>CURSOR_OPT_PARALLEL_OK</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* can only execute DML/SELECT via this path */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot execute utility commands"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* plan the subquery, this may be another distributed query */</comment>
	<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>queryPlan</name> <init>= <expr><call><name>pg_plan_query</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>cursorOptions</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ExecutePlanIntoDestReceiver</name><argument_list>(<argument><expr><name>queryPlan</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ExecutePlanIntoDestReceiver executes a query plan and sends results to the given
 * DestReceiver.
 */</comment>
<function><type><name>void</name></type>
<name>ExecutePlanIntoDestReceiver</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>queryPlan</name></decl></parameter>, <parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>,
							<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>eflags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type> <name>count</name> <init>= <expr><name>FETCH_ALL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* create a new portal for executing the query */</comment>
	<decl_stmt><decl><type><name>Portal</name></type> <name>portal</name> <init>= <expr><call><name>CreateNewPortal</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* don't display the portal in pg_cursors, it is for internal use only */</comment>
	<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>visible</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PortalDefineQuery</name><argument_list>(<argument><expr><name>portal</name></expr></argument>,
					  <argument><expr><name>NULL</name></expr></argument>,
					  <argument><expr><literal type="string">""</literal></expr></argument>,
					  <argument><expr><name>CMDTAG_SELECT</name></expr></argument>,
					  <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>queryPlan</name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PortalStart</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>, <argument><expr><call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PortalRun</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PortalDrop</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * SetLocalMultiShardModifyModeToSequential is simply a C interface for setting
 * the following:
 *      SET LOCAL citus.multi_shard_modify_mode = 'sequential';
 */</comment>
<function><type><name>void</name></type>
<name>SetLocalMultiShardModifyModeToSequential</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>set_config_option</name><argument_list>(<argument><expr><literal type="string">"citus.multi_shard_modify_mode"</literal></expr></argument>, <argument><expr><literal type="string">"sequential"</literal></expr></argument>,
					  <argument><expr><operator>(</operator><ternary><condition><expr><call><name>superuser</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name>PGC_SUSET</name></expr> </then><else>: <expr><name>PGC_USERSET</name></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><name>PGC_S_SESSION</name></expr></argument>,
					  <argument><expr><name>GUC_ACTION_LOCAL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * EnsureSequentialMode makes sure that the current transaction is already in
 * sequential mode, or can still safely be put in sequential mode, it errors if that is
 * not possible. The error contains information for the user to retry the transaction with
 * sequential mode set from the beginning.
 *
 * Takes an ObjectType to use in the error/debug messages.
 */</comment>
<function><type><name>void</name></type>
<name>EnsureSequentialMode</name><parameter_list>(<parameter><decl><type><name>ObjectType</name></type> <name>objType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>objTypeString</name> <init>= <expr><call><name>GetObjectTypeString</name><argument_list>(<argument><expr><name>objType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ParallelQueryExecutedInTransaction</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot run %s command because there was a "</literal>
							   <literal type="string">"parallel operation on a distributed table in the "</literal>
							   <literal type="string">"transaction"</literal></expr></argument>, <argument><expr><name>objTypeString</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"When running command on/for a distributed %s, Citus "</literal>
								  <literal type="string">"needs to perform all operations over a single "</literal>
								  <literal type="string">"connection per node to ensure consistency."</literal></expr></argument>,
								  <argument><expr><name>objTypeString</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Try re-running the transaction with "</literal>
								<literal type="string">"\"SET LOCAL citus.multi_shard_modify_mode TO "</literal>
								<literal type="string">"\'sequential\';\""</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"switching to sequential query execution mode"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(
						 <argument><expr><literal type="string">"A command for a distributed %s is run. To make sure subsequent "</literal>
						 <literal type="string">"commands see the %s correctly we need to make sure to "</literal>
						 <literal type="string">"use only one connection for all future commands"</literal></expr></argument>,
						 <argument><expr><name>objTypeString</name></expr></argument>, <argument><expr><name>objTypeString</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SetLocalMultiShardModifyModeToSequential</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * GetObjectTypeString takes an ObjectType and returns the string version of it.
 * We (for now) call this function only in EnsureSequentialMode, and use the returned
 * string to generate error/debug messages.
 *
 * If GetObjectTypeString gets called with an ObjectType that is not in the switch
 * statement, the function will return the string "object", and emit a debug message.
 * In that case, make sure you've added the newly supported type to the switch statement.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>GetObjectTypeString</name><parameter_list>(<parameter><decl><type><name>ObjectType</name></type> <name>objType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>objType</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>OBJECT_AGGREGATE</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><literal type="string">"aggregate"</literal></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>OBJECT_COLLATION</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><literal type="string">"collation"</literal></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>OBJECT_DATABASE</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><literal type="string">"database"</literal></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>OBJECT_DOMAIN</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><literal type="string">"domain"</literal></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>OBJECT_EXTENSION</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><literal type="string">"extension"</literal></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>OBJECT_FOREIGN_SERVER</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><literal type="string">"foreign server"</literal></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>OBJECT_FUNCTION</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><literal type="string">"function"</literal></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>OBJECT_SCHEMA</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><literal type="string">"schema"</literal></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>OBJECT_TSCONFIGURATION</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><literal type="string">"text search configuration"</literal></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>OBJECT_TSDICTIONARY</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><literal type="string">"text search dictionary"</literal></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>OBJECT_TYPE</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><literal type="string">"type"</literal></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>OBJECT_VIEW</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><literal type="string">"view"</literal></expr>;</return>
		</block_content>}</block>

		<default>default:</default>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unsupported object type"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Please add string conversion for the object."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><literal type="string">"object"</literal></expr>;</return>
		</block_content>}</block>
	</block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
 * AlterTableConstraintCheck returns if the given query is an ALTER TABLE
 * constraint check query.
 *
 * Postgres uses SPI to execute these queries. To see examples of how these
 * constraint check queries look like, see RI_Initial_Check() and RI_Fkey_check().
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>AlterTableConstraintCheck</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AlterTableInProgress</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * These queries are one or more SELECT queries, where postgres checks
	 * their results either for NULL values or existence of a row at all.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>SkipConstraintValidation</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * While an ALTER TABLE is in progress, we might do SELECTs on some
	 * catalog tables too. For example, when dropping a column, citus_drop_trigger()
	 * runs some SELECTs on catalog tables. These are not constraint check queries.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCitusPlan</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>planTree</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExecutorBoundParams returns the bound parameters of the current ongoing call
 * to ExecutorRun. This is meant to be used by UDFs which need to access bound
 * parameters.
 */</comment>
<function><type><name>ParamListInfo</name></type>
<name>ExecutorBoundParams</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ExecutorLevel</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>executorBoundParams</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * EnsureTaskExecutionAllowed ensures that we do not perform remote
 * execution from within a task. That could happen when the user calls
 * a function in a query that gets pushed down to the worker, and the
 * function performs a query on a distributed table.
 */</comment>
<function><type><name>void</name></type>
<name>EnsureTaskExecutionAllowed</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isRemote</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IsTaskExecutionAllowed</name><argument_list>(<argument><expr><name>isRemote</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot execute a distributed query from a query on a "</literal>
						   <literal type="string">"shard"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Executing a distributed query in a function call that "</literal>
							  <literal type="string">"may be pushed to a remote node can lead to incorrect "</literal>
							  <literal type="string">"results."</literal></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Avoid nesting of distributed queries or use alter user "</literal>
							<literal type="string">"current_user set citus.allow_nested_distributed_execution "</literal>
							<literal type="string">"to on to allow it with possible incorrectness."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * IsTaskExecutionAllowed determines whether task execution is currently allowed.
 * In general, nested distributed execution is not allowed, except in a few cases
 * (forced function call delegation, triggers).
 *
 * We distinguish between local and remote tasks because triggers only disallow
 * remote task execution.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsTaskExecutionAllowed</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isRemote</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>AllowNestedDistributedExecution</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* user explicitly allows nested execution */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isRemote</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>AllowedDistributionColumnValue</name><operator>.</operator><name>isActive</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * When we are in a forced delegated function call, we explicitly check
			 * whether local tasks use the same distribution column value in
			 * EnsureForceDelegationDistributionKey.
			 */</comment>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>InTrigger</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * In triggers on shards we only disallow remote tasks. This has a few
			 * reasons:
			 *
			 * - We want to enable access to co-located shards, but do not have additional
			 *   checks yet.
			 * - Users need to explicitly set enable_unsafe_triggers in order to create
			 *   triggers on distributed tables.
			 * - Triggers on Citus local tables should be able to access other Citus local
			 *   tables.
			 */</comment>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><operator>!</operator><call><name>InLocalTaskExecutionOnShard</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>MaybeInRemoteTaskExecution</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * InLocalTaskExecutionOnShard returns whether we are currently in the local executor
 * and it is working on a shard of a distributed table.
 *
 * In general, we can allow distributed queries inside of local executor, because
 * we can correctly assign tasks to connections. However, we preemptively protect
 * against distributed queries inside of queries on shards of a distributed table,
 * because those might start failing after a shard move.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>InLocalTaskExecutionOnShard</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>LocalExecutorShardId</name> <operator>==</operator> <name>INVALID_SHARD_ID</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* local executor is not active or is processing a task without shards */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DistributedTableShardId</name><argument_list>(<argument><expr><name>LocalExecutorShardId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Local executor is processing a query on a shard, but the shard belongs
		 * to a reference table or Citus local table. We do not expect those to
		 * move.
		 */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * MaybeInRemoteTaskExecution returns whether we could in a remote task execution.
 *
 * We consider anything that happens in a Citus-internal backend, except deleged
 * function or procedure calls as a potential task execution.
 *
 * This function will also return true in other scenarios, such as during metadata
 * syncing. However, since this function is mainly used for restricting (dangerous)
 * nested executions, it is good to be pessimistic.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>MaybeInRemoteTaskExecution</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCitusInternalBackend</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* in a regular, client-initiated backend doing a regular task */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>InTopLevelDelegatedFunctionCall</name> <operator>||</operator> <name>InDelegatedProcedureCall</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* in a citus-initiated backend, but also in a delegated a procedure call */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * InTrigger returns whether the execution is currently in a trigger.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>InTrigger</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>pg_trigger_depth</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
</unit>
