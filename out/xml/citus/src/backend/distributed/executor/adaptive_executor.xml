<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/citus/src/backend/distributed/executor/adaptive_executor.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * adaptive_executor.c
 *
 * The adaptive executor executes a list of tasks (queries on shards) over
 * a connection pool per worker node. The results of the queries, if any,
 * are written to a tuple store.
 *
 * The concepts in the executor are modelled in a set of structs:
 *
 * - DistributedExecution:
 *     Execution of a Task list over a set of WorkerPools.
 * - WorkerPool
 *     Pool of WorkerSessions for the same worker which opportunistically
 *     executes "unassigned" tasks from a queue.
 * - WorkerSession:
 *     Connection to a worker that is used to execute "assigned" tasks
 *     from a queue and may execute unassigned tasks from the WorkerPool.
 * - ShardCommandExecution:
 *     Execution of a Task across a list of placements.
 * - TaskPlacementExecution:
 *     Execution of a Task on a specific placement.
 *     Used in the WorkerPool and WorkerSession queues.
 *
 * Every connection pool (WorkerPool) and every connection (WorkerSession)
 * have a queue of tasks that are ready to execute (readyTaskQueue) and a
 * queue/set of pending tasks that may become ready later in the execution
 * (pendingTaskQueue). The tasks are wrapped in a ShardCommandExecution,
 * which keeps track of the state of execution and is referenced from a
 * TaskPlacementExecution, which is the data structure that is actually
 * added to the queues and describes the state of the execution of a task
 * on a particular worker node.
 *
 * When the task list is part of a bigger distributed transaction, the
 * shards that are accessed or modified by the task may have already been
 * accessed earlier in the transaction. We need to make sure we use the
 * same connection since it may hold relevant locks or have uncommitted
 * writes. In that case we "assign" the task to a connection by adding
 * it to the task queue of specific connection (in
 * AssignTasksToConnectionsOrWorkerPool). Otherwise we consider the task
 * unassigned and add it to the task queue of a worker pool, which means
 * that it can be executed over any connection in the pool.
 *
 * A task may be executed on multiple placements in case of a reference
 * table or a replicated distributed table. Depending on the type of
 * task, it may not be ready to be executed on a worker node immediately.
 * For instance, INSERTs on a reference table are executed serially across
 * placements to avoid deadlocks when concurrent INSERTs take conflicting
 * locks. At the beginning, only the "first" placement is ready to execute
 * and therefore added to the readyTaskQueue in the pool or connection.
 * The remaining placements are added to the pendingTaskQueue. Once
 * execution on the first placement is done the second placement moves
 * from pendingTaskQueue to readyTaskQueue. The same approach is used to
 * fail over read-only tasks to another placement.
 *
 * Once all the tasks are added to a queue, the main loop in
 * RunDistributedExecution repeatedly does the following:
 *
 * For each pool:
 * - ManageWorkPool evaluates whether to open additional connections
 *   based on the number unassigned tasks that are ready to execute
 *   and the targetPoolSize of the execution.
 *
 * Poll all connections:
 * - We use a WaitEventSet that contains all (non-failed) connections
 *   and is rebuilt whenever the set of active connections or any of
 *   their wait flags change.
 *
 *   We almost always check for WL_SOCKET_READABLE because a session
 *   can emit notices at any time during execution, but it will only
 *   wake up WaitEventSetWait when there are actual bytes to read.
 *
 *   We check for WL_SOCKET_WRITEABLE just after sending bytes in case
 *   there is not enough space in the TCP buffer. Since a socket is
 *   almost always writable we also use WL_SOCKET_WRITEABLE as a
 *   mechanism to wake up WaitEventSetWait for non-I/O events, e.g.
 *   when a task moves from pending to ready.
 *
 * For each connection that is ready:
 * - ConnectionStateMachine handles connection establishment and failure
 *   as well as command execution via TransactionStateMachine.
 *
 * When a connection is ready to execute a new task, it first checks its
 * own readyTaskQueue and otherwise takes a task from the worker pool's
 * readyTaskQueue (on a first-come-first-serve basis).
 *
 * In cases where the tasks finish quickly (e.g. &lt;1ms), a single
 * connection will often be sufficient to finish all tasks. It is
 * therefore not necessary that all connections are established
 * successfully or open a transaction (which may be blocked by an
 * intermediate pgbouncer in transaction pooling mode). It is therefore
 * essential that we take a task from the queue only after opening a
 * transaction block.
 *
 * When a command on a worker finishes or the connection is lost, we call
 * PlacementExecutionDone, which then updates the state of the task
 * based on whether we need to run it on other placements. When a
 * connection fails or all connections to a worker fail, we also call
 * PlacementExecutionDone for all queued tasks to try the next placement
 * and, if necessary, mark shard placements as inactive. If a task fails
 * to execute on all placements, the execution fails and the distributed
 * transaction rolls back.
 *
 * For multi-row INSERTs, tasks are executed sequentially by
 * SequentialRunDistributedExecution instead of in parallel, which allows
 * a high degree of concurrency without high risk of deadlocks.
 * Conversely, multi-row UPDATE/DELETE/DDL commands take aggressive locks
 * which forbids concurrency, but allows parallelism without high risk
 * of deadlocks. Note that this is unrelated to SEQUENTIAL_CONNECTION,
 * which indicates that we should use at most one connection per node, but
 * can run tasks in parallel across nodes. This is used when there are
 * writes to a reference table that has foreign keys from a distributed
 * table.
 *
 * Execution finishes when all tasks are done, the query errors out, or
 * the user cancels the query.
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-fe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/dbcommands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/schemacmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/adaptive_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/cancel_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_custom_scan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_safe_lib.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/connection_management.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands/multi_copy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/deparse_shard_query.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shared_connection_stats.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/distributed_execution_locks.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/intermediate_result_pruning.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/local_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_explain.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_partitioning_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_physical_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_server_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/param_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/placement_access.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/placement_connection.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/relation_access_tracking.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/remote_commands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/repartition_join_execution.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/resource_lock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shared_connection_stats.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/subplan_execution.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/transaction_management.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/transaction_identifier.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/tuple_destination.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/version_compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/backend_data.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/ilist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"portability/instr_time.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/latch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timestamp.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SLOW_START_DISABLED</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>


<comment type="block">/*
 * DistributedExecution represents the execution of a distributed query
 * plan.
 */</comment>
<typedef>typedef <type><struct>struct <name>DistributedExecution</name>
<block>{
	<comment type="block">/* the corresponding distributed plan's modLevel */</comment>
	<decl_stmt><decl><type><name>RowModifyLevel</name></type> <name>modLevel</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * remoteAndLocalTaskList contains all the tasks required to finish the
	 * execution. remoteTaskList contains all the tasks required to
	 * finish the remote execution. localTaskList contains all the
	 * local tasks required to finish the local execution.
	 *
	 * remoteAndLocalTaskList is the union of remoteTaskList and localTaskList.
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>remoteAndLocalTaskList</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>remoteTaskList</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>localTaskList</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If a task specific destination is not provided for a task, then use
	 * defaultTupleDest.
	 */</comment>
	<decl_stmt><decl><type><name>TupleDestination</name> <modifier>*</modifier></type><name>defaultTupleDest</name></decl>;</decl_stmt>

	<comment type="block">/* Parameters for parameterized plans. Can be NULL. */</comment>
	<decl_stmt><decl><type><name>ParamListInfo</name></type> <name>paramListInfo</name></decl>;</decl_stmt>

	<comment type="block">/* list of workers involved in the execution */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>workerList</name></decl>;</decl_stmt>

	<comment type="block">/* list of all connections used for distributed execution */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>sessionList</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Flag to indiciate that the set of connections we are interested
	 * in has changed and waitEventSet needs to be rebuilt.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>rebuildWaitEventSet</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Flag to indiciate that the set of wait events we are interested
	 * in might have changed and waitEventSet needs to be updated.
	 *
	 * Note that we set this flag whenever we assign a value to waitFlags,
	 * but we don't check that the waitFlags is actually different from the
	 * previous value. So we might have some false positives for this flag,
	 * which is OK, because in this case ModifyWaitEvent() is noop.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>waitFlagsChanged</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * WaitEventSet used for waiting for I/O events.
	 *
	 * This could also be local to RunDistributedExecution(), but in that case
	 * we had to mark it as "volatile" to avoid PG_TRY()/PG_CATCH() issues, and
	 * cast it to non-volatile when doing WaitEventSetFree(). We thought that
	 * would make code a bit harder to read than making this non-local, so we
	 * move it here. See comments for PG_TRY() in postgres/src/include/elog.h
	 * and "man 3 siglongjmp" for more context.
	 */</comment>
	<decl_stmt><decl><type><name>WaitEventSet</name> <modifier>*</modifier></type><name>waitEventSet</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * The number of connections we aim to open per worker.
	 *
	 * If there are no more tasks to assigned, the actual number may be lower.
	 * If there are already more connections, the actual number may be higher.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>targetPoolSize</name></decl>;</decl_stmt>

	<comment type="block">/* total number of tasks to execute */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>totalTaskCount</name></decl>;</decl_stmt>

	<comment type="block">/* number of tasks that still need to be executed */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>unfinishedTaskCount</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Flag to indicate whether throwing errors on cancellation is
	 * allowed.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>raiseInterrupts</name></decl>;</decl_stmt>

	<comment type="block">/* transactional properties of the current execution */</comment>
	<decl_stmt><decl><type><name>TransactionProperties</name> <modifier>*</modifier></type><name>transactionProperties</name></decl>;</decl_stmt>

	<comment type="block">/* indicates whether distributed execution has failed */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>failed</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * For SELECT commands or INSERT/UPDATE/DELETE commands with RETURNING,
	 * the total number of rows received from the workers. For
	 * INSERT/UPDATE/DELETE commands without RETURNING, the total number of
	 * tuples modified.
	 *
	 * Note that for replicated tables (e.g., reference tables), we only consider
	 * a single replica's rows that are processed.
	 */</comment>
	<decl_stmt><decl><type><name>uint64</name></type> <name>rowsProcessed</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * The following fields are used while receiving results from remote nodes.
	 * We store this information here to avoid re-allocating it every time.
	 *
	 * columnArray field is reset/calculated per row, so might be useless for
	 * other contexts. The benefit of keeping it here is to avoid allocating
	 * the array over and over again.
	 */</comment>
	<decl_stmt><decl><type><name>uint32</name></type> <name>allocatedColumnCount</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>columnArray</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name> <modifier>*</modifier></type><name>stringInfoDataArray</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * jobIdList contains all jobs in the job tree, this is used to
	 * do cleanup for repartition queries.
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>jobIdList</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Indicates whether we can execute tasks locally during distributed
	 * execution. In other words, this flag must be set to false when
	 * executing a command that we surely know that local execution would
	 * fail, such as CREATE INDEX CONCURRENTLY.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>localExecutionSupported</name></decl>;</decl_stmt>
}</block></struct></type> <name>DistributedExecution</name>;</typedef>


<comment type="block">/*
 * WorkerPoolFailureState indicates the current state of the
 * pool.
 */</comment>
<typedef>typedef <type><enum>enum <name>WorkerPoolFailureState</name>
<block>{
	<comment type="block">/* safe to continue execution*/</comment>
	<decl><name>WORKER_POOL_NOT_FAILED</name></decl>,

	<comment type="block">/* if a pool fails, the execution fails */</comment>
	<decl><name>WORKER_POOL_FAILED</name></decl>,

	<comment type="block">/*
	 * The remote execution over the pool failed, but we failed over
	 * to the local execution and still finish the execution.
	 */</comment>
	<decl><name>WORKER_POOL_FAILED_OVER_TO_LOCAL</name></decl>
}</block></enum></type> <name>WorkerPoolFailureState</name>;</typedef>

<comment type="block">/*
 * WorkerPool represents a pool of sessions on the same worker.
 *
 * A WorkerPool has two queues containing the TaskPlacementExecutions that need
 * to be executed on the worker.
 *
 * TaskPlacementExecutions that are ready to execute are in readyTaskQueue.
 * TaskPlacementExecutions that may need to be executed once execution on
 * another worker finishes or fails are in pendingTaskQueue.
 *
 * In TransactionStateMachine, the sessions opportunistically take
 * TaskPlacementExecutions from the readyQueue when they are ready and have no
 * assigned tasks.
 *
 * We track connection timeouts per WorkerPool. When the first connection is
 * established we set the poolStartTime and if no connection can be established
 * before NodeConnectionTime, the WorkerPool fails. There is some specialised
 * logic in case citus.force_max_query_parallelization is enabled because we
 * may fail to establish a connection per placement after already establishing
 * some connections earlier in the execution.
 *
 * A WorkerPool fails if all connection attempts failed or all connections
 * are lost. In that case, all TaskPlacementExecutions in the queues are
 * marked as failed in PlacementExecutionDone, which typically causes the
 * task and therefore the distributed execution to fail. In case of a
 * replicated table or a SELECT on a reference table, the remaining placements
 * will be tried by moving them from a pendingTaskQueue to a readyTaskQueue.
 */</comment>
<typedef>typedef <type><struct>struct <name>WorkerPool</name>
<block>{
	<comment type="block">/* distributed execution in which the worker participates */</comment>
	<decl_stmt><decl><type><name>DistributedExecution</name> <modifier>*</modifier></type><name>distributedExecution</name></decl>;</decl_stmt>

	<comment type="block">/* worker node on which we have a pool of sessions */</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nodeName</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nodePort</name></decl>;</decl_stmt>

	<comment type="block">/* all sessions on the worker that are part of the current execution */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>sessionList</name></decl>;</decl_stmt>

	<comment type="block">/* number of connections that were established */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>activeConnectionCount</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Keep track of how many connections are ready for execution, in
	 * order to (efficiently) know whether more connections to the worker
	 * are needed.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>idleConnectionCount</name></decl>;</decl_stmt>

	<comment type="block">/* number of connections that did not send a command */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>unusedConnectionCount</name></decl>;</decl_stmt>

	<comment type="block">/* number of failed connections */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>failedConnectionCount</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Placement executions destined for worker node, but not assigned to any
	 * connection and not yet ready to start (depends on other placement
	 * executions).
	 */</comment>
	<decl_stmt><decl><type><name>dlist_head</name></type> <name>pendingTaskQueue</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Placement executions destined for worker node, but not assigned to any
	 * connection and not ready to start.
	 */</comment>
	<decl_stmt><decl><type><name>dlist_head</name></type> <name>readyTaskQueue</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>readyTaskCount</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We keep this for enforcing the connection timeouts. In our definition, a pool
	 * starts when the first connection establishment starts.
	 */</comment>
	<decl_stmt><decl><type><name>instr_time</name></type> <name>poolStartTime</name></decl>;</decl_stmt>

	<comment type="block">/* indicates whether to check for the connection timeout */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>checkForPoolTimeout</name></decl>;</decl_stmt>

	<comment type="block">/* last time we opened a connection */</comment>
	<decl_stmt><decl><type><name>instr_time</name></type> <name>lastConnectionOpenTime</name></decl>;</decl_stmt>

	<comment type="block">/* maximum number of connections we are allowed to open at once */</comment>
	<decl_stmt><decl><type><name>uint32</name></type> <name>maxNewConnectionsPerCycle</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Set to true if the pool is to local node. We use this value to
	 * avoid re-calculating often.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>poolToLocalNode</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * This is only set in WorkerPoolFailed() function. Once a pool fails, we do not
	 * use it anymore.
	 */</comment>
	<decl_stmt><decl><type><name>WorkerPoolFailureState</name></type> <name>failureState</name></decl>;</decl_stmt>

	<comment type="block">/* execution statistics per pool, in microseconds */</comment>
	<decl_stmt><decl><type><name>uint64</name></type> <name>totalTaskExecutionTime</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>totalExecutedTasks</name></decl>;</decl_stmt>
}</block></struct></type> <name>WorkerPool</name>;</typedef>

<struct_decl>struct <name>TaskPlacementExecution</name>;</struct_decl>

<comment type="block">/*
 * WorkerSession represents a session on a worker that can execute tasks
 * (sequentially) and is part of a WorkerPool.
 *
 * Each WorkerSession has two queues containing TaskPlacementExecutions that
 * need to be executed within this particular session because the session
 * accessed the same or co-located placements earlier in the transaction.
 *
 * TaskPlacementExecutions that are ready to execute are in readyTaskQueue.
 * TaskPlacementExecutions that may need to be executed once execution on
 * another worker finishes or fails are in pendingTaskQueue.
 */</comment>
<typedef>typedef <type><struct>struct <name>WorkerSession</name>
<block>{
	<comment type="block">/* only useful for debugging */</comment>
	<decl_stmt><decl><type><name>uint64</name></type> <name>sessionId</name></decl>;</decl_stmt>

	<comment type="block">/* worker pool of which this session is part */</comment>
	<decl_stmt><decl><type><name>WorkerPool</name> <modifier>*</modifier></type><name>workerPool</name></decl>;</decl_stmt>

	<comment type="block">/* connection over which the session is established */</comment>
	<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl>;</decl_stmt>

	<comment type="block">/* tasks that need to be executed on this connection, but are not ready to start  */</comment>
	<decl_stmt><decl><type><name>dlist_head</name></type> <name>pendingTaskQueue</name></decl>;</decl_stmt>

	<comment type="block">/* tasks that need to be executed on this connection and are ready to start */</comment>
	<decl_stmt><decl><type><name>dlist_head</name></type> <name>readyTaskQueue</name></decl>;</decl_stmt>

	<comment type="block">/* task the worker should work on or NULL */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>TaskPlacementExecution</name></name> <modifier>*</modifier></type><name>currentTask</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * The number of commands sent to the worker over the session. Excludes
	 * distributed transaction related commands such as BEGIN/COMMIT etc.
	 */</comment>
	<decl_stmt><decl><type><name>uint64</name></type> <name>commandsSent</name></decl>;</decl_stmt>

	<comment type="block">/* index in the wait event set */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>waitEventSetIndex</name></decl>;</decl_stmt>

	<comment type="block">/* events reported by the latest call to WaitEventSetWait */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>latestUnconsumedWaitEvents</name></decl>;</decl_stmt>

	<comment type="block">/* for some restricted scenarios, we allow a single connection retry */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>connectionRetried</name></decl>;</decl_stmt>

	<comment type="block">/* keep track of if the session has an active connection */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>sessionHasActiveConnection</name></decl>;</decl_stmt>
}</block></struct></type> <name>WorkerSession</name>;</typedef>


<struct_decl>struct <name>TaskPlacementExecution</name>;</struct_decl>

<comment type="block">/* GUC, determining whether Citus opens 1 connection per task */</comment>
<decl_stmt><decl><type><name>bool</name></type> <name>ForceMaxQueryParallelization</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>MaxAdaptiveExecutorPoolSize</name> <init>= <expr><literal type="number">16</literal></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <name>PG_VERSION_14</name></expr></cpp:if>
<decl_stmt><decl><type><name>bool</name></type> <name>EnableBinaryProtocol</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>bool</name></type> <name>EnableBinaryProtocol</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* GUC, number of ms to wait between opening connections to the same worker */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>ExecutorSlowStartInterval</name> <init>= <expr><literal type="number">10</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>EnableCostBasedConnectionEstablishment</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>PreventIncompleteConnectionEstablishment</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>


<comment type="block">/*
 * TaskExecutionState indicates whether or not a command on a shard
 * has finished, or whether it has failed.
 */</comment>
<typedef>typedef <type><enum>enum <name>TaskExecutionState</name>
<block>{
	<decl><name>TASK_EXECUTION_NOT_FINISHED</name></decl>,
	<decl><name>TASK_EXECUTION_FINISHED</name></decl>,
	<decl><name>TASK_EXECUTION_FAILED</name></decl>,
	<decl><name>TASK_EXECUTION_FAILOVER_TO_LOCAL_EXECUTION</name></decl>
}</block></enum></type> <name>TaskExecutionState</name>;</typedef>

<comment type="block">/*
 * PlacementExecutionOrder indicates whether a command should be executed
 * on any replica, on all replicas sequentially (in order), or on all
 * replicas in parallel.
 */</comment>
<typedef>typedef <type><enum>enum <name>PlacementExecutionOrder</name>
<block>{
	<decl><name>EXECUTION_ORDER_ANY</name></decl>,
	<decl><name>EXECUTION_ORDER_SEQUENTIAL</name></decl>,
	<decl><name>EXECUTION_ORDER_PARALLEL</name></decl>,
}</block></enum></type> <name>PlacementExecutionOrder</name>;</typedef>


<comment type="block">/*
 * ShardCommandExecution represents an execution of a command on a shard
 * that may (need to) run across multiple placements.
 */</comment>
<typedef>typedef <type><struct>struct <name>ShardCommandExecution</name>
<block>{
	<comment type="block">/* description of the task */</comment>
	<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name></decl>;</decl_stmt>

	<comment type="block">/* cached AttInMetadata for task */</comment>
	<decl_stmt><decl><type><name>AttInMetadata</name> <modifier>*</modifier><modifier>*</modifier></type><name>attributeInputMetadata</name></decl>;</decl_stmt>

	<comment type="block">/* indicates whether the attributeInputMetadata has binary or text
	 * encoding/decoding functions */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>binaryResults</name></decl>;</decl_stmt>

	<comment type="block">/* order in which the command should be replicated on replicas */</comment>
	<decl_stmt><decl><type><name>PlacementExecutionOrder</name></type> <name>executionOrder</name></decl>;</decl_stmt>

	<comment type="block">/* executions of the command on the placements of the shard */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>TaskPlacementExecution</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>placementExecutions</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>placementExecutionCount</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * RETURNING results from other shard placements can be ignored
	 * after we got results from the first placements.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>gotResults</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>TaskExecutionState</name></type> <name>executionState</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Indicates whether given shard command can be executed locally on
	 * placements. Normally determined by DistributedExecution's same field.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>localExecutionSupported</name></decl>;</decl_stmt>
}</block></struct></type> <name>ShardCommandExecution</name>;</typedef>

<comment type="block">/*
 * TaskPlacementExecutionState indicates whether a command is running
 * on a shard placement, or finished or failed.
 */</comment>
<typedef>typedef <type><enum>enum <name>TaskPlacementExecutionState</name>
<block>{
	<decl><name>PLACEMENT_EXECUTION_NOT_READY</name></decl>,
	<decl><name>PLACEMENT_EXECUTION_READY</name></decl>,
	<decl><name>PLACEMENT_EXECUTION_RUNNING</name></decl>,
	<decl><name>PLACEMENT_EXECUTION_FINISHED</name></decl>,
	<decl><name>PLACEMENT_EXECUTION_FAILOVER_TO_LOCAL_EXECUTION</name></decl>,
	<decl><name>PLACEMENT_EXECUTION_FAILED</name></decl>
}</block></enum></type> <name>TaskPlacementExecutionState</name>;</typedef>

<comment type="block">/*
 * TaskPlacementExecution represents the an execution of a command
 * on a shard placement.
 */</comment>
<typedef>typedef <type><struct>struct <name>TaskPlacementExecution</name>
<block>{
	<comment type="block">/* shard command execution of which this placement execution is part */</comment>
	<decl_stmt><decl><type><name>ShardCommandExecution</name> <modifier>*</modifier></type><name>shardCommandExecution</name></decl>;</decl_stmt>

	<comment type="block">/* shard placement on which this command runs */</comment>
	<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>shardPlacement</name></decl>;</decl_stmt>

	<comment type="block">/* state of the execution of the command on the placement */</comment>
	<decl_stmt><decl><type><name>TaskPlacementExecutionState</name></type> <name>executionState</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Task query can contain multiple queries. queryIndex tracks results of
	 * which query we are waiting for.
	 */</comment>
	<decl_stmt><decl><type><name>uint32</name></type> <name>queryIndex</name></decl>;</decl_stmt>

	<comment type="block">/* worker pool on which the placement needs to be executed */</comment>
	<decl_stmt><decl><type><name>WorkerPool</name> <modifier>*</modifier></type><name>workerPool</name></decl>;</decl_stmt>

	<comment type="block">/* the session the placement execution is assigned to or NULL */</comment>
	<decl_stmt><decl><type><name>WorkerSession</name> <modifier>*</modifier></type><name>assignedSession</name></decl>;</decl_stmt>

	<comment type="block">/* membership in assigned task queue of a particular session */</comment>
	<decl_stmt><decl><type><name>dlist_node</name></type> <name>sessionPendingQueueNode</name></decl>;</decl_stmt>

	<comment type="block">/* membership in ready-to-start assigned task queue of a particular session */</comment>
	<decl_stmt><decl><type><name>dlist_node</name></type> <name>sessionReadyQueueNode</name></decl>;</decl_stmt>

	<comment type="block">/* membership in assigned task queue of worker */</comment>
	<decl_stmt><decl><type><name>dlist_node</name></type> <name>workerPendingQueueNode</name></decl>;</decl_stmt>

	<comment type="block">/* membership in ready-to-start task queue of worker */</comment>
	<decl_stmt><decl><type><name>dlist_node</name></type> <name>workerReadyQueueNode</name></decl>;</decl_stmt>

	<comment type="block">/* index in array of placement executions in a ShardCommandExecution */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>placementExecutionIndex</name></decl>;</decl_stmt>

	<comment type="block">/* execution time statistics for this placement execution */</comment>
	<decl_stmt><decl><type><name>instr_time</name></type> <name>startTime</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>instr_time</name></type> <name>endTime</name></decl>;</decl_stmt>
}</block></struct></type> <name>TaskPlacementExecution</name>;</typedef>


<comment type="block">/* local functions */</comment>
<function_decl><type><specifier>static</specifier> <name>DistributedExecution</name> <modifier>*</modifier></type> <name>CreateDistributedExecution</name><parameter_list>(<parameter><decl><type><name>RowModifyLevel</name></type> <name>modLevel</name></decl></parameter>,
														 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name></decl></parameter>,
														 <parameter><decl><type><name>ParamListInfo</name></type> <name>paramListInfo</name></decl></parameter>,
														 <parameter><decl><type><name>int</name></type> <name>targetPoolSize</name></decl></parameter>,
														 <parameter><decl><type><name>TupleDestination</name> <modifier>*</modifier></type>
														 <name>defaultTupleDest</name></decl></parameter>,
														 <parameter><decl><type><name>TransactionProperties</name> <modifier>*</modifier></type>
														 <name>xactProperties</name></decl></parameter>,
														 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>jobIdList</name></decl></parameter>,
														 <parameter><decl><type><name>bool</name></type> <name>localExecutionSupported</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TransactionProperties</name></type> <name>DecideTransactionPropertiesForTaskList</name><parameter_list>(<parameter><decl><type><name>RowModifyLevel</name></type>
																	<name>modLevel</name></decl></parameter>,
																	<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name></decl></parameter>,
																	<parameter><decl><type><name>bool</name></type>
																	<name>exludeFromTransaction</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>StartDistributedExecution</name><parameter_list>(<parameter><decl><type><name>DistributedExecution</name> <modifier>*</modifier></type><name>execution</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RunLocalExecution</name><parameter_list>(<parameter><decl><type><name>CitusScanState</name> <modifier>*</modifier></type><name>scanState</name></decl></parameter>, <parameter><decl><type><name>DistributedExecution</name> <modifier>*</modifier></type><name>execution</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RunDistributedExecution</name><parameter_list>(<parameter><decl><type><name>DistributedExecution</name> <modifier>*</modifier></type><name>execution</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SequentialRunDistributedExecution</name><parameter_list>(<parameter><decl><type><name>DistributedExecution</name> <modifier>*</modifier></type><name>execution</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>FinishDistributedExecution</name><parameter_list>(<parameter><decl><type><name>DistributedExecution</name> <modifier>*</modifier></type><name>execution</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CleanUpSessions</name><parameter_list>(<parameter><decl><type><name>DistributedExecution</name> <modifier>*</modifier></type><name>execution</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>LockPartitionsForDistributedPlan</name><parameter_list>(<parameter><decl><type><name>DistributedPlan</name> <modifier>*</modifier></type><name>distributedPlan</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AcquireExecutorShardLocksForExecution</name><parameter_list>(<parameter><decl><type><name>DistributedExecution</name> <modifier>*</modifier></type><name>execution</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ModifiedTableReplicated</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>DistributedExecutionModifiesDatabase</name><parameter_list>(<parameter><decl><type><name>DistributedExecution</name> <modifier>*</modifier></type><name>execution</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>TaskListModifiesDatabase</name><parameter_list>(<parameter><decl><type><name>RowModifyLevel</name></type> <name>modLevel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>DistributedExecutionRequiresRollback</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>TaskListRequires2PC</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>SelectForUpdateOnReferenceTable</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AssignTasksToConnectionsOrWorkerPool</name><parameter_list>(<parameter><decl><type><name>DistributedExecution</name> <modifier>*</modifier></type><name>execution</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>UnclaimAllSessionConnections</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sessionList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PlacementExecutionOrder</name></type> <name>ExecutionOrderForTask</name><parameter_list>(<parameter><decl><type><name>RowModifyLevel</name></type> <name>modLevel</name></decl></parameter>, <parameter><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>WorkerPool</name> <modifier>*</modifier></type> <name>FindOrCreateWorkerPool</name><parameter_list>(<parameter><decl><type><name>DistributedExecution</name> <modifier>*</modifier></type><name>execution</name></decl></parameter>,
										   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>nodeName</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nodePort</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>WorkerSession</name> <modifier>*</modifier></type> <name>FindOrCreateWorkerSession</name><parameter_list>(<parameter><decl><type><name>WorkerPool</name> <modifier>*</modifier></type><name>workerPool</name></decl></parameter>,
												 <parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>RemoteSocketClosedForNewSession</name><parameter_list>(<parameter><decl><type><name>WorkerSession</name> <modifier>*</modifier></type><name>session</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ManageWorkerPool</name><parameter_list>(<parameter><decl><type><name>WorkerPool</name> <modifier>*</modifier></type><name>workerPool</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ShouldWaitForSlowStart</name><parameter_list>(<parameter><decl><type><name>WorkerPool</name> <modifier>*</modifier></type><name>workerPool</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>CalculateNewConnectionCount</name><parameter_list>(<parameter><decl><type><name>WorkerPool</name> <modifier>*</modifier></type><name>workerPool</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>UsingExistingSessionsCheaperThanEstablishingNewConnections</name><parameter_list>(<parameter><decl><type><name>int</name></type>
																	   <name>readyTaskCount</name></decl></parameter>,
																	   <parameter><decl><type><name>WorkerPool</name> <modifier>*</modifier></type>
																	   <name>workerPool</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>double</name></type> <name>AvgTaskExecutionTimeApproximation</name><parameter_list>(<parameter><decl><type><name>WorkerPool</name> <modifier>*</modifier></type><name>workerPool</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>double</name></type> <name>AvgConnectionEstablishmentTime</name><parameter_list>(<parameter><decl><type><name>WorkerPool</name> <modifier>*</modifier></type><name>workerPool</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>OpenNewConnections</name><parameter_list>(<parameter><decl><type><name>WorkerPool</name> <modifier>*</modifier></type><name>workerPool</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>newConnectionCount</name></decl></parameter>,
							   <parameter><decl><type><name>TransactionProperties</name> <modifier>*</modifier></type><name>transactionProperties</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CheckConnectionTimeout</name><parameter_list>(<parameter><decl><type><name>WorkerPool</name> <modifier>*</modifier></type><name>workerPool</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>MarkEstablishingSessionsTimedOut</name><parameter_list>(<parameter><decl><type><name>WorkerPool</name> <modifier>*</modifier></type><name>workerPool</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>UsableConnectionCount</name><parameter_list>(<parameter><decl><type><name>WorkerPool</name> <modifier>*</modifier></type><name>workerPool</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>long</name></type> <name>NextEventTimeout</name><parameter_list>(<parameter><decl><type><name>DistributedExecution</name> <modifier>*</modifier></type><name>execution</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>WaitEventSet</name> <modifier>*</modifier></type> <name>BuildWaitEventSet</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sessionList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AddSessionToWaitEventSet</name><parameter_list>(<parameter><decl><type><name>WorkerSession</name> <modifier>*</modifier></type><name>session</name></decl></parameter>,
									 <parameter><decl><type><name>WaitEventSet</name> <modifier>*</modifier></type><name>waitEventSet</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RebuildWaitEventSetFlags</name><parameter_list>(<parameter><decl><type><name>WaitEventSet</name> <modifier>*</modifier></type><name>waitEventSet</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sessionList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TaskPlacementExecution</name> <modifier>*</modifier></type> <name>PopPlacementExecution</name><parameter_list>(<parameter><decl><type><name>WorkerSession</name> <modifier>*</modifier></type><name>session</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TaskPlacementExecution</name> <modifier>*</modifier></type> <name>PopAssignedPlacementExecution</name><parameter_list>(<parameter><decl><type><name>WorkerSession</name> <modifier>*</modifier></type><name>session</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TaskPlacementExecution</name> <modifier>*</modifier></type> <name>PopUnassignedPlacementExecution</name><parameter_list>(<parameter><decl><type><name>WorkerPool</name> <modifier>*</modifier></type><name>workerPool</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>StartPlacementExecutionOnSession</name><parameter_list>(<parameter><decl><type><name>TaskPlacementExecution</name> <modifier>*</modifier></type><name>placementExecution</name></decl></parameter>,
											 <parameter><decl><type><name>WorkerSession</name> <modifier>*</modifier></type><name>session</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>SendNextQuery</name><parameter_list>(<parameter><decl><type><name>TaskPlacementExecution</name> <modifier>*</modifier></type><name>placementExecution</name></decl></parameter>,
						  <parameter><decl><type><name>WorkerSession</name> <modifier>*</modifier></type><name>session</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ConnectionStateMachine</name><parameter_list>(<parameter><decl><type><name>WorkerSession</name> <modifier>*</modifier></type><name>session</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>HasUnfinishedTaskForSession</name><parameter_list>(<parameter><decl><type><name>WorkerSession</name> <modifier>*</modifier></type><name>session</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>HandleMultiConnectionSuccess</name><parameter_list>(<parameter><decl><type><name>WorkerSession</name> <modifier>*</modifier></type><name>session</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>HasAnyConnectionFailure</name><parameter_list>(<parameter><decl><type><name>WorkerPool</name> <modifier>*</modifier></type><name>workerPool</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>Activate2PCIfModifyingTransactionExpandsToNewNode</name><parameter_list>(<parameter><decl><type><name>WorkerSession</name> <modifier>*</modifier></type><name>session</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>TransactionModifiedDistributedTable</name><parameter_list>(<parameter><decl><type><name>DistributedExecution</name> <modifier>*</modifier></type><name>execution</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>TransactionStateMachine</name><parameter_list>(<parameter><decl><type><name>WorkerSession</name> <modifier>*</modifier></type><name>session</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>UpdateConnectionWaitFlags</name><parameter_list>(<parameter><decl><type><name>WorkerSession</name> <modifier>*</modifier></type><name>session</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>waitFlags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>CheckConnectionReady</name><parameter_list>(<parameter><decl><type><name>WorkerSession</name> <modifier>*</modifier></type><name>session</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ReceiveResults</name><parameter_list>(<parameter><decl><type><name>WorkerSession</name> <modifier>*</modifier></type><name>session</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>storeRows</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WorkerSessionFailed</name><parameter_list>(<parameter><decl><type><name>WorkerSession</name> <modifier>*</modifier></type><name>session</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WorkerPoolFailed</name><parameter_list>(<parameter><decl><type><name>WorkerPool</name> <modifier>*</modifier></type><name>workerPool</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>PlacementExecutionDone</name><parameter_list>(<parameter><decl><type><name>TaskPlacementExecution</name> <modifier>*</modifier></type><name>placementExecution</name></decl></parameter>,
								   <parameter><decl><type><name>bool</name></type> <name>succeeded</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ScheduleNextPlacementExecution</name><parameter_list>(<parameter><decl><type><name>TaskPlacementExecution</name> <modifier>*</modifier></type><name>placementExecution</name></decl></parameter>,
										   <parameter><decl><type><name>bool</name></type> <name>succeeded</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>CanFailoverPlacementExecutionToLocalExecution</name><parameter_list>(<parameter><decl><type><name>TaskPlacementExecution</name> <modifier>*</modifier></type>
														  <name>placementExecution</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>PlacementExecutionReady</name><parameter_list>(<parameter><decl><type><name>TaskPlacementExecution</name> <modifier>*</modifier></type><name>placementExecution</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TaskExecutionState</name></type> <name>TaskExecutionStateMachine</name><parameter_list>(<parameter><decl><type><name>ShardCommandExecution</name> <modifier>*</modifier></type>
													<name>shardCommandExecution</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>HasDependentJobs</name><parameter_list>(<parameter><decl><type><name>Job</name> <modifier>*</modifier></type><name>mainJob</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExtractParametersForRemoteExecution</name><parameter_list>(<parameter><decl><type><name>ParamListInfo</name></type> <name>paramListInfo</name></decl></parameter>,
												<parameter><decl><type><name>Oid</name> <modifier>*</modifier><modifier>*</modifier></type><name>parameterTypes</name></decl></parameter>,
												<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>parameterValues</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>GetEventSetSize</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sessionList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ProcessSessionsWithFailedWaitEventSetOperations</name><parameter_list>(
	<parameter><decl><type><name>DistributedExecution</name> <modifier>*</modifier></type><name>execution</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>HasIncompleteConnectionEstablishment</name><parameter_list>(<parameter><decl><type><name>DistributedExecution</name> <modifier>*</modifier></type><name>execution</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>RebuildWaitEventSet</name><parameter_list>(<parameter><decl><type><name>DistributedExecution</name> <modifier>*</modifier></type><name>execution</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ProcessWaitEvents</name><parameter_list>(<parameter><decl><type><name>DistributedExecution</name> <modifier>*</modifier></type><name>execution</name></decl></parameter>, <parameter><decl><type><name>WaitEvent</name> <modifier>*</modifier></type><name>events</name></decl></parameter>, <parameter><decl><type><name>int</name></type>
							  <name>eventCount</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>cancellationReceived</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <name>PG_VERSION_15</name></expr></cpp:if>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ProcessWaitEventsForSocketClosed</name><parameter_list>(<parameter><decl><type><name>WaitEvent</name> <modifier>*</modifier></type><name>events</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eventCount</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><specifier>static</specifier> <name>long</name></type> <name>MillisecondsBetweenTimestamps</name><parameter_list>(<parameter><decl><type><name>instr_time</name></type> <name>startTime</name></decl></parameter>, <parameter><decl><type><name>instr_time</name></type> <name>endTime</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint64</name></type> <name>MicrosecondsBetweenTimestamps</name><parameter_list>(<parameter><decl><type><name>instr_time</name></type> <name>startTime</name></decl></parameter>, <parameter><decl><type><name>instr_time</name></type> <name>endTime</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HeapTuple</name></type> <name>BuildTupleFromBytes</name><parameter_list>(<parameter><decl><type><name>AttInMetadata</name> <modifier>*</modifier></type><name>attinmeta</name></decl></parameter>, <parameter><decl><type><name>fmStringInfo</name> <modifier>*</modifier></type><name>values</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>AttInMetadata</name> <modifier>*</modifier></type> <name>TupleDescGetAttBinaryInMetadata</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>WorkerPoolCompare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>lhsKey</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>rhsKey</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SetAttributeInputMetadata</name><parameter_list>(<parameter><decl><type><name>DistributedExecution</name> <modifier>*</modifier></type><name>execution</name></decl></parameter>,
									  <parameter><decl><type><name>ShardCommandExecution</name> <modifier>*</modifier></type><name>shardCommandExecution</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>LookupTaskPlacementHostAndPort</name><parameter_list>(<parameter><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>taskPlacement</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>nodeName</name></decl></parameter>,
										   <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nodePort</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsDummyPlacement</name><parameter_list>(<parameter><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>taskPlacement</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * AdaptiveExecutorPreExecutorRun gets called right before postgres starts its executor
 * run. Given that the result of our subplans would be evaluated before the first call to
 * the exec function of our custom scan we make sure our subplans have executed before.
 */</comment>
<function><type><name>void</name></type>
<name>AdaptiveExecutorPreExecutorRun</name><parameter_list>(<parameter><decl><type><name>CitusScanState</name> <modifier>*</modifier></type><name>scanState</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>scanState</name><operator>-&gt;</operator><name>finishedPreScan</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Cursors (and hence RETURN QUERY syntax in pl/pgsql functions)
		 * may trigger AdaptiveExecutorPreExecutorRun() on every fetch
		 * operation. Though, we should only execute PreScan once.
		 */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>DistributedPlan</name> <modifier>*</modifier></type><name>distributedPlan</name> <init>= <expr><name><name>scanState</name><operator>-&gt;</operator><name>distributedPlan</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * PostgreSQL takes locks on all partitions in the executor. It's not entirely
	 * clear why this is necessary (instead of locking the parent during DDL), but
	 * we do the same for consistency.
	 */</comment>
	<expr_stmt><expr><call><name>LockPartitionsForDistributedPlan</name><argument_list>(<argument><expr><name>distributedPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecuteSubPlans</name><argument_list>(<argument><expr><name>distributedPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>scanState</name><operator>-&gt;</operator><name>finishedPreScan</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * AdaptiveExecutor is called via CitusExecScan on the
 * first call of CitusExecScan. The function fills the tupleStore
 * of the input scanScate.
 */</comment>
<function><type><name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>AdaptiveExecutor</name><parameter_list>(<parameter><decl><type><name>CitusScanState</name> <modifier>*</modifier></type><name>scanState</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>resultSlot</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>DistributedPlan</name> <modifier>*</modifier></type><name>distributedPlan</name> <init>= <expr><name><name>scanState</name><operator>-&gt;</operator><name>distributedPlan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name> <modifier>*</modifier></type><name>executorState</name> <init>= <expr><call><name>ScanStateGetExecutorState</name><argument_list>(<argument><expr><name>scanState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParamListInfo</name></type> <name>paramListInfo</name> <init>= <expr><name><name>executorState</name><operator>-&gt;</operator><name>es_param_list_info</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>randomAccess</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>interTransactions</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>targetPoolSize</name> <init>= <expr><name>MaxAdaptiveExecutorPoolSize</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>jobIdList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Job</name> <modifier>*</modifier></type><name>job</name> <init>= <expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>workerJob</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name> <init>= <expr><name><name>job</name><operator>-&gt;</operator><name>taskList</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* we should only call this once before the scan finished */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>scanState</name><operator>-&gt;</operator><name>finishedRemoteScan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>localContext</name> <init>= <expr><call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
													   <argument><expr><literal type="string">"AdaptiveExecutor"</literal></expr></argument>,
													   <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>localContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


	<comment type="block">/* Reset Task fields that are only valid for a single execution */</comment>
	<expr_stmt><expr><call><name>ResetExplainAnalyzeData</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>scanState</name><operator>-&gt;</operator><name>tuplestorestate</name></name> <operator>=</operator>
		<call><name>tuplestore_begin_heap</name><argument_list>(<argument><expr><name>randomAccess</name></expr></argument>, <argument><expr><name>interTransactions</name></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name> <init>= <expr><call><name>ScanStateGetTupleDescriptor</name><argument_list>(<argument><expr><name>scanState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDestination</name> <modifier>*</modifier></type><name>defaultTupleDest</name> <init>=
		<expr><call><name>CreateTupleStoreTupleDest</name><argument_list>(<argument><expr><name><name>scanState</name><operator>-&gt;</operator><name>tuplestorestate</name></name></expr></argument>, <argument><expr><name>tupleDescriptor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RequestedForExplainAnalyze</name><argument_list>(<argument><expr><name>scanState</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We use multiple queries per task in EXPLAIN ANALYZE which need to
		 * be part of the same transaction.
		 */</comment>
		<expr_stmt><expr><call><name>UseCoordinatedTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>taskList</name> <operator>=</operator> <call><name>ExplainAnalyzeTaskList</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>, <argument><expr><name>defaultTupleDest</name></expr></argument>, <argument><expr><name>tupleDescriptor</name></expr></argument>,
										  <argument><expr><name>paramListInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>hasDependentJobs</name> <init>= <expr><call><name>HasDependentJobs</name><argument_list>(<argument><expr><name>job</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>hasDependentJobs</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* jobs use intermediate results, which require a distributed transaction */</comment>
		<expr_stmt><expr><call><name>UseCoordinatedTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>jobIdList</name> <operator>=</operator> <call><name>ExecuteDependentTasks</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>, <argument><expr><name>job</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>MultiShardConnectionType</name> <operator>==</operator> <name>SEQUENTIAL_CONNECTION</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* defer decision after ExecuteSubPlans() */</comment>
		<expr_stmt><expr><name>targetPoolSize</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>excludeFromXact</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>TransactionProperties</name></type> <name>xactProperties</name> <init>= <expr><call><name>DecideTransactionPropertiesForTaskList</name><argument_list>(
		<argument><expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>modLevel</name></name></expr></argument>, <argument><expr><name>taskList</name></expr></argument>, <argument><expr><name>excludeFromXact</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>localExecutionSupported</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * In some rare cases, we have prepared statements that pass a parameter
	 * and never used in the query, mark such parameters' type as Invalid(0),
	 * which will be used later in ExtractParametersFromParamList() to map them
	 * to a generic datatype. Skip for dynamic parameters.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>paramListInfo</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>paramListInfo</name><operator>-&gt;</operator><name>paramFetch</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>paramListInfo</name> <operator>=</operator> <call><name>copyParamList</name><argument_list>(<argument><expr><name>paramListInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MarkUnreferencedExternParams</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>job</name><operator>-&gt;</operator><name>jobQuery</name></name></expr></argument>, <argument><expr><name>paramListInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>DistributedExecution</name> <modifier>*</modifier></type><name>execution</name> <init>= <expr><call><name>CreateDistributedExecution</name><argument_list>(
		<argument><expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>modLevel</name></name></expr></argument>,
		<argument><expr><name>taskList</name></expr></argument>,
		<argument><expr><name>paramListInfo</name></expr></argument>,
		<argument><expr><name>targetPoolSize</name></expr></argument>,
		<argument><expr><name>defaultTupleDest</name></expr></argument>,
		<argument><expr><operator>&amp;</operator><name>xactProperties</name></expr></argument>,
		<argument><expr><name>jobIdList</name></expr></argument>,
		<argument><expr><name>localExecutionSupported</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Make sure that we acquire the appropriate locks even if the local tasks
	 * are going to be executed with local execution.
	 */</comment>
	<expr_stmt><expr><call><name>StartDistributedExecution</name><argument_list>(<argument><expr><name>execution</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ShouldRunTasksSequentially</name><argument_list>(<argument><expr><name><name>execution</name><operator>-&gt;</operator><name>remoteTaskList</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SequentialRunDistributedExecution</name><argument_list>(<argument><expr><name>execution</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>RunDistributedExecution</name><argument_list>(<argument><expr><name>execution</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* execute tasks local to the node (if any) */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>execution</name><operator>-&gt;</operator><name>localTaskList</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* now execute the local tasks */</comment>
		<expr_stmt><expr><call><name>RunLocalExecution</name><argument_list>(<argument><expr><name>scanState</name></expr></argument>, <argument><expr><name>execution</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>CmdType</name></type> <name>commandType</name> <init>= <expr><name><name>job</name><operator>-&gt;</operator><name>jobQuery</name><operator>-&gt;</operator><name>commandType</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>commandType</name> <operator>!=</operator> <name>CMD_SELECT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>executorState</name><operator>-&gt;</operator><name>es_processed</name></name> <operator>=</operator> <name><name>execution</name><operator>-&gt;</operator><name>rowsProcessed</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>FinishDistributedExecution</name><argument_list>(<argument><expr><name>execution</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>SortReturning</name> <operator>&amp;&amp;</operator> <name><name>distributedPlan</name><operator>-&gt;</operator><name>expectResults</name></name> <operator>&amp;&amp;</operator> <name>commandType</name> <operator>!=</operator> <name>CMD_SELECT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SortTupleStore</name><argument_list>(<argument><expr><name>scanState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>resultSlot</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * HasDependentJobs returns true if there is any dependent job
 * for the mainjob(top level) job.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>HasDependentJobs</name><parameter_list>(<parameter><decl><type><name>Job</name> <modifier>*</modifier></type><name>mainJob</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>mainJob</name><operator>-&gt;</operator><name>dependentJobList</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RunLocalExecution runs the localTaskList in the execution, fills the tuplestore
 * and sets the es_processed if necessary.
 *
 * It also sorts the tuplestore if there are no remote tasks remaining.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RunLocalExecution</name><parameter_list>(<parameter><decl><type><name>CitusScanState</name> <modifier>*</modifier></type><name>scanState</name></decl></parameter>, <parameter><decl><type><name>DistributedExecution</name> <modifier>*</modifier></type><name>execution</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name> <init>= <expr><call><name>ScanStateGetExecutorState</name><argument_list>(<argument><expr><name>scanState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isUtilityCommand</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>rowsProcessed</name> <init>= <expr><call><name>ExecuteLocalTaskListExtended</name><argument_list>(<argument><expr><name><name>execution</name><operator>-&gt;</operator><name>localTaskList</name></name></expr></argument>,
														<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_param_list_info</name></name></expr></argument>,
														<argument><expr><name><name>scanState</name><operator>-&gt;</operator><name>distributedPlan</name></name></expr></argument>,
														<argument><expr><name><name>execution</name><operator>-&gt;</operator><name>defaultTupleDest</name></name></expr></argument>,
														<argument><expr><name>isUtilityCommand</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>execution</name><operator>-&gt;</operator><name>rowsProcessed</name></name> <operator>+=</operator> <name>rowsProcessed</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ExecuteUtilityTaskList is a wrapper around executing task
 * list for utility commands.
 */</comment>
<function><type><name>uint64</name></type>
<name>ExecuteUtilityTaskList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>utilityTaskList</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>localExecutionSupported</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RowModifyLevel</name></type> <name>modLevel</name> <init>= <expr><name>ROW_MODIFY_NONE</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExecutionParams</name> <modifier>*</modifier></type><name>executionParams</name> <init>= <expr><call><name>CreateBasicExecutionParams</name><argument_list>(
		<argument><expr><name>modLevel</name></expr></argument>, <argument><expr><name>utilityTaskList</name></expr></argument>, <argument><expr><name>MaxAdaptiveExecutorPoolSize</name></expr></argument>, <argument><expr><name>localExecutionSupported</name></expr></argument>
		)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>executionParams</name><operator>-&gt;</operator><name>xactProperties</name></name> <operator>=</operator>
		<call><name>DecideTransactionPropertiesForTaskList</name><argument_list>(<argument><expr><name>modLevel</name></expr></argument>, <argument><expr><name>utilityTaskList</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>executionParams</name><operator>-&gt;</operator><name>isUtilityCommand</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<return>return <expr><call><name>ExecuteTaskListExtended</name><argument_list>(<argument><expr><name>executionParams</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExecuteUtilityTaskListExtended is a wrapper around executing task
 * list for utility commands.
 */</comment>
<function><type><name>uint64</name></type>
<name>ExecuteUtilityTaskListExtended</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>utilityTaskList</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>poolSize</name></decl></parameter>,
							   <parameter><decl><type><name>bool</name></type> <name>localExecutionSupported</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RowModifyLevel</name></type> <name>modLevel</name> <init>= <expr><name>ROW_MODIFY_NONE</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExecutionParams</name> <modifier>*</modifier></type><name>executionParams</name> <init>= <expr><call><name>CreateBasicExecutionParams</name><argument_list>(
		<argument><expr><name>modLevel</name></expr></argument>, <argument><expr><name>utilityTaskList</name></expr></argument>, <argument><expr><name>poolSize</name></expr></argument>, <argument><expr><name>localExecutionSupported</name></expr></argument>
		)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>excludeFromXact</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>executionParams</name><operator>-&gt;</operator><name>xactProperties</name></name> <operator>=</operator>
		<call><name>DecideTransactionPropertiesForTaskList</name><argument_list>(<argument><expr><name>modLevel</name></expr></argument>, <argument><expr><name>utilityTaskList</name></expr></argument>,
											   <argument><expr><name>excludeFromXact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>executionParams</name><operator>-&gt;</operator><name>isUtilityCommand</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<return>return <expr><call><name>ExecuteTaskListExtended</name><argument_list>(<argument><expr><name>executionParams</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExecuteTaskList is a proxy to ExecuteTaskListExtended
 * with defaults for some of the arguments.
 */</comment>
<function><type><name>uint64</name></type>
<name>ExecuteTaskList</name><parameter_list>(<parameter><decl><type><name>RowModifyLevel</name></type> <name>modLevel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>localExecutionSupported</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExecutionParams</name> <modifier>*</modifier></type><name>executionParams</name> <init>= <expr><call><name>CreateBasicExecutionParams</name><argument_list>(
		<argument><expr><name>modLevel</name></expr></argument>, <argument><expr><name>taskList</name></expr></argument>, <argument><expr><name>MaxAdaptiveExecutorPoolSize</name></expr></argument>, <argument><expr><name>localExecutionSupported</name></expr></argument>
		)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>excludeFromXact</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>executionParams</name><operator>-&gt;</operator><name>xactProperties</name></name> <operator>=</operator> <call><name>DecideTransactionPropertiesForTaskList</name><argument_list>(
		<argument><expr><name>modLevel</name></expr></argument>, <argument><expr><name>taskList</name></expr></argument>, <argument><expr><name>excludeFromXact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>ExecuteTaskListExtended</name><argument_list>(<argument><expr><name>executionParams</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExecuteTaskListOutsideTransaction is a proxy to ExecuteTaskListExtended
 * with defaults for some of the arguments.
 */</comment>
<function><type><name>uint64</name></type>
<name>ExecuteTaskListOutsideTransaction</name><parameter_list>(<parameter><decl><type><name>RowModifyLevel</name></type> <name>modLevel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name></decl></parameter>,
								  <parameter><decl><type><name>int</name></type> <name>targetPoolSize</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>jobIdList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * As we are going to run the tasks outside transaction, we shouldn't use local execution.
	 * However, there is some problem when using local execution related to
	 * repartition joins, when we solve that problem, we can execute the tasks
	 * coming to this path with local execution. See PR:3711
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>localExecutionSupported</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExecutionParams</name> <modifier>*</modifier></type><name>executionParams</name> <init>= <expr><call><name>CreateBasicExecutionParams</name><argument_list>(
		<argument><expr><name>modLevel</name></expr></argument>, <argument><expr><name>taskList</name></expr></argument>, <argument><expr><name>targetPoolSize</name></expr></argument>, <argument><expr><name>localExecutionSupported</name></expr></argument>
		)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>executionParams</name><operator>-&gt;</operator><name>xactProperties</name></name> <operator>=</operator> <call><name>DecideTransactionPropertiesForTaskList</name><argument_list>(
		<argument><expr><name>modLevel</name></expr></argument>, <argument><expr><name>taskList</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>ExecuteTaskListExtended</name><argument_list>(<argument><expr><name>executionParams</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExecuteTaskListIntoTupleDest is a proxy to ExecuteTaskListExtended() with defaults
 * for some of the arguments.
 */</comment>
<function><type><name>uint64</name></type>
<name>ExecuteTaskListIntoTupleDest</name><parameter_list>(<parameter><decl><type><name>RowModifyLevel</name></type> <name>modLevel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name></decl></parameter>,
							 <parameter><decl><type><name>TupleDestination</name> <modifier>*</modifier></type><name>tupleDest</name></decl></parameter>,
							 <parameter><decl><type><name>bool</name></type> <name>expectResults</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>targetPoolSize</name> <init>= <expr><name>MaxAdaptiveExecutorPoolSize</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>localExecutionSupported</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExecutionParams</name> <modifier>*</modifier></type><name>executionParams</name> <init>= <expr><call><name>CreateBasicExecutionParams</name><argument_list>(
		<argument><expr><name>modLevel</name></expr></argument>, <argument><expr><name>taskList</name></expr></argument>, <argument><expr><name>targetPoolSize</name></expr></argument>, <argument><expr><name>localExecutionSupported</name></expr></argument>
		)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>executionParams</name><operator>-&gt;</operator><name>xactProperties</name></name> <operator>=</operator> <call><name>DecideTransactionPropertiesForTaskList</name><argument_list>(
		<argument><expr><name>modLevel</name></expr></argument>, <argument><expr><name>taskList</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>executionParams</name><operator>-&gt;</operator><name>expectResults</name></name> <operator>=</operator> <name>expectResults</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>executionParams</name><operator>-&gt;</operator><name>tupleDestination</name></name> <operator>=</operator> <name>tupleDest</name></expr>;</expr_stmt>

	<return>return <expr><call><name>ExecuteTaskListExtended</name><argument_list>(<argument><expr><name>executionParams</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExecuteTaskListExtended sets up the execution for given task list and
 * runs it.
 */</comment>
<function><type><name>uint64</name></type>
<name>ExecuteTaskListExtended</name><parameter_list>(<parameter><decl><type><name>ExecutionParams</name> <modifier>*</modifier></type><name>executionParams</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParamListInfo</name></type> <name>paramListInfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>locallyProcessedRows</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>TupleDestination</name> <modifier>*</modifier></type><name>defaultTupleDest</name> <init>= <expr><name><name>executionParams</name><operator>-&gt;</operator><name>tupleDestination</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>MultiShardConnectionType</name> <operator>==</operator> <name>SEQUENTIAL_CONNECTION</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>executionParams</name><operator>-&gt;</operator><name>targetPoolSize</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>DistributedExecution</name> <modifier>*</modifier></type><name>execution</name> <init>=
		<expr><call><name>CreateDistributedExecution</name><argument_list>(
			<argument><expr><name><name>executionParams</name><operator>-&gt;</operator><name>modLevel</name></name></expr></argument>, <argument><expr><name><name>executionParams</name><operator>-&gt;</operator><name>taskList</name></name></expr></argument>,
			<argument><expr><name>paramListInfo</name></expr></argument>, <argument><expr><name><name>executionParams</name><operator>-&gt;</operator><name>targetPoolSize</name></name></expr></argument>,
			<argument><expr><name>defaultTupleDest</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>executionParams</name><operator>-&gt;</operator><name>xactProperties</name></name></expr></argument>,
			<argument><expr><name><name>executionParams</name><operator>-&gt;</operator><name>jobIdList</name></name></expr></argument>, <argument><expr><name><name>executionParams</name><operator>-&gt;</operator><name>localExecutionSupported</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If current transaction accessed local placements and task list includes
	 * tasks that should be executed locally (accessing any of the local placements),
	 * then we should error out as it would cause inconsistencies across the
	 * remote connection and local execution.
	 */</comment>
	<expr_stmt><expr><call><name>EnsureCompatibleLocalExecutionState</name><argument_list>(<argument><expr><name><name>execution</name><operator>-&gt;</operator><name>remoteTaskList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* run the remote execution */</comment>
	<expr_stmt><expr><call><name>StartDistributedExecution</name><argument_list>(<argument><expr><name>execution</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RunDistributedExecution</name><argument_list>(<argument><expr><name>execution</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FinishDistributedExecution</name><argument_list>(<argument><expr><name>execution</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* now, switch back to the local execution */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>executionParams</name><operator>-&gt;</operator><name>isUtilityCommand</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>locallyProcessedRows</name> <operator>+=</operator> <call><name>ExecuteLocalUtilityTaskList</name><argument_list>(<argument><expr><name><name>execution</name><operator>-&gt;</operator><name>localTaskList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>locallyProcessedRows</name> <operator>+=</operator> <call><name>ExecuteLocalTaskList</name><argument_list>(<argument><expr><name><name>execution</name><operator>-&gt;</operator><name>localTaskList</name></name></expr></argument>,
													 <argument><expr><name>defaultTupleDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name><name>execution</name><operator>-&gt;</operator><name>rowsProcessed</name></name> <operator>+</operator> <name>locallyProcessedRows</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateBasicExecutionParams creates basic execution parameters with some common
 * fields.
 */</comment>
<function><type><name>ExecutionParams</name> <modifier>*</modifier></type>
<name>CreateBasicExecutionParams</name><parameter_list>(<parameter><decl><type><name>RowModifyLevel</name></type> <name>modLevel</name></decl></parameter>,
						   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name></decl></parameter>,
						   <parameter><decl><type><name>int</name></type> <name>targetPoolSize</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name></type> <name>localExecutionSupported</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExecutionParams</name> <modifier>*</modifier></type><name>executionParams</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExecutionParams</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>executionParams</name><operator>-&gt;</operator><name>modLevel</name></name> <operator>=</operator> <name>modLevel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>executionParams</name><operator>-&gt;</operator><name>taskList</name></name> <operator>=</operator> <name>taskList</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>executionParams</name><operator>-&gt;</operator><name>targetPoolSize</name></name> <operator>=</operator> <name>targetPoolSize</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>executionParams</name><operator>-&gt;</operator><name>localExecutionSupported</name></name> <operator>=</operator> <name>localExecutionSupported</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>executionParams</name><operator>-&gt;</operator><name>tupleDestination</name></name> <operator>=</operator> <call><name>CreateTupleDestNone</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>executionParams</name><operator>-&gt;</operator><name>expectResults</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>executionParams</name><operator>-&gt;</operator><name>isUtilityCommand</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>executionParams</name><operator>-&gt;</operator><name>jobIdList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<return>return <expr><name>executionParams</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateDistributedExecution creates a distributed execution data structure for
 * a distributed plan.
 */</comment>
<function><type><specifier>static</specifier> <name>DistributedExecution</name> <modifier>*</modifier></type>
<name>CreateDistributedExecution</name><parameter_list>(<parameter><decl><type><name>RowModifyLevel</name></type> <name>modLevel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name></decl></parameter>,
						   <parameter><decl><type><name>ParamListInfo</name></type> <name>paramListInfo</name></decl></parameter>,
						   <parameter><decl><type><name>int</name></type> <name>targetPoolSize</name></decl></parameter>, <parameter><decl><type><name>TupleDestination</name> <modifier>*</modifier></type><name>defaultTupleDest</name></decl></parameter>,
						   <parameter><decl><type><name>TransactionProperties</name> <modifier>*</modifier></type><name>xactProperties</name></decl></parameter>,
						   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>jobIdList</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>localExecutionSupported</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DistributedExecution</name> <modifier>*</modifier></type><name>execution</name> <init>=
		<expr><operator>(</operator><name>DistributedExecution</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DistributedExecution</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>execution</name><operator>-&gt;</operator><name>modLevel</name></name> <operator>=</operator> <name>modLevel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>execution</name><operator>-&gt;</operator><name>remoteAndLocalTaskList</name></name> <operator>=</operator> <name>taskList</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>execution</name><operator>-&gt;</operator><name>transactionProperties</name></name> <operator>=</operator> <name>xactProperties</name></expr>;</expr_stmt>

	<comment type="block">/* we are going to calculate this values below */</comment>
	<expr_stmt><expr><name><name>execution</name><operator>-&gt;</operator><name>localTaskList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>execution</name><operator>-&gt;</operator><name>remoteTaskList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>execution</name><operator>-&gt;</operator><name>paramListInfo</name></name> <operator>=</operator> <name>paramListInfo</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>execution</name><operator>-&gt;</operator><name>workerList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>execution</name><operator>-&gt;</operator><name>sessionList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>execution</name><operator>-&gt;</operator><name>targetPoolSize</name></name> <operator>=</operator> <name>targetPoolSize</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>execution</name><operator>-&gt;</operator><name>defaultTupleDest</name></name> <operator>=</operator> <name>defaultTupleDest</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>execution</name><operator>-&gt;</operator><name>rowsProcessed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>execution</name><operator>-&gt;</operator><name>raiseInterrupts</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>execution</name><operator>-&gt;</operator><name>rebuildWaitEventSet</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>execution</name><operator>-&gt;</operator><name>waitFlagsChanged</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>execution</name><operator>-&gt;</operator><name>jobIdList</name></name> <operator>=</operator> <name>jobIdList</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>execution</name><operator>-&gt;</operator><name>localExecutionSupported</name></name> <operator>=</operator> <name>localExecutionSupported</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Since task can have multiple queries, we are not sure how many columns we should
	 * allocate for. We start with 16, and reallocate when we need more.
	 */</comment>
	<expr_stmt><expr><name><name>execution</name><operator>-&gt;</operator><name>allocatedColumnCount</name></name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>execution</name><operator>-&gt;</operator><name>columnArray</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>execution</name><operator>-&gt;</operator><name>allocatedColumnCount</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>EnableBinaryProtocol</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Initialize enough StringInfos for each column. These StringInfos
		 * (and thus the backing buffers) will be reused for each row.
		 * We will reference these StringInfos in the columnArray if the value
		 * is not NULL.
		 *
		 * NOTE: StringInfos are always grown in the memory context in which
		 * they were initially created. So appending in any memory context will
		 * result in bufferes that are still valid after removing that memory
		 * context.
		 */</comment>
		<expr_stmt><expr><name><name>execution</name><operator>-&gt;</operator><name>stringInfoDataArray</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(
			<argument><expr><name><name>execution</name><operator>-&gt;</operator><name>allocatedColumnCount</name></name> <operator>*</operator>
			<sizeof>sizeof<argument_list>(<argument><expr><name>StringInfoData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>execution</name><operator>-&gt;</operator><name>allocatedColumnCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>execution</name><operator>-&gt;</operator><name>stringInfoDataArray</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>execution</name><operator>-&gt;</operator><name>localExecutionSupported</name></name> <operator>&amp;&amp;</operator>
		<call><name>ShouldExecuteTasksLocally</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>readOnlyPlan</name> <init>= <expr><operator>!</operator><call><name>TaskListModifiesDatabase</name><argument_list>(<argument><expr><name>modLevel</name></expr></argument>, <argument><expr><name>taskList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ExtractLocalAndRemoteTasks</name><argument_list>(<argument><expr><name>readOnlyPlan</name></expr></argument>, <argument><expr><name>taskList</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>execution</name><operator>-&gt;</operator><name>localTaskList</name></name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name><name>execution</name><operator>-&gt;</operator><name>remoteTaskList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Get a shallow copy of the list as we rely on remoteAndLocalTaskList
		 * across the execution.
		 */</comment>
		<expr_stmt><expr><name><name>execution</name><operator>-&gt;</operator><name>remoteTaskList</name></name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name><name>execution</name><operator>-&gt;</operator><name>remoteAndLocalTaskList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>execution</name><operator>-&gt;</operator><name>totalTaskCount</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>execution</name><operator>-&gt;</operator><name>remoteTaskList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>execution</name><operator>-&gt;</operator><name>unfinishedTaskCount</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>execution</name><operator>-&gt;</operator><name>remoteTaskList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>execution</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DecideTransactionPropertiesForTaskList decides whether to use remote transaction
 * blocks, whether to use 2PC for the given task list, and whether to error on any
 * failure.
 *
 * Since these decisions have specific dependencies on each other (e.g. 2PC implies
 * errorOnAnyFailure, but not the other way around) we keep them in the same place.
 */</comment>
<function><type><specifier>static</specifier> <name>TransactionProperties</name></type>
<name>DecideTransactionPropertiesForTaskList</name><parameter_list>(<parameter><decl><type><name>RowModifyLevel</name></type> <name>modLevel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name></decl></parameter>, <parameter><decl><type><name>bool</name></type>
									   <name>exludeFromTransaction</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionProperties</name></type> <name>xactProperties</name></decl>;</decl_stmt>

	<comment type="block">/* ensure uninitialized padding doesn't escape the function */</comment>
	<expr_stmt><expr><call><name>memset_struct_0</name><argument_list>(<argument><expr><name>xactProperties</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xactProperties</name><operator>.</operator><name>errorOnAnyFailure</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xactProperties</name><operator>.</operator><name>useRemoteTransactionBlocks</name></name> <operator>=</operator> <name>TRANSACTION_BLOCKS_ALLOWED</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xactProperties</name><operator>.</operator><name>requires2PC</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>taskList</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* nothing to do, return defaults */</comment>
		<return>return <expr><name>xactProperties</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>exludeFromTransaction</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>xactProperties</name><operator>.</operator><name>useRemoteTransactionBlocks</name></name> <operator>=</operator> <name>TRANSACTION_BLOCKS_DISALLOWED</name></expr>;</expr_stmt>
		<return>return <expr><name>xactProperties</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TaskListCannotBeExecutedInTransaction</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We prefer to error on any failures for CREATE INDEX
		 * CONCURRENTLY or VACUUM//VACUUM ANALYZE (e.g., COMMIT_PROTOCOL_BARE).
		 */</comment>
		<expr_stmt><expr><name><name>xactProperties</name><operator>.</operator><name>errorOnAnyFailure</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xactProperties</name><operator>.</operator><name>useRemoteTransactionBlocks</name></name> <operator>=</operator> <name>TRANSACTION_BLOCKS_DISALLOWED</name></expr>;</expr_stmt>
		<return>return <expr><name>xactProperties</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>DistributedExecutionRequiresRollback</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* transaction blocks are required if the task list needs to roll back */</comment>
		<expr_stmt><expr><name><name>xactProperties</name><operator>.</operator><name>useRemoteTransactionBlocks</name></name> <operator>=</operator> <name>TRANSACTION_BLOCKS_REQUIRED</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>TaskListRequires2PC</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Although using two phase commit protocol is an independent decision than
			 * failing on any error, we prefer to couple them. Our motivation is that
			 * the failures are rare, and we prefer to avoid marking placements invalid
			 * in case of failures.
			 */</comment>
			<expr_stmt><expr><name><name>xactProperties</name><operator>.</operator><name>errorOnAnyFailure</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>xactProperties</name><operator>.</operator><name>requires2PC</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>InCoordinatedTransaction</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If we are already in a coordinated transaction then transaction blocks
		 * are required even if they are not strictly required for the current
		 * execution.
		 */</comment>
		<expr_stmt><expr><name><name>xactProperties</name><operator>.</operator><name>useRemoteTransactionBlocks</name></name> <operator>=</operator> <name>TRANSACTION_BLOCKS_REQUIRED</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>xactProperties</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * StartDistributedExecution sets up the coordinated transaction and 2PC for
 * the execution whenever necessary. It also keeps track of parallel relation
 * accesses to enforce restrictions that arise due to foreign keys to reference
 * tables.
 */</comment>
<function><type><name>void</name></type>
<name>StartDistributedExecution</name><parameter_list>(<parameter><decl><type><name>DistributedExecution</name> <modifier>*</modifier></type><name>execution</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionProperties</name> <modifier>*</modifier></type><name>xactProperties</name> <init>= <expr><name><name>execution</name><operator>-&gt;</operator><name>transactionProperties</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>xactProperties</name><operator>-&gt;</operator><name>useRemoteTransactionBlocks</name></name> <operator>==</operator> <name>TRANSACTION_BLOCKS_REQUIRED</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>UseCoordinatedTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>xactProperties</name><operator>-&gt;</operator><name>requires2PC</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Use2PCForCoordinatedTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Prevent unsafe concurrent modifications of replicated shards by taking
	 * locks.
	 *
	 * When modifying a reference tables in MX mode, we take the lock via RPC
	 * to the first worker in a transaction block, which activates a coordinated
	 * transaction. We need to do this before determining whether the execution
	 * should use transaction blocks (see below).
	 */</comment>
	<expr_stmt><expr><call><name>AcquireExecutorShardLocksForExecution</name><argument_list>(<argument><expr><name>execution</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We should not record parallel access if the target pool size is less than 2.
	 * The reason is that we define parallel access as at least two connections
	 * accessing established to worker node.
	 *
	 * It is not ideal to have this check here, it'd have been better if we simply passed
	 * DistributedExecution directly to the RecordParallelAccess*() function. However,
	 * since we have two other executors that rely on the function, we had to only pass
	 * the tasklist to have a common API.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>execution</name><operator>-&gt;</operator><name>targetPoolSize</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Record the access for both the local and remote tasks. The main goal
		 * is to make sure that Citus behaves consistently even if the local
		 * shards are moved away.
		 */</comment>
		<expr_stmt><expr><call><name>RecordParallelRelationAccessForTaskList</name><argument_list>(<argument><expr><name><name>execution</name><operator>-&gt;</operator><name>remoteAndLocalTaskList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* make sure we are not doing remote execution from within a task */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>execution</name><operator>-&gt;</operator><name>remoteTaskList</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>isRemote</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>EnsureTaskExecutionAllowed</name><argument_list>(<argument><expr><name>isRemote</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *  DistributedExecutionModifiesDatabase returns true if the execution modifies the data
 *  or the schema.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>DistributedExecutionModifiesDatabase</name><parameter_list>(<parameter><decl><type><name>DistributedExecution</name> <modifier>*</modifier></type><name>execution</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>TaskListModifiesDatabase</name><argument_list>(<argument><expr><name><name>execution</name><operator>-&gt;</operator><name>modLevel</name></name></expr></argument>,
									<argument><expr><name><name>execution</name><operator>-&gt;</operator><name>remoteAndLocalTaskList</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 *  DistributedPlanModifiesDatabase returns true if the plan modifies the data
 *  or the schema.
 */</comment>
<function><type><name>bool</name></type>
<name>DistributedPlanModifiesDatabase</name><parameter_list>(<parameter><decl><type><name>DistributedPlan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>TaskListModifiesDatabase</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>modLevel</name></name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>workerJob</name><operator>-&gt;</operator><name>taskList</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 *  TaskListModifiesDatabase is a helper function for DistributedExecutionModifiesDatabase and
 *  DistributedPlanModifiesDatabase.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>TaskListModifiesDatabase</name><parameter_list>(<parameter><decl><type><name>RowModifyLevel</name></type> <name>modLevel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>modLevel</name> <operator>&gt;</operator> <name>ROW_MODIFY_READONLY</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we cannot decide by only checking the row modify level,
	 * we should look closer to the tasks.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* is this ever possible? */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>firstTask</name> <init>= <expr><operator>(</operator><name>Task</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><operator>!</operator><call><name>ReadOnlyTask</name><argument_list>(<argument><expr><name><name>firstTask</name><operator>-&gt;</operator><name>taskType</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DistributedExecutionRequiresRollback returns true if the distributed
 * execution should start a CoordinatedTransaction. In other words, if the
 * function returns true, the execution sends BEGIN; to every connection
 * involved in the distributed execution.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>DistributedExecutionRequiresRollback</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>taskCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>taskCount</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name> <init>= <expr><operator>(</operator><name>Task</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>task</name><operator>-&gt;</operator><name>cannotBeExecutedInTransction</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* vacuum, create index concurrently etc. */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>selectForUpdate</name> <init>= <expr><name><name>task</name><operator>-&gt;</operator><name>relationRowLockList</name></name> <operator>!=</operator> <name>NIL</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>selectForUpdate</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Do not check SelectOpensTransactionBlock, always open transaction block
		 * if SELECT FOR UPDATE is executed inside a distributed transaction.
		 */</comment>
		<return>return <expr><call><name>IsMultiStatementTransaction</name><argument_list>()</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ReadOnlyTask</name><argument_list>(<argument><expr><name><name>task</name><operator>-&gt;</operator><name>taskType</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>SelectOpensTransactionBlock</name> <operator>&amp;&amp;</operator>
			   <call><name>IsTransactionBlock</name><argument_list>()</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsMultiStatementTransaction</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>task</name><operator>-&gt;</operator><name>taskPlacementList</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Single DML/DDL tasks with replicated tables (including
		 * reference and non-reference tables) should require
		 * BEGIN/COMMIT/ROLLBACK.
		 */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>task</name><operator>-&gt;</operator><name>queryCount</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * When there are multiple sequential queries in a task
		 * we need to run those as a transaction.
		 */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * TaskListRequires2PC determines whether the given task list requires 2PC.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>TaskListRequires2PC</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>taskList</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name> <init>= <expr><operator>(</operator><name>Task</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>ReadOnlyTask</name><argument_list>(<argument><expr><name><name>task</name><operator>-&gt;</operator><name>taskType</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* we do not trigger 2PC for ReadOnly queries */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>singleTask</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>singleTask</name> <operator>&amp;&amp;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>task</name><operator>-&gt;</operator><name>taskPlacementList</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* we do not trigger 2PC for modifications that are:
		 *    - single task
		 *    - single placement
		 */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Otherwise, all modifications are done via 2PC. This includes:
	 *    - Multi-shard commands irrespective of the replication factor
	 *    - Single-shard commands that are targeting more than one replica
	 */</comment>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ReadOnlyTask returns true if the input task does a read-only operation
 * on the database.
 */</comment>
<function><type><name>bool</name></type>
<name>ReadOnlyTask</name><parameter_list>(<parameter><decl><type><name>TaskType</name></type> <name>taskType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>taskType</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>READ_TASK</name></expr>:</case>
		<case>case <expr><name>MAP_OUTPUT_FETCH_TASK</name></expr>:</case>
		<case>case <expr><name>MAP_TASK</name></expr>:</case>
		<case>case <expr><name>MERGE_TASK</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block>

		<default>default:</default>
		<block>{<block_content>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block>
	</block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
 * TaskListCannotBeExecutedInTransaction returns true if any of the
 * tasks in the input cannot be executed in a transaction. These are
 * tasks like VACUUM or CREATE INDEX CONCURRENTLY etc.
 */</comment>
<function><type><name>bool</name></type>
<name>TaskListCannotBeExecutedInTransaction</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>task</argument>, <argument>taskList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>task</name><operator>-&gt;</operator><name>cannotBeExecutedInTransction</name></name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SelectForUpdateOnReferenceTable returns true if the input task
 * contains a FOR UPDATE clause that locks any reference tables.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>SelectForUpdateOnReferenceTable</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* we currently do not support SELECT FOR UPDATE on multi task queries */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name> <init>= <expr><operator>(</operator><name>Task</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelationRowLock</name> <modifier>*</modifier></type><name>relationRowLock</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>relationRowLock</argument>, <argument>task-&gt;relationRowLockList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name><name>relationRowLock</name><operator>-&gt;</operator><name>relationId</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>REFERENCE_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * LockPartitionsForDistributedPlan ensures commands take locks on all partitions
 * of a distributed table that appears in the query. We do this primarily out of
 * consistency with PostgreSQL locking.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>LockPartitionsForDistributedPlan</name><parameter_list>(<parameter><decl><type><name>DistributedPlan</name> <modifier>*</modifier></type><name>distributedPlan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>DistributedPlanModifiesDatabase</name><argument_list>(<argument><expr><name>distributedPlan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>targetRelationId</name> <init>= <expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>targetRelationId</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>LockPartitionsInRelationList</name><argument_list>(<argument><expr><call><name>list_make1_oid</name><argument_list>(<argument><expr><name>targetRelationId</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Lock partitions of tables that appear in a SELECT or subquery. In the
	 * DML case this also includes the target relation, but since we already
	 * have a stronger lock this doesn't do any harm.
	 */</comment>
	<expr_stmt><expr><call><name>LockPartitionsInRelationList</name><argument_list>(<argument><expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>relationIdList</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * AcquireExecutorShardLocksForExecution acquires advisory lock on shard IDs
 * to prevent unsafe concurrent modifications of shards.
 *
 * We prevent concurrent modifications of shards in two cases:
 * 1. Any non-commutative writes to a replicated table
 * 2. Multi-shard writes that are executed in parallel
 *
 * The first case ensures we do not apply updates in different orders on
 * different replicas (e.g. of a reference table), which could lead the
 * replicas to diverge.
 *
 * The second case prevents deadlocks due to out-of-order execution.
 *
 * There are two GUCs that can override the default behaviors.
 *  'citus.all_modifications_commutative' relaxes locking
 *  that's done for the purpose of keeping replicas consistent.
 *  'citus.enable_deadlock_prevention' relaxes locking done for
 *  the purpose of avoiding deadlocks between concurrent
 *  multi-shard commands.
 *
 * We do not take executor shard locks for utility commands such as
 * TRUNCATE because the table locks already prevent concurrent access.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AcquireExecutorShardLocksForExecution</name><parameter_list>(<parameter><decl><type><name>DistributedExecution</name> <modifier>*</modifier></type><name>execution</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RowModifyLevel</name></type> <name>modLevel</name> <init>= <expr><name><name>execution</name><operator>-&gt;</operator><name>modLevel</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* acquire the locks for both the remote and local tasks */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name> <init>= <expr><name><name>execution</name><operator>-&gt;</operator><name>remoteAndLocalTaskList</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>modLevel</name> <operator>&lt;=</operator> <name>ROW_MODIFY_READONLY</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>SelectForUpdateOnReferenceTable</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Executor locks only apply to DML commands and SELECT FOR UPDATE queries
		 * touching reference tables.
		 */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>requiresParallelExecutionLocks</name> <init>=
		<expr><operator>!</operator><operator>(</operator><call><name>list_length</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>||</operator> <call><name>ShouldRunTasksSequentially</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>modifiedTableReplicated</name> <init>= <expr><call><name>ModifiedTableReplicated</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>modifiedTableReplicated</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>requiresParallelExecutionLocks</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * When a distributed query on tables with replication
		 * factor == 1 and command hits only a single shard, we
		 * rely on Postgres to handle the serialization of the
		 * concurrent modifications on the workers.
		 *
		 * For reference tables, even if their placements are replicated
		 * ones (e.g., single node), we acquire the distributed execution
		 * locks to be consistent when new node(s) are added. So, they
		 * do not return at this point.
		 */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We first assume that all the remaining modifications are going to
	 * be serialized. So, start with an ExclusiveLock and lower the lock level
	 * as much as possible.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>lockMode</name> <init>= <expr><name>ExclusiveLock</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * In addition to honouring commutativity rules, we currently only
	 * allow a single multi-shard command on a shard at a time. Otherwise,
	 * concurrent multi-shard commands may take row-level locks on the
	 * shard placements in a different order and create a distributed
	 * deadlock. This applies even when writes are commutative and/or
	 * there is no replication. This can be relaxed via
	 * EnableDeadlockPrevention.
	 *
	 * 1. If citus.all_modifications_commutative is set to true, then all locks
	 * are acquired as RowExclusiveLock.
	 *
	 * 2. If citus.all_modifications_commutative is false, then only the shards
	 * with more than one replicas are locked with ExclusiveLock. Otherwise, the
	 * lock is acquired with ShareUpdateExclusiveLock.
	 *
	 * ShareUpdateExclusiveLock conflicts with itself such that only one
	 * multi-shard modification at a time is allowed on a shard. It also conflicts
	 * with ExclusiveLock, which ensures that updates/deletes/upserts are applied
	 * in the same order on all placements. It does not conflict with
	 * RowExclusiveLock, which is normally obtained by single-shard, commutative
	 * writes.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>modifiedTableReplicated</name> <operator>&amp;&amp;</operator> <name>requiresParallelExecutionLocks</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * When there is no replication then we only need to prevent
		 * concurrent multi-shard commands on the same shards. This is
		 * because concurrent, parallel commands may modify the same
		 * set of shards, but in different orders. The order of the
		 * accesses might trigger distributed deadlocks that are not
		 * possible to happen on non-distributed systems such
		 * regular Postgres.
		 *
		 * As an example, assume that we have two queries: query-1 and query-2.
		 * Both queries access shard-1 and shard-2. If query-1 first accesses to
		 * shard-1 then shard-2, and query-2 accesses shard-2 then shard-1, these
		 * two commands might block each other in case they modify the same rows
		 * (e.g., cause distributed deadlocks).
		 *
		 * In either case, ShareUpdateExclusive has the desired effect, since
		 * it conflicts with itself and ExclusiveLock (taken by non-commutative
		 * writes).
		 *
		 * However, some users find this too restrictive, so we allow them to
		 * reduce to a RowExclusiveLock when citus.enable_deadlock_prevention
		 * is enabled, which lets multi-shard modifications run in parallel as
		 * long as they all disable the GUC.
		 */</comment>
		<expr_stmt><expr><name>lockMode</name> <operator>=</operator>
			<ternary><condition><expr><name>EnableDeadlockPrevention</name></expr> ?</condition><then> <expr><name>ShareUpdateExclusiveLock</name></expr> </then><else>: <expr><name>RowExclusiveLock</name></expr></else></ternary></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCoordinator</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We also skip taking a heavy-weight lock when running a multi-shard
			 * commands from workers, since we currently do not prevent concurrency
			 * across workers anyway.
			 */</comment>
			<expr_stmt><expr><name>lockMode</name> <operator>=</operator> <name>RowExclusiveLock</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>modifiedTableReplicated</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * When we are executing distributed queries on replicated tables, our
		 * default behaviour is to prevent any concurrency. This is valid
		 * for when parallel execution is happening or not.
		 *
		 * The reason is that we cannot control the order of the placement accesses
		 * of two distributed queries to the same shards. The order of the accesses
		 * might cause the replicas of the same shard placements diverge. This is
		 * not possible to happen on non-distributed systems such regular Postgres.
		 *
		 * As an example, assume that we have two queries: query-1 and query-2.
		 * Both queries only access the placements of shard-1, say p-1 and p-2.
		 *
		 * And, assume that these queries are non-commutative, such as:
		 *  query-1: UPDATE table SET b = 1 WHERE key = 1;
		 *  query-2: UPDATE table SET b = 2 WHERE key = 1;
		 *
		 * If query-1 accesses to p-1 then p-2, and query-2 accesses
		 * p-2 then p-1, these two commands would leave the p-1 and p-2
		 * diverged (e.g., the values for the column "b" would be different).
		 *
		 * The only exception to this rule is the single shard commutative
		 * modifications, such as INSERTs. In that case, we can allow
		 * concurrency among such backends, hence lowering the lock level
		 * to RowExclusiveLock.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>requiresParallelExecutionLocks</name> <operator>&amp;&amp;</operator> <name>modLevel</name> <operator>&lt;</operator> <name>ROW_MODIFY_NONCOMMUTATIVE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>lockMode</name> <operator>=</operator> <name>RowExclusiveLock</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>AllModificationsCommutative</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The mapping is overridden when all_modifications_commutative is set to true.
		 * In that case, all modifications are treated as commutative, which can be used
		 * to communicate that the application is only generating commutative
		 * UPDATE/DELETE/UPSERT commands and exclusive locks are unnecessary. This
		 * is irrespective of single-shard/multi-shard or replicated tables.
		 */</comment>
		<expr_stmt><expr><name>lockMode</name> <operator>=</operator> <name>RowExclusiveLock</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* now, iterate on the tasks and acquire the executor locks on the shards */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>anchorShardIntervalList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>relationRowLockList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>requiresConsistentSnapshotRelationShardList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>task</argument>, <argument>taskList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>anchorShardInterval</name> <init>= <expr><call><name>LoadShardInterval</name><argument_list>(<argument><expr><name><name>task</name><operator>-&gt;</operator><name>anchorShardId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>anchorShardIntervalList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>anchorShardIntervalList</name></expr></argument>, <argument><expr><name>anchorShardInterval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Acquire additional locks for SELECT .. FOR UPDATE on reference tables */</comment>
		<expr_stmt><expr><call><name>AcquireExecutorShardLocksForRelationRowLockList</name><argument_list>(<argument><expr><name><name>task</name><operator>-&gt;</operator><name>relationRowLockList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>relationRowLockList</name> <operator>=</operator>
			<call><name>list_concat</name><argument_list>(<argument><expr><name>relationRowLockList</name></expr></argument>,
						<argument><expr><name><name>task</name><operator>-&gt;</operator><name>relationRowLockList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If the task has a subselect, then we may need to lock the shards from which
		 * the query selects as well to prevent the subselects from seeing different
		 * results on different replicas.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>RequiresConsistentSnapshot</name><argument_list>(<argument><expr><name>task</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * ExclusiveLock conflicts with all lock types used by modifications
			 * and therefore prevents other modifications from running
			 * concurrently.
			 */</comment>
			<expr_stmt><expr><name>requiresConsistentSnapshotRelationShardList</name> <operator>=</operator>
				<call><name>list_concat</name><argument_list>(<argument><expr><name>requiresConsistentSnapshotRelationShardList</name></expr></argument>,
							<argument><expr><name><name>task</name><operator>-&gt;</operator><name>relationShardList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Acquire the locks in a sorted way to avoid deadlocks due to lock
	 * ordering across concurrent sessions.
	 */</comment>
	<expr_stmt><expr><name>anchorShardIntervalList</name> <operator>=</operator>
		<call><name>SortList</name><argument_list>(<argument><expr><name>anchorShardIntervalList</name></expr></argument>, <argument><expr><name>CompareShardIntervalsById</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we are dealing with a partition we are also taking locks on parent table
	 * to prevent deadlocks on concurrent operations on a partition and its parent.
	 *
	 * Note that this function currently does not acquire any remote locks as that
	 * is necessary to control the concurrency across multiple nodes for replicated
	 * tables. That is because Citus currently does not allow modifications to
	 * partitions from any node other than the coordinator.
	 */</comment>
	<expr_stmt><expr><call><name>LockParentShardResourceIfPartition</name><argument_list>(<argument><expr><name>anchorShardIntervalList</name></expr></argument>, <argument><expr><name>lockMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Acquire distribution execution locks on the affected shards */</comment>
	<expr_stmt><expr><call><name>SerializeNonCommutativeWrites</name><argument_list>(<argument><expr><name>anchorShardIntervalList</name></expr></argument>, <argument><expr><name>lockMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>relationRowLockList</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Acquire additional locks for SELECT .. FOR UPDATE on reference tables */</comment>
		<expr_stmt><expr><call><name>AcquireExecutorShardLocksForRelationRowLockList</name><argument_list>(<argument><expr><name>relationRowLockList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>


	<if_stmt><if>if <condition>(<expr><name>requiresConsistentSnapshotRelationShardList</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If the task has a subselect, then we may need to lock the shards from which
		 * the query selects as well to prevent the subselects from seeing different
		 * results on different replicas.
		 *
		 * ExclusiveLock conflicts with all lock types used by modifications
		 * and therefore prevents other modifications from running
		 * concurrently.
		 */</comment>
		<expr_stmt><expr><call><name>LockRelationShardResources</name><argument_list>(<argument><expr><name>requiresConsistentSnapshotRelationShardList</name></expr></argument>,
								   <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ModifiedTableReplicated iterates on the task list and returns true
 * if any of the tasks' anchor shard is a replicated table. We qualify
 * replicated tables as any reference table or any distributed table with
 * replication factor &gt; 1.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ModifiedTableReplicated</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>task</argument>, <argument>taskList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int64</name></type> <name>shardId</name> <init>= <expr><name><name>task</name><operator>-&gt;</operator><name>anchorShardId</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>shardId</name> <operator>==</operator> <name>INVALID_SHARD_ID</name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>ReferenceTableShardId</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>RelationIdForShard</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SingleReplicatedTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FinishDistributedExecution cleans up resources associated with a
 * distributed execution.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>FinishDistributedExecution</name><parameter_list>(<parameter><decl><type><name>DistributedExecution</name> <modifier>*</modifier></type><name>execution</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>DistributedExecutionModifiesDatabase</name><argument_list>(<argument><expr><name>execution</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* prevent copying shards in same transaction */</comment>
		<expr_stmt><expr><name>XactModificationLevel</name> <operator>=</operator> <name>XACT_MODIFICATION_DATA</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CleanUpSessions does any clean-up necessary for the session used
 * during the execution. We only reach the function after successfully
 * completing all the tasks and we expect no tasks are still in progress.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CleanUpSessions</name><parameter_list>(<parameter><decl><type><name>DistributedExecution</name> <modifier>*</modifier></type><name>execution</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>sessionList</name> <init>= <expr><name><name>execution</name><operator>-&gt;</operator><name>sessionList</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* we get to this function only after successful executions */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>execution</name><operator>-&gt;</operator><name>failed</name></name> <operator>&amp;&amp;</operator> <name><name>execution</name><operator>-&gt;</operator><name>unfinishedTaskCount</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* always trigger wait event set in the first round */</comment>
	<decl_stmt><decl><type><name>WorkerSession</name> <modifier>*</modifier></type><name>session</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>session</argument>, <argument>sessionList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><name><name>session</name><operator>-&gt;</operator><name>connection</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Total number of commands sent over the session %ld: %ld "</literal>
								<literal type="string">"to node %s:%d"</literal></expr></argument>, <argument><expr><name><name>session</name><operator>-&gt;</operator><name>sessionId</name></name></expr></argument>,
								<argument><expr><name><name>session</name><operator>-&gt;</operator><name>commandsSent</name></name></expr></argument>,
								<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>, <argument><expr><name><name>connection</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>UnclaimConnection</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>connection</name><operator>-&gt;</operator><name>connectionState</name></name> <operator>==</operator> <name>MULTI_CONNECTION_CONNECTING</name> <operator>||</operator>
			<name><name>connection</name><operator>-&gt;</operator><name>connectionState</name></name> <operator>==</operator> <name>MULTI_CONNECTION_FAILED</name> <operator>||</operator>
			<name><name>connection</name><operator>-&gt;</operator><name>connectionState</name></name> <operator>==</operator> <name>MULTI_CONNECTION_LOST</name> <operator>||</operator>
			<name><name>connection</name><operator>-&gt;</operator><name>connectionState</name></name> <operator>==</operator> <name>MULTI_CONNECTION_TIMED_OUT</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We want the MultiConnection go away and not used in
			 * the subsequent executions.
			 *
			 * We cannot get MULTI_CONNECTION_LOST via the ConnectionStateMachine,
			 * but we might get it via the connection API and find us here before
			 * changing any states in the ConnectionStateMachine.
			 *
			 */</comment>
			<expr_stmt><expr><call><name>CloseConnection</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>connection</name><operator>-&gt;</operator><name>connectionState</name></name> <operator>==</operator> <name>MULTI_CONNECTION_CONNECTED</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RemoteTransaction</name> <modifier>*</modifier></type><name>transaction</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>connection</name><operator>-&gt;</operator><name>remoteTransaction</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>RemoteTransactionState</name></type> <name>transactionState</name> <init>= <expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>transactionState</name> <operator>==</operator> <name>REMOTE_TRANS_CLEARING_RESULTS</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * We might have established the connection, and even sent BEGIN, but not
				 * get to the point where we assigned a task to this specific connection
				 * (because other connections in the pool already finished all the tasks).
				 */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>session</name><operator>-&gt;</operator><name>commandsSent</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>ClearResults</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><operator>!</operator><operator>(</operator><name>transactionState</name> <operator>==</operator> <name>REMOTE_TRANS_NOT_STARTED</name> <operator>||</operator>
					   <name>transactionState</name> <operator>==</operator> <name>REMOTE_TRANS_STARTED</name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * We don't have to handle anything else. Note that the execution
				 * could only finish on connectionStates of MULTI_CONNECTION_CONNECTING,
				 * MULTI_CONNECTION_FAILED and MULTI_CONNECTION_CONNECTED. The first two
				 * are already handled above.
				 *
				 * When we're on MULTI_CONNECTION_CONNECTED, TransactionStateMachine
				 * ensures that all the necessary commands are successfully sent over
				 * the connection and everything is cleared up. Otherwise, we'd have been
				 * on MULTI_CONNECTION_FAILED state.
				 */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected transaction state at the end of "</literal>
										 <literal type="string">"execution: %d"</literal></expr></argument>, <argument><expr><name>transactionState</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* get ready for the next executions if we need use the same connection */</comment>
			<expr_stmt><expr><name><name>connection</name><operator>-&gt;</operator><name>waitFlags</name></name> <operator>=</operator> <name>WL_SOCKET_READABLE</name> <operator>|</operator> <name>WL_SOCKET_WRITEABLE</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected connection state at the end of "</literal>
									 <literal type="string">"execution: %d"</literal></expr></argument>, <argument><expr><name><name>connection</name><operator>-&gt;</operator><name>connectionState</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * UnclaimAllSessionConnections unclaims all of the connections for the given
 * sessionList.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>UnclaimAllSessionConnections</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sessionList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WorkerSession</name> <modifier>*</modifier></type><name>session</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>session</argument>, <argument>sessionList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><name><name>session</name><operator>-&gt;</operator><name>connection</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>UnclaimConnection</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * AssignTasksToConnectionsOrWorkerPool goes through the list of tasks to determine whether any
 * task placements need to be assigned to particular connections because of preceding
 * operations in the transaction. It then adds those connections to the pool and adds
 * the task placement executions to the assigned task queue of the connection.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AssignTasksToConnectionsOrWorkerPool</name><parameter_list>(<parameter><decl><type><name>DistributedExecution</name> <modifier>*</modifier></type><name>execution</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RowModifyLevel</name></type> <name>modLevel</name> <init>= <expr><name><name>execution</name><operator>-&gt;</operator><name>modLevel</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name> <init>= <expr><name><name>execution</name><operator>-&gt;</operator><name>remoteTaskList</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>task</argument>, <argument>taskList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>placementExecutionReady</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>placementExecutionIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>placementExecutionCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>task</name><operator>-&gt;</operator><name>taskPlacementList</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Execution of a command on a shard, which may have multiple replicas.
		 */</comment>
		<decl_stmt><decl><type><name>ShardCommandExecution</name> <modifier>*</modifier></type><name>shardCommandExecution</name> <init>=
			<expr><operator>(</operator><name>ShardCommandExecution</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ShardCommandExecution</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>shardCommandExecution</name><operator>-&gt;</operator><name>task</name></name> <operator>=</operator> <name>task</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shardCommandExecution</name><operator>-&gt;</operator><name>executionOrder</name></name> <operator>=</operator> <call><name>ExecutionOrderForTask</name><argument_list>(<argument><expr><name>modLevel</name></expr></argument>, <argument><expr><name>task</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shardCommandExecution</name><operator>-&gt;</operator><name>executionState</name></name> <operator>=</operator> <name>TASK_EXECUTION_NOT_FINISHED</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shardCommandExecution</name><operator>-&gt;</operator><name>localExecutionSupported</name></name> <operator>=</operator>
			<name><name>execution</name><operator>-&gt;</operator><name>localExecutionSupported</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shardCommandExecution</name><operator>-&gt;</operator><name>placementExecutions</name></name> <operator>=</operator>
			<operator>(</operator><name>TaskPlacementExecution</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>placementExecutionCount</name> <operator>*</operator>
												<sizeof>sizeof<argument_list>(<argument><expr><name>TaskPlacementExecution</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shardCommandExecution</name><operator>-&gt;</operator><name>placementExecutionCount</name></name> <operator>=</operator> <name>placementExecutionCount</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SetAttributeInputMetadata</name><argument_list>(<argument><expr><name>execution</name></expr></argument>, <argument><expr><name>shardCommandExecution</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>taskPlacement</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>taskPlacement</argument>, <argument>task-&gt;taskPlacementList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>connectionFlags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nodeName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>nodePort</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>LookupTaskPlacementHostAndPort</name><argument_list>(<argument><expr><name>taskPlacement</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nodeName</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nodePort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<decl_stmt><decl><type><name>WorkerPool</name> <modifier>*</modifier></type><name>workerPool</name> <init>= <expr><call><name>FindOrCreateWorkerPool</name><argument_list>(<argument><expr><name>execution</name></expr></argument>, <argument><expr><name>nodeName</name></expr></argument>,
															<argument><expr><name>nodePort</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Execution of a command on a shard placement, which may not always
			 * happen if the query is read-only and the shard has multiple placements.
			 */</comment>
			<decl_stmt><decl><type><name>TaskPlacementExecution</name> <modifier>*</modifier></type><name>placementExecution</name> <init>=
				<expr><operator>(</operator><name>TaskPlacementExecution</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TaskPlacementExecution</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>placementExecution</name><operator>-&gt;</operator><name>shardCommandExecution</name></name> <operator>=</operator> <name>shardCommandExecution</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>placementExecution</name><operator>-&gt;</operator><name>shardPlacement</name></name> <operator>=</operator> <name>taskPlacement</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>placementExecution</name><operator>-&gt;</operator><name>workerPool</name></name> <operator>=</operator> <name>workerPool</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>placementExecution</name><operator>-&gt;</operator><name>placementExecutionIndex</name></name> <operator>=</operator> <name>placementExecutionIndex</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>placementExecution</name><operator>-&gt;</operator><name>queryIndex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>INSTR_TIME_SET_ZERO</name><argument_list>(<argument><expr><name><name>placementExecution</name><operator>-&gt;</operator><name>startTime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>INSTR_TIME_SET_ZERO</name><argument_list>(<argument><expr><name><name>placementExecution</name><operator>-&gt;</operator><name>endTime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>placementExecutionReady</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>placementExecution</name><operator>-&gt;</operator><name>executionState</name></name> <operator>=</operator> <name>PLACEMENT_EXECUTION_READY</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>placementExecution</name><operator>-&gt;</operator><name>executionState</name></name> <operator>=</operator> <name>PLACEMENT_EXECUTION_NOT_READY</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><name><name>shardCommandExecution</name><operator>-&gt;</operator><name>placementExecutions</name><index>[<expr><name>placementExecutionIndex</name></expr>]</index></name> <operator>=</operator>
				<name>placementExecution</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>placementExecutionIndex</name><operator>++</operator></expr>;</expr_stmt>

			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>placementAccessList</name> <init>= <expr><call><name>PlacementAccessListForTask</name><argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><name>taskPlacement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>execution</name><operator>-&gt;</operator><name>transactionProperties</name><operator>-&gt;</operator><name>useRemoteTransactionBlocks</name></name> <operator>!=</operator>
				<name>TRANSACTION_BLOCKS_DISALLOWED</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Determine whether the task has to be assigned to a particular connection
				 * due to a preceding access to the placement in the same transaction.
				 */</comment>
				<expr_stmt><expr><name>connection</name> <operator>=</operator> <call><name>GetConnectionIfPlacementAccessedInXact</name><argument_list>(
					<argument><expr><name>connectionFlags</name></expr></argument>,
					<argument><expr><name>placementAccessList</name></expr></argument>,
					<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>connection</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Note: We may get the same connection for multiple task placements.
				 * FindOrCreateWorkerSession ensures that we only have one session per
				 * connection.
				 */</comment>
				<decl_stmt><decl><type><name>WorkerSession</name> <modifier>*</modifier></type><name>session</name> <init>=
					<expr><call><name>FindOrCreateWorkerSession</name><argument_list>(<argument><expr><name>workerPool</name></expr></argument>, <argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Session %ld (%s:%d) has an assigned task"</literal></expr></argument>,
										<argument><expr><name><name>session</name><operator>-&gt;</operator><name>sessionId</name></name></expr></argument>, <argument><expr><name><name>connection</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>,
										<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>placementExecution</name><operator>-&gt;</operator><name>assignedSession</name></name> <operator>=</operator> <name>session</name></expr>;</expr_stmt>

				<comment type="block">/* if executed, this task placement must use this session */</comment>
				<if_stmt><if>if <condition>(<expr><name>placementExecutionReady</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>dlist_push_tail</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>session</name><operator>-&gt;</operator><name>readyTaskQueue</name></name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name><name>placementExecution</name><operator>-&gt;</operator><name>sessionReadyQueueNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>dlist_push_tail</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>session</name><operator>-&gt;</operator><name>pendingTaskQueue</name></name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name><name>placementExecution</name><operator>-&gt;</operator><name>sessionPendingQueueNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<comment type="block">/* always poll the connection in the first round */</comment>
				<expr_stmt><expr><call><name>UpdateConnectionWaitFlags</name><argument_list>(<argument><expr><name>session</name></expr></argument>,
										  <argument><expr><name>WL_SOCKET_READABLE</name> <operator>|</operator> <name>WL_SOCKET_WRITEABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* If the connections are already avaliable, make sure to activate
				 * 2PC when necessary.
				 */</comment>
				<expr_stmt><expr><call><name>Activate2PCIfModifyingTransactionExpandsToNewNode</name><argument_list>(<argument><expr><name>session</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>placementExecution</name><operator>-&gt;</operator><name>assignedSession</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>placementExecutionReady</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* task is ready to execute on any session */</comment>
					<expr_stmt><expr><call><name>dlist_push_tail</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>workerPool</name><operator>-&gt;</operator><name>readyTaskQueue</name></name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name><name>placementExecution</name><operator>-&gt;</operator><name>workerReadyQueueNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name><name>workerPool</name><operator>-&gt;</operator><name>readyTaskCount</name></name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* task can be executed on any session, but is not yet ready */</comment>
					<expr_stmt><expr><call><name>dlist_push_tail</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>workerPool</name><operator>-&gt;</operator><name>pendingTaskQueue</name></name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name><name>placementExecution</name><operator>-&gt;</operator><name>workerPendingQueueNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>shardCommandExecution</name><operator>-&gt;</operator><name>executionOrder</name></name> <operator>!=</operator> <name>EXECUTION_ORDER_PARALLEL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Except for commands that can be executed across all placements
				 * in parallel, only the first placement execution is immediately
				 * ready. Set placementExecutionReady to false for the remaining
				 * placements.
				 */</comment>
				<expr_stmt><expr><name>placementExecutionReady</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block>

	<comment type="block">/*
	 * We sort the workerList because adaptive connection management
	 * (e.g., OPTIONAL_CONNECTION) requires any concurrent executions
	 * to wait for the connections in the same order to prevent any
	 * starvation. If we don't sort, we might end up with:
	 *      Execution 1: Get connection for worker 1, wait for worker 2
	 *      Execution 2: Get connection for worker 2, wait for worker 1
	 *
	 *  and, none could proceed. Instead, we enforce every execution establish
	 *  the required connections to workers in the same order.
	 */</comment>
	<expr_stmt><expr><name><name>execution</name><operator>-&gt;</operator><name>workerList</name></name> <operator>=</operator> <call><name>SortList</name><argument_list>(<argument><expr><name><name>execution</name><operator>-&gt;</operator><name>workerList</name></name></expr></argument>, <argument><expr><name>WorkerPoolCompare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The executor claims connections exclusively to make sure that calls to
	 * StartNodeUserDatabaseConnection do not return the same connections.
	 *
	 * We need to do this after assigning tasks to connections because the same
	 * connection may be be returned multiple times by GetPlacementListConnectionIfCached.
	 */</comment>
	<decl_stmt><decl><type><name>WorkerSession</name> <modifier>*</modifier></type><name>session</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>session</argument>, <argument>execution-&gt;sessionList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><name><name>session</name><operator>-&gt;</operator><name>connection</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ClaimConnectionExclusively</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * LookupTaskPlacementHostAndPort sets the nodename and nodeport for the given task placement
 * with a lookup.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>LookupTaskPlacementHostAndPort</name><parameter_list>(<parameter><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>taskPlacement</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>nodeName</name></decl></parameter>,
							   <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nodePort</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IsDummyPlacement</name><argument_list>(<argument><expr><name>taskPlacement</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If we create a dummy placement for the local node, it is possible
		 * that the entry doesn't exist in pg_dist_node, hence a lookup will fail.
		 * In that case we want to use the dummy placements values.
		 */</comment>
		<expr_stmt><expr><operator>*</operator><name>nodeName</name> <operator>=</operator> <name><name>taskPlacement</name><operator>-&gt;</operator><name>nodeName</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>nodePort</name> <operator>=</operator> <name><name>taskPlacement</name><operator>-&gt;</operator><name>nodePort</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * We want to lookup the node information again since it is possible that
		 * there were changes in pg_dist_node and we will get those invalidations
		 * in LookupNodeForGroup.
		 */</comment>
		<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><call><name>LookupNodeForGroup</name><argument_list>(<argument><expr><name><name>taskPlacement</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><operator>*</operator><name>nodeName</name> <operator>=</operator> <name><name>workerNode</name><operator>-&gt;</operator><name>workerName</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>nodePort</name> <operator>=</operator> <name><name>workerNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * IsDummyPlacement returns true if the given placement is a dummy placement.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsDummyPlacement</name><parameter_list>(<parameter><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>taskPlacement</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>taskPlacement</name><operator>-&gt;</operator><name>nodeId</name></name> <operator>==</operator> <name>LOCAL_NODE_ID</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * WorkerPoolCompare is based on WorkerNodeCompare function. The function
 * compares two worker nodes by their host name and port number.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>WorkerPoolCompare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>lhsKey</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>rhsKey</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>WorkerPool</name> <modifier>*</modifier></type><name>workerLhs</name> <init>= <expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>WorkerPool</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>lhsKey</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>WorkerPool</name> <modifier>*</modifier></type><name>workerRhs</name> <init>= <expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>WorkerPool</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>rhsKey</name></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>NodeNamePortCompare</name><argument_list>(<argument><expr><name><name>workerLhs</name><operator>-&gt;</operator><name>nodeName</name></name></expr></argument>, <argument><expr><name><name>workerRhs</name><operator>-&gt;</operator><name>nodeName</name></name></expr></argument>,
							   <argument><expr><name><name>workerLhs</name><operator>-&gt;</operator><name>nodePort</name></name></expr></argument>, <argument><expr><name><name>workerRhs</name><operator>-&gt;</operator><name>nodePort</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SetAttributeInputMetadata sets attributeInputMetadata in
 * shardCommandExecution for all the queries that are part of its task.
 * This contains the deserialization functions for the tuples that will be
 * received. It also sets binaryResults when applicable.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SetAttributeInputMetadata</name><parameter_list>(<parameter><decl><type><name>DistributedExecution</name> <modifier>*</modifier></type><name>execution</name></decl></parameter>,
						  <parameter><decl><type><name>ShardCommandExecution</name> <modifier>*</modifier></type><name>shardCommandExecution</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDestination</name> <modifier>*</modifier></type><name>tupleDest</name> <init>= <expr><ternary><condition><expr><name><name>shardCommandExecution</name><operator>-&gt;</operator><name>task</name><operator>-&gt;</operator><name>tupleDest</name></name></expr> ?</condition><then>
								  <expr><name><name>shardCommandExecution</name><operator>-&gt;</operator><name>task</name><operator>-&gt;</operator><name>tupleDest</name></name></expr> </then><else>:
								  <expr><name><name>execution</name><operator>-&gt;</operator><name>defaultTupleDest</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>queryCount</name> <init>= <expr><name><name>shardCommandExecution</name><operator>-&gt;</operator><name>task</name><operator>-&gt;</operator><name>queryCount</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>shardCommandExecution</name><operator>-&gt;</operator><name>attributeInputMetadata</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>queryCount</name> <operator>*</operator>
															<sizeof>sizeof<argument_list>(<argument><expr><name>AttInMetadata</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>uint32</name></type> <name>queryIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>queryIndex</name> <operator>&lt;</operator> <name>queryCount</name></expr>;</condition> <incr><expr><name>queryIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AttInMetadata</name> <modifier>*</modifier></type><name>attInMetadata</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name> <init>= <expr><call><name><name>tupleDest</name><operator>-&gt;</operator><name>tupleDescForQuery</name></name><argument_list>(<argument><expr><name>tupleDest</name></expr></argument>,
																 <argument><expr><name>queryIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>tupleDescriptor</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>attInMetadata</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>EnableBinaryProtocol</name> <operator>&amp;&amp;</operator> <call><name>CanUseBinaryCopyFormat</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>attInMetadata</name> <operator>=</operator> <call><name>TupleDescGetAttBinaryInMetadata</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>shardCommandExecution</name><operator>-&gt;</operator><name>binaryResults</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>attInMetadata</name> <operator>=</operator> <call><name>TupleDescGetAttInMetadata</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name><name>shardCommandExecution</name><operator>-&gt;</operator><name>attributeInputMetadata</name><index>[<expr><name>queryIndex</name></expr>]</index></name> <operator>=</operator> <name>attInMetadata</name></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>


<comment type="block">/*
 * ExecutionOrderForTask gives the appropriate execution order for a task.
 */</comment>
<function><type><specifier>static</specifier> <name>PlacementExecutionOrder</name></type>
<name>ExecutionOrderForTask</name><parameter_list>(<parameter><decl><type><name>RowModifyLevel</name></type> <name>modLevel</name></decl></parameter>, <parameter><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name><name>task</name><operator>-&gt;</operator><name>taskType</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>READ_TASK</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><name>EXECUTION_ORDER_ANY</name></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>MODIFY_TASK</name></expr>:</case>
		<block>{<block_content>
			<comment type="block">/*
			 * For non-commutative modifications we take aggressive locks, so
			 * there is no risk of deadlock and we can run them in parallel.
			 * When the modification is commutative, we take no additional
			 * locks, so we take a conservative approach and execute sequentially
			 * to avoid deadlocks.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>modLevel</name> <operator>&lt;</operator> <name>ROW_MODIFY_NONCOMMUTATIVE</name></expr>)</condition>
			<block>{<block_content>
				<return>return <expr><name>EXECUTION_ORDER_SEQUENTIAL</name></expr>;</return>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<return>return <expr><name>EXECUTION_ORDER_PARALLEL</name></expr>;</return>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block>

		<case>case <expr><name>DDL_TASK</name></expr>:</case>
		<case>case <expr><name>VACUUM_ANALYZE_TASK</name></expr>:</case>
		<case>case <expr><name>MAP_TASK</name></expr>:</case>
		<case>case <expr><name>MERGE_TASK</name></expr>:</case>
		<case>case <expr><name>MAP_OUTPUT_FETCH_TASK</name></expr>:</case>
		<case>case <expr><name>MERGE_FETCH_TASK</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><name>EXECUTION_ORDER_PARALLEL</name></expr>;</return>
		</block_content>}</block>

		<default>default:</default>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unsupported task type %d in adaptive executor"</literal></expr></argument>,
								   <argument><expr><name><name>task</name><operator>-&gt;</operator><name>taskType</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
 * FindOrCreateWorkerPool gets the pool of connections for a particular worker.
 */</comment>
<function><type><specifier>static</specifier> <name>WorkerPool</name> <modifier>*</modifier></type>
<name>FindOrCreateWorkerPool</name><parameter_list>(<parameter><decl><type><name>DistributedExecution</name> <modifier>*</modifier></type><name>execution</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>nodeName</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nodePort</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WorkerPool</name> <modifier>*</modifier></type><name>workerPool</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>workerPool</argument>, <argument>execution-&gt;workerList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>nodeName</name></expr></argument>, <argument><expr><name><name>workerPool</name><operator>-&gt;</operator><name>nodeName</name></name></expr></argument>, <argument><expr><name>WORKER_LENGTH</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<name>nodePort</name> <operator>==</operator> <name><name>workerPool</name><operator>-&gt;</operator><name>nodePort</name></name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>workerPool</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name>workerPool</name> <operator>=</operator> <operator>(</operator><name>WorkerPool</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WorkerPool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>workerPool</name><operator>-&gt;</operator><name>nodeName</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>nodeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>workerPool</name><operator>-&gt;</operator><name>nodePort</name></name> <operator>=</operator> <name>nodePort</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><call><name>FindWorkerNode</name><argument_list>(<argument><expr><name>nodeName</name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>workerNode</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>workerPool</name><operator>-&gt;</operator><name>poolToLocalNode</name></name> <operator>=</operator>
			<name><name>workerNode</name><operator>-&gt;</operator><name>groupId</name></name> <operator>==</operator> <call><name>GetLocalGroupId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* "open" connections aggressively when there are cached connections */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>nodeConnectionCount</name> <init>= <expr><name>MaxCachedConnectionsPerWorker</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>workerPool</name><operator>-&gt;</operator><name>maxNewConnectionsPerCycle</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>nodeConnectionCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>dlist_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>workerPool</name><operator>-&gt;</operator><name>pendingTaskQueue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>dlist_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>workerPool</name><operator>-&gt;</operator><name>readyTaskQueue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>workerPool</name><operator>-&gt;</operator><name>distributedExecution</name></name> <operator>=</operator> <name>execution</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>execution</name><operator>-&gt;</operator><name>workerList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>execution</name><operator>-&gt;</operator><name>workerList</name></name></expr></argument>, <argument><expr><name>workerPool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>workerPool</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FindOrCreateWorkerSession returns a session with the given connection,
 * either existing or new. New sessions are added to the worker pool and
 * the distributed execution.
 */</comment>
<function><type><specifier>static</specifier> <name>WorkerSession</name> <modifier>*</modifier></type>
<name>FindOrCreateWorkerSession</name><parameter_list>(<parameter><decl><type><name>WorkerPool</name> <modifier>*</modifier></type><name>workerPool</name></decl></parameter>, <parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DistributedExecution</name> <modifier>*</modifier></type><name>execution</name> <init>= <expr><name><name>workerPool</name><operator>-&gt;</operator><name>distributedExecution</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>uint64</name></type> <name>sessionId</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>WorkerSession</name> <modifier>*</modifier></type><name>session</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>session</argument>, <argument>workerPool-&gt;sessionList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>session</name><operator>-&gt;</operator><name>connection</name></name> <operator>==</operator> <name>connection</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>session</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>


	<expr_stmt><expr><name>session</name> <operator>=</operator> <operator>(</operator><name>WorkerSession</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WorkerSession</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>session</name><operator>-&gt;</operator><name>sessionId</name></name> <operator>=</operator> <name>sessionId</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>session</name><operator>-&gt;</operator><name>connection</name></name> <operator>=</operator> <name>connection</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>session</name><operator>-&gt;</operator><name>workerPool</name></name> <operator>=</operator> <name>workerPool</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>session</name><operator>-&gt;</operator><name>commandsSent</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>session</name><operator>-&gt;</operator><name>waitEventSetIndex</name></name> <operator>=</operator> <name>WAIT_EVENT_SET_INDEX_NOT_INITIALIZED</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>dlist_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>session</name><operator>-&gt;</operator><name>pendingTaskQueue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>dlist_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>session</name><operator>-&gt;</operator><name>readyTaskQueue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Before using this connection in the distributed execution, we check
	 * whether the remote connection is closed/lost. This is common
	 * when we have a cached connection and remote server restarted
	 * (due to failover or restart etc.). We do this because we can
	 * retry connection a single time.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RemoteSocketClosedForNewSession</name><argument_list>(<argument><expr><name>session</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>connection</name><operator>-&gt;</operator><name>connectionState</name></name> <operator>=</operator> <name>MULTI_CONNECTION_LOST</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>connection</name><operator>-&gt;</operator><name>connectionState</name></name> <operator>==</operator> <name>MULTI_CONNECTION_CONNECTED</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* keep track of how many connections are ready */</comment>
		<expr_stmt><expr><name><name>workerPool</name><operator>-&gt;</operator><name>activeConnectionCount</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>workerPool</name><operator>-&gt;</operator><name>idleConnectionCount</name></name><operator>++</operator></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>session</name><operator>-&gt;</operator><name>sessionHasActiveConnection</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>workerPool</name><operator>-&gt;</operator><name>unusedConnectionCount</name></name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * Record the first connection establishment time to the pool. We need this
	 * to enforce NodeConnectionTimeout.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>workerPool</name><operator>-&gt;</operator><name>sessionList</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name><name>workerPool</name><operator>-&gt;</operator><name>poolStartTime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>workerPool</name><operator>-&gt;</operator><name>checkForPoolTimeout</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>workerPool</name><operator>-&gt;</operator><name>sessionList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>workerPool</name><operator>-&gt;</operator><name>sessionList</name></name></expr></argument>, <argument><expr><name>session</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>execution</name><operator>-&gt;</operator><name>sessionList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>execution</name><operator>-&gt;</operator><name>sessionList</name></name></expr></argument>, <argument><expr><name>session</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>session</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RemoteSocketClosedForNewSession is a helper function for detecting whether
 * the remote socket corresponding to the input session is closed. This is
 * mostly common there is a cached connection and remote server restarted
 * (due to failover or restart etc.).
 *
 * The function is not a generic function that can be called at the start of
 * the execution. The function is not generic because it does not check all
 * the events, even ignores cancellation events. Future callers of this
 * function should consider its limitations.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>RemoteSocketClosedForNewSession</name><parameter_list>(<parameter><decl><type><name>WorkerSession</name> <modifier>*</modifier></type><name>session</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>socketClosed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <name>PG_VERSION_15</name></expr></cpp:if>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>WaitEventSetCanReportClosed</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* we cannot detect for this OS */</comment>
		<return>return <expr><name>socketClosed</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><name><name>session</name><operator>-&gt;</operator><name>connection</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type> <name>timeout</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt><comment type="block">/* don't wait */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>eventSetSize</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WaitEvent</name> <modifier>*</modifier></type><name>events</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><name>eventSetSize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>WaitEvent</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Only wait for WL_SOCKET_CLOSED and postmaster death, do not even check
	 * for cancellations. Everything else are going to be checked soon in the
	 * main event processing. At this point, our only goal is to understand
	 * whether the remote socket is closed or not.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>originalWaitFlags</name> <init>= <expr><name><name>connection</name><operator>-&gt;</operator><name>waitFlags</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>connection</name><operator>-&gt;</operator><name>waitFlags</name></name> <operator>=</operator> <name>WL_SOCKET_CLOSED</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>WaitEventSet</name> <modifier>*</modifier></type><name>waitEventSet</name> <init>=
		<expr><call><name>CreateWaitEventSet</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>, <argument><expr><name>eventSetSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AddSessionToWaitEventSet</name><argument_list>(<argument><expr><name>session</name></expr></argument>, <argument><expr><name>waitEventSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* always good to wait for postmaster death */</comment>
	<expr_stmt><expr><call><name>CitusAddWaitEventSetToSet</name><argument_list>(<argument><expr><name>waitEventSet</name></expr></argument>, <argument><expr><name>WL_POSTMASTER_DEATH</name></expr></argument>, <argument><expr><name>PGINVALID_SOCKET</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>eventCount</name> <init>= <expr><call><name>WaitEventSetWait</name><argument_list>(<argument><expr><name>waitEventSet</name></expr></argument>, <argument><expr><name>timeout</name></expr></argument>, <argument><expr><name>events</name></expr></argument>,
									  <argument><expr><name>eventSetSize</name></expr></argument>, <argument><expr><name>WAIT_EVENT_CLIENT_READ</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>socketClosed</name> <operator>=</operator>
		<call><name>ProcessWaitEventsForSocketClosed</name><argument_list>(<argument><expr><name>events</name></expr></argument>, <argument><expr><name>eventCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* we can at most receive a single event, which is WL_SOCKET_CLOSED */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>eventCount</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FreeWaitEventSet</name><argument_list>(<argument><expr><name>waitEventSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>events</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We only searched for WL_SOCKET_CLOSED, and we processed the
	 * event already. Now, set back to the original flags.
	 */</comment>
	<expr_stmt><expr><call><name>UpdateConnectionWaitFlags</name><argument_list>(<argument><expr><name>session</name></expr></argument>, <argument><expr><name>originalWaitFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>session</name><operator>-&gt;</operator><name>latestUnconsumedWaitEvents</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><name>socketClosed</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ShouldRunTasksSequentially returns true if each of the individual tasks
 * should be executed one by one. Note that this is different than
 * MultiShardConnectionType == SEQUENTIAL_CONNECTION case. In that case,
 * running the tasks across the nodes in parallel is acceptable and implemented
 * in that way.
 *
 * However, the executions that are qualified here would perform poorly if the
 * tasks across the workers are executed in parallel. We currently qualify only
 * one class of distributed queries here, multi-row INSERTs. If we do not enforce
 * true sequential execution, concurrent multi-row upserts could easily form
 * a distributed deadlock when the upserts touch the same rows.
 */</comment>
<function><type><name>bool</name></type>
<name>ShouldRunTasksSequentially</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* single task plans are already qualified as sequential by definition */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* all the tasks are the same, so we only look one */</comment>
	<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>initialTask</name> <init>= <expr><operator>(</operator><name>Task</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>initialTask</name><operator>-&gt;</operator><name>rowValuesLists</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* found a multi-row INSERT */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SequentialRunDistributedExecution gets a distributed execution and
 * executes each individual task in the execution sequentially, one
 * task at a time. See related function ShouldRunTasksSequentially()
 * for more detail on the definition of SequentialRun.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SequentialRunDistributedExecution</name><parameter_list>(<parameter><decl><type><name>DistributedExecution</name> <modifier>*</modifier></type><name>execution</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name> <init>= <expr><name><name>execution</name><operator>-&gt;</operator><name>remoteTaskList</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>connectionMode</name> <init>= <expr><name>MultiShardConnectionType</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * There are some implicit assumptions about this setting for the sequential
	 * executions, so make sure to set it.
	 */</comment>
	<expr_stmt><expr><name>MultiShardConnectionType</name> <operator>=</operator> <name>SEQUENTIAL_CONNECTION</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>taskToExecute</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>taskToExecute</argument>, <argument>taskList</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name><name>execution</name><operator>-&gt;</operator><name>remoteAndLocalTaskList</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>taskToExecute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>execution</name><operator>-&gt;</operator><name>remoteTaskList</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>taskToExecute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>execution</name><operator>-&gt;</operator><name>totalTaskCount</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>execution</name><operator>-&gt;</operator><name>unfinishedTaskCount</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsHoldOffCancellationReceived</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* simply call the regular execution function */</comment>
		<expr_stmt><expr><call><name>RunDistributedExecution</name><argument_list>(<argument><expr><name>execution</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* set back the original execution mode */</comment>
	<expr_stmt><expr><name>MultiShardConnectionType</name> <operator>=</operator> <name>connectionMode</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * RunDistributedExecution runs a distributed execution to completion. It first opens
 * connections for distributed execution and assigns each task with shard placements
 * that have previously been modified in the current transaction to the connection
 * that modified them. Then, it creates a wait event set to listen for events on
 * any of the connections and runs the connection state machine when a connection
 * has an event.
 */</comment>
<function><type><name>void</name></type>
<name>RunDistributedExecution</name><parameter_list>(<parameter><decl><type><name>DistributedExecution</name> <modifier>*</modifier></type><name>execution</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WaitEvent</name> <modifier>*</modifier></type><name>events</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AssignTasksToConnectionsOrWorkerPool</name><argument_list>(<argument><expr><name>execution</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block">/* Preemptively step state machines in case of immediate errors */</comment>
		<decl_stmt><decl><type><name>WorkerSession</name> <modifier>*</modifier></type><name>session</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>session</argument>, <argument>execution-&gt;sessionList</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ConnectionStateMachine</name><argument_list>(<argument><expr><name>session</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<decl_stmt><decl><type><name>bool</name></type> <name>cancellationReceived</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>int</name></type> <name>eventSetSize</name> <init>= <expr><call><name>GetEventSetSize</name><argument_list>(<argument><expr><name><name>execution</name><operator>-&gt;</operator><name>sessionList</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* always (re)build the wait event set the first time */</comment>
		<expr_stmt><expr><name><name>execution</name><operator>-&gt;</operator><name>rebuildWaitEventSet</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Iterate until all the tasks are finished. Once all the tasks
		 * are finished, ensure that that all the connection initializations
		 * are also finished. Otherwise, those connections are terminated
		 * abruptly before they are established (or failed). Instead, we let
		 * the ConnectionStateMachine() to properly handle them.
		 *
		 * Note that we could have the connections that are not established
		 * as a side effect of slow-start algorithm. At the time the algorithm
		 * decides to establish new connections, the execution might have tasks
		 * to finish. But, the execution might finish before the new connections
		 * are established.
		 *
		 * Note that the rules explained above could be overriden by any
		 * cancellation to the query. In that case, we terminate the execution
		 * irrespective of the current status of the tasks or the connections.
		 */</comment>
		<while>while <condition>(<expr><operator>!</operator><name>cancellationReceived</name> <operator>&amp;&amp;</operator>
			   <operator>(</operator><name><name>execution</name><operator>-&gt;</operator><name>unfinishedTaskCount</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator>
				<call><name>HasIncompleteConnectionEstablishment</name><argument_list>(<argument><expr><name>execution</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>WorkerPool</name> <modifier>*</modifier></type><name>workerPool</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<macro><name>foreach_ptr</name><argument_list>(<argument>workerPool</argument>, <argument>execution-&gt;workerList</argument>)</argument_list></macro>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ManageWorkerPool</name><argument_list>(<argument><expr><name>workerPool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>

			<decl_stmt><decl><type><name>bool</name></type> <name>skipWaitEvents</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>execution</name><operator>-&gt;</operator><name>remoteTaskList</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * All the tasks are failed over to the local execution, no need
				 * to wait for any connection activity.
				 */</comment>
				<continue>continue;</continue>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>execution</name><operator>-&gt;</operator><name>rebuildWaitEventSet</name></name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>events</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * The execution might take a while, so explicitly free at this point
					 * because we don't need anymore.
					 */</comment>
					<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>events</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>events</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>eventSetSize</name> <operator>=</operator> <call><name>RebuildWaitEventSet</name><argument_list>(<argument><expr><name>execution</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>events</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>eventSetSize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>WaitEvent</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>skipWaitEvents</name> <operator>=</operator>
					<call><name>ProcessSessionsWithFailedWaitEventSetOperations</name><argument_list>(<argument><expr><name>execution</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>execution</name><operator>-&gt;</operator><name>waitFlagsChanged</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>RebuildWaitEventSetFlags</name><argument_list>(<argument><expr><name><name>execution</name><operator>-&gt;</operator><name>waitEventSet</name></name></expr></argument>, <argument><expr><name><name>execution</name><operator>-&gt;</operator><name>sessionList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>execution</name><operator>-&gt;</operator><name>waitFlagsChanged</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

				<expr_stmt><expr><name>skipWaitEvents</name> <operator>=</operator>
					<call><name>ProcessSessionsWithFailedWaitEventSetOperations</name><argument_list>(<argument><expr><name>execution</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>skipWaitEvents</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Some operation on the wait event set is failed, retry
				 * as we already removed the problematic connections.
				 */</comment>
				<expr_stmt><expr><name><name>execution</name><operator>-&gt;</operator><name>rebuildWaitEventSet</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* wait for I/O events */</comment>
			<decl_stmt><decl><type><name>long</name></type> <name>timeout</name> <init>= <expr><call><name>NextEventTimeout</name><argument_list>(<argument><expr><name>execution</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>eventCount</name> <init>= <expr><call><name>WaitEventSetWait</name><argument_list>(<argument><expr><name><name>execution</name><operator>-&gt;</operator><name>waitEventSet</name></name></expr></argument>, <argument><expr><name>timeout</name></expr></argument>, <argument><expr><name>events</name></expr></argument>,
											  <argument><expr><name>eventSetSize</name></expr></argument>, <argument><expr><name>WAIT_EVENT_CLIENT_READ</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>ProcessWaitEvents</name><argument_list>(<argument><expr><name>execution</name></expr></argument>, <argument><expr><name>events</name></expr></argument>, <argument><expr><name>eventCount</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cancellationReceived</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>

		<if_stmt><if>if <condition>(<expr><name>events</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>events</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>execution</name><operator>-&gt;</operator><name>waitEventSet</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>FreeWaitEventSet</name><argument_list>(<argument><expr><name><name>execution</name><operator>-&gt;</operator><name>waitEventSet</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>execution</name><operator>-&gt;</operator><name>waitEventSet</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>CleanUpSessions</name><argument_list>(<argument><expr><name>execution</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block">/*
		 * We can still recover from error using ROLLBACK TO SAVEPOINT,
		 * unclaim all connections to allow that.
		 */</comment>
		<expr_stmt><expr><call><name>UnclaimAllSessionConnections</name><argument_list>(<argument><expr><name><name>execution</name><operator>-&gt;</operator><name>sessionList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>execution</name><operator>-&gt;</operator><name>waitEventSet</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>FreeWaitEventSet</name><argument_list>(<argument><expr><name><name>execution</name><operator>-&gt;</operator><name>waitEventSet</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>execution</name><operator>-&gt;</operator><name>waitEventSet</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ProcessSessionsWithFailedWaitEventSetOperations goes over the session list
 * and processes sessions with failed wait event set operations.
 *
 * Failed sessions are not going to generate any further events, so it is our
 * only chance to process the failure by calling into `ConnectionStateMachine`.
 *
 * The function returns true if any session failed.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ProcessSessionsWithFailedWaitEventSetOperations</name><parameter_list>(<parameter><decl><type><name>DistributedExecution</name> <modifier>*</modifier></type><name>execution</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>foundFailedSession</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WorkerSession</name> <modifier>*</modifier></type><name>session</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>session</argument>, <argument>execution-&gt;sessionList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>session</name><operator>-&gt;</operator><name>waitEventSetIndex</name></name> <operator>==</operator> <name>WAIT_EVENT_SET_INDEX_FAILED</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We can only lost only already connected connections,
			 * others are regular failures.
			 */</comment>
			<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><name><name>session</name><operator>-&gt;</operator><name>connection</name></name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>connection</name><operator>-&gt;</operator><name>connectionState</name></name> <operator>==</operator> <name>MULTI_CONNECTION_CONNECTED</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>connection</name><operator>-&gt;</operator><name>connectionState</name></name> <operator>=</operator> <name>MULTI_CONNECTION_LOST</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>connection</name><operator>-&gt;</operator><name>connectionState</name></name> <operator>=</operator> <name>MULTI_CONNECTION_FAILED</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>


			<expr_stmt><expr><call><name>ConnectionStateMachine</name><argument_list>(<argument><expr><name>session</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>session</name><operator>-&gt;</operator><name>waitEventSetIndex</name></name> <operator>=</operator> <name>WAIT_EVENT_SET_INDEX_NOT_INITIALIZED</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>foundFailedSession</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>foundFailedSession</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * HasIncompleteConnectionEstablishment returns true if any of the connections
 * that has been initiated by the executor is in initilization stage.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>HasIncompleteConnectionEstablishment</name><parameter_list>(<parameter><decl><type><name>DistributedExecution</name> <modifier>*</modifier></type><name>execution</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>PreventIncompleteConnectionEstablishment</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>WorkerSession</name> <modifier>*</modifier></type><name>session</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>session</argument>, <argument>execution-&gt;sessionList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><name><name>session</name><operator>-&gt;</operator><name>connection</name></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>connection</name><operator>-&gt;</operator><name>connectionState</name></name> <operator>==</operator> <name>MULTI_CONNECTION_INITIAL</name> <operator>||</operator>
			<name><name>connection</name><operator>-&gt;</operator><name>connectionState</name></name> <operator>==</operator> <name>MULTI_CONNECTION_CONNECTING</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RebuildWaitEventSet updates the waitEventSet for the distributed execution.
 * This happens when the connection set for the distributed execution is changed,
 * which means that we need to update which connections we wait on for events.
 * It returns the new event set size.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>RebuildWaitEventSet</name><parameter_list>(<parameter><decl><type><name>DistributedExecution</name> <modifier>*</modifier></type><name>execution</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>execution</name><operator>-&gt;</operator><name>waitEventSet</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>FreeWaitEventSet</name><argument_list>(<argument><expr><name><name>execution</name><operator>-&gt;</operator><name>waitEventSet</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>execution</name><operator>-&gt;</operator><name>waitEventSet</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>execution</name><operator>-&gt;</operator><name>waitEventSet</name></name> <operator>=</operator> <call><name>BuildWaitEventSet</name><argument_list>(<argument><expr><name><name>execution</name><operator>-&gt;</operator><name>sessionList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>execution</name><operator>-&gt;</operator><name>rebuildWaitEventSet</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>execution</name><operator>-&gt;</operator><name>waitFlagsChanged</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<return>return <expr><call><name>GetEventSetSize</name><argument_list>(<argument><expr><name><name>execution</name><operator>-&gt;</operator><name>sessionList</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ProcessWaitEvents processes the received events from connections.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ProcessWaitEvents</name><parameter_list>(<parameter><decl><type><name>DistributedExecution</name> <modifier>*</modifier></type><name>execution</name></decl></parameter>, <parameter><decl><type><name>WaitEvent</name> <modifier>*</modifier></type><name>events</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eventCount</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>cancellationReceived</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>eventIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* process I/O events */</comment>
	<for>for <control>(<init>;</init> <condition><expr><name>eventIndex</name> <operator>&lt;</operator> <name>eventCount</name></expr>;</condition> <incr><expr><name>eventIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WaitEvent</name> <modifier>*</modifier></type><name>event</name> <init>= <expr><operator>&amp;</operator><name><name>events</name><index>[<expr><name>eventIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>event</name><operator>-&gt;</operator><name>events</name></name> <operator>&amp;</operator> <name>WL_POSTMASTER_DEATH</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"postmaster was shut down, exiting"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>event</name><operator>-&gt;</operator><name>events</name></name> <operator>&amp;</operator> <name>WL_LATCH_SET</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>execution</name><operator>-&gt;</operator><name>raiseInterrupts</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>IsHoldOffCancellationReceived</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Break out of event loop immediately in case of cancellation.
				 * We cannot use "return" here inside a PG_TRY() block since
				 * then the exception stack won't be reset.
				 */</comment>
				<expr_stmt><expr><operator>*</operator><name>cancellationReceived</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>WorkerSession</name> <modifier>*</modifier></type><name>session</name> <init>= <expr><operator>(</operator><name>WorkerSession</name> <operator>*</operator><operator>)</operator> <name><name>event</name><operator>-&gt;</operator><name>user_data</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>session</name><operator>-&gt;</operator><name>latestUnconsumedWaitEvents</name></name> <operator>=</operator> <name><name>event</name><operator>-&gt;</operator><name>events</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ConnectionStateMachine</name><argument_list>(<argument><expr><name>session</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <name>PG_VERSION_15</name></expr></cpp:if>

<comment type="block">/*
 * ProcessWaitEventsForSocketClosed mainly checks for WL_SOCKET_CLOSED event.
 * If WL_SOCKET_CLOSED is found, the function sets the underlying connection's
 * state as MULTI_CONNECTION_LOST.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ProcessWaitEventsForSocketClosed</name><parameter_list>(<parameter><decl><type><name>WaitEvent</name> <modifier>*</modifier></type><name>events</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eventCount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>eventIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* process I/O events */</comment>
	<for>for <control>(<init>;</init> <condition><expr><name>eventIndex</name> <operator>&lt;</operator> <name>eventCount</name></expr>;</condition> <incr><expr><name>eventIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WaitEvent</name> <modifier>*</modifier></type><name>event</name> <init>= <expr><operator>&amp;</operator><name><name>events</name><index>[<expr><name>eventIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>event</name><operator>-&gt;</operator><name>events</name></name> <operator>&amp;</operator> <name>WL_POSTMASTER_DEATH</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"postmaster was shut down, exiting"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>WorkerSession</name> <modifier>*</modifier></type><name>session</name> <init>= <expr><operator>(</operator><name>WorkerSession</name> <operator>*</operator><operator>)</operator> <name><name>event</name><operator>-&gt;</operator><name>user_data</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>session</name><operator>-&gt;</operator><name>latestUnconsumedWaitEvents</name></name> <operator>=</operator> <name><name>event</name><operator>-&gt;</operator><name>events</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>session</name><operator>-&gt;</operator><name>latestUnconsumedWaitEvents</name></name> <operator>&amp;</operator> <name>WL_SOCKET_CLOSED</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
 * ManageWorkerPool ensures the worker pool has the appropriate number of connections
 * based on the number of pending tasks.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ManageWorkerPool</name><parameter_list>(<parameter><decl><type><name>WorkerPool</name> <modifier>*</modifier></type><name>workerPool</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DistributedExecution</name> <modifier>*</modifier></type><name>execution</name> <init>= <expr><name><name>workerPool</name><operator>-&gt;</operator><name>distributedExecution</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* we do not expand the pool further if there was any failure */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>HasAnyConnectionFailure</name><argument_list>(<argument><expr><name>workerPool</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* we wait until a slow start interval has passed before expanding the pool */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ShouldWaitForSlowStart</name><argument_list>(<argument><expr><name>workerPool</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>newConnectionCount</name> <init>= <expr><call><name>CalculateNewConnectionCount</name><argument_list>(<argument><expr><name>workerPool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>newConnectionCount</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* increase the open rate every cycle (like TCP slow start) */</comment>
	<expr_stmt><expr><name><name>workerPool</name><operator>-&gt;</operator><name>maxNewConnectionsPerCycle</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>OpenNewConnections</name><argument_list>(<argument><expr><name>workerPool</name></expr></argument>, <argument><expr><name>newConnectionCount</name></expr></argument>, <argument><expr><name><name>execution</name><operator>-&gt;</operator><name>transactionProperties</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Cannot establish new connections to the local host, most probably because the
	 * local node cannot accept new connections (e.g., hit max_connections). Switch
	 * the tasks to the local execution.
	 *
	 * We prefer initiatedConnectionCount over the new connection establishments happen
	 * in this iteration via OpenNewConnections(). The reason is that it is expected for
	 * OpenNewConnections() to not open any new connections as long as the connections
	 * are optional (e.g., the second or later connections in the pool). But, for
	 * initiatedConnectionCount to be zero, the connection to the local pool should have
	 * been failed.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>initiatedConnectionCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>workerPool</name><operator>-&gt;</operator><name>sessionList</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>initiatedConnectionCount</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Only the pools to the local node are allowed to have optional
		 * connections for the first connection. Hence, initiatedConnectionCount
		 * could only be zero for poolToLocalNode. For other pools, the connection
		 * manager would wait until it gets at least one connection.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>workerPool</name><operator>-&gt;</operator><name>poolToLocalNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>WorkerPoolFailed</name><argument_list>(<argument><expr><name>workerPool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>execution</name><operator>-&gt;</operator><name>failed</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>errHint</name> <init>=
				<expr><ternary><condition><expr><name><name>execution</name><operator>-&gt;</operator><name>localExecutionSupported</name></name></expr> ?</condition><then>
				<expr><literal type="string">"This command supports local execution. Consider enabling "</literal>
				<literal type="string">"local execution using SET citus.enable_local_execution "</literal>
				<literal type="string">"TO true;"</literal></expr> </then><else>:
				<expr><literal type="string">"Consider using a higher value for max_connections"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"the total number of connections on the "</literal>
								   <literal type="string">"server is more than max_connections(%d)"</literal></expr></argument>,
								   <argument><expr><name>MaxConnections</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>errHint</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name><name>workerPool</name><operator>-&gt;</operator><name>lastConnectionOpenTime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>execution</name><operator>-&gt;</operator><name>rebuildWaitEventSet</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * HasAnyConnectionFailure returns true if worker pool has failed,
 * or connection timed out or we have a failure in connections.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>HasAnyConnectionFailure</name><parameter_list>(<parameter><decl><type><name>WorkerPool</name> <modifier>*</modifier></type><name>workerPool</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>workerPool</name><operator>-&gt;</operator><name>failureState</name></name> <operator>==</operator> <name>WORKER_POOL_FAILED</name> <operator>||</operator>
		<name><name>workerPool</name><operator>-&gt;</operator><name>failureState</name></name> <operator>==</operator> <name>WORKER_POOL_FAILED_OVER_TO_LOCAL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* connection pool failed */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* we might fail the execution or warn the user about connection timeouts */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>workerPool</name><operator>-&gt;</operator><name>checkForPoolTimeout</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CheckConnectionTimeout</name><argument_list>(<argument><expr><name>workerPool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>failedConnectionCount</name> <init>= <expr><name><name>workerPool</name><operator>-&gt;</operator><name>failedConnectionCount</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>failedConnectionCount</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* do not attempt to open more connections after one failed */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ShouldWaitForSlowStart returns true if we should wait before
 * opening a new connection because of slow start algorithm.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ShouldWaitForSlowStart</name><parameter_list>(<parameter><decl><type><name>WorkerPool</name> <modifier>*</modifier></type><name>workerPool</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* if we can use a connection per placement, we don't need to wait for slowstart */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>UseConnectionPerPlacement</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* if slow start is disabled, we can open new connections */</comment>
	<if_stmt><if>if <condition>(<expr><name>ExecutorSlowStartInterval</name> <operator>==</operator> <name>SLOW_START_DISABLED</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>double</name></type> <name>milliSecondsPassedSince</name> <init>= <expr><call><name>MillisecondsPassedSince</name><argument_list>(
		<argument><expr><name><name>workerPool</name><operator>-&gt;</operator><name>lastConnectionOpenTime</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>milliSecondsPassedSince</name> <operator>&lt;</operator> <name>ExecutorSlowStartInterval</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Refrain from establishing new connections unless we have already
	 * finalized all the earlier connection attempts. This prevents unnecessary
	 * load on the remote nodes and emulates the TCP slow-start algorithm.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>initiatedConnectionCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>workerPool</name><operator>-&gt;</operator><name>sessionList</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>finalizedConnectionCount</name> <init>=
		<expr><name><name>workerPool</name><operator>-&gt;</operator><name>activeConnectionCount</name></name> <operator>+</operator> <name><name>workerPool</name><operator>-&gt;</operator><name>failedConnectionCount</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>finalizedConnectionCount</name> <operator>&lt;</operator> <name>initiatedConnectionCount</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CalculateNewConnectionCount returns the amount of connections
 * that we can currently open.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>CalculateNewConnectionCount</name><parameter_list>(<parameter><decl><type><name>WorkerPool</name> <modifier>*</modifier></type><name>workerPool</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DistributedExecution</name> <modifier>*</modifier></type><name>execution</name> <init>= <expr><name><name>workerPool</name><operator>-&gt;</operator><name>distributedExecution</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>targetPoolSize</name> <init>= <expr><name><name>execution</name><operator>-&gt;</operator><name>targetPoolSize</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>initiatedConnectionCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>workerPool</name><operator>-&gt;</operator><name>sessionList</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name> <name>activeConnectionCount</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name> <init>=
		<expr><name><name>workerPool</name><operator>-&gt;</operator><name>activeConnectionCount</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name> <name>idleConnectionCount</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name> <init>=
		<expr><name><name>workerPool</name><operator>-&gt;</operator><name>idleConnectionCount</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>readyTaskCount</name> <init>= <expr><name><name>workerPool</name><operator>-&gt;</operator><name>readyTaskCount</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>newConnectionCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


	<comment type="block">/* we should always have more (or equal) active connections than idle connections */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>activeConnectionCount</name> <operator>&gt;=</operator> <name>idleConnectionCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* we should always have more (or equal) initiated connections than active connections */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>initiatedConnectionCount</name> <operator>&gt;=</operator> <name>activeConnectionCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* we should never have less than 0 connections ever */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>activeConnectionCount</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>idleConnectionCount</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>UseConnectionPerPlacement</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>unusedConnectionCount</name> <init>= <expr><name><name>workerPool</name><operator>-&gt;</operator><name>unusedConnectionCount</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If force_max_query_parallelization is enabled then we ignore pool size
		 * and idle connections. Instead, we open new connections as long as there
		 * are more tasks than unused connections.
		 */</comment>

		<expr_stmt><expr><name>newConnectionCount</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>readyTaskCount</name> <operator>-</operator> <name>unusedConnectionCount</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* cannot open more than targetPoolSize connections */</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>maxNewConnectionCount</name> <init>= <expr><name>targetPoolSize</name> <operator>-</operator> <name>initiatedConnectionCount</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* total number of connections that are (almost) available for tasks */</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>usableConnectionCount</name> <init>= <expr><call><name>UsableConnectionCount</name><argument_list>(<argument><expr><name>workerPool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Number of additional connections we would need to run all ready tasks in
		 * parallel.
		 */</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>newConnectionsForReadyTasks</name> <init>= <expr><call><name>Max</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>readyTaskCount</name> <operator>-</operator> <name>usableConnectionCount</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* If Slow start is enabled we need to update the maxNewConnection to the current cycle's maximum.*/</comment>
		<if_stmt><if>if <condition>(<expr><name>ExecutorSlowStartInterval</name> <operator>!=</operator> <name>SLOW_START_DISABLED</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>maxNewConnectionCount</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name><name>workerPool</name><operator>-&gt;</operator><name>maxNewConnectionsPerCycle</name></name></expr></argument>,
										<argument><expr><name>maxNewConnectionCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Open enough connections to handle all tasks that are ready, but no more
		 * than the target pool size.
		 */</comment>
		<expr_stmt><expr><name>newConnectionCount</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>newConnectionsForReadyTasks</name></expr></argument>, <argument><expr><name>maxNewConnectionCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>EnableCostBasedConnectionEstablishment</name> <operator>&amp;&amp;</operator> <name>newConnectionCount</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<name>initiatedConnectionCount</name> <operator>&lt;=</operator> <name>MaxCachedConnectionsPerWorker</name> <operator>&amp;&amp;</operator>
			<call><name>UsingExistingSessionsCheaperThanEstablishingNewConnections</name><argument_list>(
				<argument><expr><name>readyTaskCount</name></expr></argument>, <argument><expr><name>workerPool</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Before giving the decision, we do one more check. If the cost of
			 * executing the remaining tasks over the existing sessions in the
			 * pool is cheaper than establishing new connections and executing
			 * the tasks over the new connections, we prefer the former.
			 *
			 * For cached connections we should ignore any optimizations as
			 * cached connections are almost free to get. In other words,
			 * as long as there are cached connections that the pool has
			 * not used yet, aggressively use these already established
			 * connections.
			 *
			 * Note that until MaxCachedConnectionsPerWorker has already been
			 * established within the session, we still need to establish
			 * the connections right now.
			 *
			 * Also remember that we are not trying to find the optimal number
			 * of connections for the remaining tasks here. Our goal is to prevent
			 * connection establishments that are absolutely unnecessary. In the
			 * future, we may improve the calculations below to find the optimal
			 * number of new connections required.
			 */</comment>
			<return>return <expr><literal type="number">0</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>newConnectionCount</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * UsingExistingSessionsCheaperThanEstablishingNewConnections returns true if
 * using the already established connections takes less time compared to opening
 * new connections based on the current execution's stats.
 *
 * The function returns false if the current execution has not established any connections
 * or finished any tasks (e.g., no stats to act on).
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>UsingExistingSessionsCheaperThanEstablishingNewConnections</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>readyTaskCount</name></decl></parameter>,
														   <parameter><decl><type><name>WorkerPool</name> <modifier>*</modifier></type><name>workerPool</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>activeConnectionCount</name> <init>= <expr><name><name>workerPool</name><operator>-&gt;</operator><name>activeConnectionCount</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>workerPool</name><operator>-&gt;</operator><name>totalExecutedTasks</name></name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator> <name>activeConnectionCount</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The pool has not finished any connection establishment or
		 * task yet. So, we refrain from optimizing the execution.
		 */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>double</name></type> <name>avgTaskExecutionTime</name> <init>= <expr><call><name>AvgTaskExecutionTimeApproximation</name><argument_list>(<argument><expr><name>workerPool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>avgConnectionEstablishmentTime</name> <init>= <expr><call><name>AvgConnectionEstablishmentTime</name><argument_list>(<argument><expr><name>workerPool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* we assume that we are halfway through the execution */</comment>
	<decl_stmt><decl><type><name>double</name></type> <name>remainingTimeForActiveTaskExecutionsToFinish</name> <init>= <expr><name>avgTaskExecutionTime</name> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We use "newConnectionCount" as if it is the task count as
	 * we are only interested in this iteration of CalculateNewConnectionCount().
	 */</comment>
	<decl_stmt><decl><type><name>double</name></type> <name>totalTimeToExecuteNewTasks</name> <init>= <expr><name>avgTaskExecutionTime</name> <operator>*</operator> <name>readyTaskCount</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>double</name></type> <name>estimatedExecutionTimeForNewTasks</name> <init>=
		<expr><call><name>floor</name><argument_list>(<argument><expr><name>totalTimeToExecuteNewTasks</name> <operator>/</operator> <name>activeConnectionCount</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * First finish the already running tasks, and then use the connections
	 * to execute the new tasks.
	 */</comment>
	<decl_stmt><decl><type><name>double</name></type> <name>costOfExecutingTheTasksOverExistingConnections</name> <init>=
		<expr><name>remainingTimeForActiveTaskExecutionsToFinish</name> <operator>+</operator>
		<name>estimatedExecutionTimeForNewTasks</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * For every task, the executor is supposed to establish one
	 * connection and then execute the task over the connection.
	 */</comment>
	<decl_stmt><decl><type><name>double</name></type> <name>costOfExecutingTheTasksOverNewConnection</name> <init>=
		<expr><operator>(</operator><name>avgTaskExecutionTime</name> <operator>+</operator> <name>avgConnectionEstablishmentTime</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<return>return <expr><operator>(</operator><name>costOfExecutingTheTasksOverExistingConnections</name> <operator>&lt;=</operator>
			<name>costOfExecutingTheTasksOverNewConnection</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AvgTaskExecutionTimeApproximation returns the approximation of the average task
 * execution times on the workerPool.
 */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>AvgTaskExecutionTimeApproximation</name><parameter_list>(<parameter><decl><type><name>WorkerPool</name> <modifier>*</modifier></type><name>workerPool</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type> <name>totalTaskExecutionTime</name> <init>= <expr><name><name>workerPool</name><operator>-&gt;</operator><name>totalTaskExecutionTime</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>taskCount</name> <init>= <expr><name><name>workerPool</name><operator>-&gt;</operator><name>totalExecutedTasks</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>instr_time</name></type> <name>now</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>WorkerSession</name> <modifier>*</modifier></type><name>session</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>session</argument>, <argument>workerPool-&gt;sessionList</argument>)</argument_list></macro>
	<block>{<block_content>
		<comment type="block">/*
		 * Involve the tasks that are currently running. We do this to
		 * make sure that the execution responds with new connections
		 * quickly if the actively running tasks
		 */</comment>
		<decl_stmt><decl><type><name>TaskPlacementExecution</name> <modifier>*</modifier></type><name>placementExecution</name> <init>= <expr><name><name>session</name><operator>-&gt;</operator><name>currentTask</name></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>placementExecution</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<name><name>placementExecution</name><operator>-&gt;</operator><name>executionState</name></name> <operator>==</operator> <name>PLACEMENT_EXECUTION_RUNNING</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>uint64</name></type> <name>durationInMicroSecs</name> <init>=
				<expr><call><name>MicrosecondsBetweenTimestamps</name><argument_list>(<argument><expr><name><name>placementExecution</name><operator>-&gt;</operator><name>startTime</name></name></expr></argument>, <argument><expr><name>now</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Our approximation is that we assume that the task execution is
			 * just in the halfway through.
			 */</comment>
			<expr_stmt><expr><name>totalTaskExecutionTime</name> <operator>+=</operator> <operator>(</operator><literal type="number">2</literal> <operator>*</operator> <name>durationInMicroSecs</name><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>taskCount</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><ternary><condition><expr><name>taskCount</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <name>totalTaskExecutionTime</name> <operator>/</operator> <name>taskCount</name><operator>)</operator></expr></else></ternary></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AvgConnectionEstablishmentTime calculates the average connection establishment times
 * for the input workerPool.
 */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>AvgConnectionEstablishmentTime</name><parameter_list>(<parameter><decl><type><name>WorkerPool</name> <modifier>*</modifier></type><name>workerPool</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type> <name>totalTimeMicrosec</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>sessionCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>WorkerSession</name> <modifier>*</modifier></type><name>session</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>session</argument>, <argument>workerPool-&gt;sessionList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><name><name>session</name><operator>-&gt;</operator><name>connection</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * There could be MaxCachedConnectionsPerWorker connections that are
		 * already connected. Those connections might skew the average
		 * connection establishment times for the current execution. The reason
		 * is that they are established earlier and the connection establishment
		 * times might be different at the moment those connections are established.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>connection</name><operator>-&gt;</operator><name>connectionState</name></name> <operator>==</operator> <name>MULTI_CONNECTION_CONNECTED</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>long</name></type> <name>connectionEstablishmentTime</name> <init>=
				<expr><call><name>MicrosecondsBetweenTimestamps</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>connectionEstablishmentStart</name></name></expr></argument>,
											  <argument><expr><name><name>connection</name><operator>-&gt;</operator><name>connectionEstablishmentEnd</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>totalTimeMicrosec</name> <operator>+=</operator> <name>connectionEstablishmentTime</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>++</operator><name>sessionCount</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><ternary><condition><expr><operator>(</operator><name>sessionCount</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>(</operator><name>totalTimeMicrosec</name> <operator>/</operator> <name>sessionCount</name><operator>)</operator></expr></else></ternary></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * OpenNewConnections opens the given amount of connections for the given workerPool.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>OpenNewConnections</name><parameter_list>(<parameter><decl><type><name>WorkerPool</name> <modifier>*</modifier></type><name>workerPool</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>newConnectionCount</name></decl></parameter>,
				   <parameter><decl><type><name>TransactionProperties</name> <modifier>*</modifier></type><name>transactionProperties</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"opening %d new connections to %s:%d"</literal></expr></argument>, <argument><expr><name>newConnectionCount</name></expr></argument>,
							<argument><expr><name><name>workerPool</name><operator>-&gt;</operator><name>nodeName</name></name></expr></argument>, <argument><expr><name><name>workerPool</name><operator>-&gt;</operator><name>nodePort</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>connectionIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>connectionIndex</name> <operator>&lt;</operator> <name>newConnectionCount</name></expr>;</condition> <incr><expr><name>connectionIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* experimental: just to see the perf benefits of caching connections */</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>connectionFlags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>transactionProperties</name><operator>-&gt;</operator><name>useRemoteTransactionBlocks</name></name> <operator>==</operator>
			<name>TRANSACTION_BLOCKS_DISALLOWED</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>connectionFlags</name> <operator>|=</operator> <name>OUTSIDE_TRANSACTION</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Enforce the requirements for adaptive connection management (a.k.a.,
		 * throttle connections if citus.max_shared_pool_size reached)
		 */</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>adaptiveConnectionManagementFlag</name> <init>=
			<expr><call><name>AdaptiveConnectionManagementFlag</name><argument_list>(<argument><expr><name><name>workerPool</name><operator>-&gt;</operator><name>poolToLocalNode</name></name></expr></argument>,
											 <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>workerPool</name><operator>-&gt;</operator><name>sessionList</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>connectionFlags</name> <operator>|=</operator> <name>adaptiveConnectionManagementFlag</name></expr>;</expr_stmt>

		<comment type="block">/* open a new connection to the worker */</comment>
		<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><call><name>StartNodeUserDatabaseConnection</name><argument_list>(<argument><expr><name>connectionFlags</name></expr></argument>,
																	  <argument><expr><name><name>workerPool</name><operator>-&gt;</operator><name>nodeName</name></name></expr></argument>,
																	  <argument><expr><name><name>workerPool</name><operator>-&gt;</operator><name>nodePort</name></name></expr></argument>,
																	  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>connection</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* connection can only be NULL for optional connections */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>connectionFlags</name> <operator>&amp;</operator> <name>OPTIONAL_CONNECTION</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Assign the initial state in the connection state machine. The connection
		 * may already be open, but ConnectionStateMachine will immediately detect
		 * this.
		 */</comment>
		<expr_stmt><expr><name><name>connection</name><operator>-&gt;</operator><name>connectionState</name></name> <operator>=</operator> <name>MULTI_CONNECTION_CONNECTING</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Ensure that subsequent calls to StartNodeUserDatabaseConnection get a
		 * different connection.
		 */</comment>
		<expr_stmt><expr><name><name>connection</name><operator>-&gt;</operator><name>claimedExclusively</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>workerPool</name><operator>-&gt;</operator><name>sessionList</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * The worker pool has just started to establish connections. We need to
			 * defer this initilization after StartNodeUserDatabaseConnection()
			 * because for non-optional connections, we have some logic to wait
			 * until a connection is allowed to be established.
			 */</comment>
			<expr_stmt><expr><call><name>INSTR_TIME_SET_ZERO</name><argument_list>(<argument><expr><name><name>workerPool</name><operator>-&gt;</operator><name>poolStartTime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* create a session for the connection */</comment>
		<decl_stmt><decl><type><name>WorkerSession</name> <modifier>*</modifier></type><name>session</name> <init>= <expr><call><name>FindOrCreateWorkerSession</name><argument_list>(<argument><expr><name>workerPool</name></expr></argument>, <argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* immediately run the state machine to handle potential failure */</comment>
		<expr_stmt><expr><call><name>ConnectionStateMachine</name><argument_list>(<argument><expr><name>session</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>


<comment type="block">/*
 * CheckConnectionTimeout makes sure that the execution enforces the connection
 * establishment timeout defined by the user (NodeConnectionTimeout).
 *
 * The rule is that if a worker pool has already initiated connection establishment
 * and has not succeeded to finish establishments that are necessary to execute tasks,
 * take an action. For the types of actions, see the comments in the function.
 *
 * Enforcing the timeout per pool (over per session) helps the execution to continue
 * even if we can establish a single connection as we expect to have target pool size
 * number of connections. In the end, the executor is capable of using one connection
 * to execute multiple tasks.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CheckConnectionTimeout</name><parameter_list>(<parameter><decl><type><name>WorkerPool</name> <modifier>*</modifier></type><name>workerPool</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DistributedExecution</name> <modifier>*</modifier></type><name>execution</name> <init>= <expr><name><name>workerPool</name><operator>-&gt;</operator><name>distributedExecution</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>instr_time</name></type> <name>poolStartTime</name> <init>= <expr><name><name>workerPool</name><operator>-&gt;</operator><name>poolStartTime</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>instr_time</name></type> <name>now</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>initiatedConnectionCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>workerPool</name><operator>-&gt;</operator><name>sessionList</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>activeConnectionCount</name> <init>= <expr><name><name>workerPool</name><operator>-&gt;</operator><name>activeConnectionCount</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>requiredActiveConnectionCount</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>initiatedConnectionCount</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* no connection has been planned for the pool yet */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>INSTR_TIME_IS_ZERO</name><argument_list>(<argument><expr><name>poolStartTime</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * This is a special case where we assign tasks to sessions even before
	 * the connections are established. So, make sure to apply similar
	 * restrictions. In this case, make sure that we get all the connections
	 * established.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>UseConnectionPerPlacement</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>requiredActiveConnectionCount</name> <operator>=</operator> <name>initiatedConnectionCount</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>MillisecondsBetweenTimestamps</name><argument_list>(<argument><expr><name>poolStartTime</name></expr></argument>, <argument><expr><name>now</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>NodeConnectionTimeout</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>activeConnectionCount</name> <operator>&lt;</operator> <name>requiredActiveConnectionCount</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>logLevel</name> <init>= <expr><name>WARNING</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * First fail the pool and create an opportunity to execute tasks
			 * over other pools when tasks have more than one placement to execute.
			 */</comment>
			<expr_stmt><expr><call><name>WorkerPoolFailed</name><argument_list>(<argument><expr><name>workerPool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>workerPool</name><operator>-&gt;</operator><name>failureState</name></name> <operator>==</operator> <name>WORKER_POOL_FAILED_OVER_TO_LOCAL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 *
				 * When the pool is failed over to local execution, warning
				 * the user just creates chatter as the executor is capable of
				 * finishing the execution.
				 */</comment>
				<expr_stmt><expr><name>logLevel</name> <operator>=</operator> <name>DEBUG1</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>execution</name><operator>-&gt;</operator><name>transactionProperties</name><operator>-&gt;</operator><name>errorOnAnyFailure</name></name> <operator>||</operator>
					 <name><name>execution</name><operator>-&gt;</operator><name>failed</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * The enforcement is not always erroring out. For example, if a SELECT task
				 * has two different placements, we'd warn the user, fail the pool and continue
				 * with the next placement.
				 */</comment>
				<expr_stmt><expr><name>logLevel</name> <operator>=</operator> <name>ERROR</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>logLevel</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
							   <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not establish any connections to the node "</literal>
									  <literal type="string">"%s:%d after %u ms"</literal></expr></argument>, <argument><expr><name><name>workerPool</name><operator>-&gt;</operator><name>nodeName</name></name></expr></argument>,
									  <argument><expr><name><name>workerPool</name><operator>-&gt;</operator><name>nodePort</name></name></expr></argument>,
									  <argument><expr><name>NodeConnectionTimeout</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * We hit the connection timeout. In that case, we should not let the
			 * connection establishment to continue because the execution logic
			 * pretends that failed sessions are not going to be used anymore.
			 *
			 * That's why we mark the connection as timed out to trigger the state
			 * changes in the executor.
			 */</comment>
			<expr_stmt><expr><call><name>MarkEstablishingSessionsTimedOut</name><argument_list>(<argument><expr><name>workerPool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* stop interrupting WaitEventSetWait for timeouts */</comment>
			<expr_stmt><expr><name><name>workerPool</name><operator>-&gt;</operator><name>checkForPoolTimeout</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * MarkEstablishingSessionsTimedOut goes over the sessions in the given
 * workerPool and marks them timed out. ConnectionStateMachine()
 * later cleans up the sessions.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>MarkEstablishingSessionsTimedOut</name><parameter_list>(<parameter><decl><type><name>WorkerPool</name> <modifier>*</modifier></type><name>workerPool</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WorkerSession</name> <modifier>*</modifier></type><name>session</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>session</argument>, <argument>workerPool-&gt;sessionList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><name><name>session</name><operator>-&gt;</operator><name>connection</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>connection</name><operator>-&gt;</operator><name>connectionState</name></name> <operator>==</operator> <name>MULTI_CONNECTION_CONNECTING</name> <operator>||</operator>
			<name><name>connection</name><operator>-&gt;</operator><name>connectionState</name></name> <operator>==</operator> <name>MULTI_CONNECTION_INITIAL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>connection</name><operator>-&gt;</operator><name>connectionState</name></name> <operator>=</operator> <name>MULTI_CONNECTION_TIMED_OUT</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * UsableConnectionCount returns the number of connections in the worker pool
 * that are (soon to be) usable for sending commands, this includes both idle
 * connections and connections that are still establishing.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>UsableConnectionCount</name><parameter_list>(<parameter><decl><type><name>WorkerPool</name> <modifier>*</modifier></type><name>workerPool</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>initiatedConnectionCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>workerPool</name><operator>-&gt;</operator><name>sessionList</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>activeConnectionCount</name> <init>= <expr><name><name>workerPool</name><operator>-&gt;</operator><name>activeConnectionCount</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>failedConnectionCount</name> <init>= <expr><name><name>workerPool</name><operator>-&gt;</operator><name>failedConnectionCount</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>idleConnectionCount</name> <init>= <expr><name><name>workerPool</name><operator>-&gt;</operator><name>idleConnectionCount</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* connections that are still establishing will soon be available for tasks */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>establishingConnectionCount</name> <init>=
		<expr><name>initiatedConnectionCount</name> <operator>-</operator> <name>activeConnectionCount</name> <operator>-</operator> <name>failedConnectionCount</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>usableConnectionCount</name> <init>= <expr><name>idleConnectionCount</name> <operator>+</operator> <name>establishingConnectionCount</name></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>usableConnectionCount</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * NextEventTimeout finds the earliest time at which we need to interrupt
 * WaitEventSetWait because of a timeout and returns the number of milliseconds
 * until that event with a minimum of 1ms and a maximum of 1000ms.
 *
 * This code may be sensitive to clock jumps, but only has the effect of waking
 * up WaitEventSetWait slightly earlier to later.
 */</comment>
<function><type><specifier>static</specifier> <name>long</name></type>
<name>NextEventTimeout</name><parameter_list>(<parameter><decl><type><name>DistributedExecution</name> <modifier>*</modifier></type><name>execution</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>instr_time</name></type> <name>now</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>long</name></type> <name>eventTimeout</name> <init>= <expr><literal type="number">1000</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* milliseconds */</comment>

	<decl_stmt><decl><type><name>WorkerPool</name> <modifier>*</modifier></type><name>workerPool</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>workerPool</argument>, <argument>execution-&gt;workerList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>workerPool</name><operator>-&gt;</operator><name>failureState</name></name> <operator>==</operator> <name>WORKER_POOL_FAILED</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* worker pool may have already timed out */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>INSTR_TIME_IS_ZERO</name><argument_list>(<argument><expr><name><name>workerPool</name><operator>-&gt;</operator><name>poolStartTime</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<name><name>workerPool</name><operator>-&gt;</operator><name>checkForPoolTimeout</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>long</name></type> <name>timeSincePoolStartMs</name> <init>=
				<expr><call><name>MillisecondsBetweenTimestamps</name><argument_list>(<argument><expr><name><name>workerPool</name><operator>-&gt;</operator><name>poolStartTime</name></name></expr></argument>, <argument><expr><name>now</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * This could go into the negative if the connection timeout just passed.
			 * In that case we want to wake up as soon as possible. Once the timeout
			 * has been processed, checkForPoolTimeout will be false so we will skip
			 * this check.
			 */</comment>
			<decl_stmt><decl><type><name>long</name></type> <name>timeUntilConnectionTimeoutMs</name> <init>=
				<expr><name>NodeConnectionTimeout</name> <operator>-</operator> <name>timeSincePoolStartMs</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>timeUntilConnectionTimeoutMs</name> <operator>&lt;</operator> <name>eventTimeout</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>eventTimeout</name> <operator>=</operator> <name>timeUntilConnectionTimeoutMs</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>int</name></type> <name>initiatedConnectionCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>workerPool</name><operator>-&gt;</operator><name>sessionList</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If there are connections to open we wait at most up to the end of the
		 * current slow start interval.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>workerPool</name><operator>-&gt;</operator><name>readyTaskCount</name></name> <operator>&gt;</operator> <call><name>UsableConnectionCount</name><argument_list>(<argument><expr><name>workerPool</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<name>initiatedConnectionCount</name> <operator>&lt;</operator> <name><name>execution</name><operator>-&gt;</operator><name>targetPoolSize</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>long</name></type> <name>timeSinceLastConnectMs</name> <init>=
				<expr><call><name>MillisecondsBetweenTimestamps</name><argument_list>(<argument><expr><name><name>workerPool</name><operator>-&gt;</operator><name>lastConnectionOpenTime</name></name></expr></argument>, <argument><expr><name>now</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>long</name></type> <name>timeUntilSlowStartInterval</name> <init>=
				<expr><name>ExecutorSlowStartInterval</name> <operator>-</operator> <name>timeSinceLastConnectMs</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>timeUntilSlowStartInterval</name> <operator>&lt;</operator> <name>eventTimeout</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>eventTimeout</name> <operator>=</operator> <name>timeUntilSlowStartInterval</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><call><name>Max</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>eventTimeout</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * MillisecondsBetweenTimestamps is a helper to get the number of milliseconds
 * between timestamps when it is expected to be small enough to fit in a
 * long.
 */</comment>
<function><type><specifier>static</specifier> <name>long</name></type>
<name>MillisecondsBetweenTimestamps</name><parameter_list>(<parameter><decl><type><name>instr_time</name></type> <name>startTime</name></decl></parameter>, <parameter><decl><type><name>instr_time</name></type> <name>endTime</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>INSTR_TIME_SUBTRACT</name><argument_list>(<argument><expr><name>endTime</name></expr></argument>, <argument><expr><name>startTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>INSTR_TIME_GET_MILLISEC</name><argument_list>(<argument><expr><name>endTime</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * MicrosecondsBetweenTimestamps is a helper to get the number of microseconds
 * between timestamps.
 */</comment>
<function><type><specifier>static</specifier> <name>uint64</name></type>
<name>MicrosecondsBetweenTimestamps</name><parameter_list>(<parameter><decl><type><name>instr_time</name></type> <name>startTime</name></decl></parameter>, <parameter><decl><type><name>instr_time</name></type> <name>endTime</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>INSTR_TIME_SUBTRACT</name><argument_list>(<argument><expr><name>endTime</name></expr></argument>, <argument><expr><name>startTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>INSTR_TIME_GET_MICROSEC</name><argument_list>(<argument><expr><name>endTime</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ConnectionStateMachine opens a connection and descends into the transaction
 * state machine when ready.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ConnectionStateMachine</name><parameter_list>(<parameter><decl><type><name>WorkerSession</name> <modifier>*</modifier></type><name>session</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WorkerPool</name> <modifier>*</modifier></type><name>workerPool</name> <init>= <expr><name><name>session</name><operator>-&gt;</operator><name>workerPool</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DistributedExecution</name> <modifier>*</modifier></type><name>execution</name> <init>= <expr><name><name>workerPool</name><operator>-&gt;</operator><name>distributedExecution</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><name><name>session</name><operator>-&gt;</operator><name>connection</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiConnectionState</name></type> <name>currentState</name></decl>;</decl_stmt>

	<do>do <block>{<block_content>
		<expr_stmt><expr><name>currentState</name> <operator>=</operator> <name><name>connection</name><operator>-&gt;</operator><name>connectionState</name></name></expr>;</expr_stmt>

		<switch>switch <condition>(<expr><name>currentState</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>MULTI_CONNECTION_INITIAL</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/* simply iterate the state machine */</comment>
				<expr_stmt><expr><name><name>connection</name><operator>-&gt;</operator><name>connectionState</name></name> <operator>=</operator> <name>MULTI_CONNECTION_CONNECTING</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

			<case>case <expr><name>MULTI_CONNECTION_TIMED_OUT</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * When the connection timeout happens, the connection
				 * might still be able to successfuly established. However,
				 * the executor should not try to use this connection as
				 * the state machines might have already progressed and used
				 * new pools/sessions instead. That's why we terminate the
				 * connection, clear any state associated with it.
				 */</comment>
				<expr_stmt><expr><name><name>connection</name><operator>-&gt;</operator><name>connectionState</name></name> <operator>=</operator> <name>MULTI_CONNECTION_FAILED</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

			<case>case <expr><name>MULTI_CONNECTION_CONNECTING</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ConnStatusType</name></type> <name>status</name> <init>= <expr><call><name>PQstatus</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>CONNECTION_OK</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>HandleMultiConnectionSuccess</name><argument_list>(<argument><expr><name>session</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>UpdateConnectionWaitFlags</name><argument_list>(<argument><expr><name>session</name></expr></argument>,
											  <argument><expr><name>WL_SOCKET_READABLE</name> <operator>|</operator> <name>WL_SOCKET_WRITEABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>status</name> <operator>==</operator> <name>CONNECTION_BAD</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>connection</name><operator>-&gt;</operator><name>connectionState</name></name> <operator>=</operator> <name>MULTI_CONNECTION_FAILED</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>

				<decl_stmt><decl><type><name>int</name></type> <name>beforePollSocket</name> <init>= <expr><call><name>PQsocket</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>PostgresPollingStatusType</name></type> <name>pollMode</name> <init>= <expr><call><name>PQconnectPoll</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>beforePollSocket</name> <operator>!=</operator> <call><name>PQsocket</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* rebuild the wait events if PQconnectPoll() changed the socket */</comment>
					<expr_stmt><expr><name><name>execution</name><operator>-&gt;</operator><name>rebuildWaitEventSet</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>pollMode</name> <operator>==</operator> <name>PGRES_POLLING_FAILED</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>connection</name><operator>-&gt;</operator><name>connectionState</name></name> <operator>=</operator> <name>MULTI_CONNECTION_FAILED</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>pollMode</name> <operator>==</operator> <name>PGRES_POLLING_READING</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>UpdateConnectionWaitFlags</name><argument_list>(<argument><expr><name>session</name></expr></argument>, <argument><expr><name>WL_SOCKET_READABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* we should have a valid socket */</comment>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PQsocket</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>pollMode</name> <operator>==</operator> <name>PGRES_POLLING_WRITING</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>UpdateConnectionWaitFlags</name><argument_list>(<argument><expr><name>session</name></expr></argument>, <argument><expr><name>WL_SOCKET_WRITEABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* we should have a valid socket */</comment>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PQsocket</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>HandleMultiConnectionSuccess</name><argument_list>(<argument><expr><name>session</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>UpdateConnectionWaitFlags</name><argument_list>(<argument><expr><name>session</name></expr></argument>,
											  <argument><expr><name>WL_SOCKET_READABLE</name> <operator>|</operator> <name>WL_SOCKET_WRITEABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* we should have a valid socket */</comment>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PQsocket</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<break>break;</break>
			</block_content>}</block>

			<case>case <expr><name>MULTI_CONNECTION_CONNECTED</name></expr>:</case>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>HasUnfinishedTaskForSession</name><argument_list>(<argument><expr><name>session</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Connection is ready, and we have unfinished tasks.
					 * So, run the transaction state machine.
					 */</comment>
					<expr_stmt><expr><call><name>TransactionStateMachine</name><argument_list>(<argument><expr><name>session</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/*
					 * Connection is ready, but we don't have any unfinished
					 * tasks that this session can execute.
					 *
					 * Note that we can be in a situation where the executor
					 * decides to establish a connection, but not need to
					 * use it at the time the connection is established. This could
					 * happen when the earlier connections manages to finish all the
					 * tasks after this connection
					 *
					 * As no tasks are ready to be executed at the moment, we
					 * mark the socket readable to get any notices if exists.
					 */</comment>
					<expr_stmt><expr><call><name>UpdateConnectionWaitFlags</name><argument_list>(<argument><expr><name>session</name></expr></argument>, <argument><expr><name>WL_SOCKET_READABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<break>break;</break>
			</block_content>}</block>

			<case>case <expr><name>MULTI_CONNECTION_LOST</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * If a connection is lost, we retry the connection for some
				 * very restricted scenarios. The main use case is to retry
				 * connection establishment when a cached connection is used
				 * in the executor while remote server has restarted / failedover
				 * etc.
				 *
				 * For simplicity, we only allow retrying connection establishment
				 * a single time.
				 *
				 * We can only retry connection when the remote transaction has
				 * not started over the connection. Otherwise, we'd have to deal
				 * with restoring the transaction state, which iis beyond our
				 * purpose at this time.
				 */</comment>
				<decl_stmt><decl><type><name>RemoteTransaction</name> <modifier>*</modifier></type><name>transaction</name> <init>= <expr><operator>&amp;</operator><name><name>connection</name><operator>-&gt;</operator><name>remoteTransaction</name></name></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>session</name><operator>-&gt;</operator><name>connectionRetried</name></name> <operator>&amp;&amp;</operator>
					<name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>==</operator> <name>REMOTE_TRANS_NOT_STARTED</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Try to connect again, we will reuse the same MultiConnection
					 * and keep it as claimed.
					 */</comment>
					<expr_stmt><expr><call><name>RestartConnection</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* socket have changed */</comment>
					<expr_stmt><expr><name><name>execution</name><operator>-&gt;</operator><name>rebuildWaitEventSet</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>session</name><operator>-&gt;</operator><name>latestUnconsumedWaitEvents</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

					<expr_stmt><expr><name><name>session</name><operator>-&gt;</operator><name>connectionRetried</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

					<break>break;</break>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name><name>connection</name><operator>-&gt;</operator><name>connectionState</name></name> <operator>=</operator> <name>MULTI_CONNECTION_FAILED</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

			<case>case <expr><name>MULTI_CONNECTION_FAILED</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/* managed to connect, but connection was lost */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>session</name><operator>-&gt;</operator><name>sessionHasActiveConnection</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>workerPool</name><operator>-&gt;</operator><name>activeConnectionCount</name></name><operator>--</operator></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>session</name><operator>-&gt;</operator><name>currentTask</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* this was an idle connection */</comment>
						<expr_stmt><expr><name><name>workerPool</name><operator>-&gt;</operator><name>idleConnectionCount</name></name><operator>--</operator></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<expr_stmt><expr><name><name>session</name><operator>-&gt;</operator><name>sessionHasActiveConnection</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* connection failed or was lost */</comment>
				<decl_stmt><decl><type><name>int</name></type> <name>totalConnectionCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>workerPool</name><operator>-&gt;</operator><name>sessionList</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>workerPool</name><operator>-&gt;</operator><name>failedConnectionCount</name></name><operator>++</operator></expr>;</expr_stmt>

				<comment type="block">/* if the connection executed a critical command it should fail */</comment>
				<expr_stmt><expr><call><name>MarkRemoteTransactionFailed</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* mark all assigned placement executions as failed */</comment>
				<expr_stmt><expr><call><name>WorkerSessionFailed</name><argument_list>(<argument><expr><name>session</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>workerPool</name><operator>-&gt;</operator><name>failedConnectionCount</name></name> <operator>&gt;=</operator> <name>totalConnectionCount</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * All current connection attempts have failed.
					 * Mark all unassigned placement executions as failed.
					 *
					 * We do not currently retry if the first connection
					 * attempt fails.
					 */</comment>
					<expr_stmt><expr><call><name>WorkerPoolFailed</name><argument_list>(<argument><expr><name>workerPool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * The execution may have failed as a result of WorkerSessionFailed
				 * or WorkerPoolFailed.
				 *
				 * Even if this execution has not failed -- but just a single session is
				 * failed -- and an earlier execution in this transaction which marked
				 * the remote transaction as critical, we should fail right away as the
				 * transaction will fail anyway on PREPARE/COMMIT time.
				 */</comment>
				<decl_stmt><decl><type><name>RemoteTransaction</name> <modifier>*</modifier></type><name>transaction</name> <init>= <expr><operator>&amp;</operator><name><name>connection</name><operator>-&gt;</operator><name>remoteTransaction</name></name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionCritical</name></name> <operator>||</operator>
					<name><name>execution</name><operator>-&gt;</operator><name>failed</name></name> <operator>||</operator>
					<operator>(</operator><name><name>execution</name><operator>-&gt;</operator><name>transactionProperties</name><operator>-&gt;</operator><name>errorOnAnyFailure</name></name> <operator>&amp;&amp;</operator>
					 <name><name>workerPool</name><operator>-&gt;</operator><name>failureState</name></name> <operator>!=</operator> <name>WORKER_POOL_FAILED_OVER_TO_LOCAL</name><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* a task has failed due to this connection failure */</comment>
					<expr_stmt><expr><call><name>ReportConnectionError</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name><name>workerPool</name><operator>-&gt;</operator><name>activeConnectionCount</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator>
						 <name><name>workerPool</name><operator>-&gt;</operator><name>failureState</name></name> <operator>==</operator> <name>WORKER_POOL_FAILED_OVER_TO_LOCAL</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * We already have active connection(s) to the node, and the
					 * executor is capable of using those connections to successfully
					 * finish the execution. So, there is not much value in warning
					 * the user.
					 *
					 * Similarly when the pool is failed over to local execution, warning
					 * the user just creates chatter.
					 */</comment>
					<expr_stmt><expr><call><name>ReportConnectionError</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>DEBUG1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>ReportConnectionError</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>WARNING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<comment type="block">/* remove the connection */</comment>
				<expr_stmt><expr><call><name>UnclaimConnection</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * We forcefully close the underlying libpq connection because
				 * we don't want any subsequent execution (either subPlan executions
				 * or new command executions within a transaction block) use the
				 * connection.
				 *
				 * However, we prefer to keep the MultiConnection around until
				 * the end of FinishDistributedExecution() to simplify the code.
				 * Thus, we prefer ShutdownConnection() over CloseConnection().
				 */</comment>
				<expr_stmt><expr><call><name>ShutdownConnection</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* remove connection from wait event set */</comment>
				<expr_stmt><expr><name><name>execution</name><operator>-&gt;</operator><name>rebuildWaitEventSet</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * Reset the transaction state machine since CloseConnection()
				 * relies on it and even if we're not inside a distributed transaction
				 * we set the transaction state (e.g., REMOTE_TRANS_SENT_COMMAND).
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>connection</name><operator>-&gt;</operator><name>remoteTransaction</name><operator>.</operator><name>beginSent</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>connection</name><operator>-&gt;</operator><name>remoteTransaction</name><operator>.</operator><name>transactionState</name></name> <operator>=</operator>
						<name>REMOTE_TRANS_NOT_STARTED</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<break>break;</break>
			</block_content>}</block>

			<default>default:</default>
			<block>{<block_content>
				<break>break;</break>
			</block_content>}</block>
		</block_content>}</block></switch>
	</block_content>}</block> while <condition>(<expr><name><name>connection</name><operator>-&gt;</operator><name>connectionState</name></name> <operator>!=</operator> <name>currentState</name></expr>)</condition>;</do>
</block_content>}</block></function>


<comment type="block">/*
 * HasUnfinishedTaskForSession gets a session and returns true if there
 * are any tasks that this session can execute.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>HasUnfinishedTaskForSession</name><parameter_list>(<parameter><decl><type><name>WorkerSession</name> <modifier>*</modifier></type><name>session</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>session</name><operator>-&gt;</operator><name>currentTask</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* the session is executing a command right now */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>dlist_head</name> <modifier>*</modifier></type><name>sessionReadyTaskQueue</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>session</name><operator>-&gt;</operator><name>readyTaskQueue</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>dlist_is_empty</name><argument_list>(<argument><expr><name>sessionReadyTaskQueue</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* session has an assigned task, which is ready for execution */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>WorkerPool</name> <modifier>*</modifier></type><name>workerPool</name> <init>= <expr><name><name>session</name><operator>-&gt;</operator><name>workerPool</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dlist_head</name> <modifier>*</modifier></type><name>poolReadyTaskQueue</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>workerPool</name><operator>-&gt;</operator><name>readyTaskQueue</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>dlist_is_empty</name><argument_list>(<argument><expr><name>poolReadyTaskQueue</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Pool has unassigned tasks that can be executed
		 * by the input session.
		 */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * HandleMultiConnectionSuccess logs the established connection and updates
 * connection's state.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>HandleMultiConnectionSuccess</name><parameter_list>(<parameter><decl><type><name>WorkerSession</name> <modifier>*</modifier></type><name>session</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><name><name>session</name><operator>-&gt;</operator><name>connection</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WorkerPool</name> <modifier>*</modifier></type><name>workerPool</name> <init>= <expr><name><name>session</name><operator>-&gt;</operator><name>workerPool</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>MarkConnectionConnected</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"established connection to %s:%d for "</literal>
							<literal type="string">"session %ld in %ld microseconds"</literal></expr></argument>,
							<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>, <argument><expr><name><name>connection</name><operator>-&gt;</operator><name>port</name></name></expr></argument>,
							<argument><expr><name><name>session</name><operator>-&gt;</operator><name>sessionId</name></name></expr></argument>,
							<argument><expr><call><name>MicrosecondsBetweenTimestamps</name><argument_list>(
								<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>connectionEstablishmentStart</name></name></expr></argument>,
								<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>connectionEstablishmentEnd</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>workerPool</name><operator>-&gt;</operator><name>activeConnectionCount</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>workerPool</name><operator>-&gt;</operator><name>idleConnectionCount</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>session</name><operator>-&gt;</operator><name>sessionHasActiveConnection</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Activate2PCIfModifyingTransactionExpandsToNewNode sets the coordinated
 * transaction to use 2PC under the following circumstances:
 *     - We're already in a transaction block
 *     - At least one of the previous commands in the transaction block
 *       made a modification, which have not set 2PC itself because it
 *       was a single shard command
 *     - The input "session" is used for a distributed execution which
 *       modifies the database. However, the session (and hence the
 *       connection) is established to a different worker than the ones
 *       that is used previously in the transaction.
 *
 *  To give an example,
 *      BEGIN;
 *          -- assume that the following INSERT goes to worker-A
 *          -- also note that this single command does not activate
 *          -- 2PC itself since it is a single shard modification
 *          INSERT INTO distributed_table (dist_key) VALUES (1);
 *
 *          -- do one more single shard UPDATE hitting the same
 *          shard (or worker node in general)
 *          -- this wouldn't activate 2PC, since we're operating on the
 *          -- same worker node that we've modified earlier
 *          -- so the executor would use the same connection
 *			UPDATE distributed_table SET value = 10 WHERE dist_key = 1;
 *
 *          -- now, do one more INSERT, which goes to worker-B
 *          -- At this point, this function would activate 2PC
 *          -- since we're now expanding to a new node
 *          -- for example, if this command were a SELECT, we wouldn't
 *          -- activate 2PC since we're only interested in modifications/DDLs
 *          INSERT INTO distributed_table (dist_key) VALUES (2);
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>Activate2PCIfModifyingTransactionExpandsToNewNode</name><parameter_list>(<parameter><decl><type><name>WorkerSession</name> <modifier>*</modifier></type><name>session</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DistributedExecution</name> <modifier>*</modifier></type><name>execution</name> <init>= <expr><name><name>session</name><operator>-&gt;</operator><name>workerPool</name><operator>-&gt;</operator><name>distributedExecution</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>TransactionModifiedDistributedTable</name><argument_list>(<argument><expr><name>execution</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>DistributedExecutionModifiesDatabase</name><argument_list>(<argument><expr><name>execution</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>ConnectionModifiedPlacement</name><argument_list>(<argument><expr><name><name>session</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We already did a modification, but not on the connection that we
		 * just opened, which means we're now going to make modifications
		 * over multiple connections. Activate 2PC!
		 */</comment>
		<expr_stmt><expr><call><name>Use2PCForCoordinatedTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * TransactionModifiedDistributedTable returns true if the current transaction already
 * executed a command which modified at least one distributed table in the current
 * transaction.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>TransactionModifiedDistributedTable</name><parameter_list>(<parameter><decl><type><name>DistributedExecution</name> <modifier>*</modifier></type><name>execution</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We need to explicitly check for TRANSACTION_BLOCKS_REQUIRED due to
	 * citus.function_opens_transaction_block flag. When set to false, we
	 * should not be pretending that we're in a coordinated transaction even
	 * if XACT_MODIFICATION_DATA is set. That's why we implemented this workaround.
	 */</comment>
	<return>return <expr><name><name>execution</name><operator>-&gt;</operator><name>transactionProperties</name><operator>-&gt;</operator><name>useRemoteTransactionBlocks</name></name> <operator>==</operator>
		   <name>TRANSACTION_BLOCKS_REQUIRED</name> <operator>&amp;&amp;</operator>
		   <name>XactModificationLevel</name> <operator>==</operator> <name>XACT_MODIFICATION_DATA</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * TransactionStateMachine manages the execution of tasks over a connection.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>TransactionStateMachine</name><parameter_list>(<parameter><decl><type><name>WorkerSession</name> <modifier>*</modifier></type><name>session</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WorkerPool</name> <modifier>*</modifier></type><name>workerPool</name> <init>= <expr><name><name>session</name><operator>-&gt;</operator><name>workerPool</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DistributedExecution</name> <modifier>*</modifier></type><name>execution</name> <init>= <expr><name><name>workerPool</name><operator>-&gt;</operator><name>distributedExecution</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionBlocksUsage</name></type> <name>useRemoteTransactionBlocks</name> <init>=
		<expr><name><name>execution</name><operator>-&gt;</operator><name>transactionProperties</name><operator>-&gt;</operator><name>useRemoteTransactionBlocks</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><name><name>session</name><operator>-&gt;</operator><name>connection</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RemoteTransaction</name> <modifier>*</modifier></type><name>transaction</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>connection</name><operator>-&gt;</operator><name>remoteTransaction</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RemoteTransactionState</name></type> <name>currentState</name></decl>;</decl_stmt>

	<do>do <block>{<block_content>
		<expr_stmt><expr><name>currentState</name> <operator>=</operator> <name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckConnectionReady</name><argument_list>(<argument><expr><name>session</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* connection is busy, no state transitions to make */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<switch>switch <condition>(<expr><name>currentState</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>REMOTE_TRANS_NOT_STARTED</name></expr>:</case>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>useRemoteTransactionBlocks</name> <operator>==</operator> <name>TRANSACTION_BLOCKS_REQUIRED</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* if we're expanding the nodes in a transaction, use 2PC */</comment>
					<expr_stmt><expr><call><name>Activate2PCIfModifyingTransactionExpandsToNewNode</name><argument_list>(<argument><expr><name>session</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* need to open a transaction block first */</comment>
					<expr_stmt><expr><call><name>StartRemoteTransactionBegin</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>=</operator> <name>REMOTE_TRANS_CLEARING_RESULTS</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<decl_stmt><decl><type><name>TaskPlacementExecution</name> <modifier>*</modifier></type><name>placementExecution</name> <init>= <expr><call><name>PopPlacementExecution</name><argument_list>(
						<argument><expr><name>session</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<if_stmt><if>if <condition>(<expr><name>placementExecution</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * No tasks are ready to be executed at the moment. But we
						 * still mark the socket readable to get any notices if exists.
						 */</comment>
						<expr_stmt><expr><call><name>UpdateConnectionWaitFlags</name><argument_list>(<argument><expr><name>session</name></expr></argument>, <argument><expr><name>WL_SOCKET_READABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<break>break;</break>
					</block_content>}</block></if></if_stmt>

					<decl_stmt><decl><type><name>bool</name></type> <name>placementExecutionStarted</name> <init>=
						<expr><call><name>StartPlacementExecutionOnSession</name><argument_list>(<argument><expr><name>placementExecution</name></expr></argument>, <argument><expr><name>session</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>placementExecutionStarted</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* no need to continue, connection is lost */</comment>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>session</name><operator>-&gt;</operator><name>connection</name><operator>-&gt;</operator><name>connectionState</name></name> <operator>==</operator>
							   <name>MULTI_CONNECTION_LOST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<return>return;</return>
					</block_content>}</block></if></if_stmt>

					<expr_stmt><expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>=</operator> <name>REMOTE_TRANS_SENT_COMMAND</name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<expr_stmt><expr><call><name>UpdateConnectionWaitFlags</name><argument_list>(<argument><expr><name>session</name></expr></argument>,
										  <argument><expr><name>WL_SOCKET_READABLE</name> <operator>|</operator> <name>WL_SOCKET_WRITEABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

			<case>case <expr><name>REMOTE_TRANS_SENT_BEGIN</name></expr>:</case>
			<case>case <expr><name>REMOTE_TRANS_CLEARING_RESULTS</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>PQgetResult</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsResponseOK</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* query failures are always hard errors */</comment>
						<expr_stmt><expr><call><name>ReportResultError</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* wake up WaitEventSetWait */</comment>
					<expr_stmt><expr><call><name>UpdateConnectionWaitFlags</name><argument_list>(<argument><expr><name>session</name></expr></argument>,
											  <argument><expr><name>WL_SOCKET_READABLE</name> <operator>|</operator> <name>WL_SOCKET_WRITEABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<break>break;</break>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>session</name><operator>-&gt;</operator><name>currentTask</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>TaskPlacementExecution</name> <modifier>*</modifier></type><name>placementExecution</name> <init>= <expr><name><name>session</name><operator>-&gt;</operator><name>currentTask</name></name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>bool</name></type> <name>succeeded</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

					<comment type="block">/*
					 * Once we finished a task on a connection, we no longer
					 * allow that connection to fail.
					 */</comment>
					<expr_stmt><expr><call><name>MarkRemoteTransactionCritical</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name><name>session</name><operator>-&gt;</operator><name>currentTask</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>PlacementExecutionDone</name><argument_list>(<argument><expr><name>placementExecution</name></expr></argument>, <argument><expr><name>succeeded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* connection is ready to use for executing commands */</comment>
					<expr_stmt><expr><name><name>workerPool</name><operator>-&gt;</operator><name>idleConnectionCount</name></name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* connection needs to be writeable to send next command */</comment>
				<expr_stmt><expr><call><name>UpdateConnectionWaitFlags</name><argument_list>(<argument><expr><name>session</name></expr></argument>,
										  <argument><expr><name>WL_SOCKET_READABLE</name> <operator>|</operator> <name>WL_SOCKET_WRITEABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>transaction</name><operator>-&gt;</operator><name>beginSent</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>=</operator> <name>REMOTE_TRANS_STARTED</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>=</operator> <name>REMOTE_TRANS_NOT_STARTED</name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<break>break;</break>
			</block_content>}</block>

			<case>case <expr><name>REMOTE_TRANS_STARTED</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TaskPlacementExecution</name> <modifier>*</modifier></type><name>placementExecution</name> <init>= <expr><call><name>PopPlacementExecution</name><argument_list>(
					<argument><expr><name>session</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><name>placementExecution</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* no tasks are ready to be executed at the moment */</comment>
					<expr_stmt><expr><call><name>UpdateConnectionWaitFlags</name><argument_list>(<argument><expr><name>session</name></expr></argument>, <argument><expr><name>WL_SOCKET_READABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>

				<decl_stmt><decl><type><name>bool</name></type> <name>placementExecutionStarted</name> <init>=
					<expr><call><name>StartPlacementExecutionOnSession</name><argument_list>(<argument><expr><name>placementExecution</name></expr></argument>, <argument><expr><name>session</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>placementExecutionStarted</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* no need to continue, connection is lost */</comment>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>session</name><operator>-&gt;</operator><name>connection</name><operator>-&gt;</operator><name>connectionState</name></name> <operator>==</operator> <name>MULTI_CONNECTION_LOST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<return>return;</return>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>=</operator> <name>REMOTE_TRANS_SENT_COMMAND</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

			<case>case <expr><name>REMOTE_TRANS_SENT_COMMAND</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TaskPlacementExecution</name> <modifier>*</modifier></type><name>placementExecution</name> <init>= <expr><name><name>session</name><operator>-&gt;</operator><name>currentTask</name></name></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><name>placementExecution</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * We have seen accounts in production where the placementExecution
					 * could inadvertently be not set. Investigation documented on
					 * https://github.com/citusdata/citus-enterprise/issues/493
					 * (due to sensitive data in the initial report it is not discussed
					 * in our community repository)
					 *
					 * Currently we don't have a reliable way of reproducing this issue.
					 * Erroring here seems to be a more desirable approach compared to a
					 * SEGFAULT on the dereference of placementExecution, with a possible
					 * crash recovery as a result.
					 */</comment>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
										<argument><expr><literal type="string">"unable to recover from inconsistent state in "</literal>
										<literal type="string">"the connection state machine on coordinator"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<decl_stmt><decl><type><name>ShardCommandExecution</name> <modifier>*</modifier></type><name>shardCommandExecution</name> <init>=
					<expr><name><name>placementExecution</name><operator>-&gt;</operator><name>shardCommandExecution</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name> <init>= <expr><name><name>shardCommandExecution</name><operator>-&gt;</operator><name>task</name></name></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * In EXPLAIN ANALYZE we need to store results except for multiple placements,
				 * regardless of query type. In other cases, doing the same doesn't seem to have
				 * a drawback.
				 */</comment>
				<decl_stmt><decl><type><name>bool</name></type> <name>storeRows</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>shardCommandExecution</name><operator>-&gt;</operator><name>gotResults</name></name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* already received results from another replica */</comment>
					<expr_stmt><expr><name>storeRows</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name><name>task</name><operator>-&gt;</operator><name>partiallyLocalOrRemote</name></name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * For the tasks that involves placements from both
					 * remote and local placments, such as modifications
					 * to reference tables, we store the rows during the
					 * local placement/execution.
					 */</comment>
					<expr_stmt><expr><name>storeRows</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<decl_stmt><decl><type><name>bool</name></type> <name>fetchDone</name> <init>= <expr><call><name>ReceiveResults</name><argument_list>(<argument><expr><name>session</name></expr></argument>, <argument><expr><name>storeRows</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fetchDone</name></expr>)</condition>
				<block>{<block_content>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* if this is a multi-query task, send the next query */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>placementExecution</name><operator>-&gt;</operator><name>queryIndex</name></name> <operator>&lt;</operator> <name><name>task</name><operator>-&gt;</operator><name>queryCount</name></name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>bool</name></type> <name>querySent</name> <init>= <expr><call><name>SendNextQuery</name><argument_list>(<argument><expr><name>placementExecution</name></expr></argument>, <argument><expr><name>session</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>querySent</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* no need to continue, connection is lost */</comment>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>session</name><operator>-&gt;</operator><name>connection</name><operator>-&gt;</operator><name>connectionState</name></name> <operator>==</operator>
							   <name>MULTI_CONNECTION_LOST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<return>return;</return>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/*
					 * At this point the query might be just in pgconn buffers. We
					 * need to wait until it becomes writeable to actually send
					 * the query.
					 */</comment>
					<expr_stmt><expr><call><name>UpdateConnectionWaitFlags</name><argument_list>(<argument><expr><name>session</name></expr></argument>,
											  <argument><expr><name>WL_SOCKET_WRITEABLE</name> <operator>|</operator> <name>WL_SOCKET_READABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>=</operator> <name>REMOTE_TRANS_SENT_COMMAND</name></expr>;</expr_stmt>

					<break>break;</break>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name><name>shardCommandExecution</name><operator>-&gt;</operator><name>gotResults</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>=</operator> <name>REMOTE_TRANS_CLEARING_RESULTS</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

			<default>default:</default>
			<block>{<block_content>
				<break>break;</break>
			</block_content>}</block>
		</block_content>}</block></switch>
	</block_content>}</block>
	<comment type="block">/* iterate in case we can perform multiple transitions at once */</comment>
	while <condition>(<expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>!=</operator> <name>currentState</name></expr>)</condition>;</do>
</block_content>}</block></function>


<comment type="block">/*
 * UpdateConnectionWaitFlags is a wrapper around setting waitFlags of the connection.
 *
 * This function might further improved in a sense that to use use ModifyWaitEvent on
 * waitFlag changes as opposed to what we do now: always rebuild the wait event sets.
 * Our initial benchmarks didn't show any significant performance improvements, but
 * good to keep in mind the potential improvements.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>UpdateConnectionWaitFlags</name><parameter_list>(<parameter><decl><type><name>WorkerSession</name> <modifier>*</modifier></type><name>session</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>waitFlags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><name><name>session</name><operator>-&gt;</operator><name>connection</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DistributedExecution</name> <modifier>*</modifier></type><name>execution</name> <init>= <expr><name><name>session</name><operator>-&gt;</operator><name>workerPool</name><operator>-&gt;</operator><name>distributedExecution</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* do not take any actions if the flags not changed */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>connection</name><operator>-&gt;</operator><name>waitFlags</name></name> <operator>==</operator> <name>waitFlags</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <name>PG_VERSION_15</name></expr></cpp:if>

	<comment type="block">/* always detect closed sockets */</comment>
	<expr_stmt><expr><name><name>connection</name><operator>-&gt;</operator><name>waitFlags</name></name> <operator>=</operator> <name>waitFlags</name> <operator>|</operator> <name>WL_SOCKET_CLOSED</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name><name>connection</name><operator>-&gt;</operator><name>waitFlags</name></name> <operator>=</operator> <name>waitFlags</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* without signalling the execution, the flag changes won't be reflected */</comment>
	<expr_stmt><expr><name><name>execution</name><operator>-&gt;</operator><name>waitFlagsChanged</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CheckConnectionReady returns true if the connection is ready to
 * read or write, or false if it still has bytes to send/receive.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>CheckConnectionReady</name><parameter_list>(<parameter><decl><type><name>WorkerSession</name> <modifier>*</modifier></type><name>session</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><name><name>session</name><operator>-&gt;</operator><name>connection</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>waitFlags</name> <init>= <expr><name>WL_SOCKET_READABLE</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>connectionReady</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ConnStatusType</name></type> <name>status</name> <init>= <expr><call><name>PQstatus</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>CONNECTION_BAD</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>connection</name><operator>-&gt;</operator><name>connectionState</name></name> <operator>=</operator> <name>MULTI_CONNECTION_LOST</name></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <name>PG_VERSION_15</name></expr></cpp:if>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>session</name><operator>-&gt;</operator><name>latestUnconsumedWaitEvents</name></name> <operator>&amp;</operator> <name>WL_SOCKET_CLOSED</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>connection</name><operator>-&gt;</operator><name>connectionState</name></name> <operator>=</operator> <name>MULTI_CONNECTION_LOST</name></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* try to send all pending data */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>sendStatus</name> <init>= <expr><call><name>PQflush</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>sendStatus</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>connection</name><operator>-&gt;</operator><name>connectionState</name></name> <operator>=</operator> <name>MULTI_CONNECTION_LOST</name></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>sendStatus</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* more data to send, wait for socket to become writable */</comment>
		<expr_stmt><expr><name>waitFlags</name> <operator>=</operator> <name>waitFlags</name> <operator>|</operator> <name>WL_SOCKET_WRITEABLE</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>session</name><operator>-&gt;</operator><name>latestUnconsumedWaitEvents</name></name> <operator>&amp;</operator> <name>WL_SOCKET_READABLE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>PQconsumeInput</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>connection</name><operator>-&gt;</operator><name>connectionState</name></name> <operator>=</operator> <name>MULTI_CONNECTION_LOST</name></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQisBusy</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>connectionReady</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>UpdateConnectionWaitFlags</name><argument_list>(<argument><expr><name>session</name></expr></argument>, <argument><expr><name>waitFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* don't consume input redundantly if we cycle back into CheckConnectionReady */</comment>
	<expr_stmt><expr><name><name>session</name><operator>-&gt;</operator><name>latestUnconsumedWaitEvents</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<return>return <expr><name>connectionReady</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PopPlacementExecution returns the next available assigned or unassigned
 * placement execution for the given session.
 */</comment>
<function><type><specifier>static</specifier> <name>TaskPlacementExecution</name> <modifier>*</modifier></type>
<name>PopPlacementExecution</name><parameter_list>(<parameter><decl><type><name>WorkerSession</name> <modifier>*</modifier></type><name>session</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WorkerPool</name> <modifier>*</modifier></type><name>workerPool</name> <init>= <expr><name><name>session</name><operator>-&gt;</operator><name>workerPool</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>TaskPlacementExecution</name> <modifier>*</modifier></type><name>placementExecution</name> <init>= <expr><call><name>PopAssignedPlacementExecution</name><argument_list>(<argument><expr><name>session</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>placementExecution</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>session</name><operator>-&gt;</operator><name>commandsSent</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>UseConnectionPerPlacement</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Only send one command per connection if force_max_query_parallelisation
			 * is enabled, unless it's an assigned placement execution.
			 */</comment>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* no more assigned tasks, pick an unassigned task */</comment>
		<expr_stmt><expr><name>placementExecution</name> <operator>=</operator> <call><name>PopUnassignedPlacementExecution</name><argument_list>(<argument><expr><name>workerPool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>placementExecution</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PopAssignedPlacementExecution finds an executable task from the queue of assigned tasks.
 */</comment>
<function><type><specifier>static</specifier> <name>TaskPlacementExecution</name> <modifier>*</modifier></type>
<name>PopAssignedPlacementExecution</name><parameter_list>(<parameter><decl><type><name>WorkerSession</name> <modifier>*</modifier></type><name>session</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dlist_head</name> <modifier>*</modifier></type><name>readyTaskQueue</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>session</name><operator>-&gt;</operator><name>readyTaskQueue</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>dlist_is_empty</name><argument_list>(<argument><expr><name>readyTaskQueue</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>TaskPlacementExecution</name> <modifier>*</modifier></type><name>placementExecution</name> <init>= <expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>TaskPlacementExecution</name></expr></argument>,
																 <argument><expr><name>sessionReadyQueueNode</name></expr></argument>,
																 <argument><expr><call><name>dlist_pop_head_node</name><argument_list>(
																	 <argument><expr><name>readyTaskQueue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>placementExecution</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PopAssignedPlacementExecution finds an executable task from the queue of assigned tasks.
 */</comment>
<function><type><specifier>static</specifier> <name>TaskPlacementExecution</name> <modifier>*</modifier></type>
<name>PopUnassignedPlacementExecution</name><parameter_list>(<parameter><decl><type><name>WorkerPool</name> <modifier>*</modifier></type><name>workerPool</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dlist_head</name> <modifier>*</modifier></type><name>readyTaskQueue</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>workerPool</name><operator>-&gt;</operator><name>readyTaskQueue</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>dlist_is_empty</name><argument_list>(<argument><expr><name>readyTaskQueue</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>TaskPlacementExecution</name> <modifier>*</modifier></type><name>placementExecution</name> <init>= <expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>TaskPlacementExecution</name></expr></argument>,
																 <argument><expr><name>workerReadyQueueNode</name></expr></argument>,
																 <argument><expr><call><name>dlist_pop_head_node</name><argument_list>(
																	 <argument><expr><name>readyTaskQueue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>workerPool</name><operator>-&gt;</operator><name>readyTaskCount</name></name><operator>--</operator></expr>;</expr_stmt>

	<return>return <expr><name>placementExecution</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * StartPlacementExecutionOnSession gets a TaskPlacementExecution and
 * WorkerSession, the task's query is sent to the worker via the session.
 *
 * The function does some bookkeeping such as associating the placement
 * accesses with the connection and updating session's local variables. For
 * details read the comments in the function.
 *
 * The function returns true if the query is successfully sent over the
 * connection, otherwise false.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>StartPlacementExecutionOnSession</name><parameter_list>(<parameter><decl><type><name>TaskPlacementExecution</name> <modifier>*</modifier></type><name>placementExecution</name></decl></parameter>,
								 <parameter><decl><type><name>WorkerSession</name> <modifier>*</modifier></type><name>session</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WorkerPool</name> <modifier>*</modifier></type><name>workerPool</name> <init>= <expr><name><name>session</name><operator>-&gt;</operator><name>workerPool</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DistributedExecution</name> <modifier>*</modifier></type><name>execution</name> <init>= <expr><name><name>workerPool</name><operator>-&gt;</operator><name>distributedExecution</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><name><name>session</name><operator>-&gt;</operator><name>connection</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ShardCommandExecution</name> <modifier>*</modifier></type><name>shardCommandExecution</name> <init>=
		<expr><name><name>placementExecution</name><operator>-&gt;</operator><name>shardCommandExecution</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name> <init>= <expr><name><name>shardCommandExecution</name><operator>-&gt;</operator><name>task</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>taskPlacement</name> <init>= <expr><name><name>placementExecution</name><operator>-&gt;</operator><name>shardPlacement</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>placementAccessList</name> <init>= <expr><call><name>PlacementAccessListForTask</name><argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><name>taskPlacement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>execution</name><operator>-&gt;</operator><name>transactionProperties</name><operator>-&gt;</operator><name>useRemoteTransactionBlocks</name></name> <operator>!=</operator>
		<name>TRANSACTION_BLOCKS_DISALLOWED</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Make sure that subsequent commands on the same placement
		 * use the same connection.
		 */</comment>
		<expr_stmt><expr><call><name>AssignPlacementListToConnection</name><argument_list>(<argument><expr><name>placementAccessList</name></expr></argument>, <argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>session</name><operator>-&gt;</operator><name>commandsSent</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* first time we send a command, consider the connection used (not unused) */</comment>
		<expr_stmt><expr><name><name>workerPool</name><operator>-&gt;</operator><name>unusedConnectionCount</name></name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* connection is going to be in use */</comment>
	<expr_stmt><expr><name><name>workerPool</name><operator>-&gt;</operator><name>idleConnectionCount</name></name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>session</name><operator>-&gt;</operator><name>currentTask</name></name> <operator>=</operator> <name>placementExecution</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>placementExecution</name><operator>-&gt;</operator><name>executionState</name></name> <operator>=</operator> <name>PLACEMENT_EXECUTION_RUNNING</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>INSTR_TIME_IS_ZERO</name><argument_list>(<argument><expr><name><name>placementExecution</name><operator>-&gt;</operator><name>startTime</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The same TaskPlacementExecution can be used to have
	 * call SendNextQuery() several times if queryIndex is
	 * non-zero. Still, all are executed under the current
	 * placementExecution, so we can start the timer right
	 * now.
	 */</comment>
	<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name><name>placementExecution</name><operator>-&gt;</operator><name>startTime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>querySent</name> <init>= <expr><call><name>SendNextQuery</name><argument_list>(<argument><expr><name>placementExecution</name></expr></argument>, <argument><expr><name>session</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>querySent</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>session</name><operator>-&gt;</operator><name>commandsSent</name></name><operator>++</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>workerPool</name><operator>-&gt;</operator><name>poolToLocalNode</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * As we started remote execution to the local node,
			 * we cannot switch back to local execution as that
			 * would cause self-deadlocks and breaking
			 * read-your-own-writes consistency.
			 */</comment>
			<expr_stmt><expr><call><name>SetLocalExecutionStatus</name><argument_list>(<argument><expr><name>LOCAL_EXECUTION_DISABLED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>querySent</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SendNextQuery sends the next query for placementExecution on the given
 * session.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>SendNextQuery</name><parameter_list>(<parameter><decl><type><name>TaskPlacementExecution</name> <modifier>*</modifier></type><name>placementExecution</name></decl></parameter>,
			  <parameter><decl><type><name>WorkerSession</name> <modifier>*</modifier></type><name>session</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WorkerPool</name> <modifier>*</modifier></type><name>workerPool</name> <init>= <expr><name><name>session</name><operator>-&gt;</operator><name>workerPool</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DistributedExecution</name> <modifier>*</modifier></type><name>execution</name> <init>= <expr><name><name>workerPool</name><operator>-&gt;</operator><name>distributedExecution</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><name><name>session</name><operator>-&gt;</operator><name>connection</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ShardCommandExecution</name> <modifier>*</modifier></type><name>shardCommandExecution</name> <init>=
		<expr><name><name>placementExecution</name><operator>-&gt;</operator><name>shardCommandExecution</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>binaryResults</name> <init>= <expr><name><name>shardCommandExecution</name><operator>-&gt;</operator><name>binaryResults</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name> <init>= <expr><name><name>shardCommandExecution</name><operator>-&gt;</operator><name>task</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParamListInfo</name></type> <name>paramListInfo</name> <init>= <expr><name><name>execution</name><operator>-&gt;</operator><name>paramListInfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>querySent</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>queryIndex</name> <init>= <expr><name><name>placementExecution</name><operator>-&gt;</operator><name>queryIndex</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>queryIndex</name> <operator>&lt;</operator> <name><name>task</name><operator>-&gt;</operator><name>queryCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>queryString</name> <init>= <expr><call><name>TaskQueryStringAtIndex</name><argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><name>queryIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>paramListInfo</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>task</name><operator>-&gt;</operator><name>parametersInQueryStringResolved</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>parameterCount</name> <init>= <expr><name><name>paramListInfo</name><operator>-&gt;</operator><name>numParams</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>parameterTypes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>parameterValues</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* force evaluation of bound params */</comment>
		<expr_stmt><expr><name>paramListInfo</name> <operator>=</operator> <call><name>copyParamList</name><argument_list>(<argument><expr><name>paramListInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ExtractParametersForRemoteExecution</name><argument_list>(<argument><expr><name>paramListInfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>parameterTypes</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>parameterValues</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>querySent</name> <operator>=</operator> <call><name>SendRemoteCommandParams</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>parameterCount</name></expr></argument>,
											<argument><expr><name>parameterTypes</name></expr></argument>, <argument><expr><name>parameterValues</name></expr></argument>,
											<argument><expr><name>binaryResults</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * We only need to use SendRemoteCommandParams when we desire
		 * binaryResults. One downside of SendRemoteCommandParams is that it
		 * only supports one query in the query string. In some cases we have
		 * more than one query. In those cases we already make sure before that
		 * binaryResults is false.
		 *
		 * XXX: It also seems that SendRemoteCommandParams does something
		 * strange/incorrectly with select statements. In
		 * isolation_select_vs_all.spec, when doing an s1-router-select in one
		 * session blocked an s2-ddl-create-index-concurrently in another.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>binaryResults</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>querySent</name> <operator>=</operator> <call><name>SendRemoteCommand</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>querySent</name> <operator>=</operator> <call><name>SendRemoteCommandParams</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
												<argument><expr><name>binaryResults</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>querySent</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>connection</name><operator>-&gt;</operator><name>connectionState</name></name> <operator>=</operator> <name>MULTI_CONNECTION_LOST</name></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>singleRowMode</name> <init>= <expr><call><name>PQsetSingleRowMode</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>singleRowMode</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>connection</name><operator>-&gt;</operator><name>connectionState</name></name> <operator>=</operator> <name>MULTI_CONNECTION_LOST</name></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ReceiveResults reads the result of a command or query and writes returned
 * rows to the tuple store of the scan state. It returns whether fetching results
 * were done. On failure, it throws an error.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ReceiveResults</name><parameter_list>(<parameter><decl><type><name>WorkerSession</name> <modifier>*</modifier></type><name>session</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>storeRows</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>fetchDone</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><name><name>session</name><operator>-&gt;</operator><name>connection</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WorkerPool</name> <modifier>*</modifier></type><name>workerPool</name> <init>= <expr><name><name>session</name><operator>-&gt;</operator><name>workerPool</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DistributedExecution</name> <modifier>*</modifier></type><name>execution</name> <init>= <expr><name><name>workerPool</name><operator>-&gt;</operator><name>distributedExecution</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TaskPlacementExecution</name> <modifier>*</modifier></type><name>placementExecution</name> <init>= <expr><name><name>session</name><operator>-&gt;</operator><name>currentTask</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ShardCommandExecution</name> <modifier>*</modifier></type><name>shardCommandExecution</name> <init>=
		<expr><name><name>placementExecution</name><operator>-&gt;</operator><name>shardCommandExecution</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name> <init>= <expr><name><name>placementExecution</name><operator>-&gt;</operator><name>shardCommandExecution</name><operator>-&gt;</operator><name>task</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDestination</name> <modifier>*</modifier></type><name>tupleDest</name> <init>= <expr><ternary><condition><expr><name><name>task</name><operator>-&gt;</operator><name>tupleDest</name></name></expr> ?</condition><then>
								  <expr><name><name>task</name><operator>-&gt;</operator><name>tupleDest</name></name></expr> </then><else>:
								  <expr><name><name>execution</name><operator>-&gt;</operator><name>defaultTupleDest</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We use this context while converting each row fetched from remote node
	 * into tuple. The context is reseted on every row, thus we create it at the
	 * start of the loop and reset on every iteration.
	 */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>rowContext</name> <init>= <expr><call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
													 <argument><expr><literal type="string">"RowContext"</literal></expr></argument>,
													 <argument><expr><name>ALLOCSET_DEFAULT_MINSIZE</name></expr></argument>,
													 <argument><expr><name>ALLOCSET_DEFAULT_INITSIZE</name></expr></argument>,
													 <argument><expr><name>ALLOCSET_DEFAULT_MAXSIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><operator>!</operator><call><name>PQisBusy</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type> <name>columnIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type> <name>rowsProcessed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>PQgetResult</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* no more results, break out of loop and free allocated memory */</comment>
			<expr_stmt><expr><name>fetchDone</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>ExecStatusType</name></type> <name>resultStatus</name> <init>= <expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>resultStatus</name> <operator>==</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>currentAffectedTupleString</name> <init>= <expr><call><name>PQcmdTuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int64</name></type> <name>currentAffectedTupleCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

			<comment type="block">/* if there are multiple replicas, make sure to consider only one */</comment>
			<if_stmt><if>if <condition>(<expr><name>storeRows</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>currentAffectedTupleString</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>currentAffectedTupleCount</name> <operator>=</operator> <call><name>pg_strtoint64</name><argument_list>(<argument><expr><name>currentAffectedTupleString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>currentAffectedTupleCount</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>execution</name><operator>-&gt;</operator><name>rowsProcessed</name></name> <operator>+=</operator> <name>currentAffectedTupleCount</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* task query might contain multiple queries, so fetch until we reach NULL */</comment>
			<expr_stmt><expr><name><name>placementExecution</name><operator>-&gt;</operator><name>queryIndex</name></name><operator>++</operator></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>resultStatus</name> <operator>==</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We've already consumed all the tuples, no more results. Break out
			 * of loop and free allocated memory before returning.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* task query might contain multiple queries, so fetch until we reach NULL */</comment>
			<expr_stmt><expr><name><name>placementExecution</name><operator>-&gt;</operator><name>queryIndex</name></name><operator>++</operator></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>resultStatus</name> <operator>!=</operator> <name>PGRES_SINGLE_TUPLE</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* query failures are always hard errors */</comment>
			<expr_stmt><expr><call><name>ReportResultError</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><name>storeRows</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Already receieved rows from executing on another shard placement or
			 * doesn't need at all (e.g., DDL).
			 */</comment>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>uint32</name></type> <name>queryIndex</name> <init>= <expr><name><name>placementExecution</name><operator>-&gt;</operator><name>queryIndex</name></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>queryIndex</name> <operator>&gt;=</operator> <name><name>task</name><operator>-&gt;</operator><name>queryCount</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected query index while processing"</literal>
								   <literal type="string">" query results"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name> <init>= <expr><call><name><name>tupleDest</name><operator>-&gt;</operator><name>tupleDescForQuery</name></name><argument_list>(<argument><expr><name>tupleDest</name></expr></argument>, <argument><expr><name>queryIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>tupleDescriptor</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>rowsProcessed</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>uint32</name></type> <name>columnCount</name> <init>= <expr><call><name>PQnfields</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type> <name>expectedColumnCount</name> <init>= <expr><name><name>tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>columnCount</name> <operator>!=</operator> <name>expectedColumnCount</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected number of columns from worker: %d, "</literal>
								   <literal type="string">"expected %d"</literal></expr></argument>,
								   <argument><expr><name>columnCount</name></expr></argument>, <argument><expr><name>expectedColumnCount</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>columnCount</name> <operator>&gt;</operator> <name><name>execution</name><operator>-&gt;</operator><name>allocatedColumnCount</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>execution</name><operator>-&gt;</operator><name>columnArray</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>oldColumnCount</name> <init>= <expr><name><name>execution</name><operator>-&gt;</operator><name>allocatedColumnCount</name></name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>execution</name><operator>-&gt;</operator><name>allocatedColumnCount</name></name> <operator>=</operator> <name>columnCount</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>execution</name><operator>-&gt;</operator><name>columnArray</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>execution</name><operator>-&gt;</operator><name>allocatedColumnCount</name></name> <operator>*</operator>
											 <sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>EnableBinaryProtocol</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Using repalloc here, to not throw away any previously
				 * created StringInfos.
				 */</comment>
				<expr_stmt><expr><name><name>execution</name><operator>-&gt;</operator><name>stringInfoDataArray</name></name> <operator>=</operator> <call><name>repalloc</name><argument_list>(
					<argument><expr><name><name>execution</name><operator>-&gt;</operator><name>stringInfoDataArray</name></name></expr></argument>,
					<argument><expr><name><name>execution</name><operator>-&gt;</operator><name>allocatedColumnCount</name></name> <operator>*</operator>
					<sizeof>sizeof<argument_list>(<argument><expr><name>StringInfoData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>oldColumnCount</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>columnCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>execution</name><operator>-&gt;</operator><name>stringInfoDataArray</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></for>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>columnArray</name> <init>= <expr><name><name>execution</name><operator>-&gt;</operator><name>columnArray</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StringInfoData</name> <modifier>*</modifier></type><name>stringInfoDataArray</name> <init>= <expr><name><name>execution</name><operator>-&gt;</operator><name>stringInfoDataArray</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>binaryResults</name> <init>= <expr><name><name>shardCommandExecution</name><operator>-&gt;</operator><name>binaryResults</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * stringInfoDataArray is NULL when EnableBinaryProtocol is false. So
		 * we make sure binaryResults is also false in that case. Otherwise we
		 * cannot store them anywhere.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>EnableBinaryProtocol</name> <operator>||</operator> <operator>!</operator><name>binaryResults</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><decl><type><name>uint32</name></type> <name>rowIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>rowIndex</name> <operator>&lt;</operator> <name>rowsProcessed</name></expr>;</condition> <incr><expr><name>rowIndex</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>uint64</name></type> <name>tupleLibpqSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Switch to a temporary memory context that we reset after each
			 * tuple. This protects us from any memory leaks that might be
			 * present in anything we do to parse a tuple.
			 */</comment>
			<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>rowContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>columnArray</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>columnCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<for>for <control>(<init><expr><name>columnIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>columnIndex</name> <operator>&lt;</operator> <name>columnCount</name></expr>;</condition> <incr><expr><name>columnIndex</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><name>columnIndex</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>columnArray</name><index>[<expr><name>columnIndex</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type> <name>valueLength</name> <init>= <expr><call><name>PQgetlength</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><name>columnIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>value</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><name>columnIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<if_stmt><if>if <condition>(<expr><name>binaryResults</name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><call><name>PQfformat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>columnIndex</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected text result"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
						<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>stringInfoDataArray</name><index>[<expr><name>columnIndex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>stringInfoDataArray</name><index>[<expr><name>columnIndex</name></expr>]</index></name></expr></argument>,
											   <argument><expr><name>value</name></expr></argument>, <argument><expr><name>valueLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>columnArray</name><index>[<expr><name>columnIndex</name></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>stringInfoDataArray</name><index>[<expr><name>columnIndex</name></expr>]</index></name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><call><name>PQfformat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>columnIndex</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected binary result"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
						<expr_stmt><expr><name><name>columnArray</name><index>[<expr><name>columnIndex</name></expr>]</index></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>

					<expr_stmt><expr><name>tupleLibpqSize</name> <operator>+=</operator> <name>valueLength</name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></for>

			<decl_stmt><decl><type><name>AttInMetadata</name> <modifier>*</modifier></type><name>attInMetadata</name> <init>=
				<expr><name><name>shardCommandExecution</name><operator>-&gt;</operator><name>attributeInputMetadata</name><index>[<expr><name>queryIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>HeapTuple</name></type> <name>heapTuple</name></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>binaryResults</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>heapTuple</name> <operator>=</operator> <call><name>BuildTupleFromBytes</name><argument_list>(<argument><expr><name>attInMetadata</name></expr></argument>,
												<argument><expr><operator>(</operator><name>fmStringInfo</name> <operator>*</operator><operator>)</operator> <name>columnArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>heapTuple</name> <operator>=</operator> <call><name>BuildTupleFromCStrings</name><argument_list>(<argument><expr><name>attInMetadata</name></expr></argument>,
												   <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>columnArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name><name>tupleDest</name><operator>-&gt;</operator><name>putTuple</name></name><argument_list>(<argument><expr><name>tupleDest</name></expr></argument>, <argument><expr><name>task</name></expr></argument>,
								<argument><expr><name><name>placementExecution</name><operator>-&gt;</operator><name>placementExecutionIndex</name></name></expr></argument>, <argument><expr><name>queryIndex</name></expr></argument>,
								<argument><expr><name>heapTuple</name></expr></argument>, <argument><expr><name>tupleLibpqSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>rowContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>execution</name><operator>-&gt;</operator><name>rowsProcessed</name></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* the context is local to the function, so not needed anymore */</comment>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>rowContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>fetchDone</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * TupleDescGetAttBinaryInMetadata - Build an AttInMetadata structure based on
 * the supplied TupleDesc. AttInMetadata can be used in conjunction with
 * fmStringInfos containing binary encoded types to produce a properly formed
 * tuple.
 *
 * NOTE: This function is a copy of the PG function TupleDescGetAttInMetadata,
 * except that it uses getTypeBinaryInputInfo instead of getTypeInputInfo.
 */</comment>
<function><type><specifier>static</specifier> <name>AttInMetadata</name> <modifier>*</modifier></type>
<name>TupleDescGetAttBinaryInMetadata</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>natts</name> <init>= <expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>atttypeid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>attinfuncid</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>AttInMetadata</name> <modifier>*</modifier></type><name>attinmeta</name> <init>= <expr><operator>(</operator><name>AttInMetadata</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AttInMetadata</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* "Bless" the tupledesc so that we can make rowtype datums with it */</comment>
	<expr_stmt><expr><name><name>attinmeta</name><operator>-&gt;</operator><name>tupdesc</name></name> <operator>=</operator> <call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Gather info needed later to call the "in" function for each attribute
	 */</comment>
	<decl_stmt><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>attinfuncinfo</name> <init>= <expr><operator>(</operator><name>FmgrInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>attioparams</name> <init>= <expr><operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name> <modifier>*</modifier></type><name>atttypmods</name> <init>= <expr><operator>(</operator><name>int32</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Ignore dropped attributes */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>att</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>atttypeid</name> <operator>=</operator> <name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>getTypeBinaryInputInfo</name><argument_list>(<argument><expr><name>atttypeid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>attinfuncid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>attioparams</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>attinfuncid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>attinfuncinfo</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>atttypmods</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>att</name><operator>-&gt;</operator><name>atttypmod</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>attinmeta</name><operator>-&gt;</operator><name>attinfuncs</name></name> <operator>=</operator> <name>attinfuncinfo</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attinmeta</name><operator>-&gt;</operator><name>attioparams</name></name> <operator>=</operator> <name>attioparams</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attinmeta</name><operator>-&gt;</operator><name>atttypmods</name></name> <operator>=</operator> <name>atttypmods</name></expr>;</expr_stmt>

	<return>return <expr><name>attinmeta</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * BuildTupleFromBytes - build a HeapTuple given user data in binary form.
 * values is an array of StringInfos, one for each attribute of the return
 * tuple. A NULL StringInfo pointer indicates we want to create a NULL field.
 *
 * NOTE: This function is a copy of the PG function BuildTupleFromCStrings,
 * except that it uses ReceiveFunctionCall instead of InputFunctionCall.
 */</comment>
<function><type><specifier>static</specifier> <name>HeapTuple</name></type>
<name>BuildTupleFromBytes</name><parameter_list>(<parameter><decl><type><name>AttInMetadata</name> <modifier>*</modifier></type><name>attinmeta</name></decl></parameter>, <parameter><decl><type><name>fmStringInfo</name> <modifier>*</modifier></type><name>values</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupdesc</name> <init>= <expr><name><name>attinmeta</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>natts</name> <init>= <expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>dvalues</name> <init>= <expr><operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name> <init>= <expr><operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Call the "in" function for each non-dropped attribute, even for nulls,
	 * to support domains.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attisdropped</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Non-dropped attributes */</comment>
			<expr_stmt><expr><name><name>dvalues</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>ReceiveFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>attinmeta</name><operator>-&gt;</operator><name>attinfuncs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
											 <argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
											 <argument><expr><name><name>attinmeta</name><operator>-&gt;</operator><name>attioparams</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
											 <argument><expr><name><name>attinmeta</name><operator>-&gt;</operator><name>atttypmods</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Handle dropped attributes by setting to NULL */</comment>
			<expr_stmt><expr><name><name>dvalues</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Form a tuple
	 */</comment>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name> <init>= <expr><call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>dvalues</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Release locally palloc'd space.  XXX would probably be good to pfree
	 * values of pass-by-reference datums, as well.
	 */</comment>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>dvalues</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>tuple</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * WorkerPoolFailed marks a worker pool and all the placement executions scheduled
 * on it as failed.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>WorkerPoolFailed</name><parameter_list>(<parameter><decl><type><name>WorkerPool</name> <modifier>*</modifier></type><name>workerPool</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>succeeded</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dlist_iter</name></type> <name>iter</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * A pool cannot fail multiple times, the necessary actions
	 * has already be taken, so bail out.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>workerPool</name><operator>-&gt;</operator><name>failureState</name></name> <operator>==</operator> <name>WORKER_POOL_FAILED</name> <operator>||</operator>
		<name><name>workerPool</name><operator>-&gt;</operator><name>failureState</name></name> <operator>==</operator> <name>WORKER_POOL_FAILED_OVER_TO_LOCAL</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;workerPool-&gt;pendingTaskQueue</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TaskPlacementExecution</name> <modifier>*</modifier></type><name>placementExecution</name> <init>=
			<expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>TaskPlacementExecution</name></expr></argument>, <argument><expr><name>workerPendingQueueNode</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>PlacementExecutionDone</name><argument_list>(<argument><expr><name>placementExecution</name></expr></argument>, <argument><expr><name>succeeded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;workerPool-&gt;readyTaskQueue</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TaskPlacementExecution</name> <modifier>*</modifier></type><name>placementExecution</name> <init>=
			<expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>TaskPlacementExecution</name></expr></argument>, <argument><expr><name>workerReadyQueueNode</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>PlacementExecutionDone</name><argument_list>(<argument><expr><name>placementExecution</name></expr></argument>, <argument><expr><name>succeeded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<decl_stmt><decl><type><name>WorkerSession</name> <modifier>*</modifier></type><name>session</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>session</argument>, <argument>workerPool-&gt;sessionList</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>WorkerSessionFailed</name><argument_list>(<argument><expr><name>session</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* we do not want more connections in this pool */</comment>
	<expr_stmt><expr><name><name>workerPool</name><operator>-&gt;</operator><name>readyTaskCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>workerPool</name><operator>-&gt;</operator><name>failureState</name></name> <operator>!=</operator> <name>WORKER_POOL_FAILED_OVER_TO_LOCAL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* we prefer not to override WORKER_POOL_FAILED_OVER_TO_LOCAL */</comment>
		<expr_stmt><expr><name><name>workerPool</name><operator>-&gt;</operator><name>failureState</name></name> <operator>=</operator> <name>WORKER_POOL_FAILED</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * The reason is that when replication factor is &gt; 1 and we are performing
	 * a SELECT, then we only establish connections for the specific placements
	 * that we will read from. However, when a worker pool fails, we will need
	 * to establish multiple new connection to other workers and the query
	 * can only succeed if all those connections are established.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>UseConnectionPerPlacement</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>workerList</name> <init>= <expr><name><name>workerPool</name><operator>-&gt;</operator><name>distributedExecution</name><operator>-&gt;</operator><name>workerList</name></name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>WorkerPool</name> <modifier>*</modifier></type><name>pool</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>pool</argument>, <argument>workerList</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/* failed pools or pools without any connection attempts ignored */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>pool</name><operator>-&gt;</operator><name>failureState</name></name> <operator>==</operator> <name>WORKER_POOL_FAILED</name> <operator>||</operator>
				<call><name>INSTR_TIME_IS_ZERO</name><argument_list>(<argument><expr><name><name>pool</name><operator>-&gt;</operator><name>poolStartTime</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * This should give another NodeConnectionTimeout until all
			 * the necessary connections are established.
			 */</comment>
			<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name><name>pool</name><operator>-&gt;</operator><name>poolStartTime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pool</name><operator>-&gt;</operator><name>checkForPoolTimeout</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * WorkerSessionFailed marks all placement executions scheduled on the
 * connection as failed.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>WorkerSessionFailed</name><parameter_list>(<parameter><decl><type><name>WorkerSession</name> <modifier>*</modifier></type><name>session</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TaskPlacementExecution</name> <modifier>*</modifier></type><name>placementExecution</name> <init>= <expr><name><name>session</name><operator>-&gt;</operator><name>currentTask</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>succeeded</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dlist_iter</name></type> <name>iter</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>placementExecution</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* connection failed while a task was active */</comment>
		<expr_stmt><expr><call><name>PlacementExecutionDone</name><argument_list>(<argument><expr><name>placementExecution</name></expr></argument>, <argument><expr><name>succeeded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;session-&gt;pendingTaskQueue</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>placementExecution</name> <operator>=</operator>
			<call><name>dlist_container</name><argument_list>(<argument><expr><name>TaskPlacementExecution</name></expr></argument>, <argument><expr><name>sessionPendingQueueNode</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PlacementExecutionDone</name><argument_list>(<argument><expr><name>placementExecution</name></expr></argument>, <argument><expr><name>succeeded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;session-&gt;readyTaskQueue</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>placementExecution</name> <operator>=</operator>
			<call><name>dlist_container</name><argument_list>(<argument><expr><name>TaskPlacementExecution</name></expr></argument>, <argument><expr><name>sessionReadyQueueNode</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PlacementExecutionDone</name><argument_list>(<argument><expr><name>placementExecution</name></expr></argument>, <argument><expr><name>succeeded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * PlacementExecutionDone marks the given placement execution as done when
 * the results have been received or a failure occurred and sets the succeeded
 * flag accordingly. It also adds other placement executions of the same
 * task to the appropriate ready queues.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>PlacementExecutionDone</name><parameter_list>(<parameter><decl><type><name>TaskPlacementExecution</name> <modifier>*</modifier></type><name>placementExecution</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>succeeded</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WorkerPool</name> <modifier>*</modifier></type><name>workerPool</name> <init>= <expr><name><name>placementExecution</name><operator>-&gt;</operator><name>workerPool</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DistributedExecution</name> <modifier>*</modifier></type><name>execution</name> <init>= <expr><name><name>workerPool</name><operator>-&gt;</operator><name>distributedExecution</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ShardCommandExecution</name> <modifier>*</modifier></type><name>shardCommandExecution</name> <init>=
		<expr><name><name>placementExecution</name><operator>-&gt;</operator><name>shardCommandExecution</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TaskExecutionState</name></type> <name>executionState</name> <init>= <expr><name><name>shardCommandExecution</name><operator>-&gt;</operator><name>executionState</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>failedPlacementExecutionIsOnPendingQueue</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>placementExecution</name><operator>-&gt;</operator><name>executionState</name></name> <operator>==</operator> <name>PLACEMENT_EXECUTION_FAILED</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We may mark placements as failed multiple times, but should only act
		 * the first time. Nor should we accept success after failure.
		 */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>succeeded</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* mark the placement execution as finished */</comment>
		<expr_stmt><expr><name><name>placementExecution</name><operator>-&gt;</operator><name>executionState</name></name> <operator>=</operator> <name>PLACEMENT_EXECUTION_FINISHED</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>INSTR_TIME_IS_ZERO</name><argument_list>(<argument><expr><name><name>placementExecution</name><operator>-&gt;</operator><name>endTime</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name><name>placementExecution</name><operator>-&gt;</operator><name>endTime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>uint64</name></type> <name>durationMicrosecs</name> <init>=
			<expr><call><name>MicrosecondsBetweenTimestamps</name><argument_list>(<argument><expr><name><name>placementExecution</name><operator>-&gt;</operator><name>startTime</name></name></expr></argument>,
										  <argument><expr><name><name>placementExecution</name><operator>-&gt;</operator><name>endTime</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>workerPool</name><operator>-&gt;</operator><name>totalTaskExecutionTime</name></name> <operator>+=</operator> <name>durationMicrosecs</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>workerPool</name><operator>-&gt;</operator><name>totalExecutedTasks</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsLoggableLevel</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"task execution (%d) for placement (%ld) on anchor "</literal>
									<literal type="string">"shard (%ld) finished in %ld microseconds on worker "</literal>
									<literal type="string">"node %s:%d"</literal></expr></argument>, <argument><expr><name><name>shardCommandExecution</name><operator>-&gt;</operator><name>task</name><operator>-&gt;</operator><name>taskId</name></name></expr></argument>,
									<argument><expr><name><name>placementExecution</name><operator>-&gt;</operator><name>shardPlacement</name><operator>-&gt;</operator><name>placementId</name></name></expr></argument>,
									<argument><expr><name><name>shardCommandExecution</name><operator>-&gt;</operator><name>task</name><operator>-&gt;</operator><name>anchorShardId</name></name></expr></argument>,
									<argument><expr><name>durationMicrosecs</name></expr></argument>, <argument><expr><name><name>workerPool</name><operator>-&gt;</operator><name>nodeName</name></name></expr></argument>,
									<argument><expr><name><name>workerPool</name><operator>-&gt;</operator><name>nodePort</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>CanFailoverPlacementExecutionToLocalExecution</name><argument_list>(<argument><expr><name>placementExecution</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The placement execution can be done over local execution, so it is a soft
		 * failure for now.
		 */</comment>
		<expr_stmt><expr><name><name>placementExecution</name><operator>-&gt;</operator><name>executionState</name></name> <operator>=</operator>
			<name>PLACEMENT_EXECUTION_FAILOVER_TO_LOCAL_EXECUTION</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>placementExecution</name><operator>-&gt;</operator><name>executionState</name></name> <operator>==</operator> <name>PLACEMENT_EXECUTION_NOT_READY</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If the placement is in NOT_READY state, it means that the placement
			 * execution is assigned to the pending queue of a failed pool or
			 * session. So, we should not schedule the next placement execution based
			 * on this failure.
			 */</comment>
			<expr_stmt><expr><name>failedPlacementExecutionIsOnPendingQueue</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>placementExecution</name><operator>-&gt;</operator><name>executionState</name></name> <operator>=</operator> <name>PLACEMENT_EXECUTION_FAILED</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>executionState</name> <operator>!=</operator> <name>TASK_EXECUTION_NOT_FINISHED</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Task execution has already been finished, no need to continue the
		 * next placement.
		 */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Update unfinishedTaskCount only when state changes from not finished to
	 * finished or failed state.
	 */</comment>
	<decl_stmt><decl><type><name>TaskExecutionState</name></type> <name>newExecutionState</name> <init>=
		<expr><call><name>TaskExecutionStateMachine</name><argument_list>(<argument><expr><name>shardCommandExecution</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>newExecutionState</name> <operator>==</operator> <name>TASK_EXECUTION_FINISHED</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>execution</name><operator>-&gt;</operator><name>unfinishedTaskCount</name></name><operator>--</operator></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>newExecutionState</name> <operator>==</operator> <name>TASK_EXECUTION_FAILOVER_TO_LOCAL_EXECUTION</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>execution</name><operator>-&gt;</operator><name>unfinishedTaskCount</name></name><operator>--</operator></expr>;</expr_stmt>

		<comment type="block">/* move the task to the local execution */</comment>
		<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name> <init>= <expr><name><name>shardCommandExecution</name><operator>-&gt;</operator><name>task</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>execution</name><operator>-&gt;</operator><name>localTaskList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>execution</name><operator>-&gt;</operator><name>localTaskList</name></name></expr></argument>, <argument><expr><name>task</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* remove the task from the remote execution list */</comment>
		<expr_stmt><expr><name><name>execution</name><operator>-&gt;</operator><name>remoteTaskList</name></name> <operator>=</operator> <call><name>list_delete_ptr</name><argument_list>(<argument><expr><name><name>execution</name><operator>-&gt;</operator><name>remoteTaskList</name></name></expr></argument>, <argument><expr><name>task</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * As we decided to failover this task to local execution, we cannot
		 * allow remote execution to this pool during this distributedExecution.
		 */</comment>
		<expr_stmt><expr><call><name>SetLocalExecutionStatus</name><argument_list>(<argument><expr><name>LOCAL_EXECUTION_REQUIRED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>workerPool</name><operator>-&gt;</operator><name>failureState</name></name> <operator>=</operator> <name>WORKER_POOL_FAILED_OVER_TO_LOCAL</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Task %d execution is failed over to local execution"</literal></expr></argument>,
								<argument><expr><name><name>task</name><operator>-&gt;</operator><name>taskId</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>newExecutionState</name> <operator>==</operator> <name>TASK_EXECUTION_FAILED</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>execution</name><operator>-&gt;</operator><name>unfinishedTaskCount</name></name><operator>--</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * Even if a single task execution fails, there is no way to
		 * successfully finish the execution.
		 */</comment>
		<expr_stmt><expr><name><name>execution</name><operator>-&gt;</operator><name>failed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name>failedPlacementExecutionIsOnPendingQueue</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ScheduleNextPlacementExecution</name><argument_list>(<argument><expr><name>placementExecution</name></expr></argument>, <argument><expr><name>succeeded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CanFailoverPlacementExecutionToLocalExecution returns true if the input
 * TaskPlacementExecution can be fail overed to local execution. In other words,
 * the execution can be deferred to local execution.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>CanFailoverPlacementExecutionToLocalExecution</name><parameter_list>(<parameter><decl><type><name>TaskPlacementExecution</name> <modifier>*</modifier></type><name>placementExecution</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>EnableLocalExecution</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* the user explicitly disabled local execution */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>placementExecution</name><operator>-&gt;</operator><name>shardCommandExecution</name><operator>-&gt;</operator><name>localExecutionSupported</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* cannot execute given task locally */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>GetCurrentLocalExecutionStatus</name><argument_list>()</argument_list></call> <operator>==</operator> <name>LOCAL_EXECUTION_DISABLED</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If the current transaction accessed the local node over a connection
		 * then we can't use local execution because of visibility issues.
		 */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>WorkerPool</name> <modifier>*</modifier></type><name>workerPool</name> <init>= <expr><name><name>placementExecution</name><operator>-&gt;</operator><name>workerPool</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>workerPool</name><operator>-&gt;</operator><name>poolToLocalNode</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* we can only fail over tasks to local execution for local pools */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>workerPool</name><operator>-&gt;</operator><name>activeConnectionCount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The pool has already active connections, the executor is capable
		 * of using those active connections. So, no need to failover
		 * to the local execution.
		 */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>placementExecution</name><operator>-&gt;</operator><name>assignedSession</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If the placement execution has been assigned to a specific session,
		 * it has to be executed over that session. Otherwise, it would cause
		 * self-deadlocks and break read-your-own-writes consistency.
		 */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ScheduleNextPlacementExecution is triggered if the query needs to be
 * executed on any or all placements in order and there is a placement on
 * which the execution has not happened yet. If so make that placement
 * ready-to-start by adding it to the appropriate queue.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ScheduleNextPlacementExecution</name><parameter_list>(<parameter><decl><type><name>TaskPlacementExecution</name> <modifier>*</modifier></type><name>placementExecution</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>succeeded</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ShardCommandExecution</name> <modifier>*</modifier></type><name>shardCommandExecution</name> <init>=
		<expr><name><name>placementExecution</name><operator>-&gt;</operator><name>shardCommandExecution</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlacementExecutionOrder</name></type> <name>executionOrder</name> <init>= <expr><name><name>shardCommandExecution</name><operator>-&gt;</operator><name>executionOrder</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>executionOrder</name> <operator>==</operator> <name>EXECUTION_ORDER_ANY</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>succeeded</name><operator>)</operator> <operator>||</operator>
		<name>executionOrder</name> <operator>==</operator> <name>EXECUTION_ORDER_SEQUENTIAL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TaskPlacementExecution</name> <modifier>*</modifier></type><name>nextPlacementExecution</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* find a placement execution that is not yet marked as failed */</comment>
		<do>do <block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>nextPlacementExecutionIndex</name> <init>=
				<expr><name><name>placementExecution</name><operator>-&gt;</operator><name>placementExecutionIndex</name></name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * If all tasks failed then we should already have errored out.
			 * Still, be defensive and throw error instead of crashes.
			 */</comment>
			<decl_stmt><decl><type><name>int</name></type> <name>placementExecutionCount</name> <init>= <expr><name><name>shardCommandExecution</name><operator>-&gt;</operator><name>placementExecutionCount</name></name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>nextPlacementExecutionIndex</name> <operator>&gt;=</operator> <name>placementExecutionCount</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>WorkerPool</name> <modifier>*</modifier></type><name>workerPool</name> <init>= <expr><name><name>placementExecution</name><operator>-&gt;</operator><name>workerPool</name></name></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"execution cannot recover from multiple "</literal>
									   <literal type="string">"connection failures. Last node failed "</literal>
									   <literal type="string">"%s:%d"</literal></expr></argument>, <argument><expr><name><name>workerPool</name><operator>-&gt;</operator><name>nodeName</name></name></expr></argument>,
									   <argument><expr><name><name>workerPool</name><operator>-&gt;</operator><name>nodePort</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* get the next placement in the planning order */</comment>
			<expr_stmt><expr><name>nextPlacementExecution</name> <operator>=</operator>
				<name><name>shardCommandExecution</name><operator>-&gt;</operator><name>placementExecutions</name><index>[<expr><name>nextPlacementExecutionIndex</name></expr>]</index></name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>nextPlacementExecution</name><operator>-&gt;</operator><name>executionState</name></name> <operator>==</operator> <name>PLACEMENT_EXECUTION_NOT_READY</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* move the placement execution to the ready queue */</comment>
				<expr_stmt><expr><call><name>PlacementExecutionReady</name><argument_list>(<argument><expr><name>nextPlacementExecution</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block> while <condition>(<expr><name><name>nextPlacementExecution</name><operator>-&gt;</operator><name>executionState</name></name> <operator>==</operator> <name>PLACEMENT_EXECUTION_FAILED</name></expr>)</condition>;</do>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * PlacementExecutionReady adds a placement execution to the ready queue when
 * its dependent placement executions have finished.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>PlacementExecutionReady</name><parameter_list>(<parameter><decl><type><name>TaskPlacementExecution</name> <modifier>*</modifier></type><name>placementExecution</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WorkerPool</name> <modifier>*</modifier></type><name>workerPool</name> <init>= <expr><name><name>placementExecution</name><operator>-&gt;</operator><name>workerPool</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>placementExecution</name><operator>-&gt;</operator><name>assignedSession</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WorkerSession</name> <modifier>*</modifier></type><name>session</name> <init>= <expr><name><name>placementExecution</name><operator>-&gt;</operator><name>assignedSession</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><name><name>session</name><operator>-&gt;</operator><name>connection</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RemoteTransaction</name> <modifier>*</modifier></type><name>transaction</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>connection</name><operator>-&gt;</operator><name>remoteTransaction</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RemoteTransactionState</name></type> <name>transactionState</name> <init>= <expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>placementExecution</name><operator>-&gt;</operator><name>executionState</name></name> <operator>==</operator> <name>PLACEMENT_EXECUTION_NOT_READY</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* remove from not-ready task queue */</comment>
			<expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>placementExecution</name><operator>-&gt;</operator><name>sessionPendingQueueNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* add to ready-to-start task queue */</comment>
			<expr_stmt><expr><call><name>dlist_push_tail</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>session</name><operator>-&gt;</operator><name>readyTaskQueue</name></name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name><name>placementExecution</name><operator>-&gt;</operator><name>sessionReadyQueueNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>transactionState</name> <operator>==</operator> <name>REMOTE_TRANS_NOT_STARTED</name> <operator>||</operator>
			<name>transactionState</name> <operator>==</operator> <name>REMOTE_TRANS_STARTED</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If the connection is idle, wake it up by checking whether
			 * the connection is writeable.
			 */</comment>
			<expr_stmt><expr><call><name>UpdateConnectionWaitFlags</name><argument_list>(<argument><expr><name>session</name></expr></argument>, <argument><expr><name>WL_SOCKET_READABLE</name> <operator>|</operator> <name>WL_SOCKET_WRITEABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>placementExecution</name><operator>-&gt;</operator><name>executionState</name></name> <operator>==</operator> <name>PLACEMENT_EXECUTION_NOT_READY</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* remove from not-ready task queue */</comment>
			<expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>placementExecution</name><operator>-&gt;</operator><name>workerPendingQueueNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* add to ready-to-start task queue */</comment>
			<expr_stmt><expr><call><name>dlist_push_tail</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>workerPool</name><operator>-&gt;</operator><name>readyTaskQueue</name></name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name><name>placementExecution</name><operator>-&gt;</operator><name>workerReadyQueueNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>workerPool</name><operator>-&gt;</operator><name>readyTaskCount</name></name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/* wake up an idle connection by checking whether the connection is writeable */</comment>
		<decl_stmt><decl><type><name>WorkerSession</name> <modifier>*</modifier></type><name>session</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>session</argument>, <argument>workerPool-&gt;sessionList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><name><name>session</name><operator>-&gt;</operator><name>connection</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>RemoteTransaction</name> <modifier>*</modifier></type><name>transaction</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>connection</name><operator>-&gt;</operator><name>remoteTransaction</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>RemoteTransactionState</name></type> <name>transactionState</name> <init>= <expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>transactionState</name> <operator>==</operator> <name>REMOTE_TRANS_NOT_STARTED</name> <operator>||</operator>
				<name>transactionState</name> <operator>==</operator> <name>REMOTE_TRANS_STARTED</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>UpdateConnectionWaitFlags</name><argument_list>(<argument><expr><name>session</name></expr></argument>,
										  <argument><expr><name>WL_SOCKET_READABLE</name> <operator>|</operator> <name>WL_SOCKET_WRITEABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* update the state to ready for further processing */</comment>
	<expr_stmt><expr><name><name>placementExecution</name><operator>-&gt;</operator><name>executionState</name></name> <operator>=</operator> <name>PLACEMENT_EXECUTION_READY</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * TaskExecutionStateMachine returns whether a shard command execution
 * finished or failed according to its execution order. If the task is
 * already finished, simply return the state. Else, calculate the state
 * and return it.
 */</comment>
<function><type><specifier>static</specifier> <name>TaskExecutionState</name></type>
<name>TaskExecutionStateMachine</name><parameter_list>(<parameter><decl><type><name>ShardCommandExecution</name> <modifier>*</modifier></type><name>shardCommandExecution</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlacementExecutionOrder</name></type> <name>executionOrder</name> <init>= <expr><name><name>shardCommandExecution</name><operator>-&gt;</operator><name>executionOrder</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>donePlacementCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>failedPlacementCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>failedOverPlacementCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>placementCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>placementExecutionIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>placementExecutionCount</name> <init>= <expr><name><name>shardCommandExecution</name><operator>-&gt;</operator><name>placementExecutionCount</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TaskExecutionState</name></type> <name>currentTaskExecutionState</name> <init>= <expr><name><name>shardCommandExecution</name><operator>-&gt;</operator><name>executionState</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>currentTaskExecutionState</name> <operator>!=</operator> <name>TASK_EXECUTION_NOT_FINISHED</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* we've already calculated the state, simply return it */</comment>
		<return>return <expr><name>currentTaskExecutionState</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init>;</init> <condition><expr><name>placementExecutionIndex</name> <operator>&lt;</operator> <name>placementExecutionCount</name></expr>;</condition> <incr><expr><name>placementExecutionIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TaskPlacementExecution</name> <modifier>*</modifier></type><name>placementExecution</name> <init>=
			<expr><name><name>shardCommandExecution</name><operator>-&gt;</operator><name>placementExecutions</name><index>[<expr><name>placementExecutionIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TaskPlacementExecutionState</name></type> <name>executionState</name> <init>= <expr><name><name>placementExecution</name><operator>-&gt;</operator><name>executionState</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>executionState</name> <operator>==</operator> <name>PLACEMENT_EXECUTION_FINISHED</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>donePlacementCount</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>executionState</name> <operator>==</operator> <name>PLACEMENT_EXECUTION_FAILED</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>failedPlacementCount</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>executionState</name> <operator>==</operator> <name>PLACEMENT_EXECUTION_FAILOVER_TO_LOCAL_EXECUTION</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>failedOverPlacementCount</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>placementCount</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>failedPlacementCount</name> <operator>==</operator> <name>placementCount</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>currentTaskExecutionState</name> <operator>=</operator> <name>TASK_EXECUTION_FAILED</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>executionOrder</name> <operator>==</operator> <name>EXECUTION_ORDER_ANY</name> <operator>&amp;&amp;</operator> <name>donePlacementCount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>currentTaskExecutionState</name> <operator>=</operator> <name>TASK_EXECUTION_FINISHED</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>donePlacementCount</name> <operator>+</operator> <name>failedPlacementCount</name> <operator>==</operator> <name>placementCount</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>currentTaskExecutionState</name> <operator>=</operator> <name>TASK_EXECUTION_FINISHED</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>failedOverPlacementCount</name> <operator>+</operator> <name>donePlacementCount</name> <operator>+</operator> <name>failedPlacementCount</name> <operator>==</operator>
			 <name>placementCount</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * For any given task, we could have 3 end states:
		 *  - "donePlacementCount" indicates the successful placement executions
		 *  - "failedPlacementCount" indicates the failed placement executions
		 *  - "failedOverPlacementCount" indicates the placement executions that
		 *     are failed when using remote execution due to connection errors,
		 *     but there is still a possibility of being successful via
		 *     local execution. So, for now they are considered as soft
		 *     errors.
		 */</comment>
		<expr_stmt><expr><name>currentTaskExecutionState</name> <operator>=</operator> <name>TASK_EXECUTION_FAILOVER_TO_LOCAL_EXECUTION</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>currentTaskExecutionState</name> <operator>=</operator> <name>TASK_EXECUTION_NOT_FINISHED</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>shardCommandExecution</name><operator>-&gt;</operator><name>executionState</name></name> <operator>=</operator> <name>currentTaskExecutionState</name></expr>;</expr_stmt>

	<return>return <expr><name><name>shardCommandExecution</name><operator>-&gt;</operator><name>executionState</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * BuildWaitEventSet creates a WaitEventSet for the given array of connections
 * which can be used to wait for any of the sockets to become read-ready or
 * write-ready.
 */</comment>
<function><type><specifier>static</specifier> <name>WaitEventSet</name> <modifier>*</modifier></type>
<name>BuildWaitEventSet</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sessionList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* additional 2 is for postmaster and latch */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>eventSetSize</name> <init>= <expr><call><name>GetEventSetSize</name><argument_list>(<argument><expr><name>sessionList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>WaitEventSet</name> <modifier>*</modifier></type><name>waitEventSet</name> <init>=
		<expr><call><name>CreateWaitEventSet</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>, <argument><expr><name>eventSetSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>WorkerSession</name> <modifier>*</modifier></type><name>session</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>session</argument>, <argument>sessionList</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>AddSessionToWaitEventSet</name><argument_list>(<argument><expr><name>session</name></expr></argument>, <argument><expr><name>waitEventSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>CitusAddWaitEventSetToSet</name><argument_list>(<argument><expr><name>waitEventSet</name></expr></argument>, <argument><expr><name>WL_POSTMASTER_DEATH</name></expr></argument>, <argument><expr><name>PGINVALID_SOCKET</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CitusAddWaitEventSetToSet</name><argument_list>(<argument><expr><name>waitEventSet</name></expr></argument>, <argument><expr><name>WL_LATCH_SET</name></expr></argument>, <argument><expr><name>PGINVALID_SOCKET</name></expr></argument>, <argument><expr><name>MyLatch</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>waitEventSet</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AddSessionToWaitEventSet is a helper function which adds the session to
 * the waitEventSet. The function does certain checks before adding the session
 * to the waitEventSet.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AddSessionToWaitEventSet</name><parameter_list>(<parameter><decl><type><name>WorkerSession</name> <modifier>*</modifier></type><name>session</name></decl></parameter>, <parameter><decl><type><name>WaitEventSet</name> <modifier>*</modifier></type><name>waitEventSet</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><name><name>session</name><operator>-&gt;</operator><name>connection</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* connection died earlier in the transaction */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>connection</name><operator>-&gt;</operator><name>waitFlags</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* not currently waiting for this connection */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>sock</name> <init>= <expr><call><name>PQsocket</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>sock</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* connection was closed */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>waitEventSetIndex</name> <init>=
		<expr><call><name>CitusAddWaitEventSetToSet</name><argument_list>(<argument><expr><name>waitEventSet</name></expr></argument>, <argument><expr><name><name>connection</name><operator>-&gt;</operator><name>waitFlags</name></name></expr></argument>, <argument><expr><name>sock</name></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>session</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>session</name><operator>-&gt;</operator><name>waitEventSetIndex</name></name> <operator>=</operator> <name>waitEventSetIndex</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Inform failed to add to wait event set with a debug message as this
	 * is too detailed information for users.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>session</name><operator>-&gt;</operator><name>waitEventSetIndex</name></name> <operator>==</operator> <name>WAIT_EVENT_SET_INDEX_FAILED</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Adding wait event for node %s:%d failed. "</literal>
								<literal type="string">"The socket was: %d"</literal></expr></argument>,
								<argument><expr><name><name>session</name><operator>-&gt;</operator><name>workerPool</name><operator>-&gt;</operator><name>nodeName</name></name></expr></argument>,
								<argument><expr><name><name>session</name><operator>-&gt;</operator><name>workerPool</name><operator>-&gt;</operator><name>nodePort</name></name></expr></argument>, <argument><expr><name>sock</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * GetEventSetSize returns the event set size for a list of sessions.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>GetEventSetSize</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sessionList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* additional 2 is for postmaster and latch */</comment>
	<return>return <expr><call><name>list_length</name><argument_list>(<argument><expr><name>sessionList</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RebuildWaitEventSetFlags modifies the given waitEventSet with the wait flags
 * for connections in the sessionList.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RebuildWaitEventSetFlags</name><parameter_list>(<parameter><decl><type><name>WaitEventSet</name> <modifier>*</modifier></type><name>waitEventSet</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sessionList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WorkerSession</name> <modifier>*</modifier></type><name>session</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>session</argument>, <argument>sessionList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><name><name>session</name><operator>-&gt;</operator><name>connection</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>waitEventSetIndex</name> <init>= <expr><name><name>session</name><operator>-&gt;</operator><name>waitEventSetIndex</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* connection died earlier in the transaction */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>connection</name><operator>-&gt;</operator><name>waitFlags</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* not currently waiting for this connection */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>int</name></type> <name>sock</name> <init>= <expr><call><name>PQsocket</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>sock</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* connection was closed */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>bool</name></type> <name>success</name> <init>=
			<expr><call><name>CitusModifyWaitEvent</name><argument_list>(<argument><expr><name>waitEventSet</name></expr></argument>, <argument><expr><name>waitEventSetIndex</name></expr></argument>,
								 <argument><expr><name><name>connection</name><operator>-&gt;</operator><name>waitFlags</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"modifying wait event for node %s:%d failed. "</literal>
									<literal type="string">"The wait event index was: %d"</literal></expr></argument>,
									<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>, <argument><expr><name><name>connection</name><operator>-&gt;</operator><name>port</name></name></expr></argument>,
									<argument><expr><name>waitEventSetIndex</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>session</name><operator>-&gt;</operator><name>waitEventSetIndex</name></name> <operator>=</operator> <name>WAIT_EVENT_SET_INDEX_FAILED</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * SetLocalForceMaxQueryParallelization is simply a C interface for setting
 * the following:
 *      SET LOCAL citus.force_max_query_parallelization TO on;
 */</comment>
<function><type><name>void</name></type>
<name>SetLocalForceMaxQueryParallelization</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>set_config_option</name><argument_list>(<argument><expr><literal type="string">"citus.force_max_query_parallelization"</literal></expr></argument>, <argument><expr><literal type="string">"on"</literal></expr></argument>,
					  <argument><expr><operator>(</operator><ternary><condition><expr><call><name>superuser</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name>PGC_SUSET</name></expr> </then><else>: <expr><name>PGC_USERSET</name></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><name>PGC_S_SESSION</name></expr></argument>,
					  <argument><expr><name>GUC_ACTION_LOCAL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ExtractParametersForRemoteExecution extracts parameter types and values from
 * the given ParamListInfo structure, and fills parameter type and value arrays.
 * It changes oid of custom types to InvalidOid so that they are the same in workers
 * and coordinators.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExtractParametersForRemoteExecution</name><parameter_list>(<parameter><decl><type><name>ParamListInfo</name></type> <name>paramListInfo</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier><modifier>*</modifier></type><name>parameterTypes</name></decl></parameter>,
									<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>parameterValues</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ExtractParametersFromParamList</name><argument_list>(<argument><expr><name>paramListInfo</name></expr></argument>, <argument><expr><name>parameterTypes</name></expr></argument>,
								   <argument><expr><name>parameterValues</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ExtractParametersFromParamList extracts parameter types and values from
 * the given ParamListInfo structure, and fills parameter type and value arrays.
 * If useOriginalCustomTypeOids is true, it uses the original oids for custom types.
 */</comment>
<function><type><name>void</name></type>
<name>ExtractParametersFromParamList</name><parameter_list>(<parameter><decl><type><name>ParamListInfo</name></type> <name>paramListInfo</name></decl></parameter>,
							   <parameter><decl><type><name>Oid</name> <modifier>*</modifier><modifier>*</modifier></type><name>parameterTypes</name></decl></parameter>,
							   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>parameterValues</name></decl></parameter>, <parameter><decl><type><name>bool</name></type>
							   <name>useOriginalCustomTypeOids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>parameterCount</name> <init>= <expr><name><name>paramListInfo</name><operator>-&gt;</operator><name>numParams</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>parameterTypes</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>parameterCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>parameterValues</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>parameterCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* get parameter types and values */</comment>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>parameterIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>parameterIndex</name> <operator>&lt;</operator> <name>parameterCount</name></expr>;</condition> <incr><expr><name>parameterIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ParamExternData</name> <modifier>*</modifier></type><name>parameterData</name> <init>= <expr><operator>&amp;</operator><name><name>paramListInfo</name><operator>-&gt;</operator><name>params</name><index>[<expr><name>parameterIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>typeOutputFunctionId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>variableLengthType</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Use 0 for data types where the oid values can be different on
		 * the coordinator and worker nodes. Therefore, the worker nodes can
		 * infer the correct oid.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>parameterData</name><operator>-&gt;</operator><name>ptype</name></name> <operator>&gt;=</operator> <name>FirstNormalObjectId</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>useOriginalCustomTypeOids</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>(</operator><operator>*</operator><name>parameterTypes</name><operator>)</operator><index>[<expr><name>parameterIndex</name></expr>]</index> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><operator>(</operator><operator>*</operator><name>parameterTypes</name><operator>)</operator><index>[<expr><name>parameterIndex</name></expr>]</index> <operator>=</operator> <name><name>parameterData</name><operator>-&gt;</operator><name>ptype</name></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * If the parameter is not referenced / used (ptype == 0) and
		 * would otherwise have errored out inside standard_planner()),
		 * don't pass a value to the remote side, and pass text oid to prevent
		 * undetermined data type errors on workers.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>parameterData</name><operator>-&gt;</operator><name>ptype</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>(</operator><operator>*</operator><name>parameterValues</name><operator>)</operator><index>[<expr><name>parameterIndex</name></expr>]</index> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>(</operator><operator>*</operator><name>parameterTypes</name><operator>)</operator><index>[<expr><name>parameterIndex</name></expr>]</index> <operator>=</operator> <name>TEXTOID</name></expr>;</expr_stmt>

			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If the parameter is NULL then we preserve its type, but
		 * don't need to evaluate its value.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>parameterData</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>(</operator><operator>*</operator><name>parameterValues</name><operator>)</operator><index>[<expr><name>parameterIndex</name></expr>]</index> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name><name>parameterData</name><operator>-&gt;</operator><name>ptype</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typeOutputFunctionId</name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>variableLengthType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>(</operator><operator>*</operator><name>parameterValues</name><operator>)</operator><index>[<expr><name>parameterIndex</name></expr>]</index> <operator>=</operator> <call><name>OidOutputFunctionCall</name><argument_list>(<argument><expr><name>typeOutputFunctionId</name></expr></argument>,
																   <argument><expr><name><name>parameterData</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>
</unit>
