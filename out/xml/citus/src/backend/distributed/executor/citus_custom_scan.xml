<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/builded_projects/citus/src/backend/distributed/executor/citus_custom_scan.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * citus_custom_scan.c
 *
 * Definitions of custom scan methods for all executor types.
 *
 * Copyright (c) Citus Data, Inc.
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_version_constants.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/copy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/backend_data.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_custom_scan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_nodefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_ruleutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/connection_management.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/deparse_shard_query.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/distributed_execution_locks.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/insert_select_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/insert_select_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/local_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/local_plan_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_server_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_router_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/query_stats.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shard_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/subplan_execution.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_log_messages.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/colocation_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/function_call_delegation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>


<decl_stmt><decl><type><specifier>extern</specifier> <name>AllowedDistributionColumn</name></type> <name>AllowedDistributionColumnValue</name></decl>;</decl_stmt>

<comment type="block">/* functions for creating custom scan nodes */</comment>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type> <name>AdaptiveExecutorCreateScan</name><parameter_list>(<parameter><decl><type><name>CustomScan</name> <modifier>*</modifier></type><name>scan</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type> <name>NonPushableInsertSelectCreateScan</name><parameter_list>(<parameter><decl><type><name>CustomScan</name> <modifier>*</modifier></type><name>scan</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type> <name>DelayedErrorCreateScan</name><parameter_list>(<parameter><decl><type><name>CustomScan</name> <modifier>*</modifier></type><name>scan</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* functions that are common to different scans */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CitusBeginScan</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CitusBeginReadOnlyScan</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CitusBeginModifyScan</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CitusPreExecScan</name><parameter_list>(<parameter><decl><type><name>CitusScanState</name> <modifier>*</modifier></type><name>scanState</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ModifyJobNeedsEvaluation</name><parameter_list>(<parameter><decl><type><name>Job</name> <modifier>*</modifier></type><name>workerJob</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RegenerateTaskForFasthPathQuery</name><parameter_list>(<parameter><decl><type><name>Job</name> <modifier>*</modifier></type><name>workerJob</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RegenerateTaskListForInsert</name><parameter_list>(<parameter><decl><type><name>Job</name> <modifier>*</modifier></type><name>workerJob</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>DistributedPlan</name> <modifier>*</modifier></type> <name>CopyDistributedPlanWithoutCache</name><parameter_list>(
	<parameter><decl><type><name>DistributedPlan</name> <modifier>*</modifier></type><name>originalDistributedPlan</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CitusEndScan</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CitusReScan</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SetJobColocationId</name><parameter_list>(<parameter><decl><type><name>Job</name> <modifier>*</modifier></type><name>job</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>EnsureForceDelegationDistributionKey</name><parameter_list>(<parameter><decl><type><name>Job</name> <modifier>*</modifier></type><name>job</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>EnsureAnchorShardsInJobExist</name><parameter_list>(<parameter><decl><type><name>Job</name> <modifier>*</modifier></type><name>job</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>AnchorShardsInTaskListExist</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>TryToRerouteFastPathModifyQuery</name><parameter_list>(<parameter><decl><type><name>Job</name> <modifier>*</modifier></type><name>job</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/* create custom scan methods for all executors */</comment>
<decl_stmt><decl><type><name>CustomScanMethods</name></type> <name>AdaptiveExecutorCustomScanMethods</name> <init>= <expr><block>{
	<expr><literal type="string">"Citus Adaptive"</literal></expr>,
	<expr><name>AdaptiveExecutorCreateScan</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>CustomScanMethods</name></type> <name>NonPushableInsertSelectCustomScanMethods</name> <init>= <expr><block>{
	<expr><literal type="string">"Citus INSERT ... SELECT"</literal></expr>,
	<expr><name>NonPushableInsertSelectCreateScan</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>CustomScanMethods</name></type> <name>DelayedErrorCustomScanMethods</name> <init>= <expr><block>{
	<expr><literal type="string">"Citus Delayed Error"</literal></expr>,
	<expr><name>DelayedErrorCreateScan</name></expr>
}</block></expr></init></decl>;</decl_stmt>


<comment type="block">/*
 * Define executor methods for the different executor types.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>CustomExecMethods</name></type> <name>AdaptiveExecutorCustomExecMethods</name> <init>= <expr><block>{
	<expr><operator>.</operator><name>CustomName</name> <operator>=</operator> <literal type="string">"AdaptiveExecutorScan"</literal></expr>,
	<expr><operator>.</operator><name>BeginCustomScan</name> <operator>=</operator> <name>CitusBeginScan</name></expr>,
	<expr><operator>.</operator><name>ExecCustomScan</name> <operator>=</operator> <name>CitusExecScan</name></expr>,
	<expr><operator>.</operator><name>EndCustomScan</name> <operator>=</operator> <name>CitusEndScan</name></expr>,
	<expr><operator>.</operator><name>ReScanCustomScan</name> <operator>=</operator> <name>CitusReScan</name></expr>,
	<expr><operator>.</operator><name>ExplainCustomScan</name> <operator>=</operator> <name>CitusExplainScan</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>CustomExecMethods</name></type> <name>NonPushableInsertSelectCustomExecMethods</name> <init>= <expr><block>{
	<expr><operator>.</operator><name>CustomName</name> <operator>=</operator> <literal type="string">"NonPushableInsertSelectScan"</literal></expr>,
	<expr><operator>.</operator><name>BeginCustomScan</name> <operator>=</operator> <name>CitusBeginScan</name></expr>,
	<expr><operator>.</operator><name>ExecCustomScan</name> <operator>=</operator> <name>NonPushableInsertSelectExecScan</name></expr>,
	<expr><operator>.</operator><name>EndCustomScan</name> <operator>=</operator> <name>CitusEndScan</name></expr>,
	<expr><operator>.</operator><name>ReScanCustomScan</name> <operator>=</operator> <name>CitusReScan</name></expr>,
	<expr><operator>.</operator><name>ExplainCustomScan</name> <operator>=</operator> <name>NonPushableInsertSelectExplainScan</name></expr>
}</block></expr></init></decl>;</decl_stmt>


<comment type="block">/*
 * IsCitusCustomState returns if a given PlanState node is a CitusCustomState node.
 */</comment>
<function><type><name>bool</name></type>
<name>IsCitusCustomState</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planState</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>planState</name></expr></argument>, <argument><expr><name>CustomScanState</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>css</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>CustomScanState</name></expr></argument>, <argument><expr><name>planState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>css</name><operator>-&gt;</operator><name>methods</name></name> <operator>==</operator> <operator>&amp;</operator><name>AdaptiveExecutorCustomExecMethods</name> <operator>||</operator>
		<name><name>css</name><operator>-&gt;</operator><name>methods</name></name> <operator>==</operator> <operator>&amp;</operator><name>NonPushableInsertSelectCustomExecMethods</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Let PostgreSQL know about Citus' custom scan nodes.
 */</comment>
<function><type><name>void</name></type>
<name>RegisterCitusCustomScanMethods</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>RegisterCustomScanMethods</name><argument_list>(<argument><expr><operator>&amp;</operator><name>AdaptiveExecutorCustomScanMethods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RegisterCustomScanMethods</name><argument_list>(<argument><expr><operator>&amp;</operator><name>NonPushableInsertSelectCustomScanMethods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RegisterCustomScanMethods</name><argument_list>(<argument><expr><operator>&amp;</operator><name>DelayedErrorCustomScanMethods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CitusBeginScan sets the coordinator backend initiated by Citus for queries using
 * that function as the BeginCustomScan callback.
 *
 * The function also handles deferred shard pruning along with function evaluations.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CitusBeginScan</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CitusScanState</name> <modifier>*</modifier></type><name>scanState</name> <init>= <expr><operator>(</operator><name>CitusScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Make sure we can see notices during regular queries, which would typically
	 * be the result of a function that raises a notices being called.
	 */</comment>
	<expr_stmt><expr><call><name>EnableWorkerMessagePropagation</name><argument_list>()</argument_list></call></expr>;</expr_stmt>


	<comment type="block">/*
	 * Since we are using a tuplestore we cannot use the virtual tuples postgres had
	 * already setup on the CustomScan. Instead we need to reinitialize the tuples as
	 * minimal.
	 *
	 * During initialization postgres also created the projection information and the
	 * quals, but both are 'compiled' to be executed on virtual tuples. Since we replaced
	 * the tuples with minimal tuples we also compile both the projection and the quals
	 * on to these 'new' tuples.
	 */</comment>
	<expr_stmt><expr><call><name>ExecInitResultSlot</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanState</name><operator>-&gt;</operator><name>customScanState</name><operator>.</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TTSOpsMinimalTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecInitScanTupleSlot</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>ss</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>scandesc</name></name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>TTSOpsMinimalTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecAssignScanProjectionInfoWithVarno</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>ss</name></name></expr></argument>, <argument><expr><name>INDEX_VAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>qual</name></name> <operator>=</operator> <call><name>ExecInitQual</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>, <argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>DistributedPlan</name> <modifier>*</modifier></type><name>distributedPlan</name> <init>= <expr><name><name>scanState</name><operator>-&gt;</operator><name>distributedPlan</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>insertSelectQuery</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * INSERT..SELECT via coordinator or re-partitioning are special because
		 * the SELECT part is planned separately.
		 */</comment>
		<return>return;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>modLevel</name></name> <operator>==</operator> <name>ROW_MODIFY_READONLY</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CitusBeginReadOnlyScan</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>CitusBeginModifyScan</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>


	<comment type="block">/*
	 * If there is force_delgation functions' distribution argument set,
	 * enforce it
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>AllowedDistributionColumnValue</name><operator>.</operator><name>isActive</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Job</name> <modifier>*</modifier></type><name>workerJob</name> <init>= <expr><name><name>scanState</name><operator>-&gt;</operator><name>distributedPlan</name><operator>-&gt;</operator><name>workerJob</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>EnsureForceDelegationDistributionKey</name><argument_list>(<argument><expr><name>workerJob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * In case of a prepared statement, we will see this distributed plan again
	 * on the next execution with a higher usage counter.
	 */</comment>
	<expr_stmt><expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>numberOfTimesExecuted</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CitusPreExecScan is called right before postgres' executor starts pulling tuples.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CitusPreExecScan</name><parameter_list>(<parameter><decl><type><name>CitusScanState</name> <modifier>*</modifier></type><name>scanState</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>AdaptiveExecutorPreExecutorRun</name><argument_list>(<argument><expr><name>scanState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CitusExecScan is called when a tuple is pulled from a custom scan.
 * On the first call, it executes the distributed query and writes the
 * results to a tuple store. The postgres executor calls this function
 * repeatedly to read tuples from the tuple store.
 */</comment>
<function><type><name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>CitusExecScan</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CitusScanState</name> <modifier>*</modifier></type><name>scanState</name> <init>= <expr><operator>(</operator><name>CitusScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>scanState</name><operator>-&gt;</operator><name>finishedRemoteScan</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>AdaptiveExecutor</name><argument_list>(<argument><expr><name>scanState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>scanState</name><operator>-&gt;</operator><name>finishedRemoteScan</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>ReturnTupleFromTuplestore</name><argument_list>(<argument><expr><name>scanState</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CitusBeginReadOnlyScan handles deferred pruning and plan caching for SELECTs.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CitusBeginReadOnlyScan</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CitusScanState</name> <modifier>*</modifier></type><name>scanState</name> <init>= <expr><operator>(</operator><name>CitusScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DistributedPlan</name> <modifier>*</modifier></type><name>originalDistributedPlan</name> <init>= <expr><name><name>scanState</name><operator>-&gt;</operator><name>distributedPlan</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>originalDistributedPlan</name><operator>-&gt;</operator><name>workerJob</name><operator>-&gt;</operator><name>jobQuery</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>originalDistributedPlan</name><operator>-&gt;</operator><name>workerJob</name><operator>-&gt;</operator><name>deferredPruning</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * For SELECT queries that have already been pruned we can proceed straight
		 * to execution, since none of the prepared statement logic applies.
		 */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Create a copy of the generic plan for the current execution, but make a shallow
	 * copy of the plan cache. That means we'll be able to access the plan cache via
	 * currentPlan-&gt;workerJob-&gt;localPlannedStatements, but it will be preserved across
	 * executions by the prepared statement logic.
	 */</comment>
	<decl_stmt><decl><type><name>DistributedPlan</name> <modifier>*</modifier></type><name>currentPlan</name> <init>=
		<expr><call><name>CopyDistributedPlanWithoutCache</name><argument_list>(<argument><expr><name>originalDistributedPlan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>scanState</name><operator>-&gt;</operator><name>distributedPlan</name></name> <operator>=</operator> <name>currentPlan</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Job</name> <modifier>*</modifier></type><name>workerJob</name> <init>= <expr><name><name>currentPlan</name><operator>-&gt;</operator><name>workerJob</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>jobQuery</name> <init>= <expr><name><name>workerJob</name><operator>-&gt;</operator><name>jobQuery</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planState</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>scanState</name><operator>-&gt;</operator><name>customScanState</name><operator>.</operator><name>ss</name><operator>.</operator><name>ps</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We only do deferred pruning for fast path queries, which have a single
	 * partition column value.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>currentPlan</name><operator>-&gt;</operator><name>fastPathRouterPlan</name></name> <operator>||</operator> <operator>!</operator><name>EnableFastPathRouterPlanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Evaluate parameters, because the parameters are only available on the
	 * coordinator and are required for pruning.
	 *
	 * We don't evaluate functions for read-only queries on the coordinator
	 * at the moment. Most function calls would be in a context where they
	 * should be re-evaluated for every row in case of volatile functions.
	 *
	 * TODO: evaluate stable functions
	 */</comment>
	<expr_stmt><expr><call><name>ExecuteCoordinatorEvaluableExpressions</name><argument_list>(<argument><expr><name>jobQuery</name></expr></argument>, <argument><expr><name>planState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* job query no longer has parameters, so we should not send any */</comment>
	<expr_stmt><expr><name><name>workerJob</name><operator>-&gt;</operator><name>parametersInJobQueryResolved</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/* parameters are filled in, so we can generate a task for this execution */</comment>
	<expr_stmt><expr><call><name>RegenerateTaskForFasthPathQuery</name><argument_list>(<argument><expr><name>workerJob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsLocalPlanCachingSupported</name><argument_list>(<argument><expr><name>workerJob</name></expr></argument>, <argument><expr><name>originalDistributedPlan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>workerJob</name><operator>-&gt;</operator><name>taskList</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * We are going to execute this task locally. If it's not already in
		 * the cache, create a local plan now and add it to the cache. During
		 * execution, we will get the plan from the cache.
		 *
		 * The plan will be cached across executions when originalDistributedPlan
		 * represents a prepared statement.
		 */</comment>
		<expr_stmt><expr><call><name>CacheLocalPlanForShardQuery</name><argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><name>originalDistributedPlan</name></expr></argument>,
									<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_param_list_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CitusBeginModifyScan prepares the scan state for a modification.
 *
 * Modifications are special because:
 * a) we evaluate function calls (e.g. nextval) here and the outcome may
 *    determine which shards are affected by this query.
 * b) we need to take metadata locks to make sure no write is left behind
 *    when finalizing a shard move.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CitusBeginModifyScan</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CitusScanState</name> <modifier>*</modifier></type><name>scanState</name> <init>= <expr><operator>(</operator><name>CitusScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planState</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>scanState</name><operator>-&gt;</operator><name>customScanState</name><operator>.</operator><name>ss</name><operator>.</operator><name>ps</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DistributedPlan</name> <modifier>*</modifier></type><name>originalDistributedPlan</name> <init>= <expr><name><name>scanState</name><operator>-&gt;</operator><name>distributedPlan</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>localContext</name> <init>= <expr><call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
													   <argument><expr><literal type="string">"CitusBeginModifyScan"</literal></expr></argument>,
													   <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>localContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>DistributedPlan</name> <modifier>*</modifier></type><name>currentPlan</name> <init>=
		<expr><call><name>CopyDistributedPlanWithoutCache</name><argument_list>(<argument><expr><name>originalDistributedPlan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>scanState</name><operator>-&gt;</operator><name>distributedPlan</name></name> <operator>=</operator> <name>currentPlan</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Job</name> <modifier>*</modifier></type><name>workerJob</name> <init>= <expr><name><name>currentPlan</name><operator>-&gt;</operator><name>workerJob</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>jobQuery</name> <init>= <expr><name><name>workerJob</name><operator>-&gt;</operator><name>jobQuery</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ModifyJobNeedsEvaluation</name><argument_list>(<argument><expr><name>workerJob</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecuteCoordinatorEvaluableExpressions</name><argument_list>(<argument><expr><name>jobQuery</name></expr></argument>, <argument><expr><name>planState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* job query no longer has parameters, so we should not send any */</comment>
		<expr_stmt><expr><name><name>workerJob</name><operator>-&gt;</operator><name>parametersInJobQueryResolved</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>workerJob</name><operator>-&gt;</operator><name>deferredPruning</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * At this point, we're about to do the shard pruning for fast-path queries.
		 * Given that pruning is deferred always for INSERTs, we get here
		 * !EnableFastPathRouterPlanner  as well. Given that INSERT statements with
		 * CTEs/sublinks etc are not eligible for fast-path router plan, we get here
		 * jobQuery-&gt;commandType == CMD_INSERT as well.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>currentPlan</name><operator>-&gt;</operator><name>fastPathRouterPlan</name></name> <operator>||</operator> <operator>!</operator><name>EnableFastPathRouterPlanner</name> <operator>||</operator>
			   <name><name>jobQuery</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_INSERT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We can only now decide which shard to use, so we need to build a new task
		 * list.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>jobQuery</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_INSERT</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>RegenerateTaskListForInsert</name><argument_list>(<argument><expr><name>workerJob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>RegenerateTaskForFasthPathQuery</name><argument_list>(<argument><expr><name>workerJob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>workerJob</name><operator>-&gt;</operator><name>requiresCoordinatorEvaluation</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * When there is no deferred pruning, but we did evaluate functions, then
		 * we only rebuild the query strings in the existing tasks.
		 */</comment>
		<expr_stmt><expr><call><name>RebuildQueryStrings</name><argument_list>(<argument><expr><name>workerJob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>


	<comment type="block">/* We skip shard related things if the job contains only local tables */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ModifyLocalTableJob</name><argument_list>(<argument><expr><name>workerJob</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Now that we know the shard ID(s) we can acquire the necessary shard metadata
		 * locks. Once we have the locks it's safe to load the placement metadata.
		 */</comment>

		<comment type="block">/* prevent concurrent placement changes */</comment>
		<expr_stmt><expr><call><name>AcquireMetadataLocks</name><argument_list>(<argument><expr><name><name>workerJob</name><operator>-&gt;</operator><name>taskList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * In case of a split, the shard might no longer be available. In that
		 * case try to reroute. We can only do this for fast path queries.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>currentPlan</name><operator>-&gt;</operator><name>fastPathRouterPlan</name></name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>AnchorShardsInTaskListExist</name><argument_list>(<argument><expr><name><name>workerJob</name><operator>-&gt;</operator><name>taskList</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>TryToRerouteFastPathModifyQuery</name><argument_list>(<argument><expr><name>workerJob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* ensure there is no invalid shard */</comment>
		<expr_stmt><expr><call><name>EnsureAnchorShardsInJobExist</name><argument_list>(<argument><expr><name>workerJob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* modify tasks are always assigned using first-replica policy */</comment>
		<expr_stmt><expr><name><name>workerJob</name><operator>-&gt;</operator><name>taskList</name></name> <operator>=</operator> <call><name>FirstReplicaAssignTaskList</name><argument_list>(<argument><expr><name><name>workerJob</name><operator>-&gt;</operator><name>taskList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>


	<comment type="block">/*
	 * Now that we have populated the task placements we can determine whether
	 * any of them are local to this node and cache a plan if needed.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsLocalPlanCachingSupported</name><argument_list>(<argument><expr><name>workerJob</name></expr></argument>, <argument><expr><name>originalDistributedPlan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>workerJob</name><operator>-&gt;</operator><name>taskList</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * We are going to execute this task locally. If it's not already in
		 * the cache, create a local plan now and add it to the cache. During
		 * execution, we will get the plan from the cache.
		 *
		 * WARNING: In this function we'll use the original plan with the original
		 * query tree, meaning parameters and function calls are back and we'll
		 * redo evaluation in the local (Postgres) executor. The reason we do this
		 * is that we only need to cache one generic plan per shard.
		 *
		 * The plan will be cached across executions when originalDistributedPlan
		 * represents a prepared statement.
		 */</comment>
		<expr_stmt><expr><call><name>CacheLocalPlanForShardQuery</name><argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><name>originalDistributedPlan</name></expr></argument>,
									<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_param_list_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * TryToRerouteFastPathModifyQuery tries to reroute non-existent shards in given job if it finds any such shard,
 * only for fastpath queries.
 *
 * Should only be called if the job belongs to a fastpath modify query
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>TryToRerouteFastPathModifyQuery</name><parameter_list>(<parameter><decl><type><name>Job</name> <modifier>*</modifier></type><name>job</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>job</name><operator>-&gt;</operator><name>jobQuery</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_INSERT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>RegenerateTaskListForInsert</name><argument_list>(<argument><expr><name>job</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>RegenerateTaskForFasthPathQuery</name><argument_list>(<argument><expr><name>job</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RebuildQueryStrings</name><argument_list>(<argument><expr><name>job</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * EnsureAnchorShardsInJobExist ensures all shards are valid in job.
 * If it finds a non-existent shard in given job, it throws an error.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>EnsureAnchorShardsInJobExist</name><parameter_list>(<parameter><decl><type><name>Job</name> <modifier>*</modifier></type><name>job</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AnchorShardsInTaskListExist</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>taskList</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_T_R_SERIALIZATION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"shard for the given value does not exist"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(
							<argument><expr><literal type="string">"A concurrent shard split may have moved the data into a new set of shards."</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Retry the query."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * AnchorShardsInTaskListExist checks whether all the anchor shards in the task list
 * still exist.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>AnchorShardsInTaskListExist</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>task</argument>, <argument>taskList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ShardExists</name><argument_list>(<argument><expr><name><name>task</name><operator>-&gt;</operator><name>anchorShardId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ModifyJobNeedsEvaluation checks whether the functions and parameters in the job query
 * need to be evaluated before we can build task query strings.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ModifyJobNeedsEvaluation</name><parameter_list>(<parameter><decl><type><name>Job</name> <modifier>*</modifier></type><name>workerJob</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>workerJob</name><operator>-&gt;</operator><name>requiresCoordinatorEvaluation</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* query contains functions that need to be evaluated on the coordinator */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>workerJob</name><operator>-&gt;</operator><name>partitionKeyValue</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* the value of the distribution column is already known */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* pruning was deferred due to a parameter in the partition column */</comment>
	<return>return <expr><name><name>workerJob</name><operator>-&gt;</operator><name>deferredPruning</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CopyDistributedPlanWithoutCache is a helper function which copies the
 * distributedPlan into the current memory context.
 *
 * We must not change the distributed plan since it may be reused across multiple
 * executions of a prepared statement. Instead we create a deep copy that we only
 * use for the current execution.
 *
 * We also exclude localPlannedStatements from the copyObject call for performance
 * reasons, as they are immutable, so no need to have a deep copy.
 */</comment>
<function><type><specifier>static</specifier> <name>DistributedPlan</name> <modifier>*</modifier></type>
<name>CopyDistributedPlanWithoutCache</name><parameter_list>(<parameter><decl><type><name>DistributedPlan</name> <modifier>*</modifier></type><name>originalDistributedPlan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>localPlannedStatements</name> <init>=
		<expr><name><name>originalDistributedPlan</name><operator>-&gt;</operator><name>workerJob</name><operator>-&gt;</operator><name>localPlannedStatements</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>originalDistributedPlan</name><operator>-&gt;</operator><name>workerJob</name><operator>-&gt;</operator><name>localPlannedStatements</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>DistributedPlan</name> <modifier>*</modifier></type><name>distributedPlan</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>originalDistributedPlan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* set back the immutable field */</comment>
	<expr_stmt><expr><name><name>originalDistributedPlan</name><operator>-&gt;</operator><name>workerJob</name><operator>-&gt;</operator><name>localPlannedStatements</name></name> <operator>=</operator> <name>localPlannedStatements</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>workerJob</name><operator>-&gt;</operator><name>localPlannedStatements</name></name> <operator>=</operator> <name>localPlannedStatements</name></expr>;</expr_stmt>

	<return>return <expr><name>distributedPlan</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RegenerateTaskListForInsert does the shard pruning for an INSERT query
 * queries and rebuilds the query strings.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RegenerateTaskListForInsert</name><parameter_list>(<parameter><decl><type><name>Job</name> <modifier>*</modifier></type><name>workerJob</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>jobQuery</name> <init>= <expr><name><name>workerJob</name><operator>-&gt;</operator><name>jobQuery</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>parametersInJobQueryResolved</name> <init>= <expr><name><name>workerJob</name><operator>-&gt;</operator><name>parametersInJobQueryResolved</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DeferredErrorMessage</name> <modifier>*</modifier></type><name>planningError</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* need to perform shard pruning, rebuild the task list from scratch */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name> <init>= <expr><call><name>RouterInsertTaskList</name><argument_list>(<argument><expr><name>jobQuery</name></expr></argument>, <argument><expr><name>parametersInJobQueryResolved</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>planningError</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>planningError</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>RaiseDeferredError</name><argument_list>(<argument><expr><name>planningError</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>workerJob</name><operator>-&gt;</operator><name>taskList</name></name> <operator>=</operator> <name>taskList</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>workerJob</name><operator>-&gt;</operator><name>partitionKeyValue</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If we were not able to determine the partition key value in the planner,
		 * take another shot now. It may still be NULL in case of a multi-row
		 * insert.
		 */</comment>
		<expr_stmt><expr><name><name>workerJob</name><operator>-&gt;</operator><name>partitionKeyValue</name></name> <operator>=</operator> <call><name>ExtractInsertPartitionKeyValue</name><argument_list>(<argument><expr><name>jobQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>RebuildQueryStrings</name><argument_list>(<argument><expr><name>workerJob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * RegenerateTaskForFasthPathQuery does the shard pruning for
 * UPDATE/DELETE/SELECT fast path router queries and rebuilds the query strings.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RegenerateTaskForFasthPathQuery</name><parameter_list>(<parameter><decl><type><name>Job</name> <modifier>*</modifier></type><name>workerJob</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>isMultiShardQuery</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardIntervalList</name> <init>=
		<expr><call><name>TargetShardIntervalForFastPathQuery</name><argument_list>(<argument><expr><name><name>workerJob</name><operator>-&gt;</operator><name>jobQuery</name></name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>isMultiShardQuery</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name><name>workerJob</name><operator>-&gt;</operator><name>partitionKeyValue</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * A fast-path router query can only yield multiple shards when the parameter
	 * cannot be resolved properly, which can be triggered by SQL function.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>isMultiShardQuery</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot perform distributed planning on this "</literal>
							   <literal type="string">"query because parameterized queries for SQL "</literal>
							   <literal type="string">"functions referencing distributed tables are "</literal>
							   <literal type="string">"not supported"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Consider using PL/pgSQL functions instead."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>shardsPresent</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>relationShardList</name> <init>=
		<expr><call><name>RelationShardListForShardIntervalList</name><argument_list>(<argument><expr><name>shardIntervalList</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shardsPresent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>UpdateRelationToShardNames</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>workerJob</name><operator>-&gt;</operator><name>jobQuery</name></name></expr></argument>, <argument><expr><name>relationShardList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* fast path queries cannot have local tables */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>hasLocalRelation</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>placementList</name> <init>=
		<expr><call><name>CreateTaskPlacementListForShardIntervals</name><argument_list>(<argument><expr><name>shardIntervalList</name></expr></argument>, <argument><expr><name>shardsPresent</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
												 <argument><expr><name>hasLocalRelation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>shardId</name> <init>= <expr><name>INVALID_SHARD_ID</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>shardsPresent</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>shardId</name> <operator>=</operator> <call><name>GetAnchorShardId</name><argument_list>(<argument><expr><name>shardIntervalList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>isLocalTableModification</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>GenerateSingleShardRouterTaskList</name><argument_list>(<argument><expr><name>workerJob</name></expr></argument>,
									  <argument><expr><name>relationShardList</name></expr></argument>,
									  <argument><expr><name>placementList</name></expr></argument>,
									  <argument><expr><name>shardId</name></expr></argument>,
									  <argument><expr><name>isLocalTableModification</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * AdaptiveExecutorCreateScan creates the scan state for the adaptive executor.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>AdaptiveExecutorCreateScan</name><parameter_list>(<parameter><decl><type><name>CustomScan</name> <modifier>*</modifier></type><name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CitusScanState</name> <modifier>*</modifier></type><name>scanState</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CitusScanState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>scanState</name><operator>-&gt;</operator><name>executorType</name></name> <operator>=</operator> <name>MULTI_EXECUTOR_ADAPTIVE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanState</name><operator>-&gt;</operator><name>customScanState</name><operator>.</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_CustomScanState</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanState</name><operator>-&gt;</operator><name>distributedPlan</name></name> <operator>=</operator> <call><name>GetDistributedPlan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>scanState</name><operator>-&gt;</operator><name>customScanState</name><operator>.</operator><name>methods</name></name> <operator>=</operator> <operator>&amp;</operator><name>AdaptiveExecutorCustomExecMethods</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanState</name><operator>-&gt;</operator><name>PreExecScan</name></name> <operator>=</operator> <operator>&amp;</operator><name>CitusPreExecScan</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>scanState</name><operator>-&gt;</operator><name>finishedPreScan</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanState</name><operator>-&gt;</operator><name>finishedRemoteScan</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>scanState</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * NonPushableInsertSelectCrateScan creates the scan state for executing
 * INSERT..SELECT into a distributed table via the coordinator.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>NonPushableInsertSelectCreateScan</name><parameter_list>(<parameter><decl><type><name>CustomScan</name> <modifier>*</modifier></type><name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CitusScanState</name> <modifier>*</modifier></type><name>scanState</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CitusScanState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>scanState</name><operator>-&gt;</operator><name>executorType</name></name> <operator>=</operator> <name>MULTI_EXECUTOR_NON_PUSHABLE_INSERT_SELECT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanState</name><operator>-&gt;</operator><name>customScanState</name><operator>.</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_CustomScanState</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanState</name><operator>-&gt;</operator><name>distributedPlan</name></name> <operator>=</operator> <call><name>GetDistributedPlan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>scanState</name><operator>-&gt;</operator><name>customScanState</name><operator>.</operator><name>methods</name></name> <operator>=</operator>
		<operator>&amp;</operator><name>NonPushableInsertSelectCustomExecMethods</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>scanState</name><operator>-&gt;</operator><name>finishedPreScan</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanState</name><operator>-&gt;</operator><name>finishedRemoteScan</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>scanState</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DelayedErrorCreateScan is only called if we could not plan for the given
 * query. This is the case when a plan is not ready for execution because
 * CreateDistributedPlan() couldn't find a plan due to unresolved prepared
 * statement parameters, but didn't error out, because we expect custom plans
 * to come to our rescue. But sql (not plpgsql) functions unfortunately don't
 * go through a codepath supporting custom plans. Here, we error out with this
 * delayed error message.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>DelayedErrorCreateScan</name><parameter_list>(<parameter><decl><type><name>CustomScan</name> <modifier>*</modifier></type><name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DistributedPlan</name> <modifier>*</modifier></type><name>distributedPlan</name> <init>= <expr><call><name>GetDistributedPlan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* raise the deferred error */</comment>
	<expr_stmt><expr><call><name>RaiseDeferredError</name><argument_list>(<argument><expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>planningError</name></name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CitusEndScan is used to clean up tuple store of the given custom scan state.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CitusEndScan</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CitusScanState</name> <modifier>*</modifier></type><name>scanState</name> <init>= <expr><operator>(</operator><name>CitusScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Job</name> <modifier>*</modifier></type><name>workerJob</name> <init>= <expr><name><name>scanState</name><operator>-&gt;</operator><name>distributedPlan</name><operator>-&gt;</operator><name>workerJob</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>queryId</name> <init>= <expr><name><name>scanState</name><operator>-&gt;</operator><name>distributedPlan</name><operator>-&gt;</operator><name>queryId</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiExecutorType</name></type> <name>executorType</name> <init>= <expr><name><name>scanState</name><operator>-&gt;</operator><name>executorType</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>partitionKeyConst</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>partitionKeyString</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* stop propagating notices */</comment>
	<expr_stmt><expr><call><name>DisableWorkerMessagePropagation</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check whether we received warnings that should not have been
	 * ignored.
	 */</comment>
	<expr_stmt><expr><call><name>ErrorIfWorkerErrorIndicationReceived</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>workerJob</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>partitionKeyConst</name> <operator>=</operator> <name><name>workerJob</name><operator>-&gt;</operator><name>partitionKeyValue</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * queryId is not set if pg_stat_statements is not installed,
	 * it can be set with as of pg14: set compute_query_id to on;
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>queryId</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>partitionKeyConst</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>executorType</name> <operator>==</operator> <name>MULTI_EXECUTOR_ADAPTIVE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>partitionKeyString</name> <operator>=</operator> <call><name>DatumToString</name><argument_list>(<argument><expr><name><name>partitionKeyConst</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>,
											   <argument><expr><name><name>partitionKeyConst</name><operator>-&gt;</operator><name>consttype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* queries without partition key are also recorded */</comment>
		<expr_stmt><expr><call><name>CitusQueryStatsExecutorsEntry</name><argument_list>(<argument><expr><name>queryId</name></expr></argument>, <argument><expr><name>executorType</name></expr></argument>, <argument><expr><name>partitionKeyString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>scanState</name><operator>-&gt;</operator><name>tuplestorestate</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>tuplestore_end</name><argument_list>(<argument><expr><name><name>scanState</name><operator>-&gt;</operator><name>tuplestorestate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scanState</name><operator>-&gt;</operator><name>tuplestorestate</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CitusReScan is not normally called, except in certain cases of
 * DECLARE .. CURSOR WITH HOLD ..
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CitusReScan</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content> </block_content>}</block></function>


<comment type="block">/*
 * ScanStateGetTupleDescriptor returns the tuple descriptor for the given
 * scan state.
 */</comment>
<function><type><name>TupleDesc</name></type>
<name>ScanStateGetTupleDescriptor</name><parameter_list>(<parameter><decl><type><name>CitusScanState</name> <modifier>*</modifier></type><name>scanState</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>scanState</name><operator>-&gt;</operator><name>customScanState</name><operator>.</operator><name>ss</name><operator>.</operator><name>ss_ScanTupleSlot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ScanStateGetExecutorState returns the executor state for the given scan
 * state.
 */</comment>
<function><type><name>EState</name> <modifier>*</modifier></type>
<name>ScanStateGetExecutorState</name><parameter_list>(<parameter><decl><type><name>CitusScanState</name> <modifier>*</modifier></type><name>scanState</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>scanState</name><operator>-&gt;</operator><name>customScanState</name><operator>.</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FetchCitusCustomScanIfExists traverses a given plan and returns a Citus CustomScan
 * if it has any.
 */</comment>
<function><type><name>CustomScan</name> <modifier>*</modifier></type>
<name>FetchCitusCustomScanIfExists</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>plan</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsCitusCustomScan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><operator>(</operator><name>CustomScan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>CustomScan</name> <modifier>*</modifier></type><name>customScan</name> <init>= <expr><call><name>FetchCitusCustomScanIfExists</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>customScan</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>customScan</name> <operator>=</operator> <call><name>FetchCitusCustomScanIfExists</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>customScan</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsCitusPlan returns whether a Plan contains a CustomScan generated by Citus
 * by recursively walking through the plan tree.
 */</comment>
<function><type><name>bool</name></type>
<name>IsCitusPlan</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>plan</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsCitusCustomScan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>IsCitusPlan</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IsCitusPlan</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsCitusCustomScan returns whether Plan node is a CustomScan generated by Citus.
 */</comment>
<function><type><name>bool</name></type>
<name>IsCitusCustomScan</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>plan</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>CustomScan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>CustomScan</name> <modifier>*</modifier></type><name>customScan</name> <init>= <expr><operator>(</operator><name>CustomScan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>customScan</name><operator>-&gt;</operator><name>custom_private</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>privateNode</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>customScan</name><operator>-&gt;</operator><name>custom_private</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CitusIsA</name><argument_list>(<argument><expr><name>privateNode</name></expr></argument>, <argument><expr><name>DistributedPlan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * In a Job, given a list of relations, if all them belong to the same
 * colocation group, the Job's colocation ID is set to the group ID, else,
 * it will be set to INVALID_COLOCATION_ID.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SetJobColocationId</name><parameter_list>(<parameter><decl><type><name>Job</name> <modifier>*</modifier></type><name>job</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>jobColocationId</name> <init>= <expr><name>INVALID_COLOCATION_ID</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>job</name><operator>-&gt;</operator><name>partitionKeyValue</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* if the Job has no shard key, nothing to do */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name> <init>= <expr><call><name>ExtractRangeTableEntryList</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>jobQuery</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>rangeTableCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach</name><argument_list>(<argument>rangeTableCell</argument>, <argument>rangeTableList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>rangeTableCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* ignore the non distributed table */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>uint32</name></type> <name>colocationId</name> <init>= <expr><call><name>TableColocationId</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>jobColocationId</name> <operator>==</operator> <name>INVALID_COLOCATION_ID</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Initialize the ID */</comment>
			<expr_stmt><expr><name>jobColocationId</name> <operator>=</operator> <name>colocationId</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>jobColocationId</name> <operator>!=</operator> <name>colocationId</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Tables' colocationId is not the same */</comment>
			<expr_stmt><expr><name>jobColocationId</name> <operator>=</operator> <name>INVALID_COLOCATION_ID</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name><name>job</name><operator>-&gt;</operator><name>colocationId</name></name> <operator>=</operator> <name>jobColocationId</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Any function with force_delegate flag(true) must ensure that the Job's
 * partition key match with the functions' distribution argument.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>EnsureForceDelegationDistributionKey</name><parameter_list>(<parameter><decl><type><name>Job</name> <modifier>*</modifier></type><name>job</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* If the Job has the subquery, punt the shard-key-check to the subquery */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>job</name><operator>-&gt;</operator><name>subqueryPushdown</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the query doesn't have shard key, nothing to check, only exception is when
	 * the query doesn't have distributed tables but an RTE with intermediate_results
	 * function (a subquery plan).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>job</name><operator>-&gt;</operator><name>partitionKeyValue</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>queryContainsDistributedTable</name> <init>=
			<expr><call><name>FindNodeMatchingCheckFunction</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>job</name><operator>-&gt;</operator><name>jobQuery</name></name></expr></argument>, <argument><expr><name>IsDistributedTableRTE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>queryContainsDistributedTable</name></expr>)</condition>
		<block>{<block_content>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* We should match both the key and the colocation ID */</comment>
	<expr_stmt><expr><call><name>SetJobColocationId</name><argument_list>(<argument><expr><name>job</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsShardKeyValueAllowed</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>partitionKeyValue</name></name></expr></argument>, <argument><expr><name><name>job</name><operator>-&gt;</operator><name>colocationId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(
							<argument><expr><literal type="string">"queries must filter by the distribution argument in the same "</literal>
							<literal type="string">"colocation group when using the forced function pushdown"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(
							<argument><expr><literal type="string">"consider disabling forced delegation through "</literal>
							<literal type="string">"create_distributed_table(..., force_delegation := false)"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
</unit>
