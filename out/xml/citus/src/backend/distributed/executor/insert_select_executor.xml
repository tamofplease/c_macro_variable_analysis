<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/citus/src/backend/distributed/executor/insert_select_executor.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * insert_select_executor.c
 *
 * Executor logic for INSERT..SELECT.
 *
 * Copyright (c) Citus Data, Inc.
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_ruleutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands/multi_copy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/adaptive_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/deparse_shard_query.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/distributed_execution_locks.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/insert_select_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/insert_select_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/intermediate_results.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/local_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_partitioning_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_physical_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_router_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/local_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/distributed_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/recursive_planning.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/relation_access_tracking.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/resource_lock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shardinterval_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/subplan_execution.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/transaction_management.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/version_compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/execnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/parsenodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/plannodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_coerce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/pquery.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/portal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>

<comment type="block">/* Config variables managed via guc.c */</comment>
<decl_stmt><decl><type><name>bool</name></type> <name>EnableRepartitionedInsertSelect</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>


<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>TwoPhaseInsertSelectTaskList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>targetRelationId</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>insertSelectQuery</name></decl></parameter>,
										   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>resultIdPrefix</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecutePlanIntoRelation</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>targetRelationId</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>insertTargetList</name></decl></parameter>,
									<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>selectPlan</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>executorState</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type> <name>ExecutePlanIntoColocatedIntermediateResults</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>targetRelationId</name></decl></parameter>,
														  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>insertTargetList</name></decl></parameter>,
														  <parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>selectPlan</name></decl></parameter>,
														  <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>executorState</name></decl></parameter>,
														  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>intermediateResultIdPrefix</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>BuildColumnNameListFromTargetList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>targetRelationId</name></decl></parameter>,
												<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>insertTargetList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>PartitionColumnIndexFromColumnList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>columnNameList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>RedistributedInsertSelectTaskList</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>insertSelectQuery</name></decl></parameter>,
												<parameter><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>targetRelation</name></decl></parameter>,
												<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>redistributedResults</name></decl></parameter>,
												<parameter><decl><type><name>bool</name></type> <name>useBinaryFormat</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>PartitionColumnIndex</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>insertTargetList</name></decl></parameter>, <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>partitionColumn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WrapTaskListForProjection</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>projectedTargetEntries</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * NonPushableInsertSelectExecScan executes an INSERT INTO distributed_table
 * SELECT .. query either by routing via coordinator or by repartitioning
 * task results and moving data directly between nodes.
 */</comment>
<function><type><name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>NonPushableInsertSelectExecScan</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CitusScanState</name> <modifier>*</modifier></type><name>scanState</name> <init>= <expr><operator>(</operator><name>CitusScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>scanState</name><operator>-&gt;</operator><name>finishedRemoteScan</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>EState</name> <modifier>*</modifier></type><name>executorState</name> <init>= <expr><call><name>ScanStateGetExecutorState</name><argument_list>(<argument><expr><name>scanState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DistributedPlan</name> <modifier>*</modifier></type><name>distributedPlan</name> <init>= <expr><name><name>scanState</name><operator>-&gt;</operator><name>distributedPlan</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>insertSelectQuery</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>insertSelectQuery</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>insertTargetList</name> <init>= <expr><name><name>insertSelectQuery</name><operator>-&gt;</operator><name>targetList</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>selectRte</name> <init>= <expr><call><name>ExtractSelectRangeTableEntry</name><argument_list>(<argument><expr><name>insertSelectQuery</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>insertRte</name> <init>= <expr><call><name>ExtractResultRelationRTE</name><argument_list>(<argument><expr><name>insertSelectQuery</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>targetRelationId</name> <init>= <expr><name><name>insertRte</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>intermediateResultIdPrefix</name> <init>= <expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>intermediateResultIdPrefix</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>hasReturning</name> <init>= <expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>expectResults</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>shardStateHash</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>selectQuery</name> <init>= <expr><name><name>selectRte</name><operator>-&gt;</operator><name>subquery</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>selectPlan</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>selectPlanForInsertSelect</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If we are dealing with partitioned table, we also need to lock its
		 * partitions. Here we only lock targetRelation, we acquire necessary
		 * locks on selected tables during execution of those select queries.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PartitionedTable</name><argument_list>(<argument><expr><name>targetRelationId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LockPartitionRelations</name><argument_list>(<argument><expr><name>targetRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>insertSelectMethod</name></name> <operator>==</operator> <name>INSERT_SELECT_REPARTITION</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"performing repartitioned INSERT ... SELECT"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<decl_stmt><decl><type><name>DistributedPlan</name> <modifier>*</modifier></type><name>distSelectPlan</name> <init>=
				<expr><call><name>GetDistributedPlan</name><argument_list>(<argument><expr><operator>(</operator><name>CustomScan</name> <operator>*</operator><operator>)</operator> <name><name>selectPlan</name><operator>-&gt;</operator><name>planTree</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Job</name> <modifier>*</modifier></type><name>distSelectJob</name> <init>= <expr><name><name>distSelectPlan</name><operator>-&gt;</operator><name>workerJob</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>distSelectTaskList</name> <init>= <expr><name><name>distSelectJob</name><operator>-&gt;</operator><name>taskList</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>randomAccess</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>interTransactions</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>binaryFormat</name> <init>=
				<expr><call><name>CanUseBinaryCopyFormatForTargetList</name><argument_list>(<argument><expr><name><name>selectQuery</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>ExecuteSubPlans</name><argument_list>(<argument><expr><name>distSelectPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * We have a separate directory for each transaction, so choosing
			 * the same result prefix won't cause filename conflicts. Results
			 * directory name also includes node id and database id, so we don't
			 * need to include them in the filename. We include job id here for
			 * the case "INSERT/SELECTs" are executed recursively.
			 */</comment>
			<decl_stmt><decl><type><name>StringInfo</name></type> <name>distResultPrefixString</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>distResultPrefixString</name></expr></argument>,
							 <argument><expr><literal type="string">"repartitioned_results_"</literal> <name>UINT64_FORMAT</name></expr></argument>,
							 <argument><expr><name><name>distSelectJob</name><operator>-&gt;</operator><name>jobId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>distResultPrefix</name> <init>= <expr><name><name>distResultPrefixString</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>targetRelation</name> <init>=
				<expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name>targetRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>int</name></type> <name>partitionColumnIndex</name> <init>=
				<expr><call><name>PartitionColumnIndex</name><argument_list>(<argument><expr><name>insertTargetList</name></expr></argument>, <argument><expr><name><name>targetRelation</name><operator>-&gt;</operator><name>partitionColumn</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>partitionColumnIndex</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>targetRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type> <name>schemaOid</name> <init>= <expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>targetRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>schemaName</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>schemaOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errmsg</name><argument_list>(
									<argument><expr><literal type="string">"the partition column of table %s should have a value"</literal></expr></argument>,
									<argument><expr><call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>,
															   <argument><expr><name>relationName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>selectPartitionTE</name> <init>= <expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>selectQuery</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
													  <argument><expr><name>partitionColumnIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>partitionColumnName</name> <init>= <expr><ternary><condition><expr><name><name>selectPartitionTE</name><operator>-&gt;</operator><name>resname</name></name></expr> ?</condition><then>
											  <expr><name><name>selectPartitionTE</name><operator>-&gt;</operator><name>resname</name></name></expr> </then><else>: <expr><literal type="string">"(none)"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
								 <argument><expr><literal type="string">"partitioning SELECT query by column index %d with name %s"</literal></expr></argument>,
								 <argument><expr><name>partitionColumnIndex</name></expr></argument>, <argument><expr><call><name>quote_literal_cstr</name><argument_list>(
									 <argument><expr><name>partitionColumnName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * ExpandWorkerTargetEntry() can add additional columns to the worker
			 * query. Modify the task queries to only select columns we need.
			 */</comment>
			<decl_stmt><decl><type><name>int</name></type> <name>requiredColumnCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>insertTargetList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>jobTargetList</name> <init>= <expr><name><name>distSelectJob</name><operator>-&gt;</operator><name>jobQuery</name><operator>-&gt;</operator><name>targetList</name></name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>jobTargetList</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>requiredColumnCount</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>projectedTargetEntries</name> <init>= <expr><call><name>ListTake</name><argument_list>(<argument><expr><name>jobTargetList</name></expr></argument>,
														<argument><expr><name>requiredColumnCount</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>WrapTaskListForProjection</name><argument_list>(<argument><expr><name>distSelectTaskList</name></expr></argument>, <argument><expr><name>projectedTargetEntries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>redistributedResults</name> <init>= <expr><call><name>RedistributeTaskListResults</name><argument_list>(<argument><expr><name>distResultPrefix</name></expr></argument>,
																	  <argument><expr><name>distSelectTaskList</name></expr></argument>,
																	  <argument><expr><name>partitionColumnIndex</name></expr></argument>,
																	  <argument><expr><name>targetRelation</name></expr></argument>,
																	  <argument><expr><name>binaryFormat</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * At this point select query has been executed on workers and results
			 * have been fetched in such a way that they are colocated with corresponding
			 * target shard. Create and execute a list of tasks of form
			 * INSERT INTO ... SELECT * FROM read_intermediate_results(...);
			 */</comment>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name> <init>= <expr><call><name>RedistributedInsertSelectTaskList</name><argument_list>(<argument><expr><name>insertSelectQuery</name></expr></argument>,
															   <argument><expr><name>targetRelation</name></expr></argument>,
															   <argument><expr><name>redistributedResults</name></expr></argument>,
															   <argument><expr><name>binaryFormat</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>scanState</name><operator>-&gt;</operator><name>tuplestorestate</name></name> <operator>=</operator>
				<call><name>tuplestore_begin_heap</name><argument_list>(<argument><expr><name>randomAccess</name></expr></argument>, <argument><expr><name>interTransactions</name></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name> <init>= <expr><call><name>ScanStateGetTupleDescriptor</name><argument_list>(<argument><expr><name>scanState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TupleDestination</name> <modifier>*</modifier></type><name>tupleDest</name> <init>= <expr><call><name>CreateTupleStoreTupleDest</name><argument_list>(
				<argument><expr><name><name>scanState</name><operator>-&gt;</operator><name>tuplestorestate</name></name></expr></argument>, <argument><expr><name>tupleDescriptor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>uint64</name></type> <name>rowsInserted</name> <init>= <expr><call><name>ExecuteTaskListIntoTupleDest</name><argument_list>(<argument><expr><name>ROW_MODIFY_COMMUTATIVE</name></expr></argument>,
															   <argument><expr><name>taskList</name></expr></argument>, <argument><expr><name>tupleDest</name></expr></argument>,
															   <argument><expr><name>hasReturning</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>executorState</name><operator>-&gt;</operator><name>es_processed</name></name> <operator>=</operator> <name>rowsInserted</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>SortReturning</name> <operator>&amp;&amp;</operator> <name>hasReturning</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>SortTupleStore</name><argument_list>(<argument><expr><name>scanState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>insertSelectQuery</name><operator>-&gt;</operator><name>onConflict</name></name> <operator>||</operator> <name>hasReturning</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
								 <argument><expr><literal type="string">"Collecting INSERT ... SELECT results on coordinator"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If we also have a workerJob that means there is a second step
			 * to the INSERT...SELECT. This happens when there is a RETURNING
			 * or ON CONFLICT clause which is implemented as a separate
			 * distributed INSERT...SELECT from a set of intermediate results
			 * to the target relation.
			 */</comment>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>prunedTaskList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>shardStateHash</name> <operator>=</operator> <call><name>ExecutePlanIntoColocatedIntermediateResults</name><argument_list>(
				<argument><expr><name>targetRelationId</name></expr></argument>,
				<argument><expr><name>insertTargetList</name></expr></argument>,
				<argument><expr><name>selectPlan</name></expr></argument>,
				<argument><expr><name>executorState</name></expr></argument>,
				<argument><expr><name>intermediateResultIdPrefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* generate tasks for the INSERT..SELECT phase */</comment>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name> <init>= <expr><call><name>TwoPhaseInsertSelectTaskList</name><argument_list>(<argument><expr><name>targetRelationId</name></expr></argument>,
														  <argument><expr><name>insertSelectQuery</name></expr></argument>,
														  <argument><expr><name>intermediateResultIdPrefix</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * We cannot actually execute INSERT...SELECT tasks that read from
			 * intermediate results that weren't created because no rows were
			 * written to them. Prune those tasks out by only including tasks
			 * on shards with connections.
			 */</comment>
			<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<macro><name>foreach_ptr</name><argument_list>(<argument>task</argument>, <argument>taskList</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>uint64</name></type> <name>shardId</name> <init>= <expr><name><name>task</name><operator>-&gt;</operator><name>anchorShardId</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type> <name>shardModified</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name>shardStateHash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shardId</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shardModified</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>shardModified</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>prunedTaskList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>prunedTaskList</name></expr></argument>, <argument><expr><name>task</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>

			<if_stmt><if>if <condition>(<expr><name>prunedTaskList</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>bool</name></type> <name>randomAccess</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type> <name>interTransactions</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>scanState</name><operator>-&gt;</operator><name>tuplestorestate</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scanState</name><operator>-&gt;</operator><name>tuplestorestate</name></name> <operator>=</operator>
					<call><name>tuplestore_begin_heap</name><argument_list>(<argument><expr><name>randomAccess</name></expr></argument>, <argument><expr><name>interTransactions</name></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name> <init>= <expr><call><name>ScanStateGetTupleDescriptor</name><argument_list>(<argument><expr><name>scanState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>TupleDestination</name> <modifier>*</modifier></type><name>tupleDest</name> <init>= <expr><call><name>CreateTupleStoreTupleDest</name><argument_list>(
					<argument><expr><name><name>scanState</name><operator>-&gt;</operator><name>tuplestorestate</name></name></expr></argument>, <argument><expr><name>tupleDescriptor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>ExecuteTaskListIntoTupleDest</name><argument_list>(<argument><expr><name>ROW_MODIFY_COMMUTATIVE</name></expr></argument>, <argument><expr><name>prunedTaskList</name></expr></argument>,
											 <argument><expr><name>tupleDest</name></expr></argument>, <argument><expr><name>hasReturning</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>SortReturning</name> <operator>&amp;&amp;</operator> <name>hasReturning</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>SortTupleStore</name><argument_list>(<argument><expr><name>scanState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
								 <argument><expr><literal type="string">"Collecting INSERT ... SELECT results on coordinator"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ExecutePlanIntoRelation</name><argument_list>(<argument><expr><name>targetRelationId</name></expr></argument>, <argument><expr><name>insertTargetList</name></expr></argument>, <argument><expr><name>selectPlan</name></expr></argument>,
									<argument><expr><name>executorState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name><name>scanState</name><operator>-&gt;</operator><name>finishedRemoteScan</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>resultSlot</name> <init>= <expr><call><name>ReturnTupleFromTuplestore</name><argument_list>(<argument><expr><name>scanState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>resultSlot</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * TwoPhaseInsertSelectTaskList generates a list of tasks for a query that
 * inserts into a target relation and selects from a set of co-located
 * intermediate results.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>TwoPhaseInsertSelectTaskList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>targetRelationId</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>insertSelectQuery</name></decl></parameter>,
							 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>resultIdPrefix</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Make a copy of the INSERT ... SELECT. We'll repeatedly replace the
	 * subquery of insertResultQuery for different intermediate results and
	 * then deparse it.
	 */</comment>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>insertResultQuery</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>insertSelectQuery</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>insertRte</name> <init>= <expr><call><name>ExtractResultRelationRTE</name><argument_list>(<argument><expr><name>insertResultQuery</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>selectRte</name> <init>= <expr><call><name>ExtractSelectRangeTableEntry</name><argument_list>(<argument><expr><name>insertResultQuery</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>targetCacheEntry</name> <init>= <expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name>targetRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>shardCount</name> <init>= <expr><name><name>targetCacheEntry</name><operator>-&gt;</operator><name>shardIntervalArrayLength</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>taskIdIndex</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>jobId</name> <init>= <expr><name>INVALID_JOB_ID</name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>shardOffset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>shardOffset</name> <operator>&lt;</operator> <name>shardCount</name></expr>;</condition> <incr><expr><name>shardOffset</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>targetShardInterval</name> <init>=
			<expr><name><name>targetCacheEntry</name><operator>-&gt;</operator><name>sortedShardIntervalArray</name><index>[<expr><name>shardOffset</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type> <name>shardId</name> <init>= <expr><name><name>targetShardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>columnAliasList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StringInfo</name></type> <name>queryString</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StringInfo</name></type> <name>resultId</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* during COPY, the shard ID is appended to the result name */</comment>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>resultId</name></expr></argument>, <argument><expr><literal type="string">"%s_"</literal> <name>UINT64_FORMAT</name></expr></argument>, <argument><expr><name>resultIdPrefix</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* generate the query on the intermediate result */</comment>
		<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>resultSelectQuery</name> <init>= <expr><call><name>BuildSubPlanResultQuery</name><argument_list>(<argument><expr><name><name>insertSelectQuery</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
														   <argument><expr><name>columnAliasList</name></expr></argument>,
														   <argument><expr><name><name>resultId</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* put the intermediate result query in the INSERT..SELECT */</comment>
		<expr_stmt><expr><name><name>selectRte</name><operator>-&gt;</operator><name>subquery</name></name> <operator>=</operator> <name>resultSelectQuery</name></expr>;</expr_stmt>

		<comment type="block">/* setting an alias simplifies deparsing of RETURNING */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>insertRte</name><operator>-&gt;</operator><name>alias</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Alias</name> <modifier>*</modifier></type><name>alias</name> <init>= <expr><call><name>makeAlias</name><argument_list>(<argument><expr><name>CITUS_TABLE_ALIAS</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>insertRte</name><operator>-&gt;</operator><name>alias</name></name> <operator>=</operator> <name>alias</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Generate a query string for the query that inserts into a shard and reads
		 * from an intermediate result.
		 *
		 * Since CTEs have already been converted to intermediate results, they need
		 * to removed from the query. Otherwise, worker queries include both
		 * intermediate results and CTEs in the query.
		 */</comment>
		<expr_stmt><expr><name><name>insertResultQuery</name><operator>-&gt;</operator><name>cteList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>deparse_shard_query</name><argument_list>(<argument><expr><name>insertResultQuery</name></expr></argument>, <argument><expr><name>targetRelationId</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"distributed statement: %s"</literal></expr></argument>, <argument><expr><name><name>queryString</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LockShardDistributionMetadata</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>insertShardPlacementList</name> <init>= <expr><call><name>ActiveShardPlacementList</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>RelationShard</name> <modifier>*</modifier></type><name>relationShard</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>RelationShard</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>relationShard</name><operator>-&gt;</operator><name>relationId</name></name> <operator>=</operator> <name><name>targetShardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relationShard</name><operator>-&gt;</operator><name>shardId</name></name> <operator>=</operator> <name><name>targetShardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>modifyTask</name> <init>= <expr><call><name>CreateBasicTask</name><argument_list>(<argument><expr><name>jobId</name></expr></argument>, <argument><expr><name>taskIdIndex</name></expr></argument>, <argument><expr><name>MODIFY_TASK</name></expr></argument>,
										   <argument><expr><name><name>queryString</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>modifyTask</name><operator>-&gt;</operator><name>dependentTaskList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>modifyTask</name><operator>-&gt;</operator><name>anchorShardId</name></name> <operator>=</operator> <name>shardId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>modifyTask</name><operator>-&gt;</operator><name>taskPlacementList</name></name> <operator>=</operator> <name>insertShardPlacementList</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>modifyTask</name><operator>-&gt;</operator><name>relationShardList</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>relationShard</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>modifyTask</name><operator>-&gt;</operator><name>replicationModel</name></name> <operator>=</operator> <name><name>targetCacheEntry</name><operator>-&gt;</operator><name>replicationModel</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>taskList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>, <argument><expr><name>modifyTask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>taskIdIndex</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>taskList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExecutePlanIntoColocatedIntermediateResults executes the given PlannedStmt
 * and inserts tuples into a set of intermediate results that are colocated with
 * the target table for further processing of ON CONFLICT or RETURNING. It also
 * returns the hash of shard states that were used to insert tuplesinto the target
 * relation.
 */</comment>
<function><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type>
<name>ExecutePlanIntoColocatedIntermediateResults</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>targetRelationId</name></decl></parameter>,
											<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>insertTargetList</name></decl></parameter>,
											<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>selectPlan</name></decl></parameter>,
											<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>executorState</name></decl></parameter>,
											<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>intermediateResultIdPrefix</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParamListInfo</name></type> <name>paramListInfo</name> <init>= <expr><name><name>executorState</name><operator>-&gt;</operator><name>es_param_list_info</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Get column name list and partition column index for the target table */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>columnNameList</name> <init>= <expr><call><name>BuildColumnNameListFromTargetList</name><argument_list>(<argument><expr><name>targetRelationId</name></expr></argument>,
															 <argument><expr><name>insertTargetList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>partitionColumnIndex</name> <init>= <expr><call><name>PartitionColumnIndexFromColumnList</name><argument_list>(<argument><expr><name>targetRelationId</name></expr></argument>,
																  <argument><expr><name>columnNameList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* set up a DestReceiver that copies into the intermediate table */</comment>
	<decl_stmt><decl><type><name>CitusCopyDestReceiver</name> <modifier>*</modifier></type><name>copyDest</name> <init>= <expr><call><name>CreateCitusCopyDestReceiver</name><argument_list>(<argument><expr><name>targetRelationId</name></expr></argument>,
																  <argument><expr><name>columnNameList</name></expr></argument>,
																  <argument><expr><name>partitionColumnIndex</name></expr></argument>,
																  <argument><expr><name>executorState</name></expr></argument>,
																  <argument><expr><name>intermediateResultIdPrefix</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ExecutePlanIntoDestReceiver</name><argument_list>(<argument><expr><name>selectPlan</name></expr></argument>, <argument><expr><name>paramListInfo</name></expr></argument>, <argument><expr><operator>(</operator><name>DestReceiver</name> <operator>*</operator><operator>)</operator> <name>copyDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>executorState</name><operator>-&gt;</operator><name>es_processed</name></name> <operator>=</operator> <name><name>copyDest</name><operator>-&gt;</operator><name>tuplesSent</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>XactModificationLevel</name> <operator>=</operator> <name>XACT_MODIFICATION_DATA</name></expr>;</expr_stmt>

	<return>return <expr><name><name>copyDest</name><operator>-&gt;</operator><name>shardStateHash</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExecutePlanIntoRelation executes the given plan and inserts the
 * results into the target relation, which is assumed to be a distributed
 * table.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecutePlanIntoRelation</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>targetRelationId</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>insertTargetList</name></decl></parameter>,
						<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>selectPlan</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>executorState</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParamListInfo</name></type> <name>paramListInfo</name> <init>= <expr><name><name>executorState</name><operator>-&gt;</operator><name>es_param_list_info</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Get column name list and partition column index for the target table */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>columnNameList</name> <init>= <expr><call><name>BuildColumnNameListFromTargetList</name><argument_list>(<argument><expr><name>targetRelationId</name></expr></argument>,
															 <argument><expr><name>insertTargetList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>partitionColumnIndex</name> <init>= <expr><call><name>PartitionColumnIndexFromColumnList</name><argument_list>(<argument><expr><name>targetRelationId</name></expr></argument>,
																  <argument><expr><name>columnNameList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* set up a DestReceiver that copies into the distributed table */</comment>
	<decl_stmt><decl><type><name>CitusCopyDestReceiver</name> <modifier>*</modifier></type><name>copyDest</name> <init>= <expr><call><name>CreateCitusCopyDestReceiver</name><argument_list>(<argument><expr><name>targetRelationId</name></expr></argument>,
																  <argument><expr><name>columnNameList</name></expr></argument>,
																  <argument><expr><name>partitionColumnIndex</name></expr></argument>,
																  <argument><expr><name>executorState</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ExecutePlanIntoDestReceiver</name><argument_list>(<argument><expr><name>selectPlan</name></expr></argument>, <argument><expr><name>paramListInfo</name></expr></argument>, <argument><expr><operator>(</operator><name>DestReceiver</name> <operator>*</operator><operator>)</operator> <name>copyDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>executorState</name><operator>-&gt;</operator><name>es_processed</name></name> <operator>=</operator> <name><name>copyDest</name><operator>-&gt;</operator><name>tuplesSent</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>XactModificationLevel</name> <operator>=</operator> <name>XACT_MODIFICATION_DATA</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * BuildColumnNameListForCopyStatement build the column name list given the insert
 * target list.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>BuildColumnNameListFromTargetList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>targetRelationId</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>insertTargetList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>columnNameList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* build the list of column names for the COPY statement */</comment>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>insertTargetEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>insertTargetEntry</argument>, <argument>insertTargetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>columnNameList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>columnNameList</name></expr></argument>, <argument><expr><name><name>insertTargetEntry</name><operator>-&gt;</operator><name>resname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>columnNameList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PartitionColumnIndexFromColumnList returns the index of partition column from given
 * column name list and relation ID. If given list doesn't contain the partition
 * column, it returns -1.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>PartitionColumnIndexFromColumnList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>columnNameList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>partitionColumn</name> <init>= <expr><call><name>PartitionColumn</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>partitionColumnIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>columnName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>columnName</argument>, <argument>columnNameList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AttrNumber</name></type> <name>attrNumber</name> <init>= <expr><call><name>get_attnum</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>columnName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* check whether this is the partition column */</comment>
		<if_stmt><if>if <condition>(<expr><name>partitionColumn</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>attrNumber</name> <operator>==</operator> <name><name>partitionColumn</name><operator>-&gt;</operator><name>varattno</name></name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>partitionColumnIndex</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>partitionColumnIndex</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsSupportedRedistributionTarget determines whether re-partitioning into the
 * given target relation is supported.
 */</comment>
<function><type><name>bool</name></type>
<name>IsSupportedRedistributionTarget</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>targetRelationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>tableEntry</name> <init>= <expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name>targetRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCitusTableTypeCacheEntry</name><argument_list>(<argument><expr><name>tableEntry</name></expr></argument>, <argument><expr><name>HASH_DISTRIBUTED</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>IsCitusTableTypeCacheEntry</name><argument_list>(<argument><expr><name>tableEntry</name></expr></argument>, <argument><expr><name>RANGE_DISTRIBUTED</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RedistributedInsertSelectTaskList returns a task list to insert given
 * redistributedResults into the given target relation.
 * redistributedResults[shardIndex] is list of cstrings each of which is
 * a result name which should be inserted into
 * targetRelation-&gt;sortedShardIntervalArray[shardIndex].
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>RedistributedInsertSelectTaskList</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>insertSelectQuery</name></decl></parameter>,
								  <parameter><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>targetRelation</name></decl></parameter>,
								  <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>redistributedResults</name></decl></parameter>,
								  <parameter><decl><type><name>bool</name></type> <name>useBinaryFormat</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Make a copy of the INSERT ... SELECT. We'll repeatedly replace the
	 * subquery of insertResultQuery for different intermediate results and
	 * then deparse it.
	 */</comment>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>insertResultQuery</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>insertSelectQuery</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>insertRte</name> <init>= <expr><call><name>ExtractResultRelationRTE</name><argument_list>(<argument><expr><name>insertResultQuery</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>selectRte</name> <init>= <expr><call><name>ExtractSelectRangeTableEntry</name><argument_list>(<argument><expr><name>insertResultQuery</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>selectTargetList</name> <init>= <expr><name><name>selectRte</name><operator>-&gt;</operator><name>subquery</name><operator>-&gt;</operator><name>targetList</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>targetRelationId</name> <init>= <expr><name><name>targetRelation</name><operator>-&gt;</operator><name>relationId</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>shardCount</name> <init>= <expr><name><name>targetRelation</name><operator>-&gt;</operator><name>shardIntervalArrayLength</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>shardOffset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>taskIdIndex</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>jobId</name> <init>= <expr><name>INVALID_JOB_ID</name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>shardOffset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>shardOffset</name> <operator>&lt;</operator> <name>shardCount</name></expr>;</condition> <incr><expr><name>shardOffset</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>targetShardInterval</name> <init>=
			<expr><name><name>targetRelation</name><operator>-&gt;</operator><name>sortedShardIntervalArray</name><index>[<expr><name>shardOffset</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>resultIdList</name> <init>= <expr><name><name>redistributedResults</name><index>[<expr><name><name>targetShardInterval</name><operator>-&gt;</operator><name>shardIndex</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type> <name>shardId</name> <init>= <expr><name><name>targetShardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StringInfo</name></type> <name>queryString</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* skip empty tasks */</comment>
		<if_stmt><if>if <condition>(<expr><name>resultIdList</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* sort result ids for consistent test output */</comment>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>sortedResultIds</name> <init>= <expr><call><name>SortList</name><argument_list>(<argument><expr><name>resultIdList</name></expr></argument>, <argument><expr><name>pg_qsort_strcmp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* generate the query on the intermediate result */</comment>
		<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>fragmentSetQuery</name> <init>= <expr><call><name>BuildReadIntermediateResultsArrayQuery</name><argument_list>(<argument><expr><name>selectTargetList</name></expr></argument>,
																		 <argument><expr><name>NIL</name></expr></argument>,
																		 <argument><expr><name>sortedResultIds</name></expr></argument>,
																		 <argument><expr><name>useBinaryFormat</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* put the intermediate result query in the INSERT..SELECT */</comment>
		<expr_stmt><expr><name><name>selectRte</name><operator>-&gt;</operator><name>subquery</name></name> <operator>=</operator> <name>fragmentSetQuery</name></expr>;</expr_stmt>

		<comment type="block">/* setting an alias simplifies deparsing of RETURNING */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>insertRte</name><operator>-&gt;</operator><name>alias</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Alias</name> <modifier>*</modifier></type><name>alias</name> <init>= <expr><call><name>makeAlias</name><argument_list>(<argument><expr><name>CITUS_TABLE_ALIAS</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>insertRte</name><operator>-&gt;</operator><name>alias</name></name> <operator>=</operator> <name>alias</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Generate a query string for the query that inserts into a shard and reads
		 * from an intermediate result.
		 *
		 * Since CTEs have already been converted to intermediate results, they need
		 * to removed from the query. Otherwise, worker queries include both
		 * intermediate results and CTEs in the query.
		 */</comment>
		<expr_stmt><expr><name><name>insertResultQuery</name><operator>-&gt;</operator><name>cteList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>deparse_shard_query</name><argument_list>(<argument><expr><name>insertResultQuery</name></expr></argument>, <argument><expr><name>targetRelationId</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"distributed statement: %s"</literal></expr></argument>, <argument><expr><name><name>queryString</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LockShardDistributionMetadata</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>insertShardPlacementList</name> <init>= <expr><call><name>ActiveShardPlacementList</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>RelationShard</name> <modifier>*</modifier></type><name>relationShard</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>RelationShard</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>relationShard</name><operator>-&gt;</operator><name>relationId</name></name> <operator>=</operator> <name><name>targetShardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relationShard</name><operator>-&gt;</operator><name>shardId</name></name> <operator>=</operator> <name><name>targetShardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>modifyTask</name> <init>= <expr><call><name>CreateBasicTask</name><argument_list>(<argument><expr><name>jobId</name></expr></argument>, <argument><expr><name>taskIdIndex</name></expr></argument>, <argument><expr><name>MODIFY_TASK</name></expr></argument>,
										   <argument><expr><name><name>queryString</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>modifyTask</name><operator>-&gt;</operator><name>dependentTaskList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>modifyTask</name><operator>-&gt;</operator><name>anchorShardId</name></name> <operator>=</operator> <name>shardId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>modifyTask</name><operator>-&gt;</operator><name>taskPlacementList</name></name> <operator>=</operator> <name>insertShardPlacementList</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>modifyTask</name><operator>-&gt;</operator><name>relationShardList</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>relationShard</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>modifyTask</name><operator>-&gt;</operator><name>replicationModel</name></name> <operator>=</operator> <name><name>targetRelation</name><operator>-&gt;</operator><name>replicationModel</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>taskList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>, <argument><expr><name>modifyTask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>taskIdIndex</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>taskList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PartitionColumnIndex finds the index of given partition column in the
 * given target list.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>PartitionColumnIndex</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>insertTargetList</name></decl></parameter>, <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>partitionColumn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>insertTargetEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>targetEntryIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>insertTargetEntry</argument>, <argument>insertTargetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>insertTargetEntry</name><operator>-&gt;</operator><name>resno</name></name> <operator>==</operator> <name><name>partitionColumn</name><operator>-&gt;</operator><name>varattno</name></name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>targetEntryIndex</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>targetEntryIndex</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsRedistributablePlan returns true if the given plan is a redistrituable plan.
 */</comment>
<function><type><name>bool</name></type>
<name>IsRedistributablePlan</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>selectPlan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>EnableRepartitionedInsertSelect</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* don't redistribute if query is not distributed or requires merge on coordinator */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCitusCustomScan</name><argument_list>(<argument><expr><name>selectPlan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>DistributedPlan</name> <modifier>*</modifier></type><name>distSelectPlan</name> <init>=
		<expr><call><name>GetDistributedPlan</name><argument_list>(<argument><expr><operator>(</operator><name>CustomScan</name> <operator>*</operator><operator>)</operator> <name>selectPlan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Job</name> <modifier>*</modifier></type><name>distSelectJob</name> <init>= <expr><name><name>distSelectPlan</name><operator>-&gt;</operator><name>workerJob</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>distSelectTaskList</name> <init>= <expr><name><name>distSelectJob</name><operator>-&gt;</operator><name>taskList</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Don't use redistribution if only one task. This is to keep the existing
	 * behaviour for CTEs that the last step is a read_intermediate_result()
	 * call. It doesn't hurt much in other cases too.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>distSelectTaskList</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* don't use redistribution for repartition joins for now */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>distSelectJob</name><operator>-&gt;</operator><name>dependentJobList</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>distSelectPlan</name><operator>-&gt;</operator><name>combineQuery</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>combineQuery</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name><name>distSelectPlan</name><operator>-&gt;</operator><name>combineQuery</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>contain_nextval_expression_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>combineQuery</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* nextval needs to be evaluated on the coordinator */</comment>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * WrapTaskListForProjection wraps task query string to only select given
 * projected columns. It modifies the taskList.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>WrapTaskListForProjection</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>projectedTargetEntries</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>projectedColumnsString</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>entryIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>targetEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>targetEntry</argument>, <argument>projectedTargetEntries</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>entryIndex</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>projectedColumnsString</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>columnName</name> <init>= <expr><name><name>targetEntry</name><operator>-&gt;</operator><name>resname</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>columnName</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>projectedColumnsString</name></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>columnName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>entryIndex</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>task</argument>, <argument>taskList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>StringInfo</name></type> <name>wrappedQuery</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>wrappedQuery</name></expr></argument>, <argument><expr><literal type="string">"SELECT %s FROM (%s) subquery"</literal></expr></argument>,
						 <argument><expr><name><name>projectedColumnsString</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
						 <argument><expr><call><name>TaskQueryString</name><argument_list>(<argument><expr><name>task</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SetTaskQueryString</name><argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><name><name>wrappedQuery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>
</unit>
