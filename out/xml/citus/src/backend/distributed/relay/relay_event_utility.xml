<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/citus/src/backend/distributed/relay/relay_event_utility.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * relay_event_utility.c
 *
 * Routines for handling DDL statements that relate to relay files. These
 * routines extend relation, index and constraint names in utility commands.
 *
 * Copyright (c) Citus Data, Inc.
 *
 * $Id$
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"c.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/skey.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/stratnum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_class.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_constraint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_safe_lib.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_partitioning_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/relay_utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/version_compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/stringinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/parsenodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pg_list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/primnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/value.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/elog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/errcodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/palloc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relcache.h"</cpp:file></cpp:include>

<comment type="block">/* Local functions forward declarations */</comment>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>UpdateWholeRowColumnReferencesWalker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>uint64</name> <modifier>*</modifier></type><name>shardId</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* exports for SQL callable functions */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>shard_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
 * RelayEventExtendNames extends relation names in the given parse tree for
 * certain utility commands. The function more specifically extends table and
 * index names in the parse tree by appending the given shardId; thereby
 * avoiding name collisions in the database among sharded tables. This function
 * has the side effect of extending relation names in the parse tree.
 */</comment>
<function><type><name>void</name></type>
<name>RelayEventExtendNames</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parseTree</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>schemaName</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* we don't extend names in extension or schema commands */</comment>
	<decl_stmt><decl><type><name>NodeTag</name></type> <name>nodeType</name> <init>= <expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>parseTree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>nodeType</name> <operator>==</operator> <name>T_CreateExtensionStmt</name> <operator>||</operator> <name>nodeType</name> <operator>==</operator> <name>T_CreateSchemaStmt</name> <operator>||</operator>
		<name>nodeType</name> <operator>==</operator> <name>T_CreateSeqStmt</name> <operator>||</operator> <name>nodeType</name> <operator>==</operator> <name>T_AlterSeqStmt</name> <operator>||</operator>
		<name>nodeType</name> <operator>==</operator> <name>T_CreateForeignServerStmt</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<switch>switch <condition>(<expr><name>nodeType</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_AlterObjectSchemaStmt</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AlterObjectSchemaStmt</name> <modifier>*</modifier></type><name>alterObjectSchemaStmt</name> <init>=
				<expr><operator>(</operator><name>AlterObjectSchemaStmt</name> <operator>*</operator><operator>)</operator> <name>parseTree</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ObjectType</name></type> <name>objectType</name> <init>= <expr><name><name>alterObjectSchemaStmt</name><operator>-&gt;</operator><name>objectType</name></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>objectType</name> <operator>==</operator> <name>OBJECT_STATISTIC_EXT</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>stat</name> <init>= <expr><call><name>makeRangeVarFromNameList</name><argument_list>(
					<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>alterObjectSchemaStmt</name><operator>-&gt;</operator><name>object</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/* append shard id */</comment>
				<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>stat</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>alterObjectSchemaStmt</name><operator>-&gt;</operator><name>object</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>MakeNameListFromRangeVar</name><argument_list>(<argument><expr><name>stat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>relationName</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>alterObjectSchemaStmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>relationSchemaName</name> <init>=
					<expr><operator>&amp;</operator><operator>(</operator><name><name>alterObjectSchemaStmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

				<comment type="block">/* prefix with schema name if it is not added already */</comment>
				<expr_stmt><expr><call><name>SetSchemaNameIfNotExist</name><argument_list>(<argument><expr><name>relationSchemaName</name></expr></argument>, <argument><expr><name>schemaName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* append shardId to base relation name */</comment>
				<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><name>relationName</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>T_AlterStatsStmt</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AlterStatsStmt</name> <modifier>*</modifier></type><name>alterStatsStmt</name> <init>= <expr><operator>(</operator><name>AlterStatsStmt</name> <operator>*</operator><operator>)</operator> <name>parseTree</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>stat</name> <init>= <expr><call><name>makeRangeVarFromNameList</name><argument_list>(<argument><expr><name><name>alterStatsStmt</name><operator>-&gt;</operator><name>defnames</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>stat</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>alterStatsStmt</name><operator>-&gt;</operator><name>defnames</name></name> <operator>=</operator> <call><name>MakeNameListFromRangeVar</name><argument_list>(<argument><expr><name>stat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>T_AlterTableStmt</name></expr>:</case>
		<block>{<block_content>
			<comment type="block">/*
			 * We append shardId to the very end of table and index, constraint
			 * and trigger names to avoid name collisions.
			 */</comment>

			<decl_stmt><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>alterTableStmt</name> <init>= <expr><operator>(</operator><name>AlterTableStmt</name> <operator>*</operator><operator>)</operator> <name>parseTree</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>relationName</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>alterTableStmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>relationSchemaName</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>alterTableStmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commandList</name> <init>= <expr><name><name>alterTableStmt</name><operator>-&gt;</operator><name>cmds</name></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* prefix with schema name if it is not added already */</comment>
			<expr_stmt><expr><call><name>SetSchemaNameIfNotExist</name><argument_list>(<argument><expr><name>relationSchemaName</name></expr></argument>, <argument><expr><name>schemaName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* append shardId to base relation name */</comment>
			<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><name>relationName</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>command</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<macro><name>foreach_ptr</name><argument_list>(<argument>command</argument>, <argument>commandList</argument>)</argument_list></macro>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>command</name><operator>-&gt;</operator><name>subtype</name></name> <operator>==</operator> <name>AT_AddConstraint</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>constraint</name> <init>= <expr><operator>(</operator><name>Constraint</name> <operator>*</operator><operator>)</operator> <name><name>command</name><operator>-&gt;</operator><name>def</name></name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>constraintName</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>constraint</name><operator>-&gt;</operator><name>conname</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>missingOk</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><name>relationId</name> <operator>=</operator> <call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name><name>alterTableStmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>,
												  <argument><expr><name>AccessShareLock</name></expr></argument>,
												  <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>constraint</name><operator>-&gt;</operator><name>indexname</name></name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>indexName</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>constraint</name><operator>-&gt;</operator><name>indexname</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
						<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><name>indexName</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/*
					 * Append shardId to constraint names if
					 *  - table is not partitioned or
					 *  - constraint is not a CHECK constraint
					 *
					 * We do not want to append shardId to partitioned table shards because
					 * the names of constraints will be inherited, and the shardId will no
					 * longer be valid for the child table.
					 *
					 * See MergeConstraintsIntoExisting function in Postgres that requires
					 * inherited check constraints in child tables to have the same name
					 * with those in parent tables.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PartitionedTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call> <operator>||</operator>
						<name><name>constraint</name><operator>-&gt;</operator><name>contype</name></name> <operator>!=</operator> <name>CONSTR_CHECK</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><name>constraintName</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name><name>command</name><operator>-&gt;</operator><name>subtype</name></name> <operator>==</operator> <name>AT_DropConstraint</name> <operator>||</operator>
						 <name><name>command</name><operator>-&gt;</operator><name>subtype</name></name> <operator>==</operator> <name>AT_ValidateConstraint</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>constraintName</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>command</name><operator>-&gt;</operator><name>name</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>constraintMissingOk</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>rvMissingOk</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
						<expr_stmt><expr><name>relationId</name> <operator>=</operator> <call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name><name>alterTableStmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>,
													  <argument><expr><name>AccessShareLock</name></expr></argument>,
													  <argument><expr><name>rvMissingOk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<decl_stmt><decl><type><name>Oid</name></type> <name>constraintOid</name> <init>= <expr><call><name>get_relation_constraint_oid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>,
																	<argument><expr><name><name>command</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
																	<argument><expr><name>constraintMissingOk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>constraintOid</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><name>constraintName</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name><name>command</name><operator>-&gt;</operator><name>subtype</name></name> <operator>==</operator> <name>AT_ClusterOn</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>indexName</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>command</name><operator>-&gt;</operator><name>name</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><name>indexName</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name><name>command</name><operator>-&gt;</operator><name>subtype</name></name> <operator>==</operator> <name>AT_ReplicaIdentity</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>ReplicaIdentityStmt</name> <modifier>*</modifier></type><name>replicaIdentity</name> <init>=
						<expr><operator>(</operator><name>ReplicaIdentityStmt</name> <operator>*</operator><operator>)</operator> <name><name>command</name><operator>-&gt;</operator><name>def</name></name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>replicaIdentity</name><operator>-&gt;</operator><name>identity_type</name></name> <operator>==</operator> <name>REPLICA_IDENTITY_INDEX</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>indexName</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>replicaIdentity</name><operator>-&gt;</operator><name>name</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
						<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><name>indexName</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name><name>command</name><operator>-&gt;</operator><name>subtype</name></name> <operator>==</operator> <name>AT_EnableTrig</name> <operator>||</operator>
						 <name><name>command</name><operator>-&gt;</operator><name>subtype</name></name> <operator>==</operator> <name>AT_DisableTrig</name> <operator>||</operator>
						 <name><name>command</name><operator>-&gt;</operator><name>subtype</name></name> <operator>==</operator> <name>AT_EnableAlwaysTrig</name> <operator>||</operator>
						 <name><name>command</name><operator>-&gt;</operator><name>subtype</name></name> <operator>==</operator> <name>AT_EnableReplicaTrig</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>triggerName</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>command</name><operator>-&gt;</operator><name>name</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><name>triggerName</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>

			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>T_AlterOwnerStmt</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AlterOwnerStmt</name> <modifier>*</modifier></type><name>alterOwnerStmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>AlterOwnerStmt</name></expr></argument>, <argument><expr><name>parseTree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* we currently extend names in alter owner statements only for statistics */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>alterOwnerStmt</name><operator>-&gt;</operator><name>objectType</name></name> <operator>==</operator> <name>OBJECT_STATISTIC_EXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>stat</name> <init>= <expr><call><name>makeRangeVarFromNameList</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>alterOwnerStmt</name><operator>-&gt;</operator><name>object</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>stat</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>alterOwnerStmt</name><operator>-&gt;</operator><name>object</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>MakeNameListFromRangeVar</name><argument_list>(<argument><expr><name>stat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>T_ClusterStmt</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ClusterStmt</name> <modifier>*</modifier></type><name>clusterStmt</name> <init>= <expr><operator>(</operator><name>ClusterStmt</name> <operator>*</operator><operator>)</operator> <name>parseTree</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* we do not support clustering the entire database */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>clusterStmt</name><operator>-&gt;</operator><name>relation</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot extend name for multi-relation cluster"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>relationName</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>clusterStmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>relationSchemaName</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>clusterStmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

			<comment type="block">/* prefix with schema name if it is not added already */</comment>
			<expr_stmt><expr><call><name>SetSchemaNameIfNotExist</name><argument_list>(<argument><expr><name>relationSchemaName</name></expr></argument>, <argument><expr><name>schemaName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><name>relationName</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>clusterStmt</name><operator>-&gt;</operator><name>indexname</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>indexName</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>clusterStmt</name><operator>-&gt;</operator><name>indexname</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><name>indexName</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>T_CreateForeignTableStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateStmt</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CreateStmt</name> <modifier>*</modifier></type><name>createStmt</name> <init>= <expr><operator>(</operator><name>CreateStmt</name> <operator>*</operator><operator>)</operator> <name>parseTree</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>relationName</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>createStmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>relationSchemaName</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>createStmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

			<comment type="block">/* prefix with schema name if it is not added already */</comment>
			<expr_stmt><expr><call><name>SetSchemaNameIfNotExist</name><argument_list>(<argument><expr><name>relationSchemaName</name></expr></argument>, <argument><expr><name>schemaName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><name>relationName</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>T_CreateTrigStmt</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CreateTrigStmt</name> <modifier>*</modifier></type><name>createTriggerStmt</name> <init>= <expr><operator>(</operator><name>CreateTrigStmt</name> <operator>*</operator><operator>)</operator> <name>parseTree</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>CreateTriggerEventExtendNames</name><argument_list>(<argument><expr><name>createTriggerStmt</name></expr></argument>, <argument><expr><name>schemaName</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>T_AlterObjectDependsStmt</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AlterObjectDependsStmt</name> <modifier>*</modifier></type><name>alterTriggerDependsStmt</name> <init>=
				<expr><operator>(</operator><name>AlterObjectDependsStmt</name> <operator>*</operator><operator>)</operator> <name>parseTree</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ObjectType</name></type> <name>objectType</name> <init>= <expr><name><name>alterTriggerDependsStmt</name><operator>-&gt;</operator><name>objectType</name></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>objectType</name> <operator>==</operator> <name>OBJECT_TRIGGER</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>AlterTriggerDependsEventExtendNames</name><argument_list>(<argument><expr><name>alterTriggerDependsStmt</name></expr></argument>,
													<argument><expr><name>schemaName</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unsafe object type in alter object "</literal>
										 <literal type="string">"depends statement"</literal></expr></argument>)</argument_list></call><operator>,</operator>
								  <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Object type: %u"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>objectType</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>T_DropStmt</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>DropStmt</name> <modifier>*</modifier></type><name>dropStmt</name> <init>= <expr><operator>(</operator><name>DropStmt</name> <operator>*</operator><operator>)</operator> <name>parseTree</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ObjectType</name></type> <name>objectType</name> <init>= <expr><name><name>dropStmt</name><operator>-&gt;</operator><name>removeType</name></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>objectType</name> <operator>==</operator> <name>OBJECT_TABLE</name> <operator>||</operator> <name>objectType</name> <operator>==</operator> <name>OBJECT_INDEX</name> <operator>||</operator>
				<name>objectType</name> <operator>==</operator> <name>OBJECT_FOREIGN_TABLE</name> <operator>||</operator> <name>objectType</name> <operator>==</operator> <name>OBJECT_FOREIGN_SERVER</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>relationSchemaNameValue</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>relationNameValue</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

				<decl_stmt><decl><type><name>uint32</name></type> <name>dropCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>dropStmt</name><operator>-&gt;</operator><name>objects</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><name>dropCount</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot extend name for multiple drop objects"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * We now need to extend a single relation or index name. To be
				 * able to do this extension, we need to extract the names'
				 * addresses from the value objects they are stored in. Other-
				 * wise, the repalloc called in AppendShardIdToName() will not
				 * have the correct memory address for the name.
				 */</comment>

				<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>relationNameList</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>dropStmt</name><operator>-&gt;</operator><name>objects</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type> <name>relationNameListLength</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>relationNameList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<switch>switch <condition>(<expr><name>relationNameListLength</name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><literal type="number">1</literal></expr>:</case>
					<block>{<block_content>
						<expr_stmt><expr><name>relationNameValue</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>relationNameList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block>

					<case>case <expr><literal type="number">2</literal></expr>:</case>
					<block>{<block_content>
						<expr_stmt><expr><name>relationSchemaNameValue</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>relationNameList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>relationNameValue</name> <operator>=</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name>relationNameList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block>

					<case>case <expr><literal type="number">3</literal></expr>:</case>
					<block>{<block_content>
						<expr_stmt><expr><name>relationSchemaNameValue</name> <operator>=</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name>relationNameList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>relationNameValue</name> <operator>=</operator> <call><name>lthird</name><argument_list>(<argument><expr><name>relationNameList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block>

					<default>default:</default>
					<block>{<block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
										<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"improper relation name: \"%s\""</literal></expr></argument>,
											   <argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>relationNameList</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block>
				</block_content>}</block></switch>

				<comment type="block">/* prefix with schema name if it is not added already */</comment>
				<if_stmt><if>if <condition>(<expr><name>relationSchemaNameValue</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>schemaNameValue</name> <init>= <expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><name>relationNameList</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>schemaNameValue</name></expr></argument>, <argument><expr><name>relationNameList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>relationName</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><call><name>strVal</name><argument_list>(<argument><expr><name>relationNameValue</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><name>relationName</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>objectType</name> <operator>==</operator> <name>OBJECT_POLICY</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>DropPolicyEventExtendNames</name><argument_list>(<argument><expr><name>dropStmt</name></expr></argument>, <argument><expr><name>schemaName</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>objectType</name> <operator>==</operator> <name>OBJECT_TRIGGER</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>DropTriggerEventExtendNames</name><argument_list>(<argument><expr><name>dropStmt</name></expr></argument>, <argument><expr><name>schemaName</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>objectType</name> <operator>==</operator> <name>OBJECT_STATISTIC_EXT</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardStatisticsList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>objectNameList</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
				<macro><name>foreach_ptr</name><argument_list>(<argument>objectNameList</argument>, <argument>dropStmt-&gt;objects</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>stat</name> <init>= <expr><call><name>makeRangeVarFromNameList</name><argument_list>(<argument><expr><name>objectNameList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>SetSchemaNameIfNotExist</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>stat</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>, <argument><expr><name>schemaName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>stat</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>shardStatisticsList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>shardStatisticsList</name></expr></argument>,
												  <argument><expr><call><name>MakeNameListFromRangeVar</name><argument_list>(<argument><expr><name>stat</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>

				<expr_stmt><expr><name><name>dropStmt</name><operator>-&gt;</operator><name>objects</name></name> <operator>=</operator> <name>shardStatisticsList</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unsafe object type in drop statement"</literal></expr></argument>)</argument_list></call><operator>,</operator>
								  <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Object type: %u"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>objectType</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<break>break;</break>
		</block_content>}</block>


		<case>case <expr><name>T_GrantStmt</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>GrantStmt</name> <modifier>*</modifier></type><name>grantStmt</name> <init>= <expr><operator>(</operator><name>GrantStmt</name> <operator>*</operator><operator>)</operator> <name>parseTree</name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>grantStmt</name><operator>-&gt;</operator><name>targtype</name></name> <operator>==</operator> <name>ACL_TARGET_OBJECT</name> <operator>&amp;&amp;</operator>
				<name><name>grantStmt</name><operator>-&gt;</operator><name>objtype</name></name> <operator>==</operator> <name>OBJECT_TABLE</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>relation</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
				<macro><name>foreach_ptr</name><argument_list>(<argument>relation</argument>, <argument>grantStmt-&gt;objects</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>relationName</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>relation</name><operator>-&gt;</operator><name>relname</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>relationSchemaName</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

					<comment type="block">/* prefix with schema name if it is not added already */</comment>
					<expr_stmt><expr><call><name>SetSchemaNameIfNotExist</name><argument_list>(<argument><expr><name>relationSchemaName</name></expr></argument>, <argument><expr><name>schemaName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><name>relationName</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>T_CreatePolicyStmt</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><call><name>CreatePolicyEventExtendNames</name><argument_list>(<argument><expr><operator>(</operator><name>CreatePolicyStmt</name> <operator>*</operator><operator>)</operator> <name>parseTree</name></expr></argument>, <argument><expr><name>schemaName</name></expr></argument>,
										 <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>T_AlterPolicyStmt</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><call><name>AlterPolicyEventExtendNames</name><argument_list>(<argument><expr><operator>(</operator><name>AlterPolicyStmt</name> <operator>*</operator><operator>)</operator> <name>parseTree</name></expr></argument>, <argument><expr><name>schemaName</name></expr></argument>,
										<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>T_IndexStmt</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>indexStmt</name> <init>= <expr><operator>(</operator><name>IndexStmt</name> <operator>*</operator><operator>)</operator> <name>parseTree</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>relationName</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>indexStmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>indexName</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>indexStmt</name><operator>-&gt;</operator><name>idxname</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>relationSchemaName</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>indexStmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Concurrent index statements cannot run within a transaction block.
			 * Therefore, we do not support them.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>indexStmt</name><operator>-&gt;</operator><name>concurrent</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot extend name for concurrent index"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * In the regular DDL execution code path (for non-sharded tables),
			 * if the index statement results from a table creation command, the
			 * indexName may be null. For sharded tables however, we intercept
			 * that code path and explicitly set the index name. Therefore, the
			 * index name in here cannot be null.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>indexName</name><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot extend name for null index name"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* extend ColumnRef nodes in the IndexStmt with the shardId */</comment>
			<expr_stmt><expr><call><name>UpdateWholeRowColumnReferencesWalker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>indexStmt</name><operator>-&gt;</operator><name>indexParams</name></name></expr></argument>,
												 <argument><expr><operator>&amp;</operator><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* prefix with schema name if it is not added already */</comment>
			<expr_stmt><expr><call><name>SetSchemaNameIfNotExist</name><argument_list>(<argument><expr><name>relationSchemaName</name></expr></argument>, <argument><expr><name>schemaName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><name>relationName</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><name>indexName</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>T_ReindexStmt</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ReindexStmt</name> <modifier>*</modifier></type><name>reindexStmt</name> <init>= <expr><operator>(</operator><name>ReindexStmt</name> <operator>*</operator><operator>)</operator> <name>parseTree</name></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>ReindexObjectType</name></type> <name>objectType</name> <init>= <expr><name><name>reindexStmt</name><operator>-&gt;</operator><name>kind</name></name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>objectType</name> <operator>==</operator> <name>REINDEX_OBJECT_TABLE</name> <operator>||</operator> <name>objectType</name> <operator>==</operator> <name>REINDEX_OBJECT_INDEX</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>objectName</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>reindexStmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>objectSchemaName</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>reindexStmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

				<comment type="block">/* prefix with schema name if it is not added already */</comment>
				<expr_stmt><expr><call><name>SetSchemaNameIfNotExist</name><argument_list>(<argument><expr><name>objectSchemaName</name></expr></argument>, <argument><expr><name>schemaName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><name>objectName</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>T_RenameStmt</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RenameStmt</name> <modifier>*</modifier></type><name>renameStmt</name> <init>= <expr><operator>(</operator><name>RenameStmt</name> <operator>*</operator><operator>)</operator> <name>parseTree</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ObjectType</name></type> <name>objectType</name> <init>= <expr><name><name>renameStmt</name><operator>-&gt;</operator><name>renameType</name></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>objectType</name> <operator>==</operator> <name>OBJECT_TABLE</name> <operator>||</operator> <name>objectType</name> <operator>==</operator> <name>OBJECT_INDEX</name> <operator>||</operator>
				<name>objectType</name> <operator>==</operator> <name>OBJECT_FOREIGN_TABLE</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>oldRelationName</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>renameStmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newRelationName</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>renameStmt</name><operator>-&gt;</operator><name>newname</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>objectSchemaName</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>renameStmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

				<comment type="block">/* prefix with schema name if it is not added already */</comment>
				<expr_stmt><expr><call><name>SetSchemaNameIfNotExist</name><argument_list>(<argument><expr><name>objectSchemaName</name></expr></argument>, <argument><expr><name>schemaName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><name>oldRelationName</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><name>newRelationName</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>objectType</name> <operator>==</operator> <name>OBJECT_COLUMN</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>relationName</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>renameStmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>objectSchemaName</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>renameStmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

				<comment type="block">/* prefix with schema name if it is not added already */</comment>
				<expr_stmt><expr><call><name>SetSchemaNameIfNotExist</name><argument_list>(<argument><expr><name>objectSchemaName</name></expr></argument>, <argument><expr><name>schemaName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><name>relationName</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>objectType</name> <operator>==</operator> <name>OBJECT_TRIGGER</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>AlterTriggerRenameEventExtendNames</name><argument_list>(<argument><expr><name>renameStmt</name></expr></argument>, <argument><expr><name>schemaName</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>objectType</name> <operator>==</operator> <name>OBJECT_POLICY</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>RenamePolicyEventExtendNames</name><argument_list>(<argument><expr><name>renameStmt</name></expr></argument>, <argument><expr><name>schemaName</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>objectType</name> <operator>==</operator> <name>OBJECT_STATISTIC_EXT</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>stat</name> <init>= <expr><call><name>makeRangeVarFromNameList</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>renameStmt</name><operator>-&gt;</operator><name>object</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>stat</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>renameStmt</name><operator>-&gt;</operator><name>newname</name></name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>SetSchemaNameIfNotExist</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>stat</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>, <argument><expr><name>schemaName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>renameStmt</name><operator>-&gt;</operator><name>object</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>MakeNameListFromRangeVar</name><argument_list>(<argument><expr><name>stat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unsafe object type in rename statement"</literal></expr></argument>)</argument_list></call><operator>,</operator>
								  <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Object type: %u"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>objectType</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>T_CreateStatsStmt</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CreateStatsStmt</name> <modifier>*</modifier></type><name>createStatsStmt</name> <init>= <expr><operator>(</operator><name>CreateStatsStmt</name> <operator>*</operator><operator>)</operator> <name>parseTree</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* because CREATE STATISTICS statements can only have one relation */</comment>
			<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>relation</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>createStatsStmt</name><operator>-&gt;</operator><name>relations</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>relationName</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>relation</name><operator>-&gt;</operator><name>relname</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>objectSchemaName</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>SetSchemaNameIfNotExist</name><argument_list>(<argument><expr><name>objectSchemaName</name></expr></argument>, <argument><expr><name>schemaName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><name>relationName</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>stat</name> <init>= <expr><call><name>makeRangeVarFromNameList</name><argument_list>(<argument><expr><name><name>createStatsStmt</name><operator>-&gt;</operator><name>defnames</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>stat</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>createStatsStmt</name><operator>-&gt;</operator><name>defnames</name></name> <operator>=</operator> <call><name>MakeNameListFromRangeVar</name><argument_list>(<argument><expr><name>stat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>T_TruncateStmt</name></expr>:</case>
		<block>{<block_content>
			<comment type="block">/*
			 * We currently do not support truncate statements. This is
			 * primarily because truncates allow implicit modifications to
			 * sequences through table column dependencies. As we have not
			 * determined our dependency model for sequences, we error here.
			 */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot extend name for truncate statement"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<default>default:</default>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unsafe statement type in name extension"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							  <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Statement type: %u"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>nodeType</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>
	</block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
 * RelayEventExtendNamesForInterShardCommands extends relation names in the given parse
 * tree for certain utility commands. The function more specifically extends table, index
 * and constraint names in the parse tree by appending the given shardId; thereby
 * avoiding name collisions in the database among sharded tables. This function
 * has the side effect of extending relation names in the parse tree.
 */</comment>
<function><type><name>void</name></type>
<name>RelayEventExtendNamesForInterShardCommands</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parseTree</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>leftShardId</name></decl></parameter>,
										   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>leftShardSchemaName</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>rightShardId</name></decl></parameter>,
										   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>rightShardSchemaName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NodeTag</name></type> <name>nodeType</name> <init>= <expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>parseTree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>nodeType</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_AlterTableStmt</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>alterTableStmt</name> <init>= <expr><operator>(</operator><name>AlterTableStmt</name> <operator>*</operator><operator>)</operator> <name>parseTree</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commandList</name> <init>= <expr><name><name>alterTableStmt</name><operator>-&gt;</operator><name>cmds</name></name></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>command</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<macro><name>foreach_ptr</name><argument_list>(<argument>command</argument>, <argument>commandList</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>referencedTableName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>relationSchemaName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>command</name><operator>-&gt;</operator><name>subtype</name></name> <operator>==</operator> <name>AT_AddConstraint</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>constraint</name> <init>= <expr><operator>(</operator><name>Constraint</name> <operator>*</operator><operator>)</operator> <name><name>command</name><operator>-&gt;</operator><name>def</name></name></expr></init></decl>;</decl_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>constraint</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTR_FOREIGN</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>referencedTableName</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>constraint</name><operator>-&gt;</operator><name>pktable</name><operator>-&gt;</operator><name>relname</name></name><operator>)</operator></expr>;</expr_stmt>
						<expr_stmt><expr><name>relationSchemaName</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>constraint</name><operator>-&gt;</operator><name>pktable</name><operator>-&gt;</operator><name>schemaname</name></name><operator>)</operator></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name><name>command</name><operator>-&gt;</operator><name>subtype</name></name> <operator>==</operator> <name>AT_AddColumn</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * TODO: This code path will never be executed since we do not
					 * support foreign constraint creation via
					 * ALTER TABLE %s ADD COLUMN %s [constraint]. However, the code
					 * is kept in case we fix the constraint creation without a name
					 * and allow foreign key creation with the mentioned command.
					 */</comment>
					<decl_stmt><decl><type><name>ColumnDef</name> <modifier>*</modifier></type><name>columnDefinition</name> <init>= <expr><operator>(</operator><name>ColumnDef</name> <operator>*</operator><operator>)</operator> <name><name>command</name><operator>-&gt;</operator><name>def</name></name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>columnConstraints</name> <init>= <expr><name><name>columnDefinition</name><operator>-&gt;</operator><name>constraints</name></name></expr></init></decl>;</decl_stmt>

					<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>constraint</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
					<macro><name>foreach_ptr</name><argument_list>(<argument>constraint</argument>, <argument>columnConstraints</argument>)</argument_list></macro>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name><name>constraint</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTR_FOREIGN</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>referencedTableName</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>constraint</name><operator>-&gt;</operator><name>pktable</name><operator>-&gt;</operator><name>relname</name></name><operator>)</operator></expr>;</expr_stmt>
							<expr_stmt><expr><name>relationSchemaName</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>constraint</name><operator>-&gt;</operator><name>pktable</name><operator>-&gt;</operator><name>schemaname</name></name><operator>)</operator></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name><name>command</name><operator>-&gt;</operator><name>subtype</name></name> <operator>==</operator> <name>AT_AttachPartition</name> <operator>||</operator>
						 <name><name>command</name><operator>-&gt;</operator><name>subtype</name></name> <operator>==</operator> <name>AT_DetachPartition</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>PartitionCmd</name> <modifier>*</modifier></type><name>partitionCommand</name> <init>= <expr><operator>(</operator><name>PartitionCmd</name> <operator>*</operator><operator>)</operator> <name><name>command</name><operator>-&gt;</operator><name>def</name></name></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name>referencedTableName</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>partitionCommand</name><operator>-&gt;</operator><name>name</name><operator>-&gt;</operator><name>relname</name></name><operator>)</operator></expr>;</expr_stmt>
					<expr_stmt><expr><name>relationSchemaName</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>partitionCommand</name><operator>-&gt;</operator><name>name</name><operator>-&gt;</operator><name>schemaname</name></name><operator>)</operator></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<continue>continue;</continue>
				</block_content>}</block></else></if_stmt>

				<comment type="block">/* prefix with schema name if it is not added already */</comment>
				<expr_stmt><expr><call><name>SetSchemaNameIfNotExist</name><argument_list>(<argument><expr><name>relationSchemaName</name></expr></argument>, <argument><expr><name>rightShardSchemaName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * We will not append shard id to left shard name. This will be
				 * handled when we drop into RelayEventExtendNames.
				 */</comment>
				<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><name>referencedTableName</name></expr></argument>, <argument><expr><name>rightShardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>

			<comment type="block">/* drop into RelayEventExtendNames for non-inter table commands */</comment>
			<expr_stmt><expr><call><name>RelayEventExtendNames</name><argument_list>(<argument><expr><name>parseTree</name></expr></argument>, <argument><expr><name>leftShardSchemaName</name></expr></argument>, <argument><expr><name>leftShardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<default>default:</default>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unsafe statement type in name extension"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							  <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Statement type: %u"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>nodeType</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>
	</block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
 * UpdateWholeRowColumnReferencesWalker extends ColumnRef nodes that end with A_Star
 * with the given shardId.
 *
 * ColumnRefs that don't reference A_Star are not extended as catalog access isn't
 * allowed here and we don't otherwise have enough context to disambiguate a
 * field name that is identical to the table name.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>UpdateWholeRowColumnReferencesWalker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>uint64</name> <modifier>*</modifier></type><name>shardId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>walkIsComplete</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>IndexElem</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>IndexElem</name> <modifier>*</modifier></type><name>indexElem</name> <init>= <expr><operator>(</operator><name>IndexElem</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>walkIsComplete</name> <operator>=</operator> <call><name>raw_expression_tree_walker</name><argument_list>(<argument><expr><name><name>indexElem</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
													<argument><expr><name>UpdateWholeRowColumnReferencesWalker</name></expr></argument>,
													<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ColumnRef</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ColumnRef</name> <modifier>*</modifier></type><name>columnRef</name> <init>= <expr><operator>(</operator><name>ColumnRef</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>lastField</name> <init>= <expr><call><name>llast</name><argument_list>(<argument><expr><name><name>columnRef</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>lastField</name></expr></argument>, <argument><expr><name>A_Star</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * ColumnRef fields list ends with an A_Star, so we can blindly
			 * extend the penultimate element with the shardId.
			 */</comment>
			<decl_stmt><decl><type><name>int</name></type> <name>colrefFieldCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>columnRef</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>relnameValue</name> <init>= <expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>columnRef</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>, <argument><expr><name>colrefFieldCount</name> <operator>-</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>relnameValue</name></expr></argument>, <argument><expr><name>String</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><operator>&amp;</operator><call><name>strVal</name><argument_list>(<argument><expr><name>relnameValue</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>*</operator><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* might be more than one ColumnRef to visit */</comment>
		<expr_stmt><expr><name>walkIsComplete</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>walkIsComplete</name> <operator>=</operator> <call><name>raw_expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
													<argument><expr><name>UpdateWholeRowColumnReferencesWalker</name></expr></argument>,
													<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>walkIsComplete</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SetSchemaNameIfNotExist function checks whether schemaName is set and if it is not set
 * it sets its value to given newSchemaName.
 */</comment>
<function><type><name>void</name></type>
<name>SetSchemaNameIfNotExist</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>schemaName</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newSchemaName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>schemaName</name><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>schemaName</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>newSchemaName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * AppendShardIdToName appends shardId to the given name. The function takes in
 * the name's address in order to reallocate memory for the name in the same
 * memory context the name was originally created in.
 */</comment>
<function><type><name>void</name></type>
<name>AppendShardIdToName</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name><name>extendedName</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nameLength</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><operator>*</operator><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>shardIdAndSeparator</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>longNameHash</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>multiByteClipLength</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>nameLength</name> <operator>&gt;=</operator> <name>NAMEDATALEN</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NAME_TOO_LONG</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"identifier must be less than %d characters"</literal></expr></argument>,
							   <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>SafeSnprintf</name><argument_list>(<argument><expr><name>shardIdAndSeparator</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>, <argument><expr><literal type="string">"%c"</literal> <name>UINT64_FORMAT</name></expr></argument>,
				 <argument><expr><name>SHARD_NAME_SEPARATOR</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>shardIdAndSeparatorLength</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>shardIdAndSeparator</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If *name strlen is &lt; (NAMEDATALEN - shardIdAndSeparatorLength),
	 * it is safe merely to append the separator and shardId.
	 */</comment>

	<if_stmt><if>if <condition>(<expr><name>nameLength</name> <operator>&lt;</operator> <operator>(</operator><name>NAMEDATALEN</name> <operator>-</operator> <name>shardIdAndSeparatorLength</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SafeSnprintf</name><argument_list>(<argument><expr><name>extendedName</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><operator>(</operator><operator>*</operator><name>name</name><operator>)</operator></expr></argument>, <argument><expr><name>shardIdAndSeparator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>

	<comment type="block">/*
	 * Otherwise, we need to truncate the name further to accommodate
	 * a sufficient hash value. The resulting name will avoid collision
	 * with other hashed names such that for any given schema with
	 * 90 distinct object names that are long enough to require hashing
	 * (typically 57-63 characters), the chance of a collision existing is:
	 *
	 * If randomly generated UTF8 names:
	 *     (1e-6) * (9.39323783788e-114) ~= (9.39e-120)
	 * If random case-insensitive ASCII names (letter first, 37 useful characters):
	 *     (1e-6) * (2.80380202421e-74) ~= (2.8e-80)
	 * If names sharing only N distinct 45- to 47-character prefixes:
	 *     (1e-6) * (1/N) = (1e-6/N)
	 *     1e-7 for 10 distinct prefixes
	 *     5e-8 for 20 distinct prefixes
	 *
	 * In practice, since shard IDs are globally unique, the risk of name collision
	 * exists only amongst objects that pertain to a single distributed table
	 * and are created for each shard: the table name and the names of any indexes
	 * or index-backed constraints. Since there are typically less than five such
	 * names, and almost never more than ten, the expected collision rate even in
	 * the worst case (ten names share same 45- to 47-character prefix) is roughly
	 * 1e-8: one in 100 million schemas will experience a name collision only if ALL
	 * 100 million schemas present the worst-case scenario.
	 */</comment>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>longNameHash</name> <operator>=</operator> <call><name>hash_any</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>*</operator><name>name</name><operator>)</operator></expr></argument>, <argument><expr><name>nameLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>multiByteClipLength</name> <operator>=</operator> <call><name>pg_mbcliplen</name><argument_list>(<argument><expr><operator>*</operator><name>name</name></expr></argument>, <argument><expr><name>nameLength</name></expr></argument>, <argument><expr><operator>(</operator><name>NAMEDATALEN</name> <operator>-</operator>
															   <name>shardIdAndSeparatorLength</name> <operator>-</operator>
															   <literal type="number">10</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SafeSnprintf</name><argument_list>(<argument><expr><name>extendedName</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>, <argument><expr><literal type="string">"%.*s%c%.8x%s"</literal></expr></argument>,
					 <argument><expr><name>multiByteClipLength</name></expr></argument>, <argument><expr><operator>(</operator><operator>*</operator><name>name</name><operator>)</operator></expr></argument>,
					 <argument><expr><name>SHARD_NAME_SEPARATOR</name></expr></argument>, <argument><expr><name>longNameHash</name></expr></argument>,
					 <argument><expr><name>shardIdAndSeparator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><operator>(</operator><operator>*</operator><name>name</name><operator>)</operator> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>repalloc</name><argument_list>(<argument><expr><operator>(</operator><operator>*</operator><name>name</name><operator>)</operator></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>neededBytes</name> <init>= <expr><call><name>SafeSnprintf</name><argument_list>(<argument><expr><operator>(</operator><operator>*</operator><name>name</name><operator>)</operator></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>extendedName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>neededBytes</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>neededBytes</name> <operator>&gt;=</operator> <name>NAMEDATALEN</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_STRING_DATA_RIGHT_TRUNCATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"new name %s would be truncated at %d characters"</literal></expr></argument>,
							   <argument><expr><name>extendedName</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * shard_name() provides a PG function interface to AppendShardNameToId above.
 * Returns the name of a shard as a quoted schema-qualified identifier.
 */</comment>
<function><type><name>Datum</name></type>
<name>shard_name</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>shardId</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>qualifiedName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>shardId</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"shard_id cannot be zero or negative value"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>


	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"object_name does not reference a valid relation"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>relationName</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"object_name does not reference a valid relation"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><operator>&amp;</operator><name>relationName</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>schemaId</name> <init>= <expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>schemaName</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>schemaId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>, <argument><expr><literal type="string">"public"</literal></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>qualifiedName</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>quote_identifier</name><argument_list>(<argument><expr><name>relationName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>qualifiedName</name> <operator>=</operator> <call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>, <argument><expr><name>relationName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name>qualifiedName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
