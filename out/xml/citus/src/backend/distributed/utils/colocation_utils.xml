<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/citus/src/backend/distributed/utils/colocation_utils.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * colocation_utils.c
 *
 * This file contains functions to perform useful operations on co-located tables.
 *
 * Copyright (c) Citus Data, Inc.
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/sequence.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/colocation_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/coordinator_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_sync.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_logical_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_partitioning_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_dist_colocation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/resource_lock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shardinterval_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/version_compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/utils/array_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_transaction.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>


<comment type="block">/* local function forward declarations */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>MarkTablesColocated</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>sourceRelationId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>targetRelationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ShardsIntervalsEqual</name><parameter_list>(<parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>leftShardInterval</name></decl></parameter>,
								 <parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>rightShardInterval</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>HashPartitionedShardIntervalsEqual</name><parameter_list>(<parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>leftShardInterval</name></decl></parameter>,
											   <parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>rightShardInterval</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>CompareShardPlacementsByNode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>leftElement</name></decl></parameter>,
										<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>rightElement</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DeleteColocationGroup</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>colocationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint32</name></type> <name>CreateColocationGroupForRelation</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>sourceRelationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>BreakColocation</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>sourceRelationId</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/* exports for SQL callable functions */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>mark_tables_colocated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>get_colocated_shard_array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>update_distributed_table_colocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<comment type="block">/*
 * mark_tables_colocated puts target tables to same colocation group with the
 * source table. If the source table is in INVALID_COLOCATION_ID group, then it
 * creates a new colocation group and assigns all tables to this new colocation
 * group.
 */</comment>
<function><type><name>Datum</name></type>
<name>mark_tables_colocated</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EnsureCoordinator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>sourceRelationId</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>relationIdArrayObject</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>relationCount</name> <init>= <expr><call><name>ArrayObjectCount</name><argument_list>(<argument><expr><name>relationIdArrayObject</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>relationCount</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"at least one target table is required for this "</literal>
							   <literal type="string">"operation"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>EnsureTableOwner</name><argument_list>(<argument><expr><name>sourceRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>relationIdDatumArray</name> <init>= <expr><call><name>DeconstructArrayObject</name><argument_list>(<argument><expr><name>relationIdArrayObject</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>relationIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>relationIndex</name> <operator>&lt;</operator> <name>relationCount</name></expr>;</condition> <incr><expr><name>relationIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>nextRelationOid</name> <init>= <expr><call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name><name>relationIdDatumArray</name><index>[<expr><name>relationIndex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* we require that the user either owns all tables or is superuser */</comment>
		<expr_stmt><expr><call><name>EnsureTableOwner</name><argument_list>(<argument><expr><name>nextRelationOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MarkTablesColocated</name><argument_list>(<argument><expr><name>sourceRelationId</name></expr></argument>, <argument><expr><name>nextRelationOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * update_distributed_table_colocation updates the colocation of a table.
 * if colocate_with -&gt; 'none' then the table is assigned a new
 * colocation group.
 */</comment>
<function><type><name>Datum</name></type>
<name>update_distributed_table_colocation</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EnsureCoordinator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>targetRelationId</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>colocateWithTableNameText</name> <init>= <expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>EnsureTableOwner</name><argument_list>(<argument><expr><name>targetRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>colocateWithTableName</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><name>colocateWithTableNameText</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsColocateWithNone</name><argument_list>(<argument><expr><name>colocateWithTableName</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>EnsureHashDistributedTable</name><argument_list>(<argument><expr><name>targetRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>BreakColocation</name><argument_list>(<argument><expr><name>targetRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>colocateWithTableId</name> <init>= <expr><call><name>ResolveRelationId</name><argument_list>(<argument><expr><name>colocateWithTableNameText</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>EnsureTableOwner</name><argument_list>(<argument><expr><name>colocateWithTableId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MarkTablesColocated</name><argument_list>(<argument><expr><name>colocateWithTableId</name></expr></argument>, <argument><expr><name>targetRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * IsColocateWithNone returns true if the given table is
 * the special keyword "none".
 */</comment>
<function><type><name>bool</name></type>
<name>IsColocateWithNone</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>colocateWithTableName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>colocateWithTableName</name></expr></argument>, <argument><expr><literal type="string">"none"</literal></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsColocateWithDefault returns true if the given table is
 * the special keyword "default".
 */</comment>
<function><type><name>bool</name></type>
<name>IsColocateWithDefault</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>colocateWithTableName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>colocateWithTableName</name></expr></argument>, <argument><expr><literal type="string">"default"</literal></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * BreakColocation breaks the colocations of the given relation id.
 * If t1, t2 and t3 are colocated and we call this function with t2,
 * t1 and t3 will stay colocated but t2 will have a new colocation id.
 * Note that this function does not move any data around for the new colocation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>BreakColocation</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>sourceRelationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Get an exclusive lock on the colocation system catalog. Therefore, we
	 * can be sure that there will no modifications on the colocation table
	 * until this transaction is committed.
	 */</comment>
	<decl_stmt><decl><type><name>Relation</name></type> <name>pgDistColocation</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><call><name>DistColocationRelationId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint32</name></type> <name>newColocationId</name> <init>= <expr><call><name>GetNextColocationId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>localOnly</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>UpdateRelationColocationGroup</name><argument_list>(<argument><expr><name>sourceRelationId</name></expr></argument>, <argument><expr><name>newColocationId</name></expr></argument>, <argument><expr><name>localOnly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* if there is not any remaining table in the colocation group, delete it */</comment>
	<expr_stmt><expr><call><name>DeleteColocationGroupIfNoTablesBelong</name><argument_list>(<argument><expr><name>sourceRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pgDistColocation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * get_colocated_shards_array returns array of shards ids which are co-located with given
 * shard.
 */</comment>
<function><type><name>Datum</name></type>
<name>get_colocated_shard_array</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>shardId</name> <init>= <expr><call><name>PG_GETARG_UINT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><call><name>LoadShardInterval</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>colocatedShardList</name> <init>= <expr><call><name>ColocatedShardIntervalList</name><argument_list>(<argument><expr><name>shardInterval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>colocatedShardCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>colocatedShardList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>colocatedShardsDatumArray</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><name>colocatedShardCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>arrayTypeId</name> <init>= <expr><name>OIDOID</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>colocatedShardIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>colocatedShardInterval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>colocatedShardInterval</argument>, <argument>colocatedShardList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint64</name></type> <name>colocatedShardId</name> <init>= <expr><name><name>colocatedShardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Datum</name></type> <name>colocatedShardDatum</name> <init>= <expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>colocatedShardId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>colocatedShardsDatumArray</name><index>[<expr><name>colocatedShardIndex</name></expr>]</index></name> <operator>=</operator> <name>colocatedShardDatum</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>colocatedShardIndex</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>colocatedShardsArrayType</name> <init>= <expr><call><name>DatumArrayToArrayType</name><argument_list>(<argument><expr><name>colocatedShardsDatumArray</name></expr></argument>,
																<argument><expr><name>colocatedShardCount</name></expr></argument>,
																<argument><expr><name>arrayTypeId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_ARRAYTYPE_P</name><argument_list>(<argument><expr><name>colocatedShardsArrayType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CreateColocationGroupForRelation creates colocation entry in
 * pg_dist_colocation and updated the colocation id in pg_dist_partition
 * for the given relation.
 */</comment>
<function><type><specifier>static</specifier> <name>uint32</name></type>
<name>CreateColocationGroupForRelation</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>sourceRelationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>shardCount</name> <init>= <expr><call><name>ShardIntervalCount</name><argument_list>(<argument><expr><name>sourceRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>shardReplicationFactor</name> <init>= <expr><call><name>TableShardReplicationFactor</name><argument_list>(<argument><expr><name>sourceRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>sourceDistributionColumn</name> <init>= <expr><call><name>DistPartitionKey</name><argument_list>(<argument><expr><name>sourceRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>sourceDistributionColumnType</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>sourceDistributionColumnCollation</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* reference tables has NULL distribution column */</comment>
	<if_stmt><if>if <condition>(<expr><name>sourceDistributionColumn</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>sourceDistributionColumnType</name> <operator>=</operator> <name><name>sourceDistributionColumn</name><operator>-&gt;</operator><name>vartype</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>sourceDistributionColumnCollation</name> <operator>=</operator> <name><name>sourceDistributionColumn</name><operator>-&gt;</operator><name>varcollid</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>uint32</name></type> <name>sourceColocationId</name> <init>= <expr><call><name>CreateColocationGroup</name><argument_list>(<argument><expr><name>shardCount</name></expr></argument>, <argument><expr><name>shardReplicationFactor</name></expr></argument>,
													  <argument><expr><name>sourceDistributionColumnType</name></expr></argument>,
													  <argument><expr><name>sourceDistributionColumnCollation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>localOnly</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>UpdateRelationColocationGroup</name><argument_list>(<argument><expr><name>sourceRelationId</name></expr></argument>, <argument><expr><name>sourceColocationId</name></expr></argument>, <argument><expr><name>localOnly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>sourceColocationId</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * MarkTablesColocated puts both tables to same colocation group. If the
 * source table is in INVALID_COLOCATION_ID group, then it creates a new
 * colocation group and assigns both tables to same colocation group. Otherwise,
 * it adds the target table to colocation group of the source table.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>MarkTablesColocated</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>sourceRelationId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>targetRelationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>sourceRelationId</name></expr></argument>, <argument><expr><name>CITUS_LOCAL_TABLE</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>targetRelationId</name></expr></argument>, <argument><expr><name>CITUS_LOCAL_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"local tables cannot be colocated with "</literal>
							   <literal type="string">"other tables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>EnsureHashDistributedTable</name><argument_list>(<argument><expr><name>sourceRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EnsureHashDistributedTable</name><argument_list>(<argument><expr><name>targetRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CheckReplicationModel</name><argument_list>(<argument><expr><name>sourceRelationId</name></expr></argument>, <argument><expr><name>targetRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CheckDistributionColumnType</name><argument_list>(<argument><expr><name>sourceRelationId</name></expr></argument>, <argument><expr><name>targetRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get an exclusive lock on the colocation system catalog. Therefore, we
	 * can be sure that there will no modifications on the colocation table
	 * until this transaction is committed.
	 */</comment>
	<decl_stmt><decl><type><name>Relation</name></type> <name>pgDistColocation</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><call><name>DistColocationRelationId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* check if shard placements are colocated */</comment>
	<expr_stmt><expr><call><name>ErrorIfShardPlacementsNotColocated</name><argument_list>(<argument><expr><name>sourceRelationId</name></expr></argument>, <argument><expr><name>targetRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get colocation group of the source table, if the source table does not
	 * have a colocation group, create a new one, and set it for the source table.
	 */</comment>
	<decl_stmt><decl><type><name>uint32</name></type> <name>sourceColocationId</name> <init>= <expr><call><name>TableColocationId</name><argument_list>(<argument><expr><name>sourceRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>sourceColocationId</name> <operator>==</operator> <name>INVALID_COLOCATION_ID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>sourceColocationId</name> <operator>=</operator> <call><name>CreateColocationGroupForRelation</name><argument_list>(<argument><expr><name>sourceRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>uint32</name></type> <name>targetColocationId</name> <init>= <expr><call><name>TableColocationId</name><argument_list>(<argument><expr><name>targetRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* finally set colocation group for the target relation */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>localOnly</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>UpdateRelationColocationGroup</name><argument_list>(<argument><expr><name>targetRelationId</name></expr></argument>, <argument><expr><name>sourceColocationId</name></expr></argument>, <argument><expr><name>localOnly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* if there is not any remaining table in the colocation group, delete it */</comment>
	<expr_stmt><expr><call><name>DeleteColocationGroupIfNoTablesBelong</name><argument_list>(<argument><expr><name>targetColocationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pgDistColocation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ErrorIfShardPlacementsNotColocated checks if the shard placements of the
 * given two relations are physically colocated. It errors out in any of
 * following cases:
 * 1.Shard counts are different,
 * 2.Shard intervals don't match
 * 3.Matching shard intervals have different number of shard placements
 * 4.Shard placements are not colocated (not on the same node)
 * 5.Shard placements have different health states
 *
 * Note that, this functions assumes that both tables are hash distributed.
 */</comment>
<function><type><name>void</name></type>
<name>ErrorIfShardPlacementsNotColocated</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>leftRelationId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>rightRelationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* get sorted shard interval lists for both tables */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>leftShardIntervalList</name> <init>= <expr><call><name>LoadShardIntervalList</name><argument_list>(<argument><expr><name>leftRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rightShardIntervalList</name> <init>= <expr><call><name>LoadShardIntervalList</name><argument_list>(<argument><expr><name>rightRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* prevent concurrent placement changes */</comment>
	<expr_stmt><expr><call><name>LockShardListMetadata</name><argument_list>(<argument><expr><name>leftShardIntervalList</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LockShardListMetadata</name><argument_list>(<argument><expr><name>rightShardIntervalList</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>leftRelationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>leftRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>rightRelationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>rightRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint32</name></type> <name>leftShardCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>leftShardIntervalList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>rightShardCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>rightShardIntervalList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>leftShardCount</name> <operator>!=</operator> <name>rightShardCount</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot colocate tables %s and %s"</literal></expr></argument>,
							   <argument><expr><name>leftRelationName</name></expr></argument>, <argument><expr><name>rightRelationName</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Shard counts don't match for %s and %s."</literal></expr></argument>,
								  <argument><expr><name>leftRelationName</name></expr></argument>, <argument><expr><name>rightRelationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* compare shard intervals one by one */</comment>
	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>leftInterval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>rightInterval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>forboth_ptr</name><argument_list>(<argument>leftInterval</argument>, <argument>leftShardIntervalList</argument>,
				<argument>rightInterval</argument>, <argument>rightShardIntervalList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint64</name></type> <name>leftShardId</name> <init>= <expr><name><name>leftInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type> <name>rightShardId</name> <init>= <expr><name><name>rightInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>bool</name></type> <name>shardsIntervalsEqual</name> <init>= <expr><call><name>ShardsIntervalsEqual</name><argument_list>(<argument><expr><name>leftInterval</name></expr></argument>, <argument><expr><name>rightInterval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>shardsIntervalsEqual</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot colocate tables %s and %s"</literal></expr></argument>,
								   <argument><expr><name>leftRelationName</name></expr></argument>, <argument><expr><name>rightRelationName</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Shard intervals don't match for %s and %s."</literal></expr></argument>,
									  <argument><expr><name>leftRelationName</name></expr></argument>, <argument><expr><name>rightRelationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>leftPlacementList</name> <init>= <expr><call><name>ShardPlacementListWithoutOrphanedPlacements</name><argument_list>(
			<argument><expr><name>leftShardId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rightPlacementList</name> <init>= <expr><call><name>ShardPlacementListWithoutOrphanedPlacements</name><argument_list>(
			<argument><expr><name>rightShardId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>leftPlacementList</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>rightPlacementList</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot colocate tables %s and %s"</literal></expr></argument>,
								   <argument><expr><name>leftRelationName</name></expr></argument>, <argument><expr><name>rightRelationName</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Shard "</literal> <name>UINT64_FORMAT</name>
									  <literal type="string">" of %s and shard "</literal> <name>UINT64_FORMAT</name>
									  <literal type="string">" of %s have different number of shard placements."</literal></expr></argument>,
									  <argument><expr><name>leftShardId</name></expr></argument>, <argument><expr><name>leftRelationName</name></expr></argument>,
									  <argument><expr><name>rightShardId</name></expr></argument>, <argument><expr><name>rightRelationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* sort shard placements according to the node */</comment>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>sortedLeftPlacementList</name> <init>= <expr><call><name>SortList</name><argument_list>(<argument><expr><name>leftPlacementList</name></expr></argument>,
												 <argument><expr><name>CompareShardPlacementsByNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>sortedRightPlacementList</name> <init>= <expr><call><name>SortList</name><argument_list>(<argument><expr><name>rightPlacementList</name></expr></argument>,
												  <argument><expr><name>CompareShardPlacementsByNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* compare shard placements one by one */</comment>
		<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>leftPlacement</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>rightPlacement</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>forboth_ptr</name><argument_list>(<argument>leftPlacement</argument>, <argument>sortedLeftPlacementList</argument>,
					<argument>rightPlacement</argument>, <argument>sortedRightPlacementList</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/*
			 * If shard placements are on different nodes, these shard
			 * placements are not colocated.
			 */</comment>
			<decl_stmt><decl><type><name>int</name></type> <name>nodeCompare</name> <init>= <expr><call><name>CompareShardPlacementsByNode</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>leftPlacement</name></expr></argument>,
														   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>rightPlacement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>nodeCompare</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot colocate tables %s and %s"</literal></expr></argument>,
									   <argument><expr><name>leftRelationName</name></expr></argument>, <argument><expr><name>rightRelationName</name></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Shard "</literal> <name>UINT64_FORMAT</name> <literal type="string">" of %s and shard "</literal>
										  <name>UINT64_FORMAT</name> <literal type="string">" of %s are not colocated."</literal></expr></argument>,
										  <argument><expr><name>leftShardId</name></expr></argument>, <argument><expr><name>leftRelationName</name></expr></argument>,
										  <argument><expr><name>rightShardId</name></expr></argument>, <argument><expr><name>rightRelationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* we also don't allow colocated shards to be in different shard states */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>leftPlacement</name><operator>-&gt;</operator><name>shardState</name></name> <operator>!=</operator> <name><name>rightPlacement</name><operator>-&gt;</operator><name>shardState</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot colocate tables %s and %s"</literal></expr></argument>,
									   <argument><expr><name>leftRelationName</name></expr></argument>, <argument><expr><name>rightRelationName</name></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s and %s have shard placements in "</literal>
										  <literal type="string">"different shard states."</literal></expr></argument>,
										  <argument><expr><name>leftRelationName</name></expr></argument>, <argument><expr><name>rightRelationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * ShardsIntervalsEqual checks if two shard intervals of distributed
 * tables are equal.
 *
 * Notes on the function:
 * (i)   The function returns true if both shard intervals are the same.
 * (ii)  The function returns false even if the shard intervals equal, but,
 *       their distribution method are different.
 * (iii) The function returns false for append and range partitioned tables
 *       excluding (i) case.
 * (iv)  For reference tables, all shards are equal (i.e., same replication factor
 *       and shard min/max values). Thus, always return true for shards of reference
 *       tables.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ShardsIntervalsEqual</name><parameter_list>(<parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>leftShardInterval</name></decl></parameter>, <parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>rightShardInterval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name>leftIntervalPartitionMethod</name> <init>= <expr><call><name>PartitionMethod</name><argument_list>(<argument><expr><name><name>leftShardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>rightIntervalPartitionMethod</name> <init>= <expr><call><name>PartitionMethod</name><argument_list>(<argument><expr><name><name>rightShardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* if both shards are the same, return true */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>leftShardInterval</name><operator>-&gt;</operator><name>shardId</name></name> <operator>==</operator> <name><name>rightShardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* if partition methods are not the same, shards cannot be considered as co-located */</comment>
	<expr_stmt><expr><name>leftIntervalPartitionMethod</name> <operator>=</operator> <call><name>PartitionMethod</name><argument_list>(<argument><expr><name><name>leftShardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rightIntervalPartitionMethod</name> <operator>=</operator> <call><name>PartitionMethod</name><argument_list>(<argument><expr><name><name>rightShardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>leftIntervalPartitionMethod</name> <operator>!=</operator> <name>rightIntervalPartitionMethod</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name><name>leftShardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>, <argument><expr><name>HASH_DISTRIBUTED</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>HashPartitionedShardIntervalsEqual</name><argument_list>(<argument><expr><name>leftShardInterval</name></expr></argument>, <argument><expr><name>rightShardInterval</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name><name>leftShardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>,
							  <argument><expr><name>CITUS_TABLE_WITH_NO_DIST_KEY</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Reference tables has only a single shard and all reference tables
		 * are always co-located with each other.
		 */</comment>

		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* append and range partitioned shard never co-located */</comment>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * HashPartitionedShardIntervalsEqual checks if two shard intervals of hash distributed
 * tables are equal. Note that, this function doesn't work with non-hash
 * partitioned table's shards.
 *
 * We do min/max value check here to decide whether two shards are colocated,
 * instead we can simply use ShardIndex function on both shards then
 * but do index check, but we avoid it because this way it is more cheaper.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>HashPartitionedShardIntervalsEqual</name><parameter_list>(<parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>leftShardInterval</name></decl></parameter>,
								   <parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>rightShardInterval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type> <name>leftShardMinValue</name> <init>= <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>leftShardInterval</name><operator>-&gt;</operator><name>minValue</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>leftShardMaxValue</name> <init>= <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>leftShardInterval</name><operator>-&gt;</operator><name>maxValue</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>rightShardMinValue</name> <init>= <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>rightShardInterval</name><operator>-&gt;</operator><name>minValue</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>rightShardMaxValue</name> <init>= <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>rightShardInterval</name><operator>-&gt;</operator><name>maxValue</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>minValuesEqual</name> <init>= <expr><name>leftShardMinValue</name> <operator>==</operator> <name>rightShardMinValue</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>maxValuesEqual</name> <init>= <expr><name>leftShardMaxValue</name> <operator>==</operator> <name>rightShardMaxValue</name></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>minValuesEqual</name> <operator>&amp;&amp;</operator> <name>maxValuesEqual</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CompareShardPlacementsByNode compares two shard placements by their nodename
 * and nodeport.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>CompareShardPlacementsByNode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>leftElement</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>rightElement</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ShardPlacement</name> <modifier>*</modifier></type><name>leftPlacement</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>ShardPlacement</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>leftElement</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ShardPlacement</name> <modifier>*</modifier></type><name>rightPlacement</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>ShardPlacement</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>rightElement</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<comment type="block">/* if node names are same, check node ports */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>leftPlacement</name><operator>-&gt;</operator><name>nodeId</name></name> <operator>&lt;</operator> <name><name>rightPlacement</name><operator>-&gt;</operator><name>nodeId</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>leftPlacement</name><operator>-&gt;</operator><name>nodeId</name></name> <operator>&gt;</operator> <name><name>rightPlacement</name><operator>-&gt;</operator><name>nodeId</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ColocationId searches pg_dist_colocation for shard count, replication factor,
 * distribution column type, and distribution column collation. If a matching entry
 * is found, it returns the colocation id, otherwise returns INVALID_COLOCATION_ID.
 */</comment>
<function><type><name>uint32</name></type>
<name>ColocationId</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>shardCount</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>replicationFactor</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>distributionColumnType</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type>
			 <name>distributionColumnCollation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>colocationId</name> <init>= <expr><name>INVALID_COLOCATION_ID</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>scanKeyCount</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scanKey</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>indexOK</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>pgDistColocation</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><call><name>DistColocationRelationId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* set scan arguments */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_pg_dist_colocation_distributioncolumntype</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>distributionColumnType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanKey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_pg_dist_colocation_shardcount</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_INT4EQ</name></expr></argument>, <argument><expr><call><name>UInt32GetDatum</name><argument_list>(<argument><expr><name>shardCount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanKey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_pg_dist_colocation_replicationfactor</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_INT4EQ</name></expr></argument>, <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>replicationFactor</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanKey</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_pg_dist_colocation_distributioncolumncollation</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(
					<argument><expr><name>distributionColumnCollation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scanDescriptor</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pgDistColocation</name></expr></argument>,
													<argument><expr><call><name>DistColocationConfigurationIndexId</name><argument_list>()</argument_list></call></expr></argument>,
													<argument><expr><name>indexOK</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>scanKeyCount</name></expr></argument>, <argument><expr><name>scanKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>colocationTuple</name> <init>= <expr><call><name>systable_getnext</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>colocationTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_dist_colocation</name></type> <name>colocationForm</name> <init>=
			<expr><operator>(</operator><name>Form_pg_dist_colocation</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>colocationTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>colocationId</name> <operator>==</operator> <name>INVALID_COLOCATION_ID</name> <operator>||</operator> <name>colocationId</name> <operator>&gt;</operator>
			<name><name>colocationForm</name><operator>-&gt;</operator><name>colocationid</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We assign the smallest colocation id among all the matches so that we
			 * assign the same colocation group for similar distributed tables
			 */</comment>
			<expr_stmt><expr><name>colocationId</name> <operator>=</operator> <name><name>colocationForm</name><operator>-&gt;</operator><name>colocationid</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>colocationTuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pgDistColocation</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>colocationId</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AcquireColocationDefaultLock serializes concurrent creation of a colocation entry
 * for default group.
 */</comment>
<function><type><name>void</name></type>
<name>AcquireColocationDefaultLock</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKTAG</name></type> <name>tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>sessionLock</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>dontWait</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SET_LOCKTAG_CITUS_OPERATION</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>CITUS_CREATE_COLOCATION_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>, <argument><expr><name>sessionLock</name></expr></argument>, <argument><expr><name>dontWait</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ReleaseColocationDefaultLock releases the lock for concurrent creation of a colocation entry
 * for default group.
 */</comment>
<function><type><name>void</name></type>
<name>ReleaseColocationDefaultLock</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKTAG</name></type> <name>tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>sessionLock</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SET_LOCKTAG_CITUS_OPERATION</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>CITUS_CREATE_COLOCATION_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>, <argument><expr><name>sessionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CreateColocationGroup creates a new colocation id and writes it into
 * pg_dist_colocation with the given configuration. It also returns the created
 * colocation id.
 */</comment>
<function><type><name>uint32</name></type>
<name>CreateColocationGroup</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>shardCount</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>replicationFactor</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>distributionColumnType</name></decl></parameter>,
					  <parameter><decl><type><name>Oid</name></type> <name>distributionColumnCollation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>colocationId</name> <init>= <expr><call><name>GetNextColocationId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>InsertColocationGroupLocally</name><argument_list>(<argument><expr><name>colocationId</name></expr></argument>, <argument><expr><name>shardCount</name></expr></argument>, <argument><expr><name>replicationFactor</name></expr></argument>,
								 <argument><expr><name>distributionColumnType</name></expr></argument>, <argument><expr><name>distributionColumnCollation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SyncNewColocationGroupToNodes</name><argument_list>(<argument><expr><name>colocationId</name></expr></argument>, <argument><expr><name>shardCount</name></expr></argument>, <argument><expr><name>replicationFactor</name></expr></argument>,
								  <argument><expr><name>distributionColumnType</name></expr></argument>, <argument><expr><name>distributionColumnCollation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>colocationId</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * InsertColocationGroupLocally inserts a record into pg_dist_colocation.
 */</comment>
<function><type><name>void</name></type>
<name>InsertColocationGroupLocally</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>colocationId</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>shardCount</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>replicationFactor</name></decl></parameter>,
							 <parameter><decl><type><name>Oid</name></type> <name>distributionColumnType</name></decl></parameter>,
							 <parameter><decl><type><name>Oid</name></type> <name>distributionColumnCollation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type> <name><name>values</name><index>[<expr><name>Natts_pg_dist_colocation</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name><name>isNulls</name><index>[<expr><name>Natts_pg_dist_colocation</name></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* form new colocation tuple */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>isNulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>isNulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_dist_colocation_colocationid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>UInt32GetDatum</name><argument_list>(<argument><expr><name>colocationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_dist_colocation_shardcount</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>UInt32GetDatum</name><argument_list>(<argument><expr><name>shardCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_dist_colocation_replicationfactor</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
		<call><name>UInt32GetDatum</name><argument_list>(<argument><expr><name>replicationFactor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_dist_colocation_distributioncolumntype</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
		<call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>distributionColumnType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_dist_colocation_distributioncolumncollation</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
		<call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>distributionColumnCollation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* open colocation relation and insert the new tuple */</comment>
	<decl_stmt><decl><type><name>Relation</name></type> <name>pgDistColocation</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><call><name>DistColocationRelationId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pgDistColocation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>heapTuple</name> <init>= <expr><call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isNulls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CatalogTupleInsert</name><argument_list>(<argument><expr><name>pgDistColocation</name></expr></argument>, <argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* increment the counter so that next command can see the row */</comment>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pgDistColocation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * GetNextColocationId allocates and returns a unique colocationId for the
 * colocation group to be created. This allocation occurs both in shared memory
 * and in write ahead logs; writing to logs avoids the risk of having
 * colocationId collisions.
 *
 * Please note that the caller is still responsible for finalizing colocationId
 * with the master node. Further note that this function relies on an internal
 * sequence created in initdb to generate unique identifiers.
 */</comment>
<function><type><name>uint32</name></type>
<name>GetNextColocationId</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>sequenceName</name> <init>= <expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name>COLOCATIONID_SEQUENCE_NAME</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>sequenceId</name> <init>= <expr><call><name>ResolveRelationId</name><argument_list>(<argument><expr><name>sequenceName</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>sequenceIdDatum</name> <init>= <expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>sequenceId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>savedUserId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>savedSecurityContext</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>GetUserIdAndSecContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>savedUserId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>savedSecurityContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetUserIdAndSecContext</name><argument_list>(<argument><expr><call><name>CitusExtensionOwner</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>SECURITY_LOCAL_USERID_CHANGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* generate new and unique colocation id from sequence */</comment>
	<decl_stmt><decl><type><name>Datum</name></type> <name>colocationIdDatum</name> <init>= <expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>nextval_oid</name></expr></argument>, <argument><expr><name>sequenceIdDatum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SetUserIdAndSecContext</name><argument_list>(<argument><expr><name>savedUserId</name></expr></argument>, <argument><expr><name>savedSecurityContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>uint32</name></type> <name>colocationId</name> <init>= <expr><call><name>DatumGetUInt32</name><argument_list>(<argument><expr><name>colocationIdDatum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>colocationId</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CheckReplicationModel checks if given relations are from the same
 * replication model. Otherwise, it errors out.
 */</comment>
<function><type><name>void</name></type>
<name>CheckReplicationModel</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>sourceRelationId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>targetRelationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>sourceTableEntry</name> <init>= <expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name>sourceRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>sourceReplicationModel</name> <init>= <expr><name><name>sourceTableEntry</name><operator>-&gt;</operator><name>replicationModel</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>targetTableEntry</name> <init>= <expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name>targetRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>targetReplicationModel</name> <init>= <expr><name><name>targetTableEntry</name><operator>-&gt;</operator><name>replicationModel</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>sourceReplicationModel</name> <operator>!=</operator> <name>targetReplicationModel</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sourceRelationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>sourceRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>targetRelationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>targetRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot colocate tables %s and %s"</literal></expr></argument>,
							   <argument><expr><name>sourceRelationName</name></expr></argument>, <argument><expr><name>targetRelationName</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Replication models don't match for %s and %s."</literal></expr></argument>,
								  <argument><expr><name>sourceRelationName</name></expr></argument>, <argument><expr><name>targetRelationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CheckDistributionColumnType checks if distribution column types of relations
 * are same. Otherwise, it errors out.
 */</comment>
<function><type><name>void</name></type>
<name>CheckDistributionColumnType</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>sourceRelationId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>targetRelationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* reference tables have NULL distribution column */</comment>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>sourceDistributionColumn</name> <init>= <expr><call><name>DistPartitionKey</name><argument_list>(<argument><expr><name>sourceRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* reference tables have NULL distribution column */</comment>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>targetDistributionColumn</name> <init>= <expr><call><name>DistPartitionKey</name><argument_list>(<argument><expr><name>targetRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>EnsureColumnTypeEquality</name><argument_list>(<argument><expr><name>sourceRelationId</name></expr></argument>, <argument><expr><name>targetRelationId</name></expr></argument>,
							 <argument><expr><name>sourceDistributionColumn</name></expr></argument>, <argument><expr><name>targetDistributionColumn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * EnsureColumnTypeEquality checks if distribution column types and collations
 * of the given columns are same. The function sets the boolean pointers.
 */</comment>
<function><type><name>void</name></type>
<name>EnsureColumnTypeEquality</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>sourceRelationId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>targetRelationId</name></decl></parameter>,
						 <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>sourceDistributionColumn</name></decl></parameter>, <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>targetDistributionColumn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>sourceDistributionColumnType</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>targetDistributionColumnType</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>sourceDistributionColumnCollation</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>targetDistributionColumnCollation</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>sourceDistributionColumn</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>sourceDistributionColumnType</name> <operator>=</operator> <name><name>sourceDistributionColumn</name><operator>-&gt;</operator><name>vartype</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>sourceDistributionColumnCollation</name> <operator>=</operator> <name><name>sourceDistributionColumn</name><operator>-&gt;</operator><name>varcollid</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>targetDistributionColumn</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>targetDistributionColumnType</name> <operator>=</operator> <name><name>targetDistributionColumn</name><operator>-&gt;</operator><name>vartype</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>targetDistributionColumnCollation</name> <operator>=</operator> <name><name>targetDistributionColumn</name><operator>-&gt;</operator><name>varcollid</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>columnTypesSame</name> <init>= <expr><name>sourceDistributionColumnType</name> <operator>==</operator> <name>targetDistributionColumnType</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>columnCollationsSame</name> <init>=
		<expr><name>sourceDistributionColumnCollation</name> <operator>==</operator> <name>targetDistributionColumnCollation</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>columnTypesSame</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sourceRelationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>sourceRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>targetRelationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>targetRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot colocate tables %s and %s"</literal></expr></argument>,
							   <argument><expr><name>sourceRelationName</name></expr></argument>, <argument><expr><name>targetRelationName</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Distribution column types don't match for "</literal>
								  <literal type="string">"%s and %s."</literal></expr></argument>, <argument><expr><name>sourceRelationName</name></expr></argument>,
								  <argument><expr><name>targetRelationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>columnCollationsSame</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sourceRelationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>sourceRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>targetRelationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>targetRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot colocate tables %s and %s"</literal></expr></argument>,
							   <argument><expr><name>sourceRelationName</name></expr></argument>, <argument><expr><name>targetRelationName</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(
							<argument><expr><literal type="string">"Distribution column collations don't match for "</literal>
							<literal type="string">"%s and %s."</literal></expr></argument>, <argument><expr><name>sourceRelationName</name></expr></argument>,
							<argument><expr><name>targetRelationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * UpdateRelationColocationGroup updates colocation group in pg_dist_partition
 * for the given relation.
 *
 * When localOnly is true, the function does not propagate changes to the
 * metadata workers.
 */</comment>
<function><type><name>void</name></type>
<name>UpdateRelationColocationGroup</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>distributedRelationId</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>colocationId</name></decl></parameter>,
							  <parameter><decl><type><name>bool</name></type> <name>localOnly</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>indexOK</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>scanKeyCount</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scanKey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name><name>values</name><index>[<expr><name>Natts_pg_dist_partition</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name><name>isNull</name><index>[<expr><name>Natts_pg_dist_partition</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name><name>replace</name><index>[<expr><name>Natts_pg_dist_partition</name></expr>]</index></name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>pgDistPartition</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><call><name>DistPartitionRelationId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pgDistPartition</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_pg_dist_partition_logicalrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>distributedRelationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scanDescriptor</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pgDistPartition</name></expr></argument>,
													<argument><expr><call><name>DistPartitionLogicalRelidIndexId</name><argument_list>()</argument_list></call></expr></argument>,
													<argument><expr><name>indexOK</name></expr></argument>,
													<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>scanKeyCount</name></expr></argument>, <argument><expr><name>scanKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>heapTuple</name> <init>= <expr><call><name>systable_getnext</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>distributedRelationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>distributedRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not find valid entry for relation %s"</literal></expr></argument>,
							   <argument><expr><name>distributedRelationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>isNull</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>isNull</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>replace</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>replace</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_dist_partition_colocationid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>UInt32GetDatum</name><argument_list>(<argument><expr><name>colocationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>isNull</name><index>[<expr><name>Anum_pg_dist_partition_colocationid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>replace</name><index>[<expr><name>Anum_pg_dist_partition_colocationid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>heapTuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>, <argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isNull</name></expr></argument>, <argument><expr><name>replace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>pgDistPartition</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>heapTuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CitusInvalidateRelcacheByRelid</name><argument_list>(<argument><expr><name>distributedRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pgDistPartition</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>shouldSyncMetadata</name> <init>= <expr><call><name>ShouldSyncTableMetadata</name><argument_list>(<argument><expr><name>distributedRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>shouldSyncMetadata</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>localOnly</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>updateColocationIdCommand</name> <init>= <expr><call><name>ColocationIdUpdateCommand</name><argument_list>(<argument><expr><name>distributedRelationId</name></expr></argument>,
																	<argument><expr><name>colocationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>SendCommandToWorkersWithMetadata</name><argument_list>(<argument><expr><name>updateColocationIdCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * TableColocationId function returns co-location id of given table. This function
 * errors out if given table is not distributed.
 */</comment>
<function><type><name>uint32</name></type>
<name>TableColocationId</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>distributedTableId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>cacheEntry</name> <init>= <expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name>distributedTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>colocationId</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * TablesColocated function checks whether given two tables are co-located and
 * returns true if they are co-located. A table is always co-located with itself.
 * If given two tables are different and they are not distributed, this function
 * errors out.
 */</comment>
<function><type><name>bool</name></type>
<name>TablesColocated</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>leftDistributedTableId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>rightDistributedTableId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>leftDistributedTableId</name> <operator>==</operator> <name>rightDistributedTableId</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>uint32</name></type> <name>leftColocationId</name> <init>= <expr><call><name>TableColocationId</name><argument_list>(<argument><expr><name>leftDistributedTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>rightColocationId</name> <init>= <expr><call><name>TableColocationId</name><argument_list>(<argument><expr><name>rightDistributedTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>leftColocationId</name> <operator>==</operator> <name>INVALID_COLOCATION_ID</name> <operator>||</operator>
		<name>rightColocationId</name> <operator>==</operator> <name>INVALID_COLOCATION_ID</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>leftColocationId</name> <operator>==</operator> <name>rightColocationId</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ShardsColocated function checks whether given two shards are co-located and
 * returns true if they are co-located. Two shards are co-located either;
 * - They are same (A shard is always co-located with itself).
 * OR
 * - Tables are hash partitioned.
 * - Tables containing the shards are co-located.
 * - Min/Max values of the shards are same.
 */</comment>
<function><type><name>bool</name></type>
<name>ShardsColocated</name><parameter_list>(<parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>leftShardInterval</name></decl></parameter>, <parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>rightShardInterval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>tablesColocated</name> <init>= <expr><call><name>TablesColocated</name><argument_list>(<argument><expr><name><name>leftShardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>,
										   <argument><expr><name><name>rightShardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>tablesColocated</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>shardIntervalEqual</name> <init>= <expr><call><name>ShardsIntervalsEqual</name><argument_list>(<argument><expr><name>leftShardInterval</name></expr></argument>,
													   <argument><expr><name>rightShardInterval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<return>return <expr><name>shardIntervalEqual</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColocatedTableList function returns list of relation ids which are co-located
 * with given table. If given table is not hash distributed, co-location is not
 * valid for that table and it is only co-located with itself.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>ColocatedTableList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>distributedTableId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>tableColocationId</name> <init>= <expr><call><name>TableColocationId</name><argument_list>(<argument><expr><name>distributedTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>colocatedTableList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If distribution type of the table is not hash, the table is only co-located
	 * with itself.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>tableColocationId</name> <operator>==</operator> <name>INVALID_COLOCATION_ID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>colocatedTableList</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>colocatedTableList</name></expr></argument>, <argument><expr><name>distributedTableId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>colocatedTableList</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>colocatedTableList</name> <operator>=</operator> <call><name>ColocationGroupTableList</name><argument_list>(<argument><expr><name>tableColocationId</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>colocatedTableList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColocationGroupTableList returns the list of tables in the given colocation
 * group. If the colocation group is INVALID_COLOCATION_ID, it returns NIL.
 *
 * If count is zero then the command is executed for all rows that it applies to.
 * If count is greater than zero, then no more than count rows will be retrieved;
 * execution stops when the count is reached, much like adding a LIMIT clause
 * to the query.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>ColocationGroupTableList</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>colocationId</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>colocatedTableList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>indexOK</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>scanKeyCount</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scanKey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If distribution type of the table is not hash, the table is only co-located
	 * with itself.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>colocationId</name> <operator>==</operator> <name>INVALID_COLOCATION_ID</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_pg_dist_partition_colocationid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_INT4EQ</name></expr></argument>, <argument><expr><call><name>UInt32GetDatum</name><argument_list>(<argument><expr><name>colocationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>pgDistPartition</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><call><name>DistPartitionRelationId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pgDistPartition</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scanDescriptor</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pgDistPartition</name></expr></argument>,
													<argument><expr><call><name>DistPartitionColocationidIndexId</name><argument_list>()</argument_list></call></expr></argument>,
													<argument><expr><name>indexOK</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>scanKeyCount</name></expr></argument>, <argument><expr><name>scanKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>heapTuple</name> <init>= <expr><call><name>systable_getnext</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name><name>isNullArray</name><index>[<expr><name>Natts_pg_dist_partition</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type> <name><name>datumArray</name><index>[<expr><name>Natts_pg_dist_partition</name></expr>]</index></name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>, <argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><name>datumArray</name></expr></argument>, <argument><expr><name>isNullArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>colocatedTableId</name> <init>= <expr><call><name>DatumGetObjectId</name><argument_list>(
			<argument><expr><name><name>datumArray</name><index>[<expr><name>Anum_pg_dist_partition_logicalrelid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>colocatedTableList</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>colocatedTableList</name></expr></argument>, <argument><expr><name>colocatedTableId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>heapTuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* fetch all rows */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>colocatedTableList</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>count</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* we are done */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pgDistPartition</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>colocatedTableList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColocatedShardIntervalList function returns list of shard intervals which are
 * co-located with given shard. If given shard is belong to append or range distributed
 * table, co-location is not valid for that shard. Therefore such shard is only co-located
 * with itself.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>ColocatedShardIntervalList</name><parameter_list>(<parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distributedTableId</name> <init>= <expr><name><name>shardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>colocatedShardList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>cacheEntry</name> <init>= <expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name>distributedTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If distribution type of the table is append or range, each shard of
	 * the shard is only co-located with itself.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableTypeCacheEntry</name><argument_list>(<argument><expr><name>cacheEntry</name></expr></argument>, <argument><expr><name>APPEND_DISTRIBUTED</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>IsCitusTableTypeCacheEntry</name><argument_list>(<argument><expr><name>cacheEntry</name></expr></argument>, <argument><expr><name>RANGE_DISTRIBUTED</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>copyShardInterval</name> <init>= <expr><call><name>CopyShardInterval</name><argument_list>(<argument><expr><name>shardInterval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>colocatedShardList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>colocatedShardList</name></expr></argument>, <argument><expr><name>copyShardInterval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>colocatedShardList</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>shardIntervalIndex</name> <init>= <expr><call><name>ShardIndex</name><argument_list>(<argument><expr><name>shardInterval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>colocatedTableList</name> <init>= <expr><call><name>ColocatedTableList</name><argument_list>(<argument><expr><name>distributedTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* ShardIndex have to find index of given shard */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>shardIntervalIndex</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>colocatedTableId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>colocatedTableId</argument>, <argument>colocatedTableList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>colocatedTableCacheEntry</name> <init>=
			<expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name>colocatedTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Since we iterate over co-located tables, shard count of each table should be
		 * same and greater than shardIntervalIndex.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>shardIntervalArrayLength</name></name> <operator>==</operator>
			   <name><name>colocatedTableCacheEntry</name><operator>-&gt;</operator><name>shardIntervalArrayLength</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>colocatedShardInterval</name> <init>=
			<expr><name><name>colocatedTableCacheEntry</name><operator>-&gt;</operator><name>sortedShardIntervalArray</name><index>[<expr><name>shardIntervalIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>copyShardInterval</name> <init>= <expr><call><name>CopyShardInterval</name><argument_list>(<argument><expr><name>colocatedShardInterval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>colocatedShardList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>colocatedShardList</name></expr></argument>, <argument><expr><name>copyShardInterval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>colocatedTableList</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>colocatedShardList</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>SortList</name><argument_list>(<argument><expr><name>colocatedShardList</name></expr></argument>, <argument><expr><name>CompareShardIntervalsById</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColocatedNonPartitionShardIntervalList function returns list of shard intervals
 * which are co-located with given shard, except partitions. If given shard is belong
 * to append or range distributed table, co-location is not valid for that shard.
 * Therefore such shard is only co-located with itself.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>ColocatedNonPartitionShardIntervalList</name><parameter_list>(<parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distributedTableId</name> <init>= <expr><name><name>shardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>colocatedShardList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>cacheEntry</name> <init>= <expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name>distributedTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If distribution type of the table is append or range, each shard of the shard
	 * is only co-located with itself. We don't expect this case to happen, since
	 * distributing partitioned tables in only supported for hash-distributed tables.
	 * Therefore, currently we can't cover here with a test.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableTypeCacheEntry</name><argument_list>(<argument><expr><name>cacheEntry</name></expr></argument>, <argument><expr><name>APPEND_DISTRIBUTED</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>IsCitusTableTypeCacheEntry</name><argument_list>(<argument><expr><name>cacheEntry</name></expr></argument>, <argument><expr><name>RANGE_DISTRIBUTED</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>copyShardInterval</name> <init>= <expr><call><name>CopyShardInterval</name><argument_list>(<argument><expr><name>shardInterval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>colocatedShardList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>colocatedShardList</name></expr></argument>, <argument><expr><name>copyShardInterval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>colocatedShardList</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skipping child tables for relation named: %s"</literal></expr></argument>,
							<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>distributedTableId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>shardIntervalIndex</name> <init>= <expr><call><name>ShardIndex</name><argument_list>(<argument><expr><name>shardInterval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>colocatedTableList</name> <init>= <expr><call><name>ColocatedTableList</name><argument_list>(<argument><expr><name>distributedTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* ShardIndex have to find index of given shard */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>shardIntervalIndex</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>colocatedTableId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>colocatedTableId</argument>, <argument>colocatedTableList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>PartitionTable</name><argument_list>(<argument><expr><name>colocatedTableId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>colocatedTableCacheEntry</name> <init>=
			<expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name>colocatedTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Since we iterate over co-located tables, shard count of each table should be
		 * same and greater than shardIntervalIndex.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>shardIntervalArrayLength</name></name> <operator>==</operator>
			   <name><name>colocatedTableCacheEntry</name><operator>-&gt;</operator><name>shardIntervalArrayLength</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>colocatedShardInterval</name> <init>=
			<expr><name><name>colocatedTableCacheEntry</name><operator>-&gt;</operator><name>sortedShardIntervalArray</name><index>[<expr><name>shardIntervalIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>copyShardInterval</name> <init>= <expr><call><name>CopyShardInterval</name><argument_list>(<argument><expr><name>colocatedShardInterval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>colocatedShardList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>colocatedShardList</name></expr></argument>, <argument><expr><name>copyShardInterval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><call><name>SortList</name><argument_list>(<argument><expr><name>colocatedShardList</name></expr></argument>, <argument><expr><name>CompareShardIntervalsById</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColocatedTableId returns an arbitrary table which belongs to given colocation
 * group. If there is not such a colocation group, it returns invalid oid.
 *
 * This function also takes an AccessShareLock on the co-colocated table to
 * guarantee that the table isn't dropped for the remainder of the transaction.
 */</comment>
<function><type><name>Oid</name></type>
<name>ColocatedTableId</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>colocationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>colocatedTableId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>indexOK</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scanKey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>scanKeyCount</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We may have a distributed table whose colocation id is INVALID_COLOCATION_ID.
	 * In this case, we do not want to send that table's id as colocated table id.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>colocationId</name> <operator>==</operator> <name>INVALID_COLOCATION_ID</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>colocatedTableId</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_pg_dist_partition_colocationid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_INT4EQ</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>colocationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>pgDistPartition</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><call><name>DistPartitionRelationId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pgDistPartition</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scanDescriptor</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pgDistPartition</name></expr></argument>,
													<argument><expr><call><name>DistPartitionColocationidIndexId</name><argument_list>()</argument_list></call></expr></argument>,
													<argument><expr><name>indexOK</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>scanKeyCount</name></expr></argument>, <argument><expr><name>scanKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>heapTuple</name> <init>= <expr><call><name>systable_getnext</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name><name>isNullArray</name><index>[<expr><name>Natts_pg_dist_partition</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type> <name><name>datumArray</name><index>[<expr><name>Natts_pg_dist_partition</name></expr>]</index></name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>, <argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><name>datumArray</name></expr></argument>, <argument><expr><name>isNullArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>colocatedTableId</name> <operator>=</operator> <call><name>DatumGetObjectId</name><argument_list>(
			<argument><expr><name><name>datumArray</name><index>[<expr><name>Anum_pg_dist_partition_logicalrelid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Make sure the relation isn't dropped for the remainder of
		 * the transaction.
		 */</comment>
		<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name>colocatedTableId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * The relation might have been dropped just before we locked it.
		 * Let's look it up.
		 */</comment>
		<decl_stmt><decl><type><name>Relation</name></type> <name>colocatedRelation</name> <init>= <expr><call><name>RelationIdGetRelation</name><argument_list>(<argument><expr><name>colocatedTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>RelationIsValid</name><argument_list>(<argument><expr><name>colocatedRelation</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* relation still exists, we can use it */</comment>
			<expr_stmt><expr><call><name>RelationClose</name><argument_list>(<argument><expr><name>colocatedRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* relation was dropped, try the next one */</comment>
		<expr_stmt><expr><name>colocatedTableId</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>heapTuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pgDistPartition</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>colocatedTableId</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColocatedShardIdInRelation returns shardId of the shard from given relation, so that
 * returned shard is co-located with given shard.
 */</comment>
<function><type><name>uint64</name></type>
<name>ColocatedShardIdInRelation</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>shardIndex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>tableCacheEntry</name> <init>= <expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name><name>tableCacheEntry</name><operator>-&gt;</operator><name>sortedShardIntervalArray</name><index>[<expr><name>shardIndex</name></expr>]</index></name><operator>-&gt;</operator><name>shardId</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DeleteColocationGroupIfNoTablesBelong function deletes given co-location group if there
 * is no relation in that co-location group. A co-location group may become empty after
 * mark_tables_colocated or upgrade_reference_table UDF calls. In that case we need to
 * remove empty co-location group to prevent orphaned co-location groups.
 */</comment>
<function><type><name>void</name></type>
<name>DeleteColocationGroupIfNoTablesBelong</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>colocationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>colocationId</name> <operator>!=</operator> <name>INVALID_COLOCATION_ID</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>colocatedTableList</name> <init>= <expr><call><name>ColocationGroupTableList</name><argument_list>(<argument><expr><name>colocationId</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>colocatedTableCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>colocatedTableList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>colocatedTableCount</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>DeleteColocationGroup</name><argument_list>(<argument><expr><name>colocationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * DeleteColocationGroup deletes the colocation group from pg_dist_colocation
 * throughout the cluster.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DeleteColocationGroup</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>colocationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>DeleteColocationGroupLocally</name><argument_list>(<argument><expr><name>colocationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SyncDeleteColocationGroupToNodes</name><argument_list>(<argument><expr><name>colocationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * DeleteColocationGroupLocally deletes the colocation group from pg_dist_colocation.
 */</comment>
<function><type><name>void</name></type>
<name>DeleteColocationGroupLocally</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>colocationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>scanKeyCount</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scanKey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>indexOK</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>pgDistColocation</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><call><name>DistColocationRelationId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_pg_dist_colocation_colocationid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_INT4EQ</name></expr></argument>, <argument><expr><call><name>UInt32GetDatum</name><argument_list>(<argument><expr><name>colocationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scanDescriptor</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pgDistColocation</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>indexOK</name></expr></argument>,
													<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>scanKeyCount</name></expr></argument>, <argument><expr><name>scanKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* if a record is found, delete it */</comment>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>heapTuple</name> <init>= <expr><call><name>systable_getnext</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * simple_heap_delete() expects that the caller has at least an
		 * AccessShareLock on primary key index.
		 *
		 * XXX: This does not seem required, do we really need to acquire this lock?
		 * Postgres doesn't acquire such locks on indexes before deleting catalog tuples.
		 * Linking here the reasons we added this lock acquirement:
		 * https://github.com/citusdata/citus/pull/2851#discussion_r306569462
		 * https://github.com/citusdata/citus/pull/2855#discussion_r313628554
		 * https://github.com/citusdata/citus/issues/1890
		 */</comment>
		<decl_stmt><decl><type><name>Relation</name></type> <name>replicaIndex</name> <init>=
			<expr><call><name>index_open</name><argument_list>(<argument><expr><call><name>RelationGetPrimaryKeyIndex</name><argument_list>(<argument><expr><name>pgDistColocation</name></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>simple_heap_delete</name><argument_list>(<argument><expr><name>pgDistColocation</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>heapTuple</name><operator>-&gt;</operator><name>t_self</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CitusInvalidateRelcacheByRelid</name><argument_list>(<argument><expr><call><name>DistColocationRelationId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>replicaIndex</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pgDistColocation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * FindColocateWithColocationId tries to find a colocation ID for a given
 * colocate_with clause passed to create_distributed_table.
 */</comment>
<function><type><name>uint32</name></type>
<name>FindColocateWithColocationId</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>replicationModel</name></decl></parameter>,
							 <parameter><decl><type><name>Oid</name></type> <name>distributionColumnType</name></decl></parameter>,
							 <parameter><decl><type><name>Oid</name></type> <name>distributionColumnCollation</name></decl></parameter>,
							 <parameter><decl><type><name>int</name></type> <name>shardCount</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>shardCountIsStrict</name></decl></parameter>,
							 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>colocateWithTableName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>colocationId</name> <init>= <expr><name>INVALID_COLOCATION_ID</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsColocateWithDefault</name><argument_list>(<argument><expr><name>colocateWithTableName</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* check for default colocation group */</comment>
		<expr_stmt><expr><name>colocationId</name> <operator>=</operator> <call><name>ColocationId</name><argument_list>(<argument><expr><name>shardCount</name></expr></argument>, <argument><expr><name>ShardReplicationFactor</name></expr></argument>,
									<argument><expr><name>distributionColumnType</name></expr></argument>,
									<argument><expr><name>distributionColumnCollation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * if the shardCount is strict then we check if the shard count
		 * of the colocated table is actually shardCount
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>shardCountIsStrict</name> <operator>&amp;&amp;</operator> <name>colocationId</name> <operator>!=</operator> <name>INVALID_COLOCATION_ID</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type> <name>colocatedTableId</name> <init>= <expr><call><name>ColocatedTableId</name><argument_list>(<argument><expr><name>colocationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>colocatedTableId</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>cacheEntry</name> <init>=
					<expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name>colocatedTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type> <name>colocatedTableShardCount</name> <init>= <expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>shardIntervalArrayLength</name></name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>colocatedTableShardCount</name> <operator>!=</operator> <name>shardCount</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>colocationId</name> <operator>=</operator> <name>INVALID_COLOCATION_ID</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>IsColocateWithNone</name><argument_list>(<argument><expr><name>colocateWithTableName</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>colocateWithTableNameText</name> <init>= <expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name>colocateWithTableName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>sourceRelationId</name> <init>= <expr><call><name>ResolveRelationId</name><argument_list>(<argument><expr><name>colocateWithTableNameText</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>EnsureTableCanBeColocatedWith</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>replicationModel</name></expr></argument>,
									  <argument><expr><name>distributionColumnType</name></expr></argument>, <argument><expr><name>sourceRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>colocationId</name> <operator>=</operator> <call><name>TableColocationId</name><argument_list>(<argument><expr><name>sourceRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>colocationId</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * EnsureTableCanBeColocatedWith checks whether a given replication model and
 * distribution column type is suitable to distribute a table to be colocated
 * with given source table.
 *
 * We only pass relationId to provide meaningful error messages.
 */</comment>
<function><type><name>void</name></type>
<name>EnsureTableCanBeColocatedWith</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>replicationModel</name></decl></parameter>,
							  <parameter><decl><type><name>Oid</name></type> <name>distributionColumnType</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>sourceRelationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>sourceTableEntry</name> <init>= <expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name>sourceRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>sourceReplicationModel</name> <init>= <expr><name><name>sourceTableEntry</name><operator>-&gt;</operator><name>replicationModel</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>sourceDistributionColumn</name> <init>= <expr><call><name>DistPartitionKeyOrError</name><argument_list>(<argument><expr><name>sourceRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCitusTableTypeCacheEntry</name><argument_list>(<argument><expr><name>sourceTableEntry</name></expr></argument>, <argument><expr><name>HASH_DISTRIBUTED</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot distribute relation"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Currently, colocate_with option is only supported "</literal>
								  <literal type="string">"for hash distributed tables."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>sourceReplicationModel</name> <operator>!=</operator> <name>replicationModel</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sourceRelationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>sourceRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot colocate tables %s and %s"</literal></expr></argument>,
							   <argument><expr><name>sourceRelationName</name></expr></argument>, <argument><expr><name>relationName</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Replication models don't match for %s and %s."</literal></expr></argument>,
								  <argument><expr><name>sourceRelationName</name></expr></argument>, <argument><expr><name>relationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>sourceDistributionColumnType</name> <init>= <expr><name><name>sourceDistributionColumn</name><operator>-&gt;</operator><name>vartype</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>sourceDistributionColumnType</name> <operator>!=</operator> <name>distributionColumnType</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sourceRelationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>sourceRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot colocate tables %s and %s"</literal></expr></argument>,
							   <argument><expr><name>sourceRelationName</name></expr></argument>, <argument><expr><name>relationName</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Distribution column types don't match for "</literal>
								  <literal type="string">"%s and %s."</literal></expr></argument>, <argument><expr><name>sourceRelationName</name></expr></argument>,
								  <argument><expr><name>relationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
</unit>
