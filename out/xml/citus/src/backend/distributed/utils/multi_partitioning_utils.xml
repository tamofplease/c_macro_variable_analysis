<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/builded_projects/citus/src/backend/distributed/utils/multi_partitioning_utils.c"><comment type="block">/*
 * multi_partitioning_utils.c
 *	  Utility functions for declarative partitioning
 *
 * Copyright (c) Citus Data, Inc.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_version_constants.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/partition.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_class.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_constraint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_inherits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablecmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/string.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_nodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/adaptive_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_ruleutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/colocation_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/coordinator_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/deparse_shard_query.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_partitioning_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_physical_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/relay_utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/resource_lock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shardinterval_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/version_compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/stringinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pg_list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"partitioning/partdesc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/varlena.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>PartitionBound</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>partitionId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Relation</name></type> <name>try_relation_open_nolock</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>CreateFixPartitionConstraintsTaskList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>WorkerFixPartitionConstraintCommandList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>,
													  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>checkConstraintList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CreateFixPartitionShardIndexNames</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>parentRelationId</name></decl></parameter>,
											  <parameter><decl><type><name>Oid</name></type> <name>partitionRelationId</name></decl></parameter>,
											  <parameter><decl><type><name>Oid</name></type> <name>parentIndexOid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>WorkerFixPartitionShardIndexNamesCommandList</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>parentShardId</name></decl></parameter>,
														   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexIdList</name></decl></parameter>,
														   <parameter><decl><type><name>Oid</name></type> <name>partitionRelationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>WorkerFixPartitionShardIndexNamesCommandListForParentShardIndex</name><parameter_list>(
	<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>qualifiedParentShardIndexName</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>parentIndexId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>partitionRelationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>WorkerFixPartitionShardIndexNamesCommandListForPartitionIndex</name><parameter_list>(<parameter><decl><type><name>Oid</name></type>
																			<name>partitionIndexId</name></decl></parameter>,
																			<parameter><decl><type><name>char</name> <modifier>*</modifier></type>
																			<name>qualifiedParentShardIndexName</name></decl></parameter>,
																			<parameter><decl><type><name>Oid</name></type>
																			<name>partitionId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>CheckConstraintNameListForRelation</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>RelationHasConstraint</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>constraintName</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>RenameConstraintCommand</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>constraintName</name></decl></parameter>,
									  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>newConstraintName</name></decl></parameter>)</parameter_list>;</function_decl>


<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>fix_pre_citus10_partitioned_table_constraint_names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>worker_fix_pre_citus10_partitioned_table_constraint_names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>fix_partition_shard_index_names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>worker_fix_partition_shard_index_names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<comment type="block">/*
 * fix_pre_citus10_partitioned_table_constraint_names fixes the constraint names of
 * partitioned table shards on workers.
 *
 * Constraint names for partitioned table shards should have shardId suffixes if and only
 * if they are unique or foreign key constraints. We mistakenly appended shardIds to
 * constraint names on ALTER TABLE dist_part_table ADD CONSTRAINT .. queries prior to
 * Citus 10. fix_pre_citus10_partitioned_table_constraint_names determines if this is the
 * case, and renames constraints back to their original names on shards.
 */</comment>
<function><type><name>Datum</name></type>
<name>fix_pre_citus10_partitioned_table_constraint_names</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>EnsureCoordinator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PartitionedTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not fix partition constraints: "</literal>
							   <literal type="string">"relation does not exist or is not partitioned"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"fix_pre_citus10_partitioned_table_constraint_names can "</literal>
							   <literal type="string">"only be called for distributed partitioned tables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name> <init>= <expr><call><name>CreateFixPartitionConstraintsTaskList</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* do not do anything if there are no constraints that should be fixed */</comment>
	<if_stmt><if>if <condition>(<expr><name>taskList</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>localExecutionSupported</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ExecuteUtilityTaskList</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>, <argument><expr><name>localExecutionSupported</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * worker_fix_pre_citus10_partitioned_table_constraint_names fixes the constraint names on a worker given a shell
 * table name and shard id.
 */</comment>
<function><type><name>Datum</name></type>
<name>worker_fix_pre_citus10_partitioned_table_constraint_names</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>shardId</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>constraintNameText</name> <init>= <expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PartitionedTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not fix partition constraints: "</literal>
							   <literal type="string">"relation does not exist or is not partitioned"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>constraintName</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><name>constraintNameText</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>shardIdAppendedConstraintName</name> <init>= <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>constraintName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><operator>&amp;</operator><name>shardIdAppendedConstraintName</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* if shardId was appended to the constraint name, rename back to original */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RelationHasConstraint</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>shardIdAppendedConstraintName</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>renameConstraintDDLCommand</name> <init>=
			<expr><call><name>RenameConstraintCommand</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>shardIdAppendedConstraintName</name></expr></argument>,
									<argument><expr><name>constraintName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ExecuteAndLogUtilityCommand</name><argument_list>(<argument><expr><name>renameConstraintDDLCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * fix_partition_shard_index_names fixes the index names of shards of partitions of
 * partitioned tables on workers. If the input is a partition rather than a partitioned
 * table, we only fix the index names of shards of that particular partition.
 *
 * When running CREATE INDEX on parent_table, we didn't explicitly create the index on
 * each partition as well. Postgres created indexes for partitions in the coordinator,
 * and also in the workers. Actually, Postgres auto-generates index names when auto-creating
 * indexes on each partition shard of the parent shards. If index name is too long, it
 * truncates the name and adds _idx postfix to it. However, when truncating the name, the
 * shardId of the partition shard can be lost. This may result in the same index name used for
 * the partition shell table and one of the partition shards.
 * For more details, check issue #4962 https://github.com/citusdata/citus/issues/4962
 *
 * fix_partition_shard_index_names renames indexes of shards of partition tables to include
 * the shardId at the end of the name, regardless of whether index name was long or short
 * As a result there will be no index name ending in _idx, rather all will end in _{shardid}
 *
 * Algorithm is:
 * foreach parentShard in shardListOfParentTableId:
 *  foreach parentIndex on parent:
 *      generate qualifiedParentShardIndexName -&gt; parentShardIndex
 *      foreach inheritedPartitionIndex on parentIndex:
 *          get table relation of inheritedPartitionIndex -&gt; partitionId
 *          foreach partitionShard in shardListOfPartitionid:
 *              generate qualifiedPartitionShardName -&gt; partitionShard
 *              generate newPartitionShardIndexName
 *              (the following happens in the worker node)
 *              foreach inheritedPartitionShardIndex on parentShardIndex:
 *                  if table relation of inheritedPartitionShardIndex is partitionShard:
 *                      if inheritedPartitionShardIndex does not have proper name:
 *                          Rename(inheritedPartitionShardIndex, newPartitionShardIndexName)
 *                      break
 */</comment>
<function><type><name>Datum</name></type>
<name>fix_partition_shard_index_names</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EnsureCoordinator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>parentIndexOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt> <comment type="block">/* fix all the indexes */</comment>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"fix_partition_shard_index_names can only be called "</literal>
							   <literal type="string">"for Citus tables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>EnsureTableOwner</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FixPartitionShardIndexNames</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>parentIndexOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * This UDF is called from fix_all_partition_shard_index_names() which iterates
	 * over all the partitioned tables. There is no need to hold all the distributed
	 * table metadata until the end of the transaction for the input table.
	 */</comment>
	<expr_stmt><expr><call><name>CitusTableCacheFlushInvalidatedEntries</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * worker_fix_partition_shard_index_names fixes the index name of the index on given
 * partition shard that has parent the given parent index.
 * The parent index should be the index of a shard of a distributed partitioned table.
 */</comment>
<function><type><name>Datum</name></type>
<name>worker_fix_partition_shard_index_names</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>parentShardIndexId</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>partitionShardName</name> <init>= <expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* resolve partitionShardId from passed in schema and partition shard name */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>partitionShardNameList</name> <init>= <expr><call><name>textToQualifiedNameList</name><argument_list>(<argument><expr><name>partitionShardName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>partitionShard</name> <init>= <expr><call><name>makeRangeVarFromNameList</name><argument_list>(<argument><expr><name>partitionShardNameList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* lock the relation with the lock mode */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>missing_ok</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>partitionShardId</name> <init>= <expr><call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>partitionShard</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>partitionShardId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EnsureTableOwner</name><argument_list>(<argument><expr><name>partitionShardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>newPartitionShardIndexNameText</name> <init>= <expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>newPartitionShardIndexName</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(
		<argument><expr><name>newPartitionShardIndexNameText</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>has_subclass</name><argument_list>(<argument><expr><name>parentShardIndexId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not fix child index names: "</literal>
							   <literal type="string">"index is not partitioned"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>partitionShardIndexIds</name> <init>= <expr><call><name>find_inheritance_children</name><argument_list>(<argument><expr><name>parentShardIndexId</name></expr></argument>,
															 <argument><expr><name>ShareRowExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>partitionShardIndexId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>partitionShardIndexId</argument>, <argument>partitionShardIndexIds</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IndexGetRelation</name><argument_list>(<argument><expr><name>partitionShardIndexId</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>partitionShardId</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>partitionShardIndexName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>partitionShardIndexId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>ExtractShardIdFromTableName</name><argument_list>(<argument><expr><name>partitionShardIndexName</name></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call> <operator>==</operator>
				<name>INVALID_SHARD_ID</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * ExtractShardIdFromTableName will return INVALID_SHARD_ID if
				 * partitionShardIndexName doesn't end in _shardid. In that case,
				 * we want to rename this partition shard index to newPartitionShardIndexName,
				 * which ends in _shardid, hence we maintain naming consistency:
				 * we can reach this partition shard index by conventional Citus naming
				 */</comment>
				<decl_stmt><decl><type><name>RenameStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RenameStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>renameType</name></name> <operator>=</operator> <name>OBJECT_INDEX</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>missing_ok</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>idxNamespace</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>get_rel_namespace</name><argument_list>(
															<argument><expr><name>partitionShardIndexId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><name>idxNamespace</name></expr></argument>, <argument><expr><name>partitionShardIndexName</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>newname</name></name> <operator>=</operator> <name>newPartitionShardIndexName</name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>RenameRelation</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * FixPartitionShardIndexNames gets a relationId. The input relationId should be
 * either a parent or partition table. If it is a parent table, then all the
 * index names on all the partitions are fixed. If it is a partition, only the
 * specific partition is fixed.
 *
 * The second parentIndexOid parameter is optional. If provided a valid Oid, only
 * that specific index name is fixed.
 */</comment>
<function><type><name>void</name></type>
<name>FixPartitionShardIndexNames</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>parentIndexOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name> <init>= <expr><call><name>try_relation_open</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>relation</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation with OID %u does not exist, skipping"</literal></expr></argument>,
								<argument><expr><name>relationId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* at this point, we should only be dealing with Citus tables */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>parentRelationId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>partitionRelationId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>parentRelationId</name> <operator>=</operator> <name>relationId</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>PartitionTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>parentRelationId</name> <operator>=</operator> <call><name>PartitionParentOid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>partitionRelationId</name> <operator>=</operator> <name>relationId</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Fixing shard index names is only applicable to "</literal>
							   <literal type="string">"partitioned tables or partitions, "</literal>
							   <literal type="string">"and \"%s\" is neither"</literal></expr></argument>,
							   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>CreateFixPartitionShardIndexNames</name><argument_list>(<argument><expr><name>parentRelationId</name></expr></argument>,
									  <argument><expr><name>partitionRelationId</name></expr></argument>,
									  <argument><expr><name>parentIndexOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CreateFixPartitionConstraintsTaskList goes over all the partitions of a distributed
 * partitioned table, and creates the list of tasks to execute
 * worker_fix_pre_citus10_partitioned_table_constraint_names UDF on worker nodes.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>CreateFixPartitionConstraintsTaskList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* enumerate the tasks when putting them to the taskList */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>taskId</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>checkConstraintList</name> <init>= <expr><call><name>CheckConstraintNameListForRelation</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* early exit if the relation does not have any check constraints */</comment>
	<if_stmt><if>if <condition>(<expr><name>checkConstraintList</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardIntervalList</name> <init>= <expr><call><name>LoadShardIntervalList</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* lock metadata before getting placement lists */</comment>
	<expr_stmt><expr><call><name>LockShardListMetadata</name><argument_list>(<argument><expr><name>shardIntervalList</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>shardInterval</argument>, <argument>shardIntervalList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint64</name></type> <name>shardId</name> <init>= <expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>queryStringList</name> <init>= <expr><call><name>WorkerFixPartitionConstraintCommandList</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>,
																		<argument><expr><name>shardId</name></expr></argument>,
																		<argument><expr><name>checkConstraintList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>Task</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>jobId</name></name> <operator>=</operator> <name>INVALID_JOB_ID</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>taskId</name></name> <operator>=</operator> <name>taskId</name><operator>++</operator></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>taskType</name></name> <operator>=</operator> <name>DDL_TASK</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SetTaskQueryStringList</name><argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><name>queryStringList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>dependentTaskList</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>replicationModel</name></name> <operator>=</operator> <name>REPLICATION_MODEL_INVALID</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>anchorShardId</name></name> <operator>=</operator> <name>shardId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>taskPlacementList</name></name> <operator>=</operator> <call><name>ActiveShardPlacementList</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>taskList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>, <argument><expr><name>task</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>taskList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CheckConstraintNameListForRelation returns a list of names of CHECK constraints
 * for a relation.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>CheckConstraintNameListForRelation</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>constraintNameList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>scanKeyCount</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scanKey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>pgConstraint</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_pg_constraint_conrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanKey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_pg_constraint_contype</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_CHAREQ</name></expr></argument>, <argument><expr><name>CONSTRAINT_CHECK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>useIndex</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scanDescriptor</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pgConstraint</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>useIndex</name></expr></argument>,
													<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>scanKeyCount</name></expr></argument>, <argument><expr><name>scanKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>heapTuple</name> <init>= <expr><call><name>systable_getnext</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>constraintForm</name> <init>= <expr><operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>constraintName</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>constraintForm</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>constraintNameList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>constraintNameList</name></expr></argument>, <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>constraintName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>heapTuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pgConstraint</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>constraintNameList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * WorkerFixPartitionConstraintCommandList creates a list of queries that will fix
 * all check constraint names of a shard.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>WorkerFixPartitionConstraintCommandList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>,
										<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>checkConstraintList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commandList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>schemaId</name> <init>= <expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>schemaName</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>schemaId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>shardRelationName</name> <init>= <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>relationName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* build shard relation name */</comment>
	<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><operator>&amp;</operator><name>shardRelationName</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>quotedShardName</name> <init>= <expr><call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>, <argument><expr><name>shardRelationName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>constraintName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>constraintName</argument>, <argument>checkConstraintList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>StringInfo</name></type> <name>shardQueryString</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>shardQueryString</name></expr></argument>,
						 <argument><expr><literal type="string">"SELECT worker_fix_pre_citus10_partitioned_table_constraint_names(%s::regclass, "</literal>
						 <name>UINT64_FORMAT</name> <literal type="string">", %s::text)"</literal></expr></argument>,
						 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>quotedShardName</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>shardId</name></expr></argument>,
						 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>constraintName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>commandList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>commandList</name></expr></argument>, <argument><expr><name><name>shardQueryString</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>commandList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateFixPartitionShardIndexNamesTaskList goes over all the
 * indexes of a distributed partitioned table unless parentIndexOid
 * is valid. If it is valid, only the given index is processed.
 *
 * The function creates the list of tasks to execute
 * worker_fix_partition_shard_index_names() on worker nodes.
 *
 * When the partitionRelationId is a valid Oid, the function only operates on the
 * given partition. Otherwise, the function create tasks for all the partitions.
 *
 * So, for example, if a new partition is created, we only need to fix only for the
 * new partition, hence partitionRelationId should be a valid Oid. However, if a new
 * index/constraint is created on the parent, we should fix all the partitions, hence
 * partitionRelationId should be InvalidOid.
 *
 * As a reflection of the above, we always create parent_table_shard_count tasks.
 * When we need to fix all the partitions, each task with parent_indexes_count
 * times partition_count query strings. When we need to fix a single
 * partition each task will have parent_indexes_count query strings. When we need
 * to fix a single index, parent_indexes_count becomes 1.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CreateFixPartitionShardIndexNames</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>parentRelationId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>partitionRelationId</name></decl></parameter>,
								  <parameter><decl><type><name>Oid</name></type> <name>parentIndexOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>partitionList</name> <init>= <expr><call><name>PartitionList</name><argument_list>(<argument><expr><name>parentRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>partitionList</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* early exit if the parent relation does not have any partitions */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>parentRelation</name> <init>= <expr><call><name>RelationIdGetRelation</name><argument_list>(<argument><expr><name>parentRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RelationIsValid</name><argument_list>(<argument><expr><name>parentRelation</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open relation with OID %u"</literal></expr></argument>, <argument><expr><name>parentRelationId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>parentIndexIdList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>parentIndexOid</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>parentIndexIdList</name> <operator>=</operator> <call><name>list_make1_oid</name><argument_list>(<argument><expr><name>parentIndexOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>parentIndexIdList</name> <operator>=</operator> <call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>parentRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>parentIndexIdList</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* early exit if the parent relation does not have any indexes */</comment>
		<expr_stmt><expr><call><name>RelationClose</name><argument_list>(<argument><expr><name>parentRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Lock shard metadata, if a specific partition is provided, lock that. Otherwise,
	 * lock all partitions.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>partitionRelationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* if a partition was provided we only need to lock that partition's metadata */</comment>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>partitionShardIntervalList</name> <init>= <expr><call><name>LoadShardIntervalList</name><argument_list>(<argument><expr><name>partitionRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>LockShardListMetadata</name><argument_list>(<argument><expr><name>partitionShardIntervalList</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>partitionId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_oid</name><argument_list>(<argument>partitionId</argument>, <argument>partitionList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>partitionShardIntervalList</name> <init>= <expr><call><name>LoadShardIntervalList</name><argument_list>(<argument><expr><name>partitionId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>LockShardListMetadata</name><argument_list>(<argument><expr><name>partitionShardIntervalList</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>parentShardIntervalList</name> <init>= <expr><call><name>LoadShardIntervalList</name><argument_list>(<argument><expr><name>parentRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* lock metadata before getting placement lists */</comment>
	<expr_stmt><expr><call><name>LockShardListMetadata</name><argument_list>(<argument><expr><name>parentShardIntervalList</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>localContext</name> <init>= <expr><call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
													   <argument><expr><literal type="string">"CreateFixPartitionShardIndexNames"</literal></expr></argument>,
													   <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>localContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>taskId</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>parentShardInterval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>parentShardInterval</argument>, <argument>parentShardIntervalList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint64</name></type> <name>parentShardId</name> <init>= <expr><name><name>parentShardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>queryStringList</name> <init>=
			<expr><call><name>WorkerFixPartitionShardIndexNamesCommandList</name><argument_list>(<argument><expr><name>parentShardId</name></expr></argument>,
														 <argument><expr><name>parentIndexIdList</name></expr></argument>,
														 <argument><expr><name>partitionRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>queryStringList</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>Task</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>jobId</name></name> <operator>=</operator> <name>INVALID_JOB_ID</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>taskId</name></name> <operator>=</operator> <name>taskId</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>taskType</name></name> <operator>=</operator> <name>DDL_TASK</name></expr>;</expr_stmt>

			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>prefix</name> <init>= <expr><literal type="string">"SELECT pg_catalog.citus_run_local_command($$"</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>postfix</name> <init>= <expr><literal type="string">"$$)"</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>string</name> <init>= <expr><call><name>StringJoinParams</name><argument_list>(<argument><expr><name>queryStringList</name></expr></argument>, <argument><expr><literal type="char">';'</literal></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>postfix</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>SetTaskQueryString</name><argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


			<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>dependentTaskList</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>replicationModel</name></name> <operator>=</operator> <name>REPLICATION_MODEL_INVALID</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>anchorShardId</name></name> <operator>=</operator> <name>parentShardId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>taskPlacementList</name></name> <operator>=</operator> <call><name>ActiveShardPlacementList</name><argument_list>(<argument><expr><name>parentShardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<decl_stmt><decl><type><name>bool</name></type> <name>localExecutionSupported</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>ExecuteUtilityTaskList</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>task</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>localExecutionSupported</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* after every iteration, clean-up all the memory associated with it */</comment>
		<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>localContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>RelationClose</name><argument_list>(<argument><expr><name>parentRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * WorkerFixPartitionShardIndexNamesCommandList creates a list of queries that will fix
 * all child index names of parent indexes on given shard of parent partitioned table.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>WorkerFixPartitionShardIndexNamesCommandList</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>parentShardId</name></decl></parameter>,
											 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>parentIndexIdList</name></decl></parameter>,
											 <parameter><decl><type><name>Oid</name></type> <name>partitionRelationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commandList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>parentIndexId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>parentIndexId</argument>, <argument>parentIndexIdList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>has_subclass</name><argument_list>(<argument><expr><name>parentIndexId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Get the qualified name of the corresponding index of given parent index
		 * in the parent shard with given parentShardId
		 */</comment>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>parentIndexName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>parentIndexId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>parentShardIndexName</name> <init>= <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>parentIndexName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><operator>&amp;</operator><name>parentShardIndexName</name></expr></argument>, <argument><expr><name>parentShardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>schemaId</name> <init>= <expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>parentIndexId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>schemaName</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>schemaId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>qualifiedParentShardIndexName</name> <init>= <expr><call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>,
																		 <argument><expr><name>parentShardIndexName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commands</name> <init>= <expr><call><name>WorkerFixPartitionShardIndexNamesCommandListForParentShardIndex</name><argument_list>(
			<argument><expr><name>qualifiedParentShardIndexName</name></expr></argument>, <argument><expr><name>parentIndexId</name></expr></argument>, <argument><expr><name>partitionRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>commandList</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>commandList</name></expr></argument>, <argument><expr><name>commands</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>commandList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * WorkerFixPartitionShardIndexNamesCommandListForParentShardIndex creates a list
 * of queries that will fix the child index names of given index on shard
 * of parent partitioned table.
 *
 * In case a partition was provided as argument (partitionRelationId isn't InvalidOid)
 * the list of queries will include only the child indexes whose relation is the
 * given partition. Otherwise, all the partitions are included.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>WorkerFixPartitionShardIndexNamesCommandListForParentShardIndex</name><parameter_list>(
	<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>qualifiedParentShardIndexName</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>parentIndexId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>partitionRelationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commandList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Get the list of all partition indexes that are children of current
	 * index on parent
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>partitionIndexIds</name> <init>=
		<expr><call><name>find_inheritance_children</name><argument_list>(<argument><expr><name>parentIndexId</name></expr></argument>, <argument><expr><name>ShareRowExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>addAllPartitions</name> <init>= <expr><operator>(</operator><name>partitionRelationId</name> <operator>==</operator> <name>InvalidOid</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>partitionIndexId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>partitionIndexId</argument>, <argument>partitionIndexIds</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>partitionId</name> <init>= <expr><call><name>IndexGetRelation</name><argument_list>(<argument><expr><name>partitionIndexId</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>addAllPartitions</name> <operator>||</operator> <name>partitionId</name> <operator>==</operator> <name>partitionRelationId</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commands</name> <init>=
				<expr><call><name>WorkerFixPartitionShardIndexNamesCommandListForPartitionIndex</name><argument_list>(
					<argument><expr><name>partitionIndexId</name></expr></argument>, <argument><expr><name>qualifiedParentShardIndexName</name></expr></argument>, <argument><expr><name>partitionId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>commandList</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>commandList</name></expr></argument>, <argument><expr><name>commands</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>commandList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * WorkerFixPartitionShardIndexNamesCommandListForPartitionIndex creates a list of queries that will fix
 * all child index names of given index on shard of parent partitioned table, whose table relation is a shard
 * of the partition that is the table relation of given partitionIndexId, which is partitionId
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>WorkerFixPartitionShardIndexNamesCommandListForPartitionIndex</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>partitionIndexId</name></decl></parameter>,
															  <parameter><decl><type><name>char</name> <modifier>*</modifier></type>
															  <name>qualifiedParentShardIndexName</name></decl></parameter>,
															  <parameter><decl><type><name>Oid</name></type> <name>partitionId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commandList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* get info for this partition relation of this index*/</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>partitionIndexName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>partitionIndexId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>partitionName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>partitionId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>partitionSchemaName</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>partitionId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>partitionShardIntervalList</name> <init>= <expr><call><name>LoadShardIntervalList</name><argument_list>(<argument><expr><name>partitionId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>partitionShardInterval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>partitionShardInterval</argument>, <argument>partitionShardIntervalList</argument>)</argument_list></macro>
	<block>{<block_content>
		<comment type="block">/*
		 * Prepare commands for each shard of current partition
		 * to fix the index name that corresponds to the
		 * current parent index name
		 */</comment>
		<decl_stmt><decl><type><name>uint64</name></type> <name>partitionShardId</name> <init>= <expr><name><name>partitionShardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* get qualified partition shard name */</comment>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>partitionShardName</name> <init>= <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>partitionName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><operator>&amp;</operator><name>partitionShardName</name></expr></argument>, <argument><expr><name>partitionShardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>qualifiedPartitionShardName</name> <init>= <expr><call><name>quote_qualified_identifier</name><argument_list>(
			<argument><expr><name>partitionSchemaName</name></expr></argument>,
			<argument><expr><name>partitionShardName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* generate the new correct index name */</comment>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>newPartitionShardIndexName</name> <init>= <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>partitionIndexName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><operator>&amp;</operator><name>newPartitionShardIndexName</name></expr></argument>, <argument><expr><name>partitionShardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* create worker_fix_partition_shard_index_names command */</comment>
		<decl_stmt><decl><type><name>StringInfo</name></type> <name>shardQueryString</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>shardQueryString</name></expr></argument>,
						 <argument><expr><literal type="string">"SELECT worker_fix_partition_shard_index_names(%s::regclass, %s, %s)"</literal></expr></argument>,
						 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>qualifiedParentShardIndexName</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>qualifiedPartitionShardName</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>newPartitionShardIndexName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>commandList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>commandList</name></expr></argument>, <argument><expr><name><name>shardQueryString</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>commandList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RelationHasConstraint checks if a relation has a constraint with a given name.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>RelationHasConstraint</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>constraintName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>scanKeyCount</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scanKey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>pgConstraint</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_pg_constraint_conrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanKey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_pg_constraint_conname</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_NAMEEQ</name></expr></argument>, <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>constraintName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>useIndex</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scanDescriptor</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pgConstraint</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>useIndex</name></expr></argument>,
													<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>scanKeyCount</name></expr></argument>, <argument><expr><name>scanKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>heapTuple</name> <init>= <expr><call><name>systable_getnext</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pgConstraint</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>found</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RenameConstraintCommand creates the query string that will rename a constraint
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>RenameConstraintCommand</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>constraintName</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>newConstraintName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>qualifiedRelationName</name> <init>= <expr><call><name>generate_qualified_relation_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>quotedConstraintName</name> <init>= <expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>constraintName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>quotedNewConstraintName</name> <init>= <expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>newConstraintName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>StringInfo</name></type> <name>renameCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>renameCommand</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE %s RENAME CONSTRAINT %s TO %s"</literal></expr></argument>,
					 <argument><expr><name>qualifiedRelationName</name></expr></argument>, <argument><expr><name>quotedConstraintName</name></expr></argument>,
					 <argument><expr><name>quotedNewConstraintName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>renameCommand</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Returns true if the given relation is a partitioned table.
 */</comment>
<function><type><name>bool</name></type>
<name>PartitionedTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name> <init>= <expr><call><name>try_relation_open</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* don't error out for tables that are dropped */</comment>
	<if_stmt><if>if <condition>(<expr><name>rel</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>partitionedTable</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>partitionedTable</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* keep the lock */</comment>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>partitionedTable</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Returns true if the given relation is a partitioned table. The function
 * doesn't acquire any locks on the input relation, thus the caller is
 * reponsible for holding the appropriate locks.
 */</comment>
<function><type><name>bool</name></type>
<name>PartitionedTableNoLock</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name> <init>= <expr><call><name>try_relation_open_nolock</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>partitionedTable</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* don't error out for tables that are dropped */</comment>
	<if_stmt><if>if <condition>(<expr><name>rel</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>partitionedTable</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* keep the lock */</comment>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>partitionedTable</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Returns true if the given relation is a partition.
 */</comment>
<function><type><name>bool</name></type>
<name>PartitionTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name> <init>= <expr><call><name>try_relation_open</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* don't error out for tables that are dropped */</comment>
	<if_stmt><if>if <condition>(<expr><name>rel</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>partitionTable</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relispartition</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* keep the lock */</comment>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>partitionTable</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Returns true if the given relation is a partition.  The function
 * doesn't acquire any locks on the input relation, thus the caller is
 * reponsible for holding the appropriate locks.
 */</comment>
<function><type><name>bool</name></type>
<name>PartitionTableNoLock</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name> <init>= <expr><call><name>try_relation_open_nolock</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* don't error out for tables that are dropped */</comment>
	<if_stmt><if>if <condition>(<expr><name>rel</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>partitionTable</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relispartition</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* keep the lock */</comment>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>partitionTable</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * try_relation_open_nolock opens a relation with given relationId without
 * acquiring locks. PostgreSQL's try_relation_open() asserts that caller
 * has already acquired a lock on the relation, which we don't always do.
 *
 * ATTENTION:
 *   1. Sync this with try_relation_open(). It hasn't changed for 10 to 12
 *      releases though.
 *   2. We should remove this after we fix the locking/distributed deadlock
 *      issues with MX Truncate. See https://github.com/citusdata/citus/pull/2894
 *      for more discussion.
 */</comment>
<function><type><specifier>static</specifier> <name>Relation</name></type>
<name>try_relation_open_nolock</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SearchSysCacheExists1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name> <init>= <expr><call><name>RelationIdGetRelation</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RelationIsValid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pgstat_init_relation</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>relation</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsChildTable returns true if the table is inherited. Note that
 * partition tables inherites by default. However, this function
 * returns false if the given table is a partition.
 */</comment>
<function><type><name>bool</name></type>
<name>IsChildTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>inheritsTuple</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>tableInherits</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>pgInherits</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>InheritsRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_pg_inherits_inhrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pgInherits</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
										  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>inheritsTuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>inheritedRelationId</name> <init>=
			<expr><operator>(</operator><operator>(</operator><name>Form_pg_inherits</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>inheritsTuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>inhrelid</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>relationId</name> <operator>==</operator> <name>inheritedRelationId</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>tableInherits</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pgInherits</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>tableInherits</name> <operator>&amp;&amp;</operator> <call><name>PartitionTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tableInherits</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>tableInherits</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsParentTable returns true if the table is inherited. Note that
 * partitioned tables inherited by default. However, this function
 * returns false if the given table is a partitioned table.
 */</comment>
<function><type><name>bool</name></type>
<name>IsParentTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>tableInherited</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>pgInherits</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>InheritsRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_pg_inherits_inhparent</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pgInherits</name></expr></argument>, <argument><expr><name>InheritsParentIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
										  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tableInherited</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pgInherits</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name> <init>= <expr><call><name>try_relation_open</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>relation</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation with OID %u does not exist"</literal></expr></argument>, <argument><expr><name>relationId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>tableInherited</name> <operator>&amp;&amp;</operator> <call><name>PartitionedTableNoLock</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tableInherited</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>tableInherited</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Wrapper around get_partition_parent
 *
 * Note: Because this function assumes that the relation whose OID is passed
 * as an argument will have precisely one parent, it should only be called
 * when it is known that the relation is a partition.
 */</comment>
<function><type><name>Oid</name></type>
<name>PartitionParentOid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>partitionOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>partitionParentOid</name> <init>= <expr><call><name>get_partition_parent_compat</name><argument_list>(<argument><expr><name>partitionOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>partitionParentOid</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PartitionWithLongestNameRelationId is a utility function that returns the
 * oid of the partition table that has the longest name in terms of number of
 * characters.
 */</comment>
<function><type><name>Oid</name></type>
<name>PartitionWithLongestNameRelationId</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>parentRelationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>longestNamePartitionId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>longestNameLength</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>partitionList</name> <init>= <expr><call><name>PartitionList</name><argument_list>(<argument><expr><name>parentRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>partitionRelationId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>partitionRelationId</argument>, <argument>partitionList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>partitionName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>partitionRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>partitionNameLength</name> <init>= <expr><call><name>strnlen</name><argument_list>(<argument><expr><name>partitionName</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>partitionNameLength</name> <operator>&gt;</operator> <name>longestNameLength</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>longestNamePartitionId</name> <operator>=</operator> <name>partitionRelationId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>longestNameLength</name> <operator>=</operator> <name>partitionNameLength</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>longestNamePartitionId</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Takes a parent relation and returns Oid list of its partitions. The
 * function errors out if the given relation is not a parent.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>PartitionList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>parentRelationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>parentRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>partitionList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>


	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PartitionedTable</name><argument_list>(<argument><expr><name>parentRelationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>parentRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a parent table"</literal></expr></argument>, <argument><expr><name>relationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><name>PartitionDesc</name></type> <name>partDesc</name> <init>= <expr><call><name>RelationGetPartitionDesc_compat</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>partDesc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>partitionCount</name> <init>= <expr><name><name>partDesc</name><operator>-&gt;</operator><name>nparts</name></name></expr></init></decl>;</decl_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>partitionIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>partitionIndex</name> <operator>&lt;</operator> <name>partitionCount</name></expr>;</condition> <incr><expr><operator>++</operator><name>partitionIndex</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>partitionList</name> <operator>=</operator>
			<call><name>lappend_oid</name><argument_list>(<argument><expr><name>partitionList</name></expr></argument>, <argument><expr><name><name>partDesc</name><operator>-&gt;</operator><name>oids</name><index>[<expr><name>partitionIndex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* keep the lock */</comment>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>partitionList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GenerateDetachPartitionCommand gets a partition table and returns
 * "ALTER TABLE parent_table DETACH PARTITION partitionName" command.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>GenerateDetachPartitionCommand</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>partitionTableId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>detachPartitionCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PartitionTable</name><argument_list>(<argument><expr><name>partitionTableId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>partitionTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a partition"</literal></expr></argument>, <argument><expr><name>relationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>parentId</name> <init>= <expr><call><name>get_partition_parent_compat</name><argument_list>(<argument><expr><name>partitionTableId</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tableQualifiedName</name> <init>= <expr><call><name>generate_qualified_relation_name</name><argument_list>(<argument><expr><name>partitionTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>parentTableQualifiedName</name> <init>= <expr><call><name>generate_qualified_relation_name</name><argument_list>(<argument><expr><name>parentId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>detachPartitionCommand</name></expr></argument>,
					 <argument><expr><literal type="string">"ALTER TABLE IF EXISTS %s DETACH PARTITION %s;"</literal></expr></argument>,
					 <argument><expr><name>parentTableQualifiedName</name></expr></argument>, <argument><expr><name>tableQualifiedName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>detachPartitionCommand</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GenerateDetachPartitionCommandRelationIdList returns the necessary command list to
 * detach the given partitions from their parents.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>GenerateDetachPartitionCommandRelationIdList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>relationIds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>detachPartitionCommands</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>relationId</argument>, <argument>relationIds</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PartitionTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>detachCommand</name> <init>= <expr><call><name>GenerateDetachPartitionCommand</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>detachPartitionCommands</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>detachPartitionCommands</name></expr></argument>, <argument><expr><name>detachCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>detachPartitionCommands</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GenereatePartitioningInformation returns the partitioning type and partition column
 * for the given parent table in the form of "PARTITION TYPE (partitioning column(s)/expression(s))".
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>GeneratePartitioningInformation</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>parentTableId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>partitionBoundCString</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PartitionedTable</name><argument_list>(<argument><expr><name>parentTableId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>parentTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a parent table"</literal></expr></argument>, <argument><expr><name>relationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Datum</name></type> <name>partitionBoundDatum</name> <init>= <expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>pg_get_partkeydef</name></expr></argument>,
													<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>parentTableId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>partitionBoundCString</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>partitionBoundDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>partitionBoundCString</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GenerateAttachShardPartitionCommand generates command to attach a child table
 * table to its parent in a partitioning hierarchy.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>GenerateAttachShardPartitionCommand</name><parameter_list>(<parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>schemaId</name> <init>= <expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>schemaName</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>schemaId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>escapedSchemaName</name> <init>= <expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>command</name> <init>= <expr><call><name>GenerateAlterTableAttachPartitionCommand</name><argument_list>(<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>escapedCommand</name> <init>= <expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>shardIndex</name> <init>= <expr><call><name>ShardIndex</name><argument_list>(<argument><expr><name>shardInterval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


	<decl_stmt><decl><type><name>StringInfo</name></type> <name>attachPartitionCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>parentRelationId</name> <init>= <expr><call><name>PartitionParentOid</name><argument_list>(<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>parentRelationId</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot attach partition"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Referenced relation cannot be found."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>parentSchemaId</name> <init>= <expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>parentRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>parentSchemaName</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>parentSchemaId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>escapedParentSchemaName</name> <init>= <expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>parentSchemaName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>parentShardId</name> <init>= <expr><call><name>ColocatedShardIdInRelation</name><argument_list>(<argument><expr><name>parentRelationId</name></expr></argument>, <argument><expr><name>shardIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>attachPartitionCommand</name></expr></argument>,
					 <argument><expr><name>WORKER_APPLY_INTER_SHARD_DDL_COMMAND</name></expr></argument>, <argument><expr><name>parentShardId</name></expr></argument>,
					 <argument><expr><name>escapedParentSchemaName</name></expr></argument>, <argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>,
					 <argument><expr><name>escapedSchemaName</name></expr></argument>, <argument><expr><name>escapedCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>attachPartitionCommand</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GenerateAlterTableAttachPartitionCommand returns the necessary command to
 * attach the given partition to its parent.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>GenerateAlterTableAttachPartitionCommand</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>partitionTableId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>createPartitionCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>


	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PartitionTable</name><argument_list>(<argument><expr><name>partitionTableId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>partitionTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a partition"</literal></expr></argument>, <argument><expr><name>relationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>parentId</name> <init>= <expr><call><name>get_partition_parent_compat</name><argument_list>(<argument><expr><name>partitionTableId</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tableQualifiedName</name> <init>= <expr><call><name>generate_qualified_relation_name</name><argument_list>(<argument><expr><name>partitionTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>parentTableQualifiedName</name> <init>= <expr><call><name>generate_qualified_relation_name</name><argument_list>(<argument><expr><name>parentId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>partitionBoundCString</name> <init>= <expr><call><name>PartitionBound</name><argument_list>(<argument><expr><name>partitionTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>createPartitionCommand</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE %s ATTACH PARTITION %s %s;"</literal></expr></argument>,
					 <argument><expr><name>parentTableQualifiedName</name></expr></argument>, <argument><expr><name>tableQualifiedName</name></expr></argument>,
					 <argument><expr><name>partitionBoundCString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>createPartitionCommand</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GenerateAttachPartitionCommandRelationIdList returns the necessary command list to
 * attach the given partitions to their parents.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>GenerateAttachPartitionCommandRelationIdList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>relationIds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>attachPartitionCommands</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>relationId</argument>, <argument>relationIds</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>attachCommand</name> <init>= <expr><call><name>GenerateAlterTableAttachPartitionCommand</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>attachPartitionCommands</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>attachPartitionCommands</name></expr></argument>, <argument><expr><name>attachCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>attachPartitionCommands</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * This function heaviliy inspired from RelationBuildPartitionDesc()
 * which is avaliable in src/backend/catalog/partition.c.
 *
 * The function simply reads the pg_class and gets the partition bound.
 * Later, converts it to text format and returns.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>PartitionBound</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>partitionId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>isnull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name> <init>= <expr><call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><name>partitionId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>partitionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * It is possible that the pg_class tuple of a partition has not been
	 * updated yet to set its relpartbound field.  The only case where
	 * this happens is when we open the parent relation to check using its
	 * partition descriptor that a new partition's bound does not overlap
	 * some existing partition.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>relispartition</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="string">""</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Datum</name></type> <name>datum</name> <init>= <expr><call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>,
								  <argument><expr><name>Anum_pg_class_relpartbound</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Datum</name></type> <name>partitionBoundDatum</name> <init>=
		<expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>pg_get_expr</name></expr></argument>, <argument><expr><name>datum</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>partitionId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>partitionBoundString</name> <init>= <expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>partitionBoundDatum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>partitionBoundString</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ListShardsUnderParentRelation returns a list of ShardInterval for every
 * shard under a given relation, meaning it includes the shards of child
 * tables in a partitioning hierarchy.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>ListShardsUnderParentRelation</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardList</name> <init>= <expr><call><name>LoadShardIntervalList</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PartitionedTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>partitionList</name> <init>= <expr><call><name>PartitionList</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>partitionRelationId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

		<macro><name>foreach_oid</name><argument_list>(<argument>partitionRelationId</argument>, <argument>partitionList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>childShardList</name> <init>= <expr><call><name>ListShardsUnderParentRelation</name><argument_list>(<argument><expr><name>partitionRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>shardList</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>shardList</name></expr></argument>, <argument><expr><name>childShardList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>shardList</name></expr>;</return>
</block_content>}</block></function>
</unit>
