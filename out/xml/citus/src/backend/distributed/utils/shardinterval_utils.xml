<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/citus/src/backend/distributed/utils/shardinterval_utils.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * shardinterval_utils.c
 *
 * This file contains functions to perform useful operations on shard intervals.
 *
 * Copyright (c) Citus Data, Inc.
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stdint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/nbtree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_join_order.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/distributed_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shard_pruning.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shardinterval_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_dist_partition.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/catcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>


<comment type="block">/*
 * SortedShardIntervalArray sorts the input shardIntervalArray. Shard intervals with
 * no min/max values are placed at the end of the array.
 */</comment>
<function><type><name>ShardInterval</name> <modifier>*</modifier><modifier>*</modifier></type>
<name>SortShardIntervalArray</name><parameter_list>(<parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier><modifier>*</modifier></type><name>shardIntervalArray</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>shardCount</name></decl></parameter>,
					   <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>, <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>shardIntervalSortCompareFunction</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SortShardIntervalContext</name></type> <name>sortContext</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>comparisonFunction</name> <operator>=</operator> <name>shardIntervalSortCompareFunction</name></expr>,
		<expr><operator>.</operator><name>collation</name> <operator>=</operator> <name>collation</name></expr>
	}</block></expr></init></decl>;</decl_stmt>

	<comment type="block">/* short cut if there are no shard intervals in the array */</comment>
	<if_stmt><if>if <condition>(<expr><name>shardCount</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>shardIntervalArray</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* if a shard doesn't have min/max values, it's placed in the end of the array */</comment>
	<expr_stmt><expr><call><name>qsort_arg</name><argument_list>(<argument><expr><name>shardIntervalArray</name></expr></argument>, <argument><expr><name>shardCount</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ShardInterval</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>,
			  <argument><expr><operator>(</operator><name>qsort_arg_comparator</name><operator>)</operator> <name>CompareShardIntervals</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>sortContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>shardIntervalArray</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CompareShardIntervals acts as a helper function to compare two shard intervals
 * by their minimum values, using the value's type comparison function.
 *
 * If a shard interval does not have min/max value, it's treated as being greater
 * than the other.
 */</comment>
<function><type><name>int</name></type>
<name>CompareShardIntervals</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>leftElement</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>rightElement</name></decl></parameter>,
					  <parameter><decl><type><name>SortShardIntervalContext</name> <modifier>*</modifier></type><name>sortContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>leftShardInterval</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>ShardInterval</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>leftElement</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>rightShardInterval</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>ShardInterval</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>rightElement</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>comparisonResult</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>leftHasNull</name> <init>= <expr><operator>(</operator><operator>!</operator><name><name>leftShardInterval</name><operator>-&gt;</operator><name>minValueExists</name></name> <operator>||</operator>
						<operator>!</operator><name><name>leftShardInterval</name><operator>-&gt;</operator><name>maxValueExists</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>rightHasNull</name> <init>= <expr><operator>(</operator><operator>!</operator><name><name>rightShardInterval</name><operator>-&gt;</operator><name>minValueExists</name></name> <operator>||</operator>
						 <operator>!</operator><name><name>rightShardInterval</name><operator>-&gt;</operator><name>maxValueExists</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>sortContext</name><operator>-&gt;</operator><name>comparisonFunction</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>leftHasNull</name> <operator>&amp;&amp;</operator> <name>rightHasNull</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>comparisonResult</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>leftHasNull</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>comparisonResult</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>rightHasNull</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>comparisonResult</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* if both shard interval have min/max values, calculate comparison result */</comment>
		<decl_stmt><decl><type><name>Datum</name></type> <name>leftDatum</name> <init>= <expr><name><name>leftShardInterval</name><operator>-&gt;</operator><name>minValue</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type> <name>rightDatum</name> <init>= <expr><name><name>rightShardInterval</name><operator>-&gt;</operator><name>minValue</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type> <name>comparisonDatum</name> <init>= <expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><name><name>sortContext</name><operator>-&gt;</operator><name>comparisonFunction</name></name></expr></argument>,
												  <argument><expr><name><name>sortContext</name><operator>-&gt;</operator><name>collation</name></name></expr></argument>, <argument><expr><name>leftDatum</name></expr></argument>,
												  <argument><expr><name>rightDatum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>comparisonResult</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>comparisonDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Two different shards should never be equal */</comment>
	<if_stmt><if>if <condition>(<expr><name>comparisonResult</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>CompareShardIntervalsById</name><argument_list>(<argument><expr><name>leftElement</name></expr></argument>, <argument><expr><name>rightElement</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>comparisonResult</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CompareShardIntervalsById is a comparison function for sort shard
 * intervals by their shard ID.
 */</comment>
<function><type><name>int</name></type>
<name>CompareShardIntervalsById</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>leftElement</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>rightElement</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>leftInterval</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>ShardInterval</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>leftElement</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>rightInterval</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>ShardInterval</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>rightElement</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>leftShardId</name> <init>= <expr><name><name>leftInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>rightShardId</name> <init>= <expr><name><name>rightInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* we compare 64-bit integers, instead of casting their difference to int */</comment>
	<if_stmt><if>if <condition>(<expr><name>leftShardId</name> <operator>&gt;</operator> <name>rightShardId</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>leftShardId</name> <operator>&lt;</operator> <name>rightShardId</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CompareShardPlacementsByShardId is a comparison function for sorting shard
 * placement by their shard ID.
 */</comment>
<function><type><name>int</name></type>
<name>CompareShardPlacementsByShardId</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>leftElement</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>rightElement</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GroupShardPlacement</name> <modifier>*</modifier></type><name>left</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>GroupShardPlacement</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>leftElement</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GroupShardPlacement</name> <modifier>*</modifier></type><name>right</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>GroupShardPlacement</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>rightElement</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>leftShardId</name> <init>= <expr><name><name>left</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>rightShardId</name> <init>= <expr><name><name>right</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* we compare 64-bit integers, instead of casting their difference to int */</comment>
	<if_stmt><if>if <condition>(<expr><name>leftShardId</name> <operator>&gt;</operator> <name>rightShardId</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>leftShardId</name> <operator>&lt;</operator> <name>rightShardId</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CompareRelationShards is a comparison function for sorting relation
 * to shard mappings by their relation ID and then shard ID.
 */</comment>
<function><type><name>int</name></type>
<name>CompareRelationShards</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>leftElement</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>rightElement</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelationShard</name> <modifier>*</modifier></type><name>leftRelationShard</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>RelationShard</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>leftElement</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelationShard</name> <modifier>*</modifier></type><name>rightRelationShard</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>RelationShard</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>rightElement</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>leftRelationId</name> <init>= <expr><name><name>leftRelationShard</name><operator>-&gt;</operator><name>relationId</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>rightRelationId</name> <init>= <expr><name><name>rightRelationShard</name><operator>-&gt;</operator><name>relationId</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>leftShardId</name> <init>= <expr><name><name>leftRelationShard</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>rightShardId</name> <init>= <expr><name><name>rightRelationShard</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>leftRelationId</name> <operator>&gt;</operator> <name>rightRelationId</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>leftRelationId</name> <operator>&lt;</operator> <name>rightRelationId</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>leftShardId</name> <operator>&gt;</operator> <name>rightShardId</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>leftShardId</name> <operator>&lt;</operator> <name>rightShardId</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ShardIndex finds the index of given shard in sorted shard interval array.
 *
 * For hash partitioned tables, it calculates hash value of a number in its
 * range (e.g. min value) and finds which shard should contain the hashed
 * value. For reference tables and citus local tables, it simply returns 0.
 * For the other table types, the function errors out.
 */</comment>
<function><type><name>int</name></type>
<name>ShardIndex</name><parameter_list>(<parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>shardIndex</name> <init>= <expr><name>INVALID_SHARD_INDEX</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distributedTableId</name> <init>= <expr><name><name>shardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>shardMinValue</name> <init>= <expr><name><name>shardInterval</name><operator>-&gt;</operator><name>minValue</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>cacheEntry</name> <init>= <expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name>distributedTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Note that, we can also support append and range distributed tables, but
	 * currently it is not required.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCitusTableTypeCacheEntry</name><argument_list>(<argument><expr><name>cacheEntry</name></expr></argument>, <argument><expr><name>HASH_DISTRIBUTED</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>IsCitusTableTypeCacheEntry</name><argument_list>(
			<argument><expr><name>cacheEntry</name></expr></argument>, <argument><expr><name>CITUS_TABLE_WITH_NO_DIST_KEY</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"finding index of a given shard is only supported for "</literal>
							   <literal type="string">"hash distributed tables, reference tables and local "</literal>
							   <literal type="string">"tables that are added to citus metadata"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* short-circuit for reference tables */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableTypeCacheEntry</name><argument_list>(<argument><expr><name>cacheEntry</name></expr></argument>, <argument><expr><name>CITUS_TABLE_WITH_NO_DIST_KEY</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Reference tables and citus local tables have only a single shard,
		 * so the index is fixed to 0.
		 */</comment>
		<expr_stmt><expr><name>shardIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<return>return <expr><name>shardIndex</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>shardIndex</name> <operator>=</operator> <call><name>FindShardIntervalIndex</name><argument_list>(<argument><expr><name>shardMinValue</name></expr></argument>, <argument><expr><name>cacheEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>shardIndex</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FindShardInterval finds a single shard interval in the cache for the
 * given partition column value. Note that reference tables do not have
 * partition columns, thus, pass partitionColumnValue and compareFunction
 * as NULL for them.
 */</comment>
<function><type><name>ShardInterval</name> <modifier>*</modifier></type>
<name>FindShardInterval</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>partitionColumnValue</name></decl></parameter>, <parameter><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>cacheEntry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type> <name>searchedValue</name> <init>= <expr><name>partitionColumnValue</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableTypeCacheEntry</name><argument_list>(<argument><expr><name>cacheEntry</name></expr></argument>, <argument><expr><name>HASH_DISTRIBUTED</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>searchedValue</name> <operator>=</operator> <call><name>FunctionCall1Coll</name><argument_list>(<argument><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>hashFunction</name></name></expr></argument>,
										  <argument><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>partitionColumn</name><operator>-&gt;</operator><name>varcollid</name></name></expr></argument>,
										  <argument><expr><name>partitionColumnValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>shardIndex</name> <init>= <expr><call><name>FindShardIntervalIndex</name><argument_list>(<argument><expr><name>searchedValue</name></expr></argument>, <argument><expr><name>cacheEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>shardIndex</name> <operator>==</operator> <name>INVALID_SHARD_INDEX</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>sortedShardIntervalArray</name><index>[<expr><name>shardIndex</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FindShardIntervalIndex finds the index of the shard interval which covers
 * the searched value. Note that the searched value must be the hashed value
 * of the original value if the distribution method is hash.
 *
 * Note that, if the searched value can not be found for hash partitioned
 * tables, we error out (unless there are no shards, in which case
 * INVALID_SHARD_INDEX is returned). This should only happen if something is
 * terribly wrong, either metadata tables are corrupted or we have a bug
 * somewhere. Such as a hash function which returns a value not in the range
 * of [PG_INT32_MIN, PG_INT32_MAX] can fire this.
 */</comment>
<function><type><name>int</name></type>
<name>FindShardIntervalIndex</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>searchedValue</name></decl></parameter>, <parameter><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>cacheEntry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier><modifier>*</modifier></type><name>shardIntervalCache</name> <init>= <expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>sortedShardIntervalArray</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>shardCount</name> <init>= <expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>shardIntervalArrayLength</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>compareFunction</name> <init>= <expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>shardIntervalCompareFunction</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>useBinarySearch</name> <init>= <expr><operator>(</operator><operator>!</operator><call><name>IsCitusTableTypeCacheEntry</name><argument_list>(<argument><expr><name>cacheEntry</name></expr></argument>, <argument><expr><name>HASH_DISTRIBUTED</name></expr></argument>)</argument_list></call> <operator>||</operator>
							<operator>!</operator><name><name>cacheEntry</name><operator>-&gt;</operator><name>hasUniformHashDistribution</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>shardIndex</name> <init>= <expr><name>INVALID_SHARD_INDEX</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>shardCount</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>INVALID_SHARD_INDEX</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableTypeCacheEntry</name><argument_list>(<argument><expr><name>cacheEntry</name></expr></argument>, <argument><expr><name>HASH_DISTRIBUTED</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>useBinarySearch</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>compareFunction</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<decl_stmt><decl><type><name>Oid</name></type> <name>shardIntervalCollation</name> <init>= <expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>partitionColumn</name><operator>-&gt;</operator><name>varcollid</name></name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>shardIndex</name> <operator>=</operator> <call><name>SearchCachedShardInterval</name><argument_list>(<argument><expr><name>searchedValue</name></expr></argument>, <argument><expr><name>shardIntervalCache</name></expr></argument>,
												   <argument><expr><name>shardCount</name></expr></argument>, <argument><expr><name>shardIntervalCollation</name></expr></argument>,
												   <argument><expr><name>compareFunction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* we should always return a valid shard index for hash partitioned tables */</comment>
			<if_stmt><if>if <condition>(<expr><name>shardIndex</name> <operator>==</operator> <name>INVALID_SHARD_INDEX</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot find shard interval"</literal></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Hash of the partition column value "</literal>
										  <literal type="string">"does not fall into any shards."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>hashedValue</name> <init>= <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>searchedValue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>shardIndex</name> <operator>=</operator> <call><name>CalculateUniformHashRangeIndex</name><argument_list>(<argument><expr><name>hashedValue</name></expr></argument>, <argument><expr><name>shardCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsCitusTableTypeCacheEntry</name><argument_list>(<argument><expr><name>cacheEntry</name></expr></argument>, <argument><expr><name>CITUS_TABLE_WITH_NO_DIST_KEY</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* non-distributed tables have a single shard, all values mapped to that shard */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>shardCount</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>shardIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>compareFunction</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>Oid</name></type> <name>shardIntervalCollation</name> <init>= <expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>partitionColumn</name><operator>-&gt;</operator><name>varcollid</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>shardIndex</name> <operator>=</operator> <call><name>SearchCachedShardInterval</name><argument_list>(<argument><expr><name>searchedValue</name></expr></argument>, <argument><expr><name>shardIntervalCache</name></expr></argument>,
											   <argument><expr><name>shardCount</name></expr></argument>, <argument><expr><name>shardIntervalCollation</name></expr></argument>,
											   <argument><expr><name>compareFunction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>shardIndex</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SearchCachedShardInterval performs a binary search for a shard interval
 * matching a given partition column value and returns its index in the cached
 * array. If it can not find any shard interval with the given value, it returns
 * INVALID_SHARD_INDEX.
 *
 * TODO: Data re-partitioning logic (worker_partition_query_resul))
 * on the worker nodes relies on this function in order to be consistent
 * with shard pruning. Since the worker nodes don't have the metadata, a
 * synthetically generated ShardInterval ** is passed to this
 * function. The synthetic shard intervals contain only shardmin and shardmax
 * values. A proper implementation of this approach should be introducing an
 * intermediate data structure (e.g., ShardRange) on which this function
 * operates instead of operating shard intervals.
 */</comment>
<function><type><name>int</name></type>
<name>SearchCachedShardInterval</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>partitionColumnValue</name></decl></parameter>, <parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier><modifier>*</modifier></type><name>shardIntervalCache</name></decl></parameter>,
						  <parameter><decl><type><name>int</name></type> <name>shardCount</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>shardIntervalCollation</name></decl></parameter>,
						  <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>compareFunction</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>lowerBoundIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>upperBoundIndex</name> <init>= <expr><name>shardCount</name></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>lowerBoundIndex</name> <operator>&lt;</operator> <name>upperBoundIndex</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>middleIndex</name> <init>= <expr><operator>(</operator><name>lowerBoundIndex</name> <operator>+</operator> <name>upperBoundIndex</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>int</name></type> <name>minValueComparison</name> <init>= <expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><name>compareFunction</name></expr></argument>,
												   <argument><expr><name>shardIntervalCollation</name></expr></argument>,
												   <argument><expr><name>partitionColumnValue</name></expr></argument>,
												   <argument><expr><name><name>shardIntervalCache</name><index>[<expr><name>middleIndex</name></expr>]</index></name><operator>-&gt;</operator>
												   <name>minValue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>minValueComparison</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>upperBoundIndex</name> <operator>=</operator> <name>middleIndex</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>int</name></type> <name>maxValueComparison</name> <init>= <expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><name>compareFunction</name></expr></argument>,
												   <argument><expr><name>shardIntervalCollation</name></expr></argument>,
												   <argument><expr><name>partitionColumnValue</name></expr></argument>,
												   <argument><expr><name><name>shardIntervalCache</name><index>[<expr><name>middleIndex</name></expr>]</index></name><operator>-&gt;</operator>
												   <name>maxValue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>maxValueComparison</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>middleIndex</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>lowerBoundIndex</name> <operator>=</operator> <name>middleIndex</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>INVALID_SHARD_INDEX</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CalculateUniformHashRangeIndex returns the index of the hash range in
 * which hashedValue falls, assuming shardCount uniform hash ranges.
 *
 * We use 64-bit integers to avoid overflow issues during arithmetic.
 *
 * NOTE: This function is ONLY for hash-distributed tables with uniform
 * hash ranges.
 */</comment>
<function><type><name>int</name></type>
<name>CalculateUniformHashRangeIndex</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>hashedValue</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>shardCount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type> <name>hashedValue64</name> <init>= <expr><operator>(</operator><name>int64</name><operator>)</operator> <name>hashedValue</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* normalize to the 0-UINT32_MAX range */</comment>
	<decl_stmt><decl><type><name>int64</name></type> <name>normalizedHashValue</name> <init>= <expr><name>hashedValue64</name> <operator>-</operator> <name>PG_INT32_MIN</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* size of each hash range */</comment>
	<decl_stmt><decl><type><name>int64</name></type> <name>hashRangeSize</name> <init>= <expr><name>HASH_TOKEN_COUNT</name> <operator>/</operator> <name>shardCount</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* index of hash range into which the hash value falls */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>shardIndex</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>normalizedHashValue</name> <operator>/</operator> <name>hashRangeSize</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>shardIndex</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>shardIndex</name></expr></argument> &gt;</argument_list></name> <name>shardCount</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"bug: shard index %d out of bounds"</literal></expr></argument>, <argument><expr><name>shardIndex</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the shard count is not power of 2, the range of the last
	 * shard becomes larger than others. For that extra piece of range,
	 * we still need to use the last shard.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>shardIndex</name> <operator>==</operator> <name>shardCount</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>shardIndex</name> <operator>=</operator> <name>shardCount</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>shardIndex</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SingleReplicatedTable checks whether all shards of a distributed table, do not have
 * more than one replica. If even one shard has more than one replica, this function
 * returns false, otherwise it returns true.
 */</comment>
<function><type><name>bool</name></type>
<name>SingleReplicatedTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardList</name> <init>= <expr><call><name>LoadShardList</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardPlacementList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* we could have append/range distributed tables without shards */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>shardList</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardIntervalList</name> <init>= <expr><call><name>LoadShardList</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name> <modifier>*</modifier></type><name>shardIdPointer</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>shardIdPointer</argument>, <argument>shardIntervalList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint64</name></type> <name>shardId</name> <init>= <expr><operator>*</operator><name>shardIdPointer</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>shardPlacementList</name> <operator>=</operator> <call><name>ShardPlacementListWithoutOrphanedPlacements</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>shardPlacementList</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>
</unit>
