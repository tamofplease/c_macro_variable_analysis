<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/citus/src/backend/distributed/utils/citus_nodefuncs.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * citus_nodefuncs.c
 *	  Helper functions for dealing with nodes
 *
 * Copyright (c) Citus Data, Inc.
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_version_constants.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_nodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_nodefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/coordinator_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/errormessage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/log_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/distributed_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_router_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_server_executor.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>CitusNodeTagNamesD</name><index>[]</index></name> <init>= <expr><block>{
	<expr><literal type="string">"MultiNode"</literal></expr>,
	<expr><literal type="string">"MultiTreeRoot"</literal></expr>,
	<expr><literal type="string">"MultiProject"</literal></expr>,
	<expr><literal type="string">"MultiCollect"</literal></expr>,
	<expr><literal type="string">"MultiSelect"</literal></expr>,
	<expr><literal type="string">"MultiTable"</literal></expr>,
	<expr><literal type="string">"MultiJoin"</literal></expr>,
	<expr><literal type="string">"MultiPartition"</literal></expr>,
	<expr><literal type="string">"MultiCartesianProduct"</literal></expr>,
	<expr><literal type="string">"MultiExtendedOp"</literal></expr>,
	<expr><literal type="string">"Job"</literal></expr>,
	<expr><literal type="string">"MapMergeJob"</literal></expr>,
	<expr><literal type="string">"DistributedPlan"</literal></expr>,
	<expr><literal type="string">"DistributedSubPlan"</literal></expr>,
	<expr><literal type="string">"UsedDistributedSubPlan"</literal></expr>,
	<expr><literal type="string">"Task"</literal></expr>,
	<expr><literal type="string">"LocalPlannedStatement"</literal></expr>,
	<expr><literal type="string">"ShardInterval"</literal></expr>,
	<expr><literal type="string">"ShardPlacement"</literal></expr>,
	<expr><literal type="string">"RelationShard"</literal></expr>,
	<expr><literal type="string">"RelationRowLock"</literal></expr>,
	<expr><literal type="string">"DeferredErrorMessage"</literal></expr>,
	<expr><literal type="string">"GroupShardPlacement"</literal></expr>,
	<expr><literal type="string">"TableDDLCommand"</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>CitusNodeTagNames</name> <init>= <expr><name>CitusNodeTagNamesD</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* support for CitusNewNode() macro */</comment>
<decl_stmt><decl><type><name>CitusNode</name> <modifier>*</modifier></type><name>newCitusNodeMacroHolder</name></decl>;</decl_stmt>

<comment type="block">/* exports for SQL callable functions */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>citus_extradata_container</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<comment type="block">/*
 * SetRangeTblExtraData adds additional data to a RTE, overwriting previous
 * values, if present.
 *
 * The data is stored as RTE_FUNCTION type RTE of a special
 * citus_extradata_container function, with the extra data serialized into the
 * function arguments. That works, because these RTEs aren't used by Postgres
 * to any significant degree, and Citus' variant of ruleutils.c knows how to
 * deal with these extended RTEs. Note that rte-&gt;eref needs to be set prior
 * to calling SetRangeTblExtraData to ensure the funccolcount can be set
 * correctly.
 *
 * NB: If used for postgres defined RTEKinds, fields specific to that RTEKind
 * will not be handled by out/readfuncs.c. For the current uses that's ok.
 */</comment>
<function><type><name>void</name></type>
<name>SetRangeTblExtraData</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>, <parameter><decl><type><name>CitusRTEKind</name></type> <name>rteKind</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>fragmentSchemaName</name></decl></parameter>,
					 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>fragmentTableName</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tableIdList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>funcColumnNames</name></decl></parameter>,
					 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>funcColumnTypes</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>funcColumnTypeMods</name></decl></parameter>,
					 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>funcCollations</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* store RTE kind as a plain int4 */</comment>
	<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>rteKindData</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>rteKindData</name><operator>-&gt;</operator><name>consttype</name></name> <operator>=</operator> <name>INT4OID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rteKindData</name><operator>-&gt;</operator><name>constlen</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rteKindData</name><operator>-&gt;</operator><name>constvalue</name></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>rteKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rteKindData</name><operator>-&gt;</operator><name>constbyval</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rteKindData</name><operator>-&gt;</operator><name>constisnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rteKindData</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/* store the fragment schema as a cstring */</comment>
	<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>fragmentSchemaData</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>fragmentSchemaData</name><operator>-&gt;</operator><name>consttype</name></name> <operator>=</operator> <name>CSTRINGOID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fragmentSchemaData</name><operator>-&gt;</operator><name>constlen</name></name> <operator>=</operator> <operator>-</operator><literal type="number">2</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fragmentSchemaData</name><operator>-&gt;</operator><name>constvalue</name></name> <operator>=</operator> <call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>fragmentSchemaName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fragmentSchemaData</name><operator>-&gt;</operator><name>constbyval</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fragmentSchemaData</name><operator>-&gt;</operator><name>constisnull</name></name> <operator>=</operator> <name>fragmentSchemaName</name> <operator>==</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fragmentSchemaData</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/* store the fragment name as a cstring */</comment>
	<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>fragmentTableData</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>fragmentTableData</name><operator>-&gt;</operator><name>consttype</name></name> <operator>=</operator> <name>CSTRINGOID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fragmentTableData</name><operator>-&gt;</operator><name>constlen</name></name> <operator>=</operator> <operator>-</operator><literal type="number">2</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fragmentTableData</name><operator>-&gt;</operator><name>constvalue</name></name> <operator>=</operator> <call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>fragmentTableName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fragmentTableData</name><operator>-&gt;</operator><name>constbyval</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fragmentTableData</name><operator>-&gt;</operator><name>constisnull</name></name> <operator>=</operator> <name>fragmentTableName</name> <operator>==</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fragmentTableData</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/* store the table id list as an array of integers: FIXME */</comment>
	<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>tableIdListData</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>tableIdListData</name><operator>-&gt;</operator><name>consttype</name></name> <operator>=</operator> <name>CSTRINGOID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tableIdListData</name><operator>-&gt;</operator><name>constbyval</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tableIdListData</name><operator>-&gt;</operator><name>constlen</name></name> <operator>=</operator> <operator>-</operator><literal type="number">2</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tableIdListData</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/* serialize tableIdList to a string, seems simplest that way */</comment>
	<if_stmt><if>if <condition>(<expr><name>tableIdList</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>serializedList</name> <init>= <expr><call><name>nodeToString</name><argument_list>(<argument><expr><name>tableIdList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>tableIdListData</name><operator>-&gt;</operator><name>constisnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tableIdListData</name><operator>-&gt;</operator><name>constvalue</name></name> <operator>=</operator> <call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>serializedList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>tableIdListData</name><operator>-&gt;</operator><name>constisnull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* create function expression to store our faux arguments in */</comment>
	<decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>fauxFuncExpr</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>fauxFuncExpr</name><operator>-&gt;</operator><name>funcid</name></name> <operator>=</operator> <call><name>CitusExtraDataContainerFuncId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fauxFuncExpr</name><operator>-&gt;</operator><name>funcresulttype</name></name> <operator>=</operator> <name>RECORDOID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fauxFuncExpr</name><operator>-&gt;</operator><name>funcretset</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fauxFuncExpr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fauxFuncExpr</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>list_make4</name><argument_list>(<argument><expr><name>rteKindData</name></expr></argument>, <argument><expr><name>fragmentSchemaData</name></expr></argument>,
									<argument><expr><name>fragmentTableData</name></expr></argument>, <argument><expr><name>tableIdListData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>RangeTblFunction</name> <modifier>*</modifier></type><name>fauxFunction</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblFunction</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>fauxFunction</name><operator>-&gt;</operator><name>funcexpr</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>fauxFuncExpr</name></expr>;</expr_stmt>

	<comment type="block">/* set the column count to pass ruleutils checks, not used elsewhere */</comment>
	<expr_stmt><expr><name><name>fauxFunction</name><operator>-&gt;</operator><name>funccolcount</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fauxFunction</name><operator>-&gt;</operator><name>funccolnames</name></name> <operator>=</operator> <name>funcColumnNames</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fauxFunction</name><operator>-&gt;</operator><name>funccoltypes</name></name> <operator>=</operator> <name>funcColumnTypes</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fauxFunction</name><operator>-&gt;</operator><name>funccoltypmods</name></name> <operator>=</operator> <name>funcColumnTypeMods</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fauxFunction</name><operator>-&gt;</operator><name>funccolcollations</name></name> <operator>=</operator> <name>funcCollations</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>=</operator> <name>RTE_FUNCTION</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>functions</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>fauxFunction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ExtractRangeTblExtraData extracts extra data stored for a range table entry
 * that previously has been stored with
 * Set/ModifyRangeTblExtraData. Parameters can be NULL if unintersting. It is
 * valid to use the function on a RTE without extra data.
 */</comment>
<function><type><name>void</name></type>
<name>ExtractRangeTblExtraData</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>, <parameter><decl><type><name>CitusRTEKind</name> <modifier>*</modifier></type><name>rteKind</name></decl></parameter>,
						 <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>fragmentSchemaName</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>fragmentTableName</name></decl></parameter>,
						 <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>tableIdList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* set base rte kind first, so this can be used for 'non-extended' RTEs as well */</comment>
	<if_stmt><if>if <condition>(<expr><name>rteKind</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>rteKind</name> <operator>=</operator> <operator>(</operator><name>CitusRTEKind</name><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* reset values of optionally-present fields, will later be overwritten, if present */</comment>
	<if_stmt><if>if <condition>(<expr><name>fragmentSchemaName</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>fragmentSchemaName</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>fragmentTableName</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>fragmentTableName</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>tableIdList</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>tableIdList</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>


	<comment type="block">/* only function RTEs have our special extra data */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_FUNCTION</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* we only ever generate one argument */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* should pretty much always be a FuncExpr, but be liberal in what we expect... */</comment>
	<decl_stmt><decl><type><name>RangeTblFunction</name> <modifier>*</modifier></type><name>fauxFunction</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>fauxFunction</name><operator>-&gt;</operator><name>funcexpr</name></name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>fauxFuncExpr</name> <init>= <expr><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name><name>fauxFunction</name><operator>-&gt;</operator><name>funcexpr</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * There will never be a range table entry with this function id, but for
	 * the purpose of this file.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fauxFuncExpr</name><operator>-&gt;</operator><name>funcid</name></name> <operator>!=</operator> <call><name>CitusExtraDataContainerFuncId</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Extra data for rtes is stored in the function arguments. The first
	 * argument stores the rtekind, second fragmentSchemaName, third
	 * fragmentTableName, fourth tableIdList.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>fauxFuncExpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">4</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected number of function arguments to "</literal>
							   <literal type="string">"citus_extradata_container"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* extract rteKind */</comment>
	<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>tmpConst</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>fauxFuncExpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>tmpConst</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tmpConst</name><operator>-&gt;</operator><name>consttype</name></name> <operator>==</operator> <name>INT4OID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rteKind</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>rteKind</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>tmpConst</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* extract fragmentSchemaName */</comment>
	<expr_stmt><expr><name>tmpConst</name> <operator>=</operator> <operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>fauxFuncExpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>tmpConst</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tmpConst</name><operator>-&gt;</operator><name>consttype</name></name> <operator>==</operator> <name>CSTRINGOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fragmentSchemaName</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>tmpConst</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>fragmentSchemaName</name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(<argument><expr><name><name>tmpConst</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* extract fragmentTableName */</comment>
	<expr_stmt><expr><name>tmpConst</name> <operator>=</operator> <operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <call><name>lthird</name><argument_list>(<argument><expr><name><name>fauxFuncExpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>tmpConst</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tmpConst</name><operator>-&gt;</operator><name>consttype</name></name> <operator>==</operator> <name>CSTRINGOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fragmentTableName</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>tmpConst</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>fragmentTableName</name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(<argument><expr><name><name>tmpConst</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* extract tableIdList, stored as a serialized integer list */</comment>
	<expr_stmt><expr><name>tmpConst</name> <operator>=</operator> <operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <call><name>lfourth</name><argument_list>(<argument><expr><name><name>fauxFuncExpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>tmpConst</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tmpConst</name><operator>-&gt;</operator><name>consttype</name></name> <operator>==</operator> <name>CSTRINGOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>tableIdList</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>tmpConst</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>deserializedList</name> <init>= <expr><call><name>stringToNode</name><argument_list>(<argument><expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><name><name>tmpConst</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>deserializedList</name></expr></argument>, <argument><expr><name>IntList</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>*</operator><name>tableIdList</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name>deserializedList</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ModifyRangeTblExtraData sets the RTE extra data fields for the passed
 * fields, leaving the current values in place for the ones not specified.
 *
 * rteKind has to be specified, fragmentSchemaName, fragmentTableName,
 * tableIdList can be set to NULL/NIL respectively to leave the current values
 * in-place.
 */</comment>
<function><type><name>void</name></type>
<name>ModifyRangeTblExtraData</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>, <parameter><decl><type><name>CitusRTEKind</name></type> <name>rteKind</name></decl></parameter>,
						<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>fragmentSchemaName</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>fragmentTableName</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tableIdList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* load existing values for the arguments not specifying a new value */</comment>
	<expr_stmt><expr><call><name>ExtractRangeTblExtraData</name><argument_list>(<argument><expr><name>rte</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><ternary><condition><expr><name>fragmentSchemaName</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name>fragmentSchemaName</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>,
							 <argument><expr><ternary><condition><expr><name>fragmentTableName</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name>fragmentTableName</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>,
							 <argument><expr><ternary><condition><expr><name>tableIdList</name> <operator>==</operator> <name>NIL</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name>tableIdList</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SetRangeTblExtraData</name><argument_list>(<argument><expr><name>rte</name></expr></argument>, <argument><expr><name>rteKind</name></expr></argument>,
						 <argument><expr><name>fragmentSchemaName</name></expr></argument>, <argument><expr><name>fragmentTableName</name></expr></argument>,
						 <argument><expr><name>tableIdList</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* GetRangeTblKind returns rtekind of a RTE, be it an extended one or not. */</comment>
<function><type><name>CitusRTEKind</name></type>
<name>GetRangeTblKind</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CitusRTEKind</name></type> <name>rteKind</name> <init>= <expr><name>CITUS_RTE_RELATION</name></expr></init></decl> <comment type="block">/* invalid */</comment>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* directly rtekind if it's not possibly an extended RTE */</comment>
		<case>case <expr><name>RTE_TABLEFUNC</name></expr>:</case>
		<case>case <expr><name>RTE_NAMEDTUPLESTORE</name></expr>:</case>
		<case>case <expr><name>RTE_RELATION</name></expr>:</case>
		<case>case <expr><name>RTE_SUBQUERY</name></expr>:</case>
		<case>case <expr><name>RTE_JOIN</name></expr>:</case>
		<case>case <expr><name>RTE_VALUES</name></expr>:</case>
		<case>case <expr><name>RTE_CTE</name></expr>:</case>
		<case>case <expr><name>RTE_RESULT</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><name>rteKind</name> <operator>=</operator> <operator>(</operator><name>CitusRTEKind</name><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>RTE_FUNCTION</name></expr>:</case>
		<block>{<block_content>
			<comment type="block">/*
			 * Extract extra data - correct even if a plain RTE_FUNCTION, not
			 * an extended one, ExtractRangeTblExtraData handles that case
			 * transparently.
			 */</comment>
			<expr_stmt><expr><call><name>ExtractRangeTblExtraData</name><argument_list>(<argument><expr><name>rte</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rteKind</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>
	</block_content>}</block></switch>

	<return>return <expr><name>rteKind</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * citus_extradata_container is a placeholder function to store information
 * needed by Citus in plain postgres node trees. Executor and other hooks
 * should always intercept statements containing calls to this function. It's
 * not actually SQL callable by the user because of an INTERNAL argument.
 */</comment>
<function><type><name>Datum</name></type>
<name>citus_extradata_container</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"not supposed to get here, did you cheat?"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>CopyUnsupportedCitusNode</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ExtensibleNode</name></name> <modifier>*</modifier></type><name>newnode</name></decl></parameter>,
						 <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ExtensibleNode</name></name> <modifier>*</modifier></type><name>oldnode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"not implemented"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>bool</name></type>
<name>EqualUnsupportedCitusNode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ExtensibleNode</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>,
						  <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ExtensibleNode</name></name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"not implemented"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* *INDENT-OFF* */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFINE_NODE_METHODS</name><parameter_list>(<parameter><type><name>type</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>{ \
		#type, \
		sizeof(type), \
		CopyNode##type, \
		EqualUnsupportedCitusNode, \
		Out##type, \
		ReadUnsupportedCitusNode \
	}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFINE_NODE_METHODS_NO_READ</name><parameter_list>(<parameter><type><name>type</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>{ \
		#type, \
		sizeof(type), \
		CopyUnsupportedCitusNode, \
		EqualUnsupportedCitusNode, \
		Out##type, \
		ReadUnsupportedCitusNode \
	}</cpp:value></cpp:define>


<comment type="block">/* *INDENT-ON* */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>ExtensibleNodeMethods</name></type> <name><name>nodeMethods</name><index>[]</index></name> <init>=
<expr><block>{
	<expr><call><name>DEFINE_NODE_METHODS</name><argument_list>(<argument><expr><name>DistributedPlan</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>DEFINE_NODE_METHODS</name><argument_list>(<argument><expr><name>DistributedSubPlan</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>DEFINE_NODE_METHODS</name><argument_list>(<argument><expr><name>UsedDistributedSubPlan</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>DEFINE_NODE_METHODS</name><argument_list>(<argument><expr><name>Job</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>DEFINE_NODE_METHODS</name><argument_list>(<argument><expr><name>ShardInterval</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>DEFINE_NODE_METHODS</name><argument_list>(<argument><expr><name>MapMergeJob</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>DEFINE_NODE_METHODS</name><argument_list>(<argument><expr><name>ShardPlacement</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>DEFINE_NODE_METHODS</name><argument_list>(<argument><expr><name>RelationShard</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>DEFINE_NODE_METHODS</name><argument_list>(<argument><expr><name>RelationRowLock</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>DEFINE_NODE_METHODS</name><argument_list>(<argument><expr><name>Task</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>DEFINE_NODE_METHODS</name><argument_list>(<argument><expr><name>LocalPlannedStatement</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>DEFINE_NODE_METHODS</name><argument_list>(<argument><expr><name>DeferredErrorMessage</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>DEFINE_NODE_METHODS</name><argument_list>(<argument><expr><name>GroupShardPlacement</name></expr></argument>)</argument_list></call></expr>,

	<comment type="block">/* nodes with only output support */</comment>
	<expr><call><name>DEFINE_NODE_METHODS_NO_READ</name><argument_list>(<argument><expr><name>MultiNode</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>DEFINE_NODE_METHODS_NO_READ</name><argument_list>(<argument><expr><name>MultiTreeRoot</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>DEFINE_NODE_METHODS_NO_READ</name><argument_list>(<argument><expr><name>MultiProject</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>DEFINE_NODE_METHODS_NO_READ</name><argument_list>(<argument><expr><name>MultiCollect</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>DEFINE_NODE_METHODS_NO_READ</name><argument_list>(<argument><expr><name>MultiSelect</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>DEFINE_NODE_METHODS_NO_READ</name><argument_list>(<argument><expr><name>MultiTable</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>DEFINE_NODE_METHODS_NO_READ</name><argument_list>(<argument><expr><name>MultiJoin</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>DEFINE_NODE_METHODS_NO_READ</name><argument_list>(<argument><expr><name>MultiPartition</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>DEFINE_NODE_METHODS_NO_READ</name><argument_list>(<argument><expr><name>MultiCartesianProduct</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>DEFINE_NODE_METHODS_NO_READ</name><argument_list>(<argument><expr><name>MultiExtendedOp</name></expr></argument>)</argument_list></call></expr>,
	<macro><name>DEFINE_NODE_METHODS_NO_READ</name><argument_list>(<argument>TableDDLCommand</argument>)</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>

<function><type><name>void</name></type>
<name>RegisterNodes</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>StaticAssertExpr</name><argument_list>(<argument><expr><call><name>lengthof</name><argument_list>(<argument><expr><name>nodeMethods</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>CitusNodeTagNamesD</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><literal type="string">"number of node methods and names do not match"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>off</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>off</name> <operator>&lt;</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>nodeMethods</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>off</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>RegisterExtensibleNodeMethods</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nodeMethods</name><index>[<expr><name>off</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>
</unit>
