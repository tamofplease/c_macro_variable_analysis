<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/citus/src/backend/distributed/utils/maintenanced.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * maintenanced.c
 *	  Background worker run for each citus using database in a postgres
 *    cluster.
 *
 * This file provides infrastructure for launching exactly one a background
 * worker for every database in which citus is used.  That background worker
 * can then perform work like deadlock detection, prepared transaction
 * recovery, and cleanup.
 *
 * Copyright (c) Citus Data, Inc.
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_version_constants.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_extension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"citus_version.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_authid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/async.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/extension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/background_jobs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_safe_lib.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/distributed_deadlock_detection.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/maintenanced.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/coordinator_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shard_cleaner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_sync.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/query_stats.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/statistics_collection.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/transaction_recovery.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/version_compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/bgworker.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/postmaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/latch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lwlock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/hashfn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/resource_lock.h"</cpp:file></cpp:include>

<comment type="block">/*
 * Shared memory data for all maintenance workers.
 */</comment>
<typedef>typedef <type><struct>struct <name>MaintenanceDaemonControlData</name>
<block>{
	<comment type="block">/*
	 * Lock protecting the shared memory state.  This is to be taken when
	 * looking up (shared mode) or inserting (exclusive mode) per-database
	 * data in MaintenanceDaemonDBHash.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>trancheId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>lockTrancheName</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LWLock</name></type> <name>lock</name></decl>;</decl_stmt>
}</block></struct></type> <name>MaintenanceDaemonControlData</name>;</typedef>


<comment type="block">/*
 * Per database worker state.
 */</comment>
<typedef>typedef <type><struct>struct <name>MaintenanceDaemonDBData</name>
<block>{
	<comment type="block">/* hash key: database to run on */</comment>
	<decl_stmt><decl><type><name>Oid</name></type> <name>databaseOid</name></decl>;</decl_stmt>

	<comment type="block">/* information: which user to use */</comment>
	<decl_stmt><decl><type><name>Oid</name></type> <name>userOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pid_t</name></type> <name>workerPid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>daemonStarted</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>triggerNodeMetadataSync</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Latch</name> <modifier>*</modifier></type><name>latch</name></decl>;</decl_stmt> <comment type="block">/* pointer to the background worker's latch */</comment>
}</block></struct></type> <name>MaintenanceDaemonDBData</name>;</typedef>

<comment type="block">/* config variable for distributed deadlock detection timeout */</comment>
<decl_stmt><decl><type><name>double</name></type> <name>DistributedDeadlockDetectionTimeoutFactor</name> <init>= <expr><literal type="number">2.0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>Recover2PCInterval</name> <init>= <expr><literal type="number">60000</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>DeferShardDeleteInterval</name> <init>= <expr><literal type="number">15000</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>BackgroundTaskQueueCheckInterval</name> <init>= <expr><literal type="number">5000</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>MaxBackgroundTaskExecutors</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* config variables for metadata sync timeout */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>MetadataSyncInterval</name> <init>= <expr><literal type="number">60000</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>MetadataSyncRetryInterval</name> <init>= <expr><literal type="number">5000</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>shmem_startup_hook_type</name></type> <name>prev_shmem_startup_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>MaintenanceDaemonControlData</name> <modifier>*</modifier></type><name>MaintenanceDaemonControl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Hash-table of workers, one entry for each database with citus
 * activated.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>MaintenanceDaemonDBHash</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>sig_atomic_t</name></type> <name>got_SIGHUP</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>sig_atomic_t</name></type> <name>got_SIGTERM</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* set to true when becoming a maintenance daemon */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsMaintenanceDaemon</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>MaintenanceDaemonSigTermHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>MaintenanceDaemonSigHupHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>MaintenanceDaemonShmemExit</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>MaintenanceDaemonErrorContext</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>MetadataSyncTriggeredCheckAndReset</name><parameter_list>(<parameter><decl><type><name>MaintenanceDaemonDBData</name> <modifier>*</modifier></type><name>dbData</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WarnMaintenanceDaemonNotStarted</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * InitializeMaintenanceDaemon, called at server start, is responsible for
 * requesting shared memory and related infrastructure required by maintenance
 * daemons.
 */</comment>
<function><type><name>void</name></type>
<name>InitializeMaintenanceDaemon</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>prev_shmem_startup_hook</name> <operator>=</operator> <name>shmem_startup_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>shmem_startup_hook</name> <operator>=</operator> <name>MaintenanceDaemonShmemInit</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * InitializeMaintenanceDaemonBackend, called at backend start and
 * configuration changes, is responsible for starting a per-database
 * maintenance worker if necessary.
 */</comment>
<function><type><name>void</name></type>
<name>InitializeMaintenanceDaemonBackend</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>extensionOwner</name> <init>= <expr><call><name>CitusExtensionOwner</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>found</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MaintenanceDaemonControl</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>MaintenanceDaemonDBData</name> <modifier>*</modifier></type><name>dbData</name> <init>= <expr><operator>(</operator><name>MaintenanceDaemonDBData</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(
		<argument><expr><name>MaintenanceDaemonDBHash</name></expr></argument>,
		<argument><expr><operator>&amp;</operator><name>MyDatabaseId</name></expr></argument>,
		<argument><expr><name>HASH_ENTER_NULL</name></expr></argument>,
		<argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>dbData</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>WarnMaintenanceDaemonNotStarted</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MaintenanceDaemonControl</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* ensure the values in MaintenanceDaemonDBData are zero */</comment>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>dbData</name><operator>)</operator> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
			   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>MaintenanceDaemonDBData</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>IsMaintenanceDaemon</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * InitializeMaintenanceDaemonBackend is called by the maintenance daemon
		 * itself. In that case, we clearly don't need to start another maintenance
		 * daemon.
		 */</comment>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MaintenanceDaemonControl</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name> <operator>||</operator> <operator>!</operator><name><name>dbData</name><operator>-&gt;</operator><name>daemonStarted</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>dbData</name><operator>-&gt;</operator><name>workerPid</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>BackgroundWorker</name></type> <name>worker</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BackgroundWorkerHandle</name> <modifier>*</modifier></type><name>handle</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>worker</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>worker</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SafeSnprintf</name><argument_list>(<argument><expr><name><name>worker</name><operator>.</operator><name>bgw_name</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>worker</name><operator>.</operator><name>bgw_name</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,
					 <argument><expr><literal type="string">"Citus Maintenance Daemon: %u/%u"</literal></expr></argument>,
					 <argument><expr><name>MyDatabaseId</name></expr></argument>, <argument><expr><name>extensionOwner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* request ability to connect to target database */</comment>
		<expr_stmt><expr><name><name>worker</name><operator>.</operator><name>bgw_flags</name></name> <operator>=</operator> <name>BGWORKER_SHMEM_ACCESS</name> <operator>|</operator> <name>BGWORKER_BACKEND_DATABASE_CONNECTION</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * No point in getting started before able to run query, but we do
		 * want to get started on Hot-Standby.
		 */</comment>
		<expr_stmt><expr><name><name>worker</name><operator>.</operator><name>bgw_start_time</name></name> <operator>=</operator> <name>BgWorkerStart_ConsistentState</name></expr>;</expr_stmt>

		<comment type="block">/* Restart after a bit after errors, but don't bog the system. */</comment>
		<expr_stmt><expr><name><name>worker</name><operator>.</operator><name>bgw_restart_time</name></name> <operator>=</operator> <literal type="number">5</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strcpy_s</name><argument_list>(<argument><expr><name><name>worker</name><operator>.</operator><name>bgw_library_name</name></name></expr></argument>,
				 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>worker</name><operator>.</operator><name>bgw_library_name</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"citus"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strcpy_s</name><argument_list>(<argument><expr><name><name>worker</name><operator>.</operator><name>bgw_function_name</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>worker</name><operator>.</operator><name>bgw_library_name</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,
				 <argument><expr><literal type="string">"CitusMaintenanceDaemonMain"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>worker</name><operator>.</operator><name>bgw_main_arg</name></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy_s</name><argument_list>(<argument><expr><name><name>worker</name><operator>.</operator><name>bgw_extra</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>worker</name><operator>.</operator><name>bgw_extra</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>extensionOwner</name></expr></argument>,
				 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>worker</name><operator>.</operator><name>bgw_notify_pid</name></name> <operator>=</operator> <name>MyProcPid</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RegisterDynamicBackgroundWorker</name><argument_list>(<argument><expr><operator>&amp;</operator><name>worker</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>handle</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>WarnMaintenanceDaemonNotStarted</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>dbData</name><operator>-&gt;</operator><name>daemonStarted</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MaintenanceDaemonControl</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>dbData</name><operator>-&gt;</operator><name>daemonStarted</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dbData</name><operator>-&gt;</operator><name>userOid</name></name> <operator>=</operator> <name>extensionOwner</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dbData</name><operator>-&gt;</operator><name>workerPid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dbData</name><operator>-&gt;</operator><name>triggerNodeMetadataSync</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MaintenanceDaemonControl</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>pid_t</name></type> <name>pid</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>WaitForBackgroundWorkerStartup</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>dbData</name><operator>-&gt;</operator><name>daemonStarted</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If owner of extension changed, wake up daemon. It'll notice and
		 * restart.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>dbData</name><operator>-&gt;</operator><name>userOid</name></name> <operator>!=</operator> <name>extensionOwner</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>dbData</name><operator>-&gt;</operator><name>userOid</name></name> <operator>=</operator> <name>extensionOwner</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>dbData</name><operator>-&gt;</operator><name>latch</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name><name>dbData</name><operator>-&gt;</operator><name>latch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MaintenanceDaemonControl</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * WarnMaintenanceDaemonNotStarted warns that maintenanced couldn't be started.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>WarnMaintenanceDaemonNotStarted</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not start maintenance background worker"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					  <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Increasing max_worker_processes might help."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CitusMaintenanceDaemonMain is the maintenance daemon's main routine, it'll
 * be started by the background worker infrastructure.  If it errors out,
 * it'll be restarted after a few seconds.
 */</comment>
<function><type><name>void</name></type>
<name>CitusMaintenanceDaemonMain</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>main_arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>databaseOid</name> <init>= <expr><call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name>main_arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name> <name>nextStatsCollectionTime</name></type> <name>USED_WITH_LIBCURL_ONLY</name> <init>=
		<expr><call><name>TimestampTzPlusMilliseconds</name><argument_list>(<argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">60</literal> <operator>*</operator> <literal type="number">1000</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name> <name>retryStatsCollection</name></type> <name>USED_WITH_LIBCURL_ONLY</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>lastRecoveryTime</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>lastShardCleanTime</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>lastStatStatementsPurgeTime</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>nextMetadataSyncTime</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* state kept for the background tasks queue monitor */</comment>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>lastBackgroundTaskQueueCheck</name> <init>= <expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BackgroundWorkerHandle</name> <modifier>*</modifier></type><name>backgroundTasksQueueBgwHandle</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>backgroundTasksQueueWarnedForLock</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We do metadata sync in a separate background worker. We need its
	 * handle to be able to check its status.
	 */</comment>
	<decl_stmt><decl><type><name>BackgroundWorkerHandle</name> <modifier>*</modifier></type><name>metadataSyncBgwHandle</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Look up this worker's configuration.
	 */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MaintenanceDaemonControl</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>MaintenanceDaemonDBData</name> <modifier>*</modifier></type><name>myDbData</name> <init>= <expr><operator>(</operator><name>MaintenanceDaemonDBData</name> <operator>*</operator><operator>)</operator>
										<call><name>hash_search</name><argument_list>(<argument><expr><name>MaintenanceDaemonDBHash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>databaseOid</name></expr></argument>,
													<argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>myDbData</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * When the database crashes, background workers are restarted, but
		 * the state in shared memory is lost. In that case, we exit and
		 * wait for a session to call InitializeMaintenanceDaemonBackend
		 * to properly add it to the hash.
		 */</comment>

		<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>myDbData</name><operator>-&gt;</operator><name>workerPid</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Another maintenance daemon is running. This usually happens because
		 * postgres restarts the daemon after an non-zero exit, and
		 * InitializeMaintenanceDaemonBackend started one before postgres did.
		 * In that case, the first one stays and the last one exits.
		 */</comment>

		<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>before_shmem_exit</name><argument_list>(<argument><expr><name>MaintenanceDaemonShmemExit</name></expr></argument>, <argument><expr><name>main_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Signal that I am the maintenance daemon now.
	 *
	 * From this point, DROP DATABASE/EXTENSION will send a SIGTERM to me.
	 */</comment>
	<expr_stmt><expr><name><name>myDbData</name><operator>-&gt;</operator><name>workerPid</name></name> <operator>=</operator> <name>MyProcPid</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Signal that we are running. This in mainly needed in case of restart after
	 * an error, otherwise the daemonStarted flag is already true.
	 */</comment>
	<expr_stmt><expr><name><name>myDbData</name><operator>-&gt;</operator><name>daemonStarted</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/* wire up signals */</comment>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>, <argument><expr><name>MaintenanceDaemonSigTermHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGHUP</name></expr></argument>, <argument><expr><name>MaintenanceDaemonSigHupHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BackgroundWorkerUnblockSignals</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>myDbData</name><operator>-&gt;</operator><name>latch</name></name> <operator>=</operator> <name>MyLatch</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>IsMaintenanceDaemon</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MaintenanceDaemonControl</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Setup error context so log messages can be properly attributed. Some of
	 * them otherwise sound like they might be from a normal user connection.
	 * Do so before setting up signals etc, so we never exit without the
	 * context setup.
	 */</comment>
	<decl_stmt><decl><type><name>ErrorContextCallback</name></type> <name>errorCallback</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errorCallback</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errorCallback</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errorCallback</name><operator>.</operator><name>callback</name></name> <operator>=</operator> <name>MaintenanceDaemonErrorContext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errorCallback</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>myDbData</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errorCallback</name><operator>.</operator><name>previous</name></name> <operator>=</operator> <name>error_context_stack</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <operator>&amp;</operator><name>errorCallback</name></expr>;</expr_stmt>


	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"starting maintenance daemon on database %u user %u"</literal></expr></argument>,
		 <argument><expr><name>databaseOid</name></expr></argument>, <argument><expr><name><name>myDbData</name><operator>-&gt;</operator><name>userOid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* connect to database, after that we can actually access catalogs */</comment>
	<expr_stmt><expr><call><name>BackgroundWorkerInitializeConnectionByOid</name><argument_list>(<argument><expr><name>databaseOid</name></expr></argument>, <argument><expr><name><name>myDbData</name><operator>-&gt;</operator><name>userOid</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* make worker recognizable in pg_stat_activity */</comment>
	<expr_stmt><expr><call><name>pgstat_report_appname</name><argument_list>(<argument><expr><literal type="string">"Citus Maintenance Daemon"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Terminate orphaned metadata sync daemons spawned from previously terminated
	 * or crashed maintenanced instances.
	 */</comment>
	<expr_stmt><expr><call><name>SignalMetadataSyncDaemon</name><argument_list>(<argument><expr><name>databaseOid</name></expr></argument>, <argument><expr><name>SIGTERM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* enter main loop */</comment>
	<while>while <condition>(<expr><operator>!</operator><name>got_SIGTERM</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>latchFlags</name> <init>= <expr><name>WL_LATCH_SET</name> <operator>|</operator> <name>WL_TIMEOUT</name> <operator>|</operator> <name>WL_POSTMASTER_DEATH</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type> <name>timeout</name> <init>= <expr><literal type="number">10000.0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* use this if the deadlock detection is disabled */</comment>
		<decl_stmt><decl><type><name>bool</name></type> <name>foundDeadlock</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CitusTableCacheFlushInvalidatedEntries</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * XXX: Each task should clear the metadata cache before every iteration
		 * by calling InvalidateMetadataSystemCache(), because otherwise it
		 * might contain stale OIDs. It appears that in some cases invalidation
		 * messages for a DROP EXTENSION may arrive during these tasks and
		 * this causes us to cache a stale pg_dist_node OID. We'd actually expect
		 * all invalidations to arrive after obtaining a lock in LockCitusExtension.
		 */</comment>

		<comment type="block">/*
		 * Perform Work. If a specific task needs to be called sooner than
		 * timeout indicates, it's ok to lower it to that value. Expensive
		 * tasks should do their own time math about whether to re-run checks.
		 */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LIBCURL</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name>EnableStatisticsCollection</name> <operator>&amp;&amp;</operator>
			<call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <name>nextStatsCollectionTime</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type> <name>statsCollectionSuccess</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>InvalidateMetadataSystemCache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Lock the extension such that it cannot be dropped or created
			 * concurrently. Skip statistics collection if citus extension is
			 * not accessible.
			 *
			 * Similarly, we skip statistics collection if there exists any
			 * version mismatch or the extension is not fully created yet.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>LockCitusExtension</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not lock the citus extension, "</literal>
										<literal type="string">"skipping statistics collection"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>CitusHasBeenLoaded</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>FlushDistTableCache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>WarnIfSyncDNS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>statsCollectionSuccess</name> <operator>=</operator> <call><name>CollectBasicUsageStatistics</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * If statistics collection was successful the next collection is
			 * 24-hours later. Also, if this was a retry attempt we don't do
			 * any more retries until 24-hours later, so we limit number of
			 * retries to one.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>statsCollectionSuccess</name> <operator>||</operator> <name>retryStatsCollection</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>nextStatsCollectionTime</name> <operator>=</operator>
					<call><name>TimestampTzPlusMilliseconds</name><argument_list>(<argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>,
												<argument><expr><name>STATS_COLLECTION_TIMEOUT_MILLIS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>retryStatsCollection</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>nextStatsCollectionTime</name> <operator>=</operator>
					<call><name>TimestampTzPlusMilliseconds</name><argument_list>(<argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>,
												<argument><expr><name>STATS_COLLECTION_RETRY_TIMEOUT_MILLIS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>retryStatsCollection</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<decl_stmt><decl><type><name>pid_t</name></type> <name>metadataSyncBgwPid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BgwHandleStatus</name></type> <name>metadataSyncStatus</name> <init>=
			<expr><ternary><condition><expr><name>metadataSyncBgwHandle</name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then>
			<expr><call><name>GetBackgroundWorkerPid</name><argument_list>(<argument><expr><name>metadataSyncBgwHandle</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>metadataSyncBgwPid</name></expr></argument>)</argument_list></call></expr> </then><else>:
			<expr><name>BGWH_STOPPED</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>metadataSyncStatus</name> <operator>!=</operator> <name>BGWH_STOPPED</name> <operator>&amp;&amp;</operator>
			<call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <name>nextMetadataSyncTime</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Metadata sync is still running, recheck in a short while.
			 */</comment>
			<decl_stmt><decl><type><name>int</name></type> <name>nextTimeout</name> <init>= <expr><name>MetadataSyncRetryInterval</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>nextMetadataSyncTime</name> <operator>=</operator>
				<call><name>TimestampTzPlusMilliseconds</name><argument_list>(<argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>nextTimeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>timeout</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>timeout</name></expr></argument>, <argument><expr><name>nextTimeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
				 <name>metadataSyncStatus</name> <operator>==</operator> <name>BGWH_STOPPED</name> <operator>&amp;&amp;</operator>
				 <operator>(</operator><call><name>MetadataSyncTriggeredCheckAndReset</name><argument_list>(<argument><expr><name>myDbData</name></expr></argument>)</argument_list></call> <operator>||</operator>
				  <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <name>nextMetadataSyncTime</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>metadataSyncBgwHandle</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>metadataSyncBgwHandle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>metadataSyncBgwHandle</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>InvalidateMetadataSystemCache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<decl_stmt><decl><type><name>int</name></type> <name>nextTimeout</name> <init>= <expr><name>MetadataSyncRetryInterval</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>syncMetadata</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>LockCitusExtension</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not lock the citus extension, "</literal>
										<literal type="string">"skipping metadata sync"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>CitusHasBeenLoaded</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>bool</name></type> <name>lockFailure</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name>syncMetadata</name> <operator>=</operator> <call><name>ShouldInitiateMetadataSync</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lockFailure</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * If lock fails, we need to recheck in a short while. If we are
				 * going to sync metadata, we should recheck in a short while to
				 * see if it failed. Otherwise, we can wait longer.
				 */</comment>
				<expr_stmt><expr><name>nextTimeout</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>lockFailure</name> <operator>||</operator> <name>syncMetadata</name><operator>)</operator></expr> ?</condition><then>
							  <expr><name>MetadataSyncRetryInterval</name></expr> </then><else>:
							  <expr><name>MetadataSyncInterval</name></expr></else></ternary></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>syncMetadata</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>metadataSyncBgwHandle</name> <operator>=</operator>
					<call><name>SpawnSyncNodeMetadataToNodes</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>, <argument><expr><name><name>myDbData</name><operator>-&gt;</operator><name>userOid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>nextMetadataSyncTime</name> <operator>=</operator>
				<call><name>TimestampTzPlusMilliseconds</name><argument_list>(<argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>nextTimeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>timeout</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>timeout</name></expr></argument>, <argument><expr><name>nextTimeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If enabled, run 2PC recovery on primary nodes (where !RecoveryInProgress()),
		 * since we'll write to the pg_dist_transaction log.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>Recover2PCInterval</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>TimestampDifferenceExceeds</name><argument_list>(<argument><expr><name>lastRecoveryTime</name></expr></argument>, <argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>,
									   <argument><expr><name>Recover2PCInterval</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>recoveredTransactionCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>InvalidateMetadataSystemCache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>LockCitusExtension</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not lock the citus extension, "</literal>
										<literal type="string">"skipping 2PC recovery"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>CitusHasBeenLoaded</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Record last recovery time at start to ensure we run once per
				 * Recover2PCInterval even if RecoverTwoPhaseCommits takes some time.
				 */</comment>
				<expr_stmt><expr><name>lastRecoveryTime</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>recoveredTransactionCount</name> <operator>=</operator> <call><name>RecoverTwoPhaseCommits</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>recoveredTransactionCount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"maintenance daemon recovered %d distributed "</literal>
									 <literal type="string">"transactions"</literal></expr></argument>,
									 <argument><expr><name>recoveredTransactionCount</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* make sure we don't wait too long */</comment>
			<expr_stmt><expr><name>timeout</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>timeout</name></expr></argument>, <argument><expr><name>Recover2PCInterval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* the config value -1 disables the distributed deadlock detection  */</comment>
		<if_stmt><if>if <condition>(<expr><name>DistributedDeadlockDetectionTimeoutFactor</name> <operator>!=</operator> <operator>-</operator><literal type="number">1.0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>double</name></type> <name>deadlockTimeout</name> <init>=
				<expr><name>DistributedDeadlockDetectionTimeoutFactor</name> <operator>*</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>DeadlockTimeout</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>InvalidateMetadataSystemCache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * We skip the deadlock detection if citus extension
			 * is not accessible.
			 *
			 * Similarly, we skip to run the deadlock checks if
			 * there exists any version mismatch or the extension
			 * is not fully created yet.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>LockCitusExtension</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not lock the citus extension, "</literal>
										<literal type="string">"skipping deadlock detection"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>CitusHasBeenLoaded</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>foundDeadlock</name> <operator>=</operator> <call><name>CheckForDistributedDeadlocks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If we find any deadlocks, run the distributed deadlock detection
			 * more often since it is quite possible that there are other
			 * deadlocks need to be resolved.
			 *
			 * Thus, we use 1/20 of the calculated value. With the default
			 * values (i.e., deadlock_timeout 1 seconds,
			 * citus.distributed_deadlock_detection_factor 2), we'd be able to cancel
			 * ~10 distributed deadlocks per second.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>foundDeadlock</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>deadlockTimeout</name> <operator>=</operator> <name>deadlockTimeout</name> <operator>/</operator> <literal type="number">20.0</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* make sure we don't wait too long */</comment>
			<expr_stmt><expr><name>timeout</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>timeout</name></expr></argument>, <argument><expr><name>deadlockTimeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>DeferShardDeleteInterval</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<call><name>TimestampDifferenceExceeds</name><argument_list>(<argument><expr><name>lastShardCleanTime</name></expr></argument>, <argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>,
									   <argument><expr><name>DeferShardDeleteInterval</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>numberOfDroppedResources</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>InvalidateMetadataSystemCache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>LockCitusExtension</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
									 <argument><expr><literal type="string">"could not lock the citus extension, skipping shard cleaning"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>CitusHasBeenLoaded</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Record last shard clean time at start to ensure we run once per
				 * DeferShardDeleteInterval.
				 */</comment>
				<expr_stmt><expr><name>lastShardCleanTime</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

				<decl_stmt><decl><type><name>bool</name></type> <name>waitForLocks</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name>numberOfDroppedResources</name> <operator>=</operator> <call><name>TryDropOrphanedResources</name><argument_list>(<argument><expr><name>waitForLocks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>numberOfDroppedResources</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"maintenance daemon dropped %d "</literal>
									 <literal type="string">"resources previously marked to be removed"</literal></expr></argument>,
									 <argument><expr><name>numberOfDroppedResources</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* make sure we don't wait too long */</comment>
			<expr_stmt><expr><name>timeout</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>timeout</name></expr></argument>, <argument><expr><name>DeferShardDeleteInterval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>StatStatementsPurgeInterval</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<name>StatStatementsTrack</name> <operator>!=</operator> <name>STAT_STATEMENTS_TRACK_NONE</name> <operator>&amp;&amp;</operator>
			<call><name>TimestampDifferenceExceeds</name><argument_list>(<argument><expr><name>lastStatStatementsPurgeTime</name></expr></argument>, <argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>,
									   <argument><expr><operator>(</operator><name>StatStatementsPurgeInterval</name> <operator>*</operator> <literal type="number">1000</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>LockCitusExtension</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not lock the citus extension, "</literal>
										<literal type="string">"skipping stat statements purging"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>CitusHasBeenLoaded</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Record last time we perform the purge to ensure we run once per
				 * StatStatementsPurgeInterval.
				 */</comment>
				<expr_stmt><expr><name>lastStatStatementsPurgeTime</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>CitusQueryStatsSynchronizeEntries</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* make sure we don't wait too long, need to convert seconds to milliseconds */</comment>
			<expr_stmt><expr><name>timeout</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>timeout</name></expr></argument>, <argument><expr><operator>(</operator><name>StatStatementsPurgeInterval</name> <operator>*</operator> <literal type="number">1000</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>pid_t</name></type> <name>backgroundTaskQueueWorkerPid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BgwHandleStatus</name></type> <name>backgroundTaskQueueWorkerStatus</name> <init>=
			<expr><ternary><condition><expr><name>backgroundTasksQueueBgwHandle</name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><call><name>GetBackgroundWorkerPid</name><argument_list>(
				<argument><expr><name>backgroundTasksQueueBgwHandle</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>backgroundTaskQueueWorkerPid</name></expr></argument>)</argument_list></call></expr> </then><else>:
			<expr><name>BGWH_STOPPED</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>BackgroundTaskQueueCheckInterval</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<call><name>TimestampDifferenceExceeds</name><argument_list>(<argument><expr><name>lastBackgroundTaskQueueCheck</name></expr></argument>,
									   <argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>,
									   <argument><expr><name>BackgroundTaskQueueCheckInterval</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<name>backgroundTaskQueueWorkerStatus</name> <operator>==</operator> <name>BGWH_STOPPED</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* clear old background worker for task queue before checking for new tasks */</comment>
			<if_stmt><if>if <condition>(<expr><name>backgroundTasksQueueBgwHandle</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>backgroundTasksQueueBgwHandle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>backgroundTasksQueueBgwHandle</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<decl_stmt><decl><type><name>bool</name></type> <name>shouldStartBackgroundTaskQueueBackgroundWorker</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>LockCitusExtension</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not lock the citus extension, "</literal>
										<literal type="string">"skipping stat statements purging"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>CitusHasBeenLoaded</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* perform catalog precheck */</comment>
				<expr_stmt><expr><name>shouldStartBackgroundTaskQueueBackgroundWorker</name> <operator>=</operator>
					<call><name>HasRunnableBackgroundTask</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>shouldStartBackgroundTaskQueueBackgroundWorker</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Before we start the background worker we want to check if an orphaned
				 * one is still running. This could happen when the maintenance daemon
				 * restarted in a way where the background task queue monitor wasn't
				 * restarted.
				 *
				 * To check if an orphaned background task queue monitor is still running
				 * we quickly acquire the lock without waiting. If we can't acquire the
				 * lock this means that some other backed still has the lock. We prevent a
				 * new backend from starting and log a warning that we found that another
				 * process still holds the lock.
				 */</comment>
				<decl_stmt><decl><type><name>LOCKTAG</name></type> <name>tag</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>SET_LOCKTAG_CITUS_OPERATION</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>CITUS_BACKGROUND_TASK_MONITOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>sessionLock</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>dontWait</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>LockAcquireResult</name></type> <name>locked</name> <init>=
					<expr><call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>, <argument><expr><name>sessionLock</name></expr></argument>, <argument><expr><name>dontWait</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>locked</name> <operator>==</operator> <name>LOCKACQUIRE_NOT_AVAIL</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>backgroundTasksQueueWarnedForLock</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"background task queue monitor already "</literal>
												 <literal type="string">"held"</literal></expr></argument>)</argument_list></call><operator>,</operator>
										  <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"the background task queue monitor "</literal>
													<literal type="string">"lock is held by another backend, "</literal>
													<literal type="string">"indicating the maintenance daemon "</literal>
													<literal type="string">"has lost track of an already "</literal>
													<literal type="string">"running background task queue "</literal>
													<literal type="string">"monitor, not starting a new one"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>backgroundTasksQueueWarnedForLock</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>LockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>, <argument><expr><name>sessionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* we were able to acquire the lock, reset the warning tracker */</comment>
					<expr_stmt><expr><name>backgroundTasksQueueWarnedForLock</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

					<comment type="block">/* spawn background worker */</comment>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"found scheduled background tasks, starting new "</literal>
										 <literal type="string">"background task queue monitor"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>backgroundTasksQueueBgwHandle</name> <operator>=</operator>
						<call><name>StartCitusBackgroundTaskQueueMonitor</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>,
															 <argument><expr><name><name>myDbData</name><operator>-&gt;</operator><name>userOid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>backgroundTasksQueueBgwHandle</name> <operator>||</operator>
						<call><name>GetBackgroundWorkerPid</name><argument_list>(<argument><expr><name>backgroundTasksQueueBgwHandle</name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name>backgroundTaskQueueWorkerPid</name></expr></argument>)</argument_list></call> <operator>==</operator>
						<name>BGWH_STOPPED</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unable to start background worker for "</literal>
												 <literal type="string">"background task execution"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* interval management */</comment>
			<expr_stmt><expr><name>lastBackgroundTaskQueueCheck</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>timeout</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>timeout</name></expr></argument>, <argument><expr><name>BackgroundTaskQueueCheckInterval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Wait until timeout, or until somebody wakes us up. Also cast the timeout to
		 * integer where we've calculated it using double for not losing the precision.
		 */</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>WaitLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>, <argument><expr><name>latchFlags</name></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name>timeout</name></expr></argument>, <argument><expr><name>PG_WAIT_EXTENSION</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* emergency bailout if postmaster has died */</comment>
		<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&amp;</operator> <name>WL_POSTMASTER_DEATH</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&amp;</operator> <name>WL_LATCH_SET</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* check for changed configuration */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>myDbData</name><operator>-&gt;</operator><name>userOid</name></name> <operator>!=</operator> <call><name>GetSessionUserId</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* return code of 1 requests worker restart */</comment>
				<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Could also add code checking whether extension still exists,
			 * but that'd complicate things a bit, because we'd have to delete
			 * the shared memory entry.  There'd potentially be a race
			 * condition where the extension gets re-created, checking that
			 * this entry still exists, and it getting deleted just after.
			 * Doesn't seem worth catering for that.
			 */</comment>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>got_SIGHUP</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>got_SIGHUP</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ProcessConfigFile</name><argument_list>(<argument><expr><name>PGC_SIGHUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>metadataSyncBgwHandle</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>TerminateBackgroundWorker</name><argument_list>(<argument><expr><name>metadataSyncBgwHandle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * MaintenanceDaemonShmemSize computes how much shared memory is required.
 */</comment>
<function><type><name>size_t</name></type>
<name>MaintenanceDaemonShmemSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type> <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>MaintenanceDaemonControlData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We request enough shared memory to have one hash-table entry for each
	 * worker process. We couldn't start more anyway, so there's little point
	 * in allocating more.
	 */</comment>
	<decl_stmt><decl><type><name>Size</name></type> <name>hashSize</name> <init>= <expr><call><name>hash_estimate_size</name><argument_list>(<argument><expr><name>max_worker_processes</name></expr></argument>,
									   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>MaintenanceDaemonDBData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><name>hashSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * MaintenanceDaemonShmemInit initializes the requested shared memory for the
 * maintenance daemon.
 */</comment>
<function><type><name>void</name></type>
<name>MaintenanceDaemonShmemInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>alreadyInitialized</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASHCTL</name></type> <name>hashInfo</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>AddinShmemInitLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>MaintenanceDaemonControl</name> <operator>=</operator>
		<operator>(</operator><name>MaintenanceDaemonControlData</name> <operator>*</operator><operator>)</operator> <call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"Citus Maintenance Daemon"</literal></expr></argument>,
														 <argument><expr><call><name>MaintenanceDaemonShmemSize</name><argument_list>()</argument_list></call></expr></argument>,
														 <argument><expr><operator>&amp;</operator><name>alreadyInitialized</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Might already be initialized on EXEC_BACKEND type platforms that call
	 * shared library initialization functions in every backend.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>alreadyInitialized</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>MaintenanceDaemonControl</name><operator>-&gt;</operator><name>trancheId</name></name> <operator>=</operator> <call><name>LWLockNewTrancheId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>MaintenanceDaemonControl</name><operator>-&gt;</operator><name>lockTrancheName</name></name> <operator>=</operator> <literal type="string">"Citus Maintenance Daemon"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRegisterTranche</name><argument_list>(<argument><expr><name><name>MaintenanceDaemonControl</name><operator>-&gt;</operator><name>trancheId</name></name></expr></argument>,
							  <argument><expr><name><name>MaintenanceDaemonControl</name><operator>-&gt;</operator><name>lockTrancheName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LWLockInitialize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MaintenanceDaemonControl</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>,
						 <argument><expr><name><name>MaintenanceDaemonControl</name><operator>-&gt;</operator><name>trancheId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>


	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hashInfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hashInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashInfo</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashInfo</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>MaintenanceDaemonDBData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashInfo</name><operator>.</operator><name>hash</name></name> <operator>=</operator> <name>tag_hash</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>hashFlags</name> <init>= <expr><operator>(</operator><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_FUNCTION</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>MaintenanceDaemonDBHash</name> <operator>=</operator> <call><name>ShmemInitHash</name><argument_list>(<argument><expr><literal type="string">"Maintenance Database Hash"</literal></expr></argument>,
											<argument><expr><name>max_worker_processes</name></expr></argument>, <argument><expr><name>max_worker_processes</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>hashInfo</name></expr></argument>, <argument><expr><name>hashFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>AddinShmemInitLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>prev_shmem_startup_hook</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>prev_shmem_startup_hook</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * MaintenaceDaemonShmemExit is the before_shmem_exit handler for cleaning up MaintenanceDaemonDBHash
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>MaintenanceDaemonShmemExit</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>databaseOid</name> <init>= <expr><call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MaintenanceDaemonControl</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>MaintenanceDaemonDBData</name> <modifier>*</modifier></type><name>myDbData</name> <init>= <expr><operator>(</operator><name>MaintenanceDaemonDBData</name> <operator>*</operator><operator>)</operator>
										<call><name>hash_search</name><argument_list>(<argument><expr><name>MaintenanceDaemonDBHash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>databaseOid</name></expr></argument>,
													<argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* myDbData is NULL after StopMaintenanceDaemon */</comment>
	<if_stmt><if>if <condition>(<expr><name>myDbData</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Confirm that I am still the registered maintenance daemon before exiting.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>myDbData</name><operator>-&gt;</operator><name>workerPid</name></name> <operator>==</operator> <name>MyProcPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>myDbData</name><operator>-&gt;</operator><name>daemonStarted</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>myDbData</name><operator>-&gt;</operator><name>workerPid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MaintenanceDaemonControl</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* MaintenanceDaemonSigTermHandler calls proc_exit(0) */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>MaintenanceDaemonSigTermHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>got_SIGTERM</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>MyProc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>procLatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * MaintenanceDaemonSigHupHandler set a flag to re-read config file at next
 * convenient time.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>MaintenanceDaemonSigHupHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>got_SIGHUP</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>MyProc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>procLatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * MaintenanceDaemonErrorContext adds some context to log messages to make it
 * easier to associate them with the maintenance daemon.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>MaintenanceDaemonErrorContext</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MaintenanceDaemonDBData</name> <modifier>*</modifier></type><name>myDbData</name> <init>= <expr><operator>(</operator><name>MaintenanceDaemonDBData</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"Citus maintenance daemon for database %u user %u"</literal></expr></argument>,
			   <argument><expr><name><name>myDbData</name><operator>-&gt;</operator><name>databaseOid</name></name></expr></argument>, <argument><expr><name><name>myDbData</name><operator>-&gt;</operator><name>userOid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * LockCitusExtension acquires a lock on the Citus extension or returns
 * false if the extension does not exist or is being dropped.
 */</comment>
<function><type><name>bool</name></type>
<name>LockCitusExtension</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>extensionOid</name> <init>= <expr><call><name>get_extension_oid</name><argument_list>(<argument><expr><literal type="string">"citus"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>extensionOid</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* citus extension does not exist */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LockDatabaseObject</name><argument_list>(<argument><expr><name>ExtensionRelationId</name></expr></argument>, <argument><expr><name>extensionOid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The extension may have been dropped and possibly recreated prior to
	 * obtaining a lock. Check whether we still get the expected OID.
	 */</comment>
	<decl_stmt><decl><type><name>Oid</name></type> <name>recheckExtensionOid</name> <init>= <expr><call><name>get_extension_oid</name><argument_list>(<argument><expr><literal type="string">"citus"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>recheckExtensionOid</name> <operator>!=</operator> <name>extensionOid</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * StopMaintenanceDaemon stops the maintenance daemon for the
 * given database and removes it from the maintenance daemon
 * control hash.
 */</comment>
<function><type><name>void</name></type>
<name>StopMaintenanceDaemon</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>databaseId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pid_t</name></type> <name>workerPid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MaintenanceDaemonControl</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>MaintenanceDaemonDBData</name> <modifier>*</modifier></type><name>dbData</name> <init>= <expr><operator>(</operator><name>MaintenanceDaemonDBData</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(
		<argument><expr><name>MaintenanceDaemonDBHash</name></expr></argument>,
		<argument><expr><operator>&amp;</operator><name>databaseId</name></expr></argument>,
		<argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>workerPid</name> <operator>=</operator> <name><name>dbData</name><operator>-&gt;</operator><name>workerPid</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MaintenanceDaemonControl</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>workerPid</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>kill</name><argument_list>(<argument><expr><name>workerPid</name></expr></argument>, <argument><expr><name>SIGTERM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * TriggerMetadataSync triggers the maintenance daemon to do
 * a node metadata sync for the given database.
 */</comment>
<function><type><name>void</name></type>
<name>TriggerNodeMetadataSync</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>databaseId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MaintenanceDaemonControl</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>MaintenanceDaemonDBData</name> <modifier>*</modifier></type><name>dbData</name> <init>= <expr><operator>(</operator><name>MaintenanceDaemonDBData</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(
		<argument><expr><name>MaintenanceDaemonDBHash</name></expr></argument>,
		<argument><expr><operator>&amp;</operator><name>databaseId</name></expr></argument>,
		<argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>dbData</name><operator>-&gt;</operator><name>triggerNodeMetadataSync</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="block">/* set latch to wake-up the maintenance loop */</comment>
		<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name><name>dbData</name><operator>-&gt;</operator><name>latch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MaintenanceDaemonControl</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * MetadataSyncTriggeredCheckAndReset checks if metadata sync has been
 * triggered for the given database, and resets the flag.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>MetadataSyncTriggeredCheckAndReset</name><parameter_list>(<parameter><decl><type><name>MaintenanceDaemonDBData</name> <modifier>*</modifier></type><name>dbData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MaintenanceDaemonControl</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>metadataSyncTriggered</name> <init>= <expr><name><name>dbData</name><operator>-&gt;</operator><name>triggerNodeMetadataSync</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>dbData</name><operator>-&gt;</operator><name>triggerNodeMetadataSync</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MaintenanceDaemonControl</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>metadataSyncTriggered</name></expr>;</return>
</block_content>}</block></function>
</unit>
