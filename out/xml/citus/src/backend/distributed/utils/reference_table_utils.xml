<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/citus/src/backend/distributed/utils/reference_table_utils.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * reference_table_utils.c
 *
 * Declarations for public utility functions related to reference tables.
 *
 * Copyright (c) Citus Data, Inc.
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/backend_data.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/colocation_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/coordinator_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_sync.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_logical_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/reference_table_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/relation_access_tracking.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/remote_commands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/resource_lock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shardinterval_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/transaction_management.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_manager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_transaction.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/postmaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>

<comment type="block">/* local function forward declarations */</comment>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>WorkersWithoutReferenceTablePlacement</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockMode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>StringInfo</name></type> <name>CopyShardPlacementToWorkerNodeQuery</name><parameter_list>(
	<parameter><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>sourceShardPlacement</name></decl></parameter>,
	<parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name></decl></parameter>,
	<parameter><decl><type><name>char</name></type> <name>transferMode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>AnyRelationsModifiedInTransaction</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>relationIdList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>ReplicatedMetadataSyncedDistributedTableList</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>NodeHasAllReferenceTableReplicas</name><parameter_list>(<parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* exports for SQL callable functions */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>upgrade_to_reference_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>replicate_reference_tables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
 * replicate_reference_tables is a UDF to ensure that allreference tables are
 * replicated to all nodes.
 */</comment>
<function><type><name>Datum</name></type>
<name>replicate_reference_tables</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>shardReplicationModeOid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>shardReplicationMode</name> <init>= <expr><call><name>LookupShardTransferMode</name><argument_list>(<argument><expr><name>shardReplicationModeOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* to prevent concurrent node additions while copying reference tables */</comment>
	<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><call><name>DistNodeRelationId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EnsureReferenceTablesExistOnAllNodesExtended</name><argument_list>(<argument><expr><name>shardReplicationMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Given the copying of reference tables and updating metadata have been done via a
	 * loopback connection we do not have to retain the lock on pg_dist_node anymore.
	 */</comment>
	<expr_stmt><expr><call><name>UnlockRelationOid</name><argument_list>(<argument><expr><call><name>DistNodeRelationId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * EnsureReferenceTablesExistOnAllNodes ensures that a shard placement for every
 * reference table exists on all nodes. If a node does not have a set of shard
 * placements, then citus_copy_shard_placement is called in a subtransaction
 * to pull the data to the new node.
 */</comment>
<function><type><name>void</name></type>
<name>EnsureReferenceTablesExistOnAllNodes</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>EnsureReferenceTablesExistOnAllNodesExtended</name><argument_list>(<argument><expr><name>TRANSFER_MODE_BLOCK_WRITES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * EnsureReferenceTablesExistOnAllNodesExtended ensures that a shard placement for every
 * reference table exists on all nodes. If a node does not have a set of shard placements,
 * then citus_copy_shard_placement is called in a subtransaction to pull the data to the
 * new node.
 *
 * The transferMode is passed on to the implementation of the copy to control the locks
 * and transferMode.
 */</comment>
<function><type><name>void</name></type>
<name>EnsureReferenceTablesExistOnAllNodesExtended</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>transferMode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>referenceTableIdList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>shardId</name> <init>= <expr><name>INVALID_SHARD_ID</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>newWorkersList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>referenceTableName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>colocationId</name> <init>= <expr><call><name>GetReferenceTableColocationId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>colocationId</name> <operator>==</operator> <name>INVALID_COLOCATION_ID</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* we have no reference table yet. */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Most of the time this function should result in a conclusion where we do not need
	 * to copy any reference tables. To prevent excessive locking the majority of the time
	 * we run our precondition checks first with a lower lock. If, after checking with the
	 * lower lock, that we might need to copy reference tables we check with a more
	 * aggressive and self conflicting lock. It is important to be self conflicting in the
	 * second run to make sure that two concurrent calls to this routine will actually not
	 * run concurrently after the initial check.
	 *
	 * If after two iterations of precondition checks we still find the need for copying
	 * reference tables we exit the loop with all locks held. This will prevent concurrent
	 * DROP TABLE and create_reference_table calls so that the list of reference tables we
	 * operate on are stable.
	 *
	 * Since the changes to the reference table placements are made via loopback
	 * connections we release the locks held at the end of this function. Due to Citus
	 * only running transactions in READ COMMITTED mode we can be sure that other
	 * transactions correctly find the metadata entries.
	 */</comment>
	<decl_stmt><decl><type><name>LOCKMODE</name></type> <name><name>lockmodes</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>AccessShareLock</name></expr>, <expr><name>ExclusiveLock</name></expr> }</block></expr></init></decl>;</decl_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>lockmodeIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>lockmodeIndex</name> <operator>&lt;</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>lockmodes</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>lockmodeIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LockColocationId</name><argument_list>(<argument><expr><name>colocationId</name></expr></argument>, <argument><expr><name><name>lockmodes</name><index>[<expr><name>lockmodeIndex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>referenceTableIdList</name> <operator>=</operator> <call><name>CitusTableTypeIdList</name><argument_list>(<argument><expr><name>REFERENCE_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>referenceTableIdList</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * No reference tables exist, make sure that any locks obtained earlier are
			 * released. It will probably not matter, but we release the locks in the
			 * reverse order we obtained them in.
			 */</comment>
			<for>for <control>(<init><decl><type><name>int</name></type> <name>releaseLockmodeIndex</name> <init>= <expr><name>lockmodeIndex</name></expr></init></decl>;</init> <condition><expr><name>releaseLockmodeIndex</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition>
				 <incr><expr><name>releaseLockmodeIndex</name><operator>--</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><call><name>UnlockColocationId</name><argument_list>(<argument><expr><name>colocationId</name></expr></argument>, <argument><expr><name><name>lockmodes</name><index>[<expr><name>releaseLockmodeIndex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>Oid</name></type> <name>referenceTableId</name> <init>= <expr><call><name>linitial_oid</name><argument_list>(<argument><expr><name>referenceTableIdList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>referenceTableName</name> <operator>=</operator> <call><name>get_rel_name</name><argument_list>(<argument><expr><name>referenceTableId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardIntervalList</name> <init>= <expr><call><name>LoadShardIntervalList</name><argument_list>(<argument><expr><name>referenceTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>shardIntervalList</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* check for corrupt metadata */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"reference table \"%s\" does not have a shard"</literal></expr></argument>,
								   <argument><expr><name>referenceTableName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><operator>(</operator><name>ShardInterval</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>shardIntervalList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>shardId</name> <operator>=</operator> <name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * We only take an access share lock, otherwise we'll hold up citus_add_node.
		 * In case of create_reference_table() where we don't want concurrent writes
		 * to pg_dist_node, we have already acquired ShareLock on pg_dist_node.
		 */</comment>
		<expr_stmt><expr><name>newWorkersList</name> <operator>=</operator> <call><name>WorkersWithoutReferenceTablePlacement</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>newWorkersList</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * All workers alreaddy have a copy of the reference tables, make sure that
			 * any locks obtained earlier are released. It will probably not matter, but
			 * we release the locks in the reverse order we obtained them in.
			 */</comment>
			<for>for <control>(<init><decl><type><name>int</name></type> <name>releaseLockmodeIndex</name> <init>= <expr><name>lockmodeIndex</name></expr></init></decl>;</init> <condition><expr><name>releaseLockmodeIndex</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition>
				 <incr><expr><name>releaseLockmodeIndex</name><operator>--</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><call><name>UnlockColocationId</name><argument_list>(<argument><expr><name>colocationId</name></expr></argument>, <argument><expr><name><name>lockmodes</name><index>[<expr><name>releaseLockmodeIndex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * citus_copy_shard_placement triggers metadata sync-up, which tries to
	 * acquire a ShareLock on pg_dist_node. We do master_copy_shad_placement
	 * in a separate connection. If we have modified pg_dist_node in the
	 * current backend, this will cause a deadlock.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>TransactionModifiedNodeMetadata</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot replicate reference tables in a transaction "</literal>
							   <literal type="string">"that modified node metadata"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Modifications to reference tables in current transaction are not visible
	 * to citus_copy_shard_placement, since it is done in a separate backend.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>AnyRelationsModifiedInTransaction</name><argument_list>(<argument><expr><name>referenceTableIdList</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot replicate reference tables in a transaction "</literal>
							   <literal type="string">"that modified a reference table"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>missingOk</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>sourceShardPlacement</name> <init>= <expr><call><name>ActiveShardPlacement</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>sourceShardPlacement</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* check for corrupt metadata */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"reference table shard "</literal>
							   <name>UINT64_FORMAT</name>
							   <literal type="string">" does not have an active shard placement"</literal></expr></argument>,
							   <argument><expr><name>shardId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>newWorkerNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>newWorkerNode</argument>, <argument>newWorkersList</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"replicating reference table '%s' to %s:%d ..."</literal></expr></argument>,
								<argument><expr><name>referenceTableName</name></expr></argument>, <argument><expr><name><name>newWorkerNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>,
								<argument><expr><name><name>newWorkerNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Call citus_copy_shard_placement using citus extension owner. Current
		 * user might not have permissions to do the copy.
		 */</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>userName</name> <init>= <expr><call><name>CitusExtensionOwnerName</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>connectionFlags</name> <init>= <expr><name>OUTSIDE_TRANSACTION</name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><call><name>GetNodeUserDatabaseConnection</name><argument_list>(
			<argument><expr><name>connectionFlags</name></expr></argument>, <argument><expr><name>LocalHostName</name></expr></argument>, <argument><expr><name>PostPortNumber</name></expr></argument>,
			<argument><expr><name>userName</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PQstatus</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CONNECTION_OK</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>UseCoordinatedTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>RemoteTransactionBegin</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<decl_stmt><decl><type><name>StringInfo</name></type> <name>placementCopyCommand</name> <init>=
				<expr><call><name>CopyShardPlacementToWorkerNodeQuery</name><argument_list>(<argument><expr><name>sourceShardPlacement</name></expr></argument>,
													<argument><expr><name>newWorkerNode</name></expr></argument>,
													<argument><expr><name>transferMode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * The placement copy command uses distributed execution to copy
			 * the shard. This is allowed when indicating that the backend is a
			 * rebalancer backend.
			 */</comment>
			<expr_stmt><expr><call><name>ExecuteCriticalRemoteCommand</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><call><name>psprintf</name><argument_list>(
											 <argument><expr><literal type="string">"SET LOCAL application_name TO '%s%ld'"</literal></expr></argument>,
											 <argument><expr><name>CITUS_REBALANCER_APPLICATION_NAME_PREFIX</name></expr></argument>,
											 <argument><expr><call><name>GetGlobalPID</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExecuteCriticalRemoteCommand</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name><name>placementCopyCommand</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>RemoteTransactionCommit</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open a connection to localhost "</literal>
								   <literal type="string">"when replicating reference tables"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errdetail</name><argument_list>(
								<argument><expr><literal type="string">"citus.replicate_reference_tables_on_activate = false "</literal>
								<literal type="string">"requires localhost connectivity."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>CloseConnection</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Since reference tables have been copied via a loopback connection we do not have to
	 * retain our locks. Since Citus only runs well in READ COMMITTED mode we can be sure
	 * that other transactions will find the reference tables copied.
	 * We have obtained and held multiple locks, here we unlock them all in the reverse
	 * order we have obtained them in.
	 */</comment>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>releaseLockmodeIndex</name> <init>= <expr><call><name>lengthof</name><argument_list>(<argument><expr><name>lockmodes</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>releaseLockmodeIndex</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition>
		 <incr><expr><name>releaseLockmodeIndex</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>UnlockColocationId</name><argument_list>(<argument><expr><name>colocationId</name></expr></argument>, <argument><expr><name><name>lockmodes</name><index>[<expr><name>releaseLockmodeIndex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>


<comment type="block">/*
 * HasNodesWithMissingReferenceTables checks if all reference tables are already copied to
 * all nodes. When a node doesn't have a copy of the reference tables we call them missing
 * and this function will return true.
 *
 * The caller might be interested in the list of all reference tables after this check and
 * this the list of tables is written to *referenceTableList if a non-null pointer is
 * passed.
 */</comment>
<function><type><name>bool</name></type>
<name>HasNodesWithMissingReferenceTables</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>referenceTableList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>colocationId</name> <init>= <expr><call><name>GetReferenceTableColocationId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>colocationId</name> <operator>==</operator> <name>INVALID_COLOCATION_ID</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* we have no reference table yet. */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>LockColocationId</name><argument_list>(<argument><expr><name>colocationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>referenceTableIdList</name> <init>= <expr><call><name>CitusTableTypeIdList</name><argument_list>(<argument><expr><name>REFERENCE_TABLE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>referenceTableList</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>referenceTableList</name> <operator>=</operator> <name>referenceTableIdList</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>referenceTableIdList</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>referenceTableId</name> <init>= <expr><call><name>linitial_oid</name><argument_list>(<argument><expr><name>referenceTableIdList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardIntervalList</name> <init>= <expr><call><name>LoadShardIntervalList</name><argument_list>(<argument><expr><name>referenceTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>shardIntervalList</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>referenceTableName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>referenceTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* check for corrupt metadata */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"reference table \"%s\" does not have a shard"</literal></expr></argument>,
							   <argument><expr><name>referenceTableName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><operator>(</operator><name>ShardInterval</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>shardIntervalList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>shardId</name> <init>= <expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>newWorkersList</name> <init>= <expr><call><name>WorkersWithoutReferenceTablePlacement</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>,
																 <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>newWorkersList</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AnyRelationsModifiedInTransaction returns true if any of the given relations
 * were modified in the current transaction.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>AnyRelationsModifiedInTransaction</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>relationIdList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach_oid</name><argument_list>(<argument>relationId</argument>, <argument>relationIdList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>GetRelationDDLAccessMode</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RELATION_NOT_ACCESSED</name> <operator>||</operator>
			<call><name>GetRelationDMLAccessMode</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RELATION_NOT_ACCESSED</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * WorkersWithoutReferenceTablePlacement returns a list of workers (WorkerNode) that
 * do not yet have a placement for the given reference table shard ID, but are
 * supposed to.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>WorkersWithoutReferenceTablePlacement</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockMode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>workersWithoutPlacements</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardPlacementList</name> <init>= <expr><call><name>ActiveShardPlacementList</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>workerNodeList</name> <init>= <expr><call><name>ReferenceTablePlacementNodeList</name><argument_list>(<argument><expr><name>lockMode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>workerNodeList</name> <operator>=</operator> <call><name>SortList</name><argument_list>(<argument><expr><name>workerNodeList</name></expr></argument>, <argument><expr><name>CompareWorkerNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>workerNode</argument>, <argument>workerNodeList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nodeName</name> <init>= <expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type> <name>nodePort</name> <init>= <expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>targetPlacement</name> <init>= <expr><call><name>SearchShardPlacementInList</name><argument_list>(<argument><expr><name>shardPlacementList</name></expr></argument>,
																	 <argument><expr><name>nodeName</name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>targetPlacement</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>workersWithoutPlacements</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>workersWithoutPlacements</name></expr></argument>, <argument><expr><name>workerNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>workersWithoutPlacements</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CopyShardPlacementToWorkerNodeQuery returns the citus_copy_shard_placement
 * command to copy the given shard placement to given node.
 */</comment>
<function><type><specifier>static</specifier> <name>StringInfo</name></type>
<name>CopyShardPlacementToWorkerNodeQuery</name><parameter_list>(<parameter><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>sourceShardPlacement</name></decl></parameter>,
									<parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name></decl></parameter>,
									<parameter><decl><type><name>char</name></type> <name>transferMode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>queryString</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>transferModeString</name> <init>=
		<expr><ternary><condition><expr><name>transferMode</name> <operator>==</operator> <name>TRANSFER_MODE_BLOCK_WRITES</name></expr> ?</condition><then> <expr><literal type="string">"block_writes"</literal></expr> </then><else>:
		<expr><ternary><condition><expr><name>transferMode</name> <operator>==</operator> <name>TRANSFER_MODE_FORCE_LOGICAL</name></expr> ?</condition><then> <expr><literal type="string">"force_logical"</literal></expr> </then><else>:
		<expr><literal type="string">"auto"</literal></expr></else></ternary></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>queryString</name></expr></argument>,
					 <argument><expr><literal type="string">"SELECT citus_copy_shard_placement("</literal>
					 <name>UINT64_FORMAT</name> <literal type="string">", %s, %d, %s, %d, "</literal>
								   <literal type="string">"transfer_mode := %s)"</literal></expr></argument>,
					 <argument><expr><name><name>sourceShardPlacement</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>,
					 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name><name>sourceShardPlacement</name><operator>-&gt;</operator><name>nodeName</name></name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name><name>sourceShardPlacement</name><operator>-&gt;</operator><name>nodePort</name></name></expr></argument>,
					 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>,
					 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>transferModeString</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>queryString</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * upgrade_to_reference_table was removed, but we maintain a dummy implementation
 * to support downgrades.
 */</comment>
<function><type><name>Datum</name></type>
<name>upgrade_to_reference_table</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"this function is deprecated and no longer used"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CreateReferenceTableColocationId creates a new co-location id for reference tables and
 * writes it into pg_dist_colocation, then returns the created co-location id. Since there
 * can be only one colocation group for all kinds of reference tables, if a co-location id
 * is already created for reference tables, this function returns it without creating
 * anything.
 */</comment>
<function><type><name>uint32</name></type>
<name>CreateReferenceTableColocationId</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>shardCount</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distributionColumnType</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distributionColumnCollation</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We don't maintain replication factor of reference tables anymore and
	 * just use -1 instead. We don't use this value in any places.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>replicationFactor</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* check for existing colocations */</comment>
	<decl_stmt><decl><type><name>uint32</name></type> <name>colocationId</name> <init>=
		<expr><call><name>ColocationId</name><argument_list>(<argument><expr><name>shardCount</name></expr></argument>, <argument><expr><name>replicationFactor</name></expr></argument>, <argument><expr><name>distributionColumnType</name></expr></argument>,
					 <argument><expr><name>distributionColumnCollation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>colocationId</name> <operator>==</operator> <name>INVALID_COLOCATION_ID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>colocationId</name> <operator>=</operator> <call><name>CreateColocationGroup</name><argument_list>(<argument><expr><name>shardCount</name></expr></argument>, <argument><expr><name>replicationFactor</name></expr></argument>,
											 <argument><expr><name>distributionColumnType</name></expr></argument>,
											 <argument><expr><name>distributionColumnCollation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>colocationId</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>uint32</name></type>
<name>GetReferenceTableColocationId</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>shardCount</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distributionColumnType</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distributionColumnCollation</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We don't maintain replication factor of reference tables anymore and
	 * just use -1 instead. We don't use this value in any places.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>replicationFactor</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* check for existing colocations */</comment>
	<decl_stmt><decl><type><name>uint32</name></type> <name>colocationId</name> <init>=
		<expr><call><name>ColocationId</name><argument_list>(<argument><expr><name>shardCount</name></expr></argument>, <argument><expr><name>replicationFactor</name></expr></argument>, <argument><expr><name>distributionColumnType</name></expr></argument>,
					 <argument><expr><name>distributionColumnCollation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>colocationId</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DeleteAllReplicatedTablePlacementsFromNodeGroup function iterates over
 * list of reference and replicated hash distributed tables and deletes
 * all placements from pg_dist_placement table for given group.
 */</comment>
<function><type><name>void</name></type>
<name>DeleteAllReplicatedTablePlacementsFromNodeGroup</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>groupId</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>localOnly</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>referenceTableList</name> <init>= <expr><call><name>CitusTableTypeIdList</name><argument_list>(<argument><expr><name>REFERENCE_TABLE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>replicatedMetadataSyncedDistributedTableList</name> <init>=
		<expr><call><name>ReplicatedMetadataSyncedDistributedTableList</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>replicatedTableList</name> <init>=
		<expr><call><name>list_concat</name><argument_list>(<argument><expr><name>referenceTableList</name></expr></argument>, <argument><expr><name>replicatedMetadataSyncedDistributedTableList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* if there are no reference tables, we do not need to do anything */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>replicatedTableList</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>StringInfo</name></type> <name>deletePlacementCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>replicatedTableId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>replicatedTableId</argument>, <argument>replicatedTableList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>placements</name> <init>=
			<expr><call><name>GroupShardPlacementsForTableOnGroup</name><argument_list>(<argument><expr><name>replicatedTableId</name></expr></argument>, <argument><expr><name>groupId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>placements</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * This happens either the node was previously disabled or the table
			 * doesn't have placement on this node.
			 */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>GroupShardPlacement</name> <modifier>*</modifier></type><name>placement</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>placement</argument>, <argument>placements</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LockShardDistributionMetadata</name><argument_list>(<argument><expr><name><name>placement</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>DeleteShardPlacementRow</name><argument_list>(<argument><expr><name><name>placement</name><operator>-&gt;</operator><name>placementId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>localOnly</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><name>deletePlacementCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>deletePlacementCommand</name></expr></argument>,
								 <argument><expr><literal type="string">"DELETE FROM pg_catalog.pg_dist_placement "</literal>
								 <literal type="string">"WHERE placementid = "</literal> <name>UINT64_FORMAT</name></expr></argument>,
								 <argument><expr><name><name>placement</name><operator>-&gt;</operator><name>placementId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>SendCommandToWorkersWithMetadata</name><argument_list>(<argument><expr><name><name>deletePlacementCommand</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * ReplicatedMetadataSyncedDistributedTableList is a helper function which returns the
 * list of replicated hash distributed tables.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>ReplicatedMetadataSyncedDistributedTableList</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>distributedRelationList</name> <init>= <expr><call><name>CitusTableTypeIdList</name><argument_list>(<argument><expr><name>DISTRIBUTED_TABLE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>replicatedHashDistributedTableList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>relationId</argument>, <argument>distributedRelationList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>ShouldSyncTableMetadata</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>SingleReplicatedTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>replicatedHashDistributedTableList</name> <operator>=</operator>
				<call><name>lappend_oid</name><argument_list>(<argument><expr><name>replicatedHashDistributedTableList</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>replicatedHashDistributedTableList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* CompareOids is a comparison function for sort shard oids */</comment>
<function><type><name>int</name></type>
<name>CompareOids</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>leftElement</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>rightElement</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>leftId</name> <init>= <expr><operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <name>leftElement</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>rightId</name> <init>= <expr><operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <name>rightElement</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>leftId</name> <operator>&gt;</operator> <operator>*</operator><name>rightId</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>*</operator><name>leftId</name> <operator>&lt;</operator> <operator>*</operator><name>rightId</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ErrorIfNotAllNodesHaveReferenceTableReplicas throws an error when one of the
 * nodes in the list does not have reference table replicas.
 */</comment>
<function><type><name>void</name></type>
<name>ErrorIfNotAllNodesHaveReferenceTableReplicas</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>workerNodeList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach_ptr</name><argument_list>(<argument>workerNode</argument>, <argument>workerNodeList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NodeHasAllReferenceTableReplicas</name><argument_list>(<argument><expr><name>workerNode</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"reference tables have not been replicated to "</literal>
								   <literal type="string">"node %s:%d yet"</literal></expr></argument>,
								   <argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>,
								   <argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Reference tables are lazily replicated after "</literal>
									  <literal type="string">"adding a node, but must exist before shards can "</literal>
									  <literal type="string">"be created on that node."</literal></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Run SELECT replicate_reference_tables(); to "</literal>
									<literal type="string">"ensure reference tables exist on all nodes."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * NodeHasAllReferenceTablesReplicas returns whether the given worker node has reference
 * table replicas. If there are no reference tables the function returns true.
 *
 * This function does not do any locking, so the situation could change immediately after,
 * though we can only ever transition from false to true, so only "false" could be the
 * incorrect answer.
 *
 * In the case where the function returns true because no reference tables exist
 * on the node, a reference table could be created immediately after. However, the
 * creation logic guarantees that this reference table will be created on all the
 * nodes, so our answer was correct.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>NodeHasAllReferenceTableReplicas</name><parameter_list>(<parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>referenceTableIdList</name> <init>= <expr><call><name>CitusTableTypeIdList</name><argument_list>(<argument><expr><name>REFERENCE_TABLE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>referenceTableIdList</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* no reference tables exist */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>referenceTableId</name> <init>= <expr><call><name>linitial_oid</name><argument_list>(<argument><expr><name>referenceTableIdList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardIntervalList</name> <init>= <expr><call><name>LoadShardIntervalList</name><argument_list>(<argument><expr><name>referenceTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>shardIntervalList</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* check for corrupt metadata */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"reference table \"%s\" can only have 1 shard"</literal></expr></argument>,
							   <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>referenceTableId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><operator>(</operator><name>ShardInterval</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>shardIntervalList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardPlacementList</name> <init>= <expr><call><name>ActiveShardPlacementList</name><argument_list>(<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>placement</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>placement</argument>, <argument>shardPlacementList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>placement</name><operator>-&gt;</operator><name>groupId</name></name> <operator>==</operator> <name><name>workerNode</name><operator>-&gt;</operator><name>groupId</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* our worker has a reference table placement */</comment>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>
</unit>
