<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/builded_projects/citus/src/backend/distributed/utils/foreign_key_relationship.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * foreign_key_relationship.c
 *   This file contains functions for creating foreign key relationship graph
 *   between distributed tables. Created relationship graph will be hold by
 *   a static variable defined in this file until an invalidation comes in.
 *
 * Copyright (c) Citus Data, Inc.
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_version_constants.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/stratnum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_constraint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/hash_helpers.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/foreign_key_relationship.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/hash_helpers.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/version_compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pg_list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lockdefs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/hsearch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/hashfn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/inval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>


<comment type="block">/*
 * ForeignConstraintRelationshipGraph holds the graph data structure for foreign constraint relationship
 * between relations. We will only have single static instance of that struct and it
 * will be invalidated after change on any foreign constraint.
 */</comment>
<typedef>typedef <type><struct>struct <name>ForeignConstraintRelationshipGraph</name>
<block>{
	<decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>nodeMap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isValid</name></decl>;</decl_stmt>
}</block></struct></type><name>ForeignConstraintRelationshipGraph</name>;</typedef>

<comment type="block">/*
 * ForeignConstraintRelationshipNode holds the data for each node of the ForeignConstraintRelationshipGraph
 * For each node we have relation id, which is the Oid of that relation, visiting
 * information for that node in the latest DFS and the list of adjacency nodes.
 * Note that we also hold back adjacency nodes for getting referenced node over
 * that one.
 */</comment>
<typedef>typedef <type><struct>struct <name>ForeignConstraintRelationshipNode</name>
<block>{
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>adjacencyList</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>backAdjacencyList</name></decl>;</decl_stmt>
}</block></struct></type><name>ForeignConstraintRelationshipNode</name>;</typedef>


<comment type="block">/*
 * ForeignConstraintRelationshipEdge will only be used while creating the ForeignConstraintRelationshipGraph.
 * It won't show edge information on the graph, yet will be used in the pre-processing
 * phase.
 */</comment>
<typedef>typedef <type><struct>struct <name>ForeignConstraintRelationshipEdge</name>
<block>{
	<decl_stmt><decl><type><name>Oid</name></type> <name>referencingRelationOID</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>referencedRelationOID</name></decl>;</decl_stmt>
}</block></struct></type><name>ForeignConstraintRelationshipEdge</name>;</typedef>


<decl_stmt><decl><type><specifier>static</specifier> <name>ForeignConstraintRelationshipGraph</name> <modifier>*</modifier></type><name>fConstraintRelationshipGraph</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>GetRelationshipNodesForFKeyConnectedRelations</name><parameter_list>(
	<parameter><decl><type><name>ForeignConstraintRelationshipNode</name> <modifier>*</modifier></type><name>relationshipNode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>GetAllNeighboursList</name><parameter_list>(<parameter><decl><type><name>ForeignConstraintRelationshipNode</name> <modifier>*</modifier></type><name>relationshipNode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ForeignConstraintRelationshipNode</name> <modifier>*</modifier></type> <name>GetRelationshipNodeForRelationId</name><parameter_list>(<parameter><decl><type><name>Oid</name></type>
																			<name>relationId</name></decl></parameter>,
																			<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isFound</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CreateForeignConstraintRelationshipGraph</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsForeignConstraintRelationshipGraphValid</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>GetNeighbourList</name><parameter_list>(<parameter><decl><type><name>ForeignConstraintRelationshipNode</name> <modifier>*</modifier></type><name>relationshipNode</name></decl></parameter>,
							   <parameter><decl><type><name>bool</name></type> <name>isReferencing</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>GetRelationIdsFromRelationshipNodeList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>fKeyRelationshipNodeList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>PopulateAdjacencyLists</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>CompareForeignConstraintRelationshipEdges</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>leftElement</name></decl></parameter>,
													 <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>rightElement</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AddForeignConstraintRelationshipEdge</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>referencingOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>referencedOid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ForeignConstraintRelationshipNode</name> <modifier>*</modifier></type> <name>CreateOrFindNode</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>adjacencyLists</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type>
															<name>relid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>GetConnectedListHelper</name><parameter_list>(<parameter><decl><type><name>ForeignConstraintRelationshipNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
									 <parameter><decl><type><name>bool</name></type> <name>isReferencing</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>GetForeignConstraintRelationshipHelper</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isReferencing</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * GetForeignKeyConnectedRelationIdList returns a list of relation id's for
 * relations that are connected to relation with relationId via a foreign
 * key graph.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>GetForeignKeyConnectedRelationIdList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* use ShareRowExclusiveLock to prevent concurent foreign key creation */</comment>
	<decl_stmt><decl><type><name>LOCKMODE</name></type> <name>lockMode</name> <init>= <expr><name>ShareRowExclusiveLock</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name> <init>= <expr><call><name>try_relation_open</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>lockMode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RelationIsValid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation with OID %d does not exist"</literal></expr></argument>,
							   <argument><expr><name>relationId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>foundInFKeyGraph</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ForeignConstraintRelationshipNode</name> <modifier>*</modifier></type><name>relationshipNode</name> <init>=
		<expr><call><name>GetRelationshipNodeForRelationId</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>foundInFKeyGraph</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>foundInFKeyGraph</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Relation could not be found in foreign key graph, then it has no
		 * foreign key relationships.
		 */</comment>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>fKeyConnectedRelationshipNodeList</name> <init>=
		<expr><call><name>GetRelationshipNodesForFKeyConnectedRelations</name><argument_list>(<argument><expr><name>relationshipNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>fKeyConnectedRelationIdList</name> <init>=
		<expr><call><name>GetRelationIdsFromRelationshipNodeList</name><argument_list>(<argument><expr><name>fKeyConnectedRelationshipNodeList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><name>fKeyConnectedRelationIdList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ShouldUndistributeCitusLocalTable returns true if given relationId needs
 * to be undistributed. Here we do not undistribute table if it's converted by the user,
 * or connected to a table converted by the user, or a reference table, via foreign keys.
 */</comment>
<function><type><name>bool</name></type>
<name>ShouldUndistributeCitusLocalTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>cacheEntry</name> <init>= <expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cacheEntry</name><operator>-&gt;</operator><name>autoConverted</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The relation is not added to metadata automatically,
		 * we shouldn't undistribute it.
		 */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * As we will operate on foreign key connected relations, here we
	 * invalidate foreign key graph so that we act on fresh graph.
	 */</comment>
	<expr_stmt><expr><call><name>InvalidateForeignKeyGraph</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>fkeyConnectedRelations</name> <init>= <expr><call><name>GetForeignKeyConnectedRelationIdList</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><operator>!</operator><call><name>RelationIdListHasReferenceTable</name><argument_list>(<argument><expr><name>fkeyConnectedRelations</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetRelationshipNodesForFKeyConnectedRelations performs breadth-first search
 * starting from input ForeignConstraintRelationshipNode and returns a list
 * of ForeignConstraintRelationshipNode objects for relations that are connected
 * to given relation node via a foreign key relationhip graph.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>GetRelationshipNodesForFKeyConnectedRelations</name><parameter_list>(
	<parameter><decl><type><name>ForeignConstraintRelationshipNode</name> <modifier>*</modifier></type><name>relationshipNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>oidVisitedMap</name> <init>= <expr><call><name>CreateSimpleHashSetWithName</name><argument_list>(<argument><expr><name>Oid</name></expr></argument>, <argument><expr><literal type="string">"oid visited hash set"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>VisitOid</name><argument_list>(<argument><expr><name>oidVisitedMap</name></expr></argument>, <argument><expr><name><name>relationshipNode</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>relationshipNodeList</name> <init>= <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>relationshipNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ForeignConstraintRelationshipNode</name> <modifier>*</modifier></type><name>currentNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr_append</name><argument_list>(<argument>currentNode</argument>, <argument>relationshipNodeList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>allNeighboursList</name> <init>= <expr><call><name>GetAllNeighboursList</name><argument_list>(<argument><expr><name>currentNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ForeignConstraintRelationshipNode</name> <modifier>*</modifier></type><name>neighbourNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>neighbourNode</argument>, <argument>allNeighboursList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type> <name>neighbourRelationId</name> <init>= <expr><name><name>neighbourNode</name><operator>-&gt;</operator><name>relationId</name></name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>OidVisited</name><argument_list>(<argument><expr><name>oidVisitedMap</name></expr></argument>, <argument><expr><name>neighbourRelationId</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>VisitOid</name><argument_list>(<argument><expr><name>oidVisitedMap</name></expr></argument>, <argument><expr><name>neighbourRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>relationshipNodeList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>relationshipNodeList</name></expr></argument>, <argument><expr><name>neighbourNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block>

	<return>return <expr><name>relationshipNodeList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetAllNeighboursList returns a list of ForeignConstraintRelationshipNode
 * objects by concatenating both (referencing &amp; referenced) adjacency lists
 * of given relationship node.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>GetAllNeighboursList</name><parameter_list>(<parameter><decl><type><name>ForeignConstraintRelationshipNode</name> <modifier>*</modifier></type><name>relationshipNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>isReferencing</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>referencedNeighboursList</name> <init>= <expr><call><name>GetNeighbourList</name><argument_list>(<argument><expr><name>relationshipNode</name></expr></argument>, <argument><expr><name>isReferencing</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>isReferencing</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>referencingNeighboursList</name> <init>= <expr><call><name>GetNeighbourList</name><argument_list>(<argument><expr><name>relationshipNode</name></expr></argument>, <argument><expr><name>isReferencing</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * GetNeighbourList returns list from graph as is, so first copy it as
	 * list_concat might invalidate it.
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>allNeighboursList</name> <init>= <expr><call><name>list_copy</name><argument_list>(<argument><expr><name>referencedNeighboursList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>allNeighboursList</name> <operator>=</operator> <call><name>list_concat_unique_ptr</name><argument_list>(<argument><expr><name>allNeighboursList</name></expr></argument>,
											   <argument><expr><name>referencingNeighboursList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>allNeighboursList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ReferencedRelationIdList is a wrapper function around GetForeignConstraintRelationshipHelper
 * to get list of relation IDs which are referenced by the given relation id.
 *
 * Note that, if relation A is referenced by relation B and relation B is referenced
 * by relation C, then the result list for relation A consists of the relation
 * IDs of relation B and relation C.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>ReferencedRelationIdList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>GetForeignConstraintRelationshipHelper</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ReferencingRelationIdList is a wrapper function around GetForeignConstraintRelationshipHelper
 * to get list of relation IDs which are referencing to given relation id.
 *
 * Note that, if relation A is referenced by relation B and relation B is referenced
 * by relation C, then the result list for relation C consists of the relation
 * IDs of relation A and relation B.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>ReferencingRelationIdList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>GetForeignConstraintRelationshipHelper</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetForeignConstraintRelationshipHelper returns the list of oids referenced or
 * referencing given relation id. It is a helper function for providing results
 * to public functions ReferencedRelationIdList and ReferencingRelationIdList.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>GetForeignConstraintRelationshipHelper</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isReferencing</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>isFound</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ForeignConstraintRelationshipNode</name> <modifier>*</modifier></type><name>relationshipNode</name> <init>=
		<expr><call><name>GetRelationshipNodeForRelationId</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isFound</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isFound</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If there is no node with the given relation id, that means given table
		 * is not referencing and is not referenced by any table
		 */</comment>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>connectedNodeList</name> <init>= <expr><call><name>GetConnectedListHelper</name><argument_list>(<argument><expr><name>relationshipNode</name></expr></argument>, <argument><expr><name>isReferencing</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>relationIdList</name> <init>= <expr><call><name>GetRelationIdsFromRelationshipNodeList</name><argument_list>(<argument><expr><name>connectedNodeList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><name>relationIdList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetRelationshipNodeForRelationId searches foreign key graph for relation
 * with relationId and returns ForeignConstraintRelationshipNode object for
 * relation if it exists in graph. Otherwise, sets isFound to false.
 *
 * Also before searching foreign key graph, this function implicitly builds
 * foreign key graph if it's invalid or not built yet.
 */</comment>
<function><type><specifier>static</specifier> <name>ForeignConstraintRelationshipNode</name> <modifier>*</modifier></type>
<name>GetRelationshipNodeForRelationId</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isFound</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CreateForeignConstraintRelationshipGraph</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ForeignConstraintRelationshipNode</name> <modifier>*</modifier></type><name>relationshipNode</name> <init>=
		<expr><operator>(</operator><name>ForeignConstraintRelationshipNode</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(
			<argument><expr><name><name>fConstraintRelationshipGraph</name><operator>-&gt;</operator><name>nodeMap</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>relationId</name></expr></argument>,
			<argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>isFound</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>relationshipNode</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateForeignConstraintRelationshipGraph creates the foreign constraint relation graph using
 * foreign constraint provided by pg_constraint metadata table.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CreateForeignConstraintRelationshipGraph</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<comment type="block">/* if we have already created the graph, use it */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsForeignConstraintRelationshipGraphValid</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ClearForeignConstraintRelationshipGraphContext</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>fConstraintRelationshipMemoryContext</name> <init>= <expr><call><name>AllocSetContextCreateInternal</name><argument_list>(
		<argument><expr><name>CacheMemoryContext</name></expr></argument>,
		<argument><expr><literal type="string">"Forign Constraint Relationship Graph Context"</literal></expr></argument>,
		<argument><expr><name>ALLOCSET_DEFAULT_MINSIZE</name></expr></argument>,
		<argument><expr><name>ALLOCSET_DEFAULT_INITSIZE</name></expr></argument>,
		<argument><expr><name>ALLOCSET_DEFAULT_MAXSIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(
		<argument><expr><name>fConstraintRelationshipMemoryContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>fConstraintRelationshipGraph</name> <operator>=</operator> <operator>(</operator><name>ForeignConstraintRelationshipGraph</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(
		<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ForeignConstraintRelationshipGraph</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fConstraintRelationshipGraph</name><operator>-&gt;</operator><name>isValid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>fConstraintRelationshipGraph</name><operator>-&gt;</operator><name>nodeMap</name></name> <operator>=</operator> <call><name>CreateSimpleHash</name><argument_list>(<argument><expr><name>Oid</name></expr></argument>,
															 <argument><expr><name>ForeignConstraintRelationshipNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PopulateAdjacencyLists</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>fConstraintRelationshipGraph</name><operator>-&gt;</operator><name>isValid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * IsForeignConstraintGraphValid check whether there is a valid graph.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsForeignConstraintRelationshipGraphValid</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We might have some concurrent metadata changes. In order to get the changes,
	 * we first need to accept the cache invalidation messages.
	 */</comment>
	<expr_stmt><expr><call><name>AcceptInvalidationMessages</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fConstraintRelationshipGraph</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>fConstraintRelationshipGraph</name><operator>-&gt;</operator><name>isValid</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SetForeignConstraintGraphInvalid sets the validity of the graph to false.
 */</comment>
<function><type><name>void</name></type>
<name>SetForeignConstraintRelationshipGraphInvalid</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>fConstraintRelationshipGraph</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>fConstraintRelationshipGraph</name><operator>-&gt;</operator><name>isValid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * GetConnectedListHelper returns list of ForeignConstraintRelationshipNode
 * objects for relations referenced by or referencing to given relation
 * according to isReferencing flag.
 *
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>GetConnectedListHelper</name><parameter_list>(<parameter><decl><type><name>ForeignConstraintRelationshipNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isReferencing</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>oidVisitedMap</name> <init>= <expr><call><name>CreateSimpleHashSetWithName</name><argument_list>(<argument><expr><name>Oid</name></expr></argument>, <argument><expr><literal type="string">"oid visited hash set"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>connectedNodeList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>relationshipNodeStack</name> <init>= <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>relationshipNodeStack</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Note that this loop considers leftmost element of
		 * relationshipNodeStack as top of the stack.
		 */</comment>

		<comment type="block">/* pop top element from stack */</comment>
		<decl_stmt><decl><type><name>ForeignConstraintRelationshipNode</name> <modifier>*</modifier></type><name>currentNode</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name>relationshipNodeStack</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>relationshipNodeStack</name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name>relationshipNodeStack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>Oid</name></type> <name>currentRelationId</name> <init>= <expr><name><name>currentNode</name><operator>-&gt;</operator><name>relationId</name></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidVisited</name><argument_list>(<argument><expr><name>oidVisitedMap</name></expr></argument>, <argument><expr><name>currentRelationId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>connectedNodeList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>connectedNodeList</name></expr></argument>, <argument><expr><name>currentNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>VisitOid</name><argument_list>(<argument><expr><name>oidVisitedMap</name></expr></argument>, <argument><expr><name>currentRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>neighbourList</name> <init>= <expr><call><name>GetNeighbourList</name><argument_list>(<argument><expr><name>currentNode</name></expr></argument>, <argument><expr><name>isReferencing</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ForeignConstraintRelationshipNode</name> <modifier>*</modifier></type><name>neighbourNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>neighbourNode</argument>, <argument>neighbourList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type> <name>neighbourRelationId</name> <init>= <expr><name><name>neighbourNode</name><operator>-&gt;</operator><name>relationId</name></name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidVisited</name><argument_list>(<argument><expr><name>oidVisitedMap</name></expr></argument>, <argument><expr><name>neighbourRelationId</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* push to stack */</comment>
				<expr_stmt><expr><name>relationshipNodeStack</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>neighbourNode</name></expr></argument>, <argument><expr><name>relationshipNodeStack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name>oidVisitedMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* finally remove yourself from list */</comment>
	<expr_stmt><expr><name>connectedNodeList</name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name>connectedNodeList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>connectedNodeList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * OidVisited returns true if given oid is visited according to given oid hash-set.
 */</comment>
<function><type><name>bool</name></type>
<name>OidVisited</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>oidVisitedMap</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name>oidVisitedMap</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>found</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * VisitOid sets given oid as visited in given hash-set.
 */</comment>
<function><type><name>void</name></type>
<name>VisitOid</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>oidVisitedMap</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name>oidVisitedMap</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oid</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * GetNeighbourList returns copy of relevant adjacency list of given
 * ForeignConstraintRelationshipNode object depending on the isReferencing
 * flag.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>GetNeighbourList</name><parameter_list>(<parameter><decl><type><name>ForeignConstraintRelationshipNode</name> <modifier>*</modifier></type><name>relationshipNode</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isReferencing</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>isReferencing</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name><name>relationshipNode</name><operator>-&gt;</operator><name>backAdjacencyList</name></name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<return>return <expr><name><name>relationshipNode</name><operator>-&gt;</operator><name>adjacencyList</name></name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * GetRelationIdsFromRelationshipNodeList returns list of relationId's for
 * given ForeignConstraintRelationshipNode object list.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>GetRelationIdsFromRelationshipNodeList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>fKeyRelationshipNodeList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>relationIdList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ForeignConstraintRelationshipNode</name> <modifier>*</modifier></type><name>fKeyRelationshipNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>fKeyRelationshipNode</argument>, <argument>fKeyRelationshipNodeList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name><name>fKeyRelationshipNode</name><operator>-&gt;</operator><name>relationId</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>relationIdList</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>relationIdList</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>relationIdList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PopulateAdjacencyLists gets foreign constraint relationship information from pg_constraint
 * metadata table and populates them to the foreign constraint relation graph.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>PopulateAdjacencyLists</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scanKey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>scanKeyCount</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>prevReferencingOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>prevReferencedOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>frelEdgeList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>pgConstraint</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_pg_constraint_contype</name></expr></argument>, <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_CHAREQ</name></expr></argument>,
				<argument><expr><call><name>CharGetDatum</name><argument_list>(<argument><expr><name>CONSTRAINT_FOREIGN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scanDescriptor</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pgConstraint</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
													<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>scanKeyCount</name></expr></argument>, <argument><expr><name>scanKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>constraintForm</name> <init>= <expr><operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>ForeignConstraintRelationshipEdge</name> <modifier>*</modifier></type><name>currentFConstraintRelationshipEdge</name> <init>= <expr><call><name>palloc</name><argument_list>(
			<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ForeignConstraintRelationshipEdge</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>currentFConstraintRelationshipEdge</name><operator>-&gt;</operator><name>referencingRelationOID</name></name> <operator>=</operator>
			<name><name>constraintForm</name><operator>-&gt;</operator><name>conrelid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>currentFConstraintRelationshipEdge</name><operator>-&gt;</operator><name>referencedRelationOID</name></name> <operator>=</operator>
			<name><name>constraintForm</name><operator>-&gt;</operator><name>confrelid</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>frelEdgeList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>frelEdgeList</name></expr></argument>, <argument><expr><name>currentFConstraintRelationshipEdge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Since there is no index on columns we are planning to sort tuples
	 * sorting tuples manually instead of using scan keys
	 */</comment>
	<expr_stmt><expr><name>frelEdgeList</name> <operator>=</operator> <call><name>SortList</name><argument_list>(<argument><expr><name>frelEdgeList</name></expr></argument>, <argument><expr><name>CompareForeignConstraintRelationshipEdges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ForeignConstraintRelationshipEdge</name> <modifier>*</modifier></type><name>currentFConstraintRelationshipEdge</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>currentFConstraintRelationshipEdge</argument>, <argument>frelEdgeList</argument>)</argument_list></macro>
	<block>{<block_content>
		<comment type="block">/* we just saw this edge, no need to add it twice */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>currentFConstraintRelationshipEdge</name><operator>-&gt;</operator><name>referencingRelationOID</name></name> <operator>==</operator>
			<name>prevReferencingOid</name> <operator>&amp;&amp;</operator>
			<name><name>currentFConstraintRelationshipEdge</name><operator>-&gt;</operator><name>referencedRelationOID</name></name> <operator>==</operator>
			<name>prevReferencedOid</name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>AddForeignConstraintRelationshipEdge</name><argument_list>(
			<argument><expr><name><name>currentFConstraintRelationshipEdge</name><operator>-&gt;</operator><name>referencingRelationOID</name></name></expr></argument>,
			<argument><expr><name><name>currentFConstraintRelationshipEdge</name><operator>-&gt;</operator>
			<name>referencedRelationOID</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>prevReferencingOid</name> <operator>=</operator> <name><name>currentFConstraintRelationshipEdge</name><operator>-&gt;</operator><name>referencingRelationOID</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>prevReferencedOid</name> <operator>=</operator> <name><name>currentFConstraintRelationshipEdge</name><operator>-&gt;</operator><name>referencedRelationOID</name></name></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pgConstraint</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CompareForeignConstraintRelationshipEdges is a helper function to compare two
 * ForeignConstraintRelationshipEdge using referencing and referenced ids respectively.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>CompareForeignConstraintRelationshipEdges</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>leftElement</name></decl></parameter>,
										  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>rightElement</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ForeignConstraintRelationshipEdge</name> <modifier>*</modifier></type><name>leftEdge</name> <init>=
		<expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>ForeignConstraintRelationshipEdge</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>leftElement</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ForeignConstraintRelationshipEdge</name> <modifier>*</modifier></type><name>rightEdge</name> <init>=
		<expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>ForeignConstraintRelationshipEdge</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>rightElement</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>referencingDiff</name> <init>= <expr><name><name>leftEdge</name><operator>-&gt;</operator><name>referencingRelationOID</name></name> <operator>-</operator>
						  <name><name>rightEdge</name><operator>-&gt;</operator><name>referencingRelationOID</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>referencedDiff</name> <init>= <expr><name><name>leftEdge</name><operator>-&gt;</operator><name>referencedRelationOID</name></name> <operator>-</operator>
						 <name><name>rightEdge</name><operator>-&gt;</operator><name>referencedRelationOID</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>referencingDiff</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>referencingDiff</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>referencedDiff</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AddForeignConstraintRelationshipEdge adds edge between the nodes having given OIDs
 * by adding referenced node to the adjacency list referencing node and adding
 * referencing node to the back adjacency list of referenced node.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AddForeignConstraintRelationshipEdge</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>referencingOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>referencedOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ForeignConstraintRelationshipNode</name> <modifier>*</modifier></type><name>referencingNode</name> <init>= <expr><call><name>CreateOrFindNode</name><argument_list>(
		<argument><expr><name><name>fConstraintRelationshipGraph</name><operator>-&gt;</operator><name>nodeMap</name></name></expr></argument>, <argument><expr><name>referencingOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ForeignConstraintRelationshipNode</name> <modifier>*</modifier></type><name>referencedNode</name> <init>= <expr><call><name>CreateOrFindNode</name><argument_list>(
		<argument><expr><name><name>fConstraintRelationshipGraph</name><operator>-&gt;</operator><name>nodeMap</name></name></expr></argument>, <argument><expr><name>referencedOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>referencingNode</name><operator>-&gt;</operator><name>adjacencyList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>referencingNode</name><operator>-&gt;</operator><name>adjacencyList</name></name></expr></argument>,
											 <argument><expr><name>referencedNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>referencedNode</name><operator>-&gt;</operator><name>backAdjacencyList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>referencedNode</name><operator>-&gt;</operator><name>backAdjacencyList</name></name></expr></argument>,
												<argument><expr><name>referencingNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CreateOrFindNode either gets or adds new node to the foreign constraint relation graph
 */</comment>
<function><type><specifier>static</specifier> <name>ForeignConstraintRelationshipNode</name> <modifier>*</modifier></type>
<name>CreateOrFindNode</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>adjacencyLists</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ForeignConstraintRelationshipNode</name> <modifier>*</modifier></type><name>node</name> <init>=
		<expr><operator>(</operator><name>ForeignConstraintRelationshipNode</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>adjacencyLists</name></expr></argument>,
														  <argument><expr><operator>&amp;</operator><name>relid</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>,
														  <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>adjacencyList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>backAdjacencyList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ClearForeignConstraintRelationshipGraphContext clear all the allocated memory obtained
 * for foreign constraint relationship graph. Since all the variables of relationship
 * graph was obtained within the same context, destroying hash map is enough as
 * it deletes the context.
 */</comment>
<function><type><name>void</name></type>
<name>ClearForeignConstraintRelationshipGraphContext</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>fConstraintRelationshipGraph</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name><name>fConstraintRelationshipGraph</name><operator>-&gt;</operator><name>nodeMap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>fConstraintRelationshipGraph</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
