<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/builded_projects/citus/src/backend/distributed/utils/citus_clauses.c"><comment type="block">/*
 * citus_clauses.c
 *
 * Routines roughly equivalent to postgres' util/clauses.
 *
 * Copyright (c) Citus Data, Inc.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/insert_select_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_router_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/version_compat.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/primnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planmain.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>


<comment type="block">/* private function declarations */</comment>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsVariableExpression</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type> <name>citus_evaluate_expr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>result_type</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>result_typmod</name></decl></parameter>,
								  <parameter><decl><type><name>Oid</name></type> <name>result_collation</name></decl></parameter>,
								  <parameter><decl><type><name>CoordinatorEvaluationContext</name> <modifier>*</modifier></type>
								  <name>coordinatorEvaluationContext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>CitusIsVolatileFunctionIdChecker</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>func_id</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>CitusIsMutableFunctionIdChecker</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>func_id</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ShouldEvaluateExpression</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expression</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ShouldEvaluateFunctions</name><parameter_list>(<parameter><decl><type><name>CoordinatorEvaluationContext</name> <modifier>*</modifier></type><name>evaluationContext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>FixFunctionArguments</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>FixFunctionArgumentsWalker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * RequiresCoordinatorEvaluation returns the executor needs to reparse and
 * try to execute this query, which is the case if the query contains
 * any stable or volatile function.
 */</comment>
<function><type><name>bool</name></type>
<name>RequiresCoordinatorEvaluation</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>query</name><operator>-&gt;</operator><name>hasModifyingCTE</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>FindNodeMatchingCheckFunction</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>query</name></expr></argument>, <argument><expr><name>CitusIsMutableFunction</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExecuteCoordinatorEvaluableExpressions evaluates expressions and parameters
 * that can be resolved to a constant.
 */</comment>
<function><type><name>void</name></type>
<name>ExecuteCoordinatorEvaluableExpressions</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planState</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CoordinatorEvaluationContext</name></type> <name>coordinatorEvaluationContext</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>coordinatorEvaluationContext</name><operator>.</operator><name>planState</name></name> <operator>=</operator> <name>planState</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>coordinatorEvaluationContext</name><operator>.</operator><name>evaluationMode</name></name> <operator>=</operator> <name>EVALUATE_PARAMS</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>coordinatorEvaluationContext</name><operator>.</operator><name>evaluationMode</name></name> <operator>=</operator> <name>EVALUATE_FUNCTIONS_PARAMS</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PartiallyEvaluateExpression</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>query</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>coordinatorEvaluationContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * PartiallyEvaluateExpression descends into an expression tree to evaluate
 * expressions that can be resolved to a constant on the master. Expressions
 * containing a Var are skipped, since the value of the Var is not known
 * on the master.
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>PartiallyEvaluateExpression</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expression</name></decl></parameter>,
							<parameter><decl><type><name>CoordinatorEvaluationContext</name> <modifier>*</modifier></type><name>coordinatorEvaluationContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>expression</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>expression</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>expression</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>NodeTag</name></type> <name>nodeTag</name> <init>= <expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>expression</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>nodeTag</name> <operator>==</operator> <name>T_Param</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Param</name> <modifier>*</modifier></type><name>param</name> <init>= <expr><operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <name>expression</name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>param</name><operator>-&gt;</operator><name>paramkind</name></name> <operator>==</operator> <name>PARAM_SUBLINK</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* ExecInitExpr cannot handle PARAM_SUBLINK */</comment>
			<return>return <expr><name>expression</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>citus_evaluate_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>expression</name></expr></argument>,
											<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>expression</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><call><name>exprTypmod</name><argument_list>(<argument><expr><name>expression</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><call><name>exprCollation</name><argument_list>(<argument><expr><name>expression</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><name>coordinatorEvaluationContext</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>ShouldEvaluateExpression</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>expression</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			 <call><name>ShouldEvaluateFunctions</name><argument_list>(<argument><expr><name>coordinatorEvaluationContext</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The planner normally evaluates constant expressions, but we may be
		 * working on the original query tree. We could rely on
		 * citus_evaluate_expr to evaluate constant expressions, but there are
		 * certain node types that citus_evaluate_expr does not expect because
		 * the planner normally replaces them (in particular, CollateExpr).
		 * Hence, we first evaluate constant expressions using
		 * eval_const_expressions before continuing.
		 *
		 * NOTE: We do not use expression_planner here, since all it does
		 * apart from calling eval_const_expressions is call fix_opfuncids.
		 * We do not need this, since that is already called in
		 * citus_evaluate_expr. So we won't needlessly traverse the expression
		 * tree by calling it another time.
		 */</comment>
		<expr_stmt><expr><name>expression</name> <operator>=</operator> <call><name>eval_const_expressions</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>expression</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * It's possible that after evaluating const expressions we
		 * actually don't need to evaluate this expression anymore e.g:
		 *
		 * 1 = 0 AND now() &gt; timestamp '10-10-2000 00:00'
		 *
		 * This statement would simply resolve to false, because 1 = 0 is
		 * false. That's why we now check again if we should evaluate the
		 * expression and only continue if we still do.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ShouldEvaluateExpression</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>expression</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>expression_tree_mutator</name><argument_list>(<argument><expr><name>expression</name></expr></argument>,
													<argument><expr><name>PartiallyEvaluateExpression</name></expr></argument>,
													<argument><expr><name>coordinatorEvaluationContext</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>FindNodeMatchingCheckFunction</name><argument_list>(<argument><expr><name>expression</name></expr></argument>, <argument><expr><name>IsVariableExpression</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * The expression contains a variable expression (e.g. a stable function,
			 * which has a column reference as its input). That means that we cannot
			 * evaluate the expression on the coordinator, since the result depends
			 * on the input.
			 *
			 * Skipping function evaluation for these expressions is safe in most
			 * cases, since the function will always be re-evaluated for every input
			 * value. An exception is function calls that call another stable function
			 * that should not be re-evaluated, such as now().
			 */</comment>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>expression_tree_mutator</name><argument_list>(<argument><expr><name>expression</name></expr></argument>,
													<argument><expr><name>PartiallyEvaluateExpression</name></expr></argument>,
													<argument><expr><name>coordinatorEvaluationContext</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>citus_evaluate_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>expression</name></expr></argument>,
											<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>expression</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><call><name>exprTypmod</name><argument_list>(<argument><expr><name>expression</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><call><name>exprCollation</name><argument_list>(<argument><expr><name>expression</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><name>coordinatorEvaluationContext</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>nodeTag</name> <operator>==</operator> <name>T_Query</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>expression</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CoordinatorEvaluationContext</name></type> <name>subContext</name> <init>= <expr><operator>*</operator><name>coordinatorEvaluationContext</name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Currently INSERT SELECT evaluates stable functions on master,
			 * while a plain SELECT does not. For evaluating SELECT evaluationMode is
			 * EVALUATE_PARAMS, but if recursing into a modifying CTE switch into
			 * EVALUATE_FUNCTIONS_PARAMS.
			 */</comment>
			<expr_stmt><expr><name><name>subContext</name><operator>.</operator><name>evaluationMode</name></name> <operator>=</operator> <name>EVALUATE_FUNCTIONS_PARAMS</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>query_tree_mutator</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
										   <argument><expr><name>PartiallyEvaluateExpression</name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>subContext</name></expr></argument>,
										   <argument><expr><name>QTW_DONT_COPY_QUERY</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>expression_tree_mutator</name><argument_list>(<argument><expr><name>expression</name></expr></argument>,
												<argument><expr><name>PartiallyEvaluateExpression</name></expr></argument>,
												<argument><expr><name>coordinatorEvaluationContext</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>expression</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ShouldEvaluateFunctions is a helper function which is used to
 * decide whether the function/expression should be evaluated with the input
 * coordinatorEvaluationContext.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ShouldEvaluateFunctions</name><parameter_list>(<parameter><decl><type><name>CoordinatorEvaluationContext</name> <modifier>*</modifier></type><name>evaluationContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>evaluationContext</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* if no context provided, evaluate, which is the default behaviour */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>evaluationContext</name><operator>-&gt;</operator><name>evaluationMode</name></name> <operator>==</operator> <name>EVALUATE_FUNCTIONS_PARAMS</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ShouldEvaluateExpression returns true if Citus should evaluate the
 * input node on the coordinator.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ShouldEvaluateExpression</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expression</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NodeTag</name></type> <name>nodeTag</name> <init>= <expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>expression</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>nodeTag</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_FuncExpr</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>funcExpr</name> <init>= <expr><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>expression</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* we cannot evaluate set returning functions */</comment>
			<decl_stmt><decl><type><name>bool</name></type> <name>isSetReturningFunction</name> <init>= <expr><name><name>funcExpr</name><operator>-&gt;</operator><name>funcretset</name></name></expr></init></decl>;</decl_stmt>
			<return>return <expr><operator>!</operator><name>isSetReturningFunction</name></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>T_OpExpr</name></expr>:</case>
		<case>case <expr><name>T_DistinctExpr</name></expr>:</case>
		<case>case <expr><name>T_NullIfExpr</name></expr>:</case>
		<case>case <expr><name>T_CoerceViaIO</name></expr>:</case>
		<case>case <expr><name>T_ArrayCoerceExpr</name></expr>:</case>
		<case>case <expr><name>T_ScalarArrayOpExpr</name></expr>:</case>
		<case>case <expr><name>T_RowExpr</name></expr>:</case>
		<case>case <expr><name>T_RowCompareExpr</name></expr>:</case>
		<case>case <expr><name>T_RelabelType</name></expr>:</case>
		<case>case <expr><name>T_CoerceToDomain</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block>

		<default>default:</default>
			<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
 * IsVariableExpression returns whether the given node is a variable expression,
 * meaning its result depends on the input data and is not constant for the whole
 * query.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsVariableExpression</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>WindowFunc</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* ExecInitExpr cannot handle PARAM_SUBLINK */</comment>
		<return>return <expr><operator>(</operator><operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>paramkind</name> <operator>==</operator> <name>PARAM_SUBLINK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * a copy of pg's evaluate_expr, pre-evaluate a constant expression
 *
 * We use the executor's routine ExecEvalExpr() to avoid duplication of
 * code and ensure we get the same result as the executor would get.
 *
 * *INDENT-OFF*
 */</comment>
<function><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type>
<name>citus_evaluate_expr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>result_type</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>result_typmod</name></decl></parameter>,
					<parameter><decl><type><name>Oid</name></type> <name>result_collation</name></decl></parameter>,
					<parameter><decl><type><name>CoordinatorEvaluationContext</name> <modifier>*</modifier></type><name>coordinatorEvaluationContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planState</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name>     <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>exprstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>const_val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>const_is_null</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type>		<name>resultTypLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>resultTypByVal</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>coordinatorEvaluationContext</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>planState</name> <operator>=</operator> <name><name>coordinatorEvaluationContext</name><operator>-&gt;</operator><name>planState</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>coordinatorEvaluationContext</name><operator>-&gt;</operator><name>evaluationMode</name></name> <operator>==</operator> <name>EVALUATE_NONE</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* bail out, the caller doesn't want params to be evaluated  */</comment>
				<return>return <expr><name>expr</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>coordinatorEvaluationContext</name><operator>-&gt;</operator><name>evaluationMode</name></name> <operator>!=</operator> <name>EVALUATE_FUNCTIONS_PARAMS</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* should only get here for node types we should evaluate */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ShouldEvaluateExpression</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* bail out, the caller doesn't want functions/expressions to be evaluated */</comment>
			<return>return <expr><name>expr</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * To use the executor, we need an EState.
	 */</comment>
	<expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We can use the estate's working context to avoid memory leaks. */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* handles default values */</comment>
	<expr_stmt><expr><call><name>FixFunctionArguments</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make sure any opfuncids are filled in. */</comment>
	<expr_stmt><expr><call><name>fix_opfuncids</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Prepare expr for execution.  (Note: we can't use ExecPrepareExpr
	 * because it'd result in recursively invoking eval_const_expressions.)
	 */</comment>
	<expr_stmt><expr><name>exprstate</name> <operator>=</operator> <call><name>ExecInitExpr</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>planState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get short lived per tuple context as evaluate_expr does. Here we don't
	 * use planState-&gt;ExprContext as it might cause double-free'ing executor
	 * state.
	 */</comment>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>planState</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If planState exists, then we add es_param_list_info to per tuple
		 * ExprContext as we need them when evaluating prepared statements.
		 */</comment>
		<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_param_list_info</name></name> <operator>=</operator> <name><name>planState</name><operator>-&gt;</operator><name>state</name><operator>-&gt;</operator><name>es_param_list_info</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * And evaluate it.
	 */</comment>
	<expr_stmt><expr><name>const_val</name> <operator>=</operator> <call><name>ExecEvalExprSwitchContext</name><argument_list>(<argument><expr><name>exprstate</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>const_is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get info needed about result datatype */</comment>
	<expr_stmt><expr><call><name>get_typlenbyval</name><argument_list>(<argument><expr><name>result_type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>resultTypLen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>resultTypByVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get back to outer memory context */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Must copy result out of sub-context used by expression eval.
	 *
	 * Also, if it's varlena, forcibly detoast it.  This protects us against
	 * storing TOAST pointers into plans that might outlive the referenced
	 * data.  (makeConst would handle detoasting anyway, but it's worth a few
	 * extra lines here so that we can do the copy and detoast in one step.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>const_is_null</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>resultTypLen</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>const_val</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>PG_DETOAST_DATUM_COPY</name><argument_list>(<argument><expr><name>const_val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>const_val</name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name>const_val</name></expr></argument>, <argument><expr><name>resultTypByVal</name></expr></argument>, <argument><expr><name>resultTypLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Release all the junk we just created */</comment>
	<expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make the constant result node.
	 */</comment>
	<return>return <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name>result_type</name></expr></argument>, <argument><expr><name>result_typmod</name></expr></argument>, <argument><expr><name>result_collation</name></expr></argument>,
							  <argument><expr><name>resultTypLen</name></expr></argument>,
							  <argument><expr><name>const_val</name></expr></argument>, <argument><expr><name>const_is_null</name></expr></argument>,
							  <argument><expr><name>resultTypByVal</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* *INDENT-ON* */</comment>


<comment type="block">/*
 * CitusIsVolatileFunctionIdChecker checks if the given function id is
 * a volatile function other than read_intermediate_result().
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>CitusIsVolatileFunctionIdChecker</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>func_id</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>func_id</name> <operator>==</operator> <call><name>CitusReadIntermediateResultFuncId</name><argument_list>()</argument_list></call> <operator>||</operator>
		<name>func_id</name> <operator>==</operator> <call><name>CitusReadIntermediateResultArrayFuncId</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><operator>(</operator><call><name>func_volatile</name><argument_list>(<argument><expr><name>func_id</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PROVOLATILE_VOLATILE</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CitusIsVolatileFunction checks if the given node is a volatile function
 * other than Citus's internal functions.
 */</comment>
<function><type><name>bool</name></type>
<name>CitusIsVolatileFunction</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Check for volatile functions in node itself */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>check_functions_in_node</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>CitusIsVolatileFunctionIdChecker</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NextValueExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* NextValueExpr is volatile */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CitusIsMutableFunctionIdChecker checks if the given function id is
 * a mutable function other than read_intermediate_result().
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>CitusIsMutableFunctionIdChecker</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>func_id</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>func_id</name> <operator>==</operator> <call><name>CitusReadIntermediateResultFuncId</name><argument_list>()</argument_list></call> <operator>||</operator>
		<name>func_id</name> <operator>==</operator> <call><name>CitusReadIntermediateResultArrayFuncId</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<return>return <expr><operator>(</operator><call><name>func_volatile</name><argument_list>(<argument><expr><name>func_id</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PROVOLATILE_IMMUTABLE</name><operator>)</operator></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CitusIsMutableFunction checks if the given node is a mutable function
 * other than Citus's internal functions.
 */</comment>
<function><type><name>bool</name></type>
<name>CitusIsMutableFunction</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Check for mutable functions in node itself */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>check_functions_in_node</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>CitusIsMutableFunctionIdChecker</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SQLValueFunction</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* all variants of SQLValueFunction are stable */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NextValueExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* NextValueExpr is volatile */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* FixFunctionArguments applies expand_function_arguments to all function calls. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>FixFunctionArguments</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>FixFunctionArgumentsWalker</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* FixFunctionArgumentsWalker is the helper function for fix_funcargs. */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>FixFunctionArgumentsWalker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>expr</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>funcExpr</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>FuncExpr</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type> <name>func_tuple</name> <init>=
			<expr><call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>funcExpr</name><operator>-&gt;</operator><name>funcid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>func_tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name><name>funcExpr</name><operator>-&gt;</operator><name>funcid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>funcExpr</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>expand_function_arguments_compat</name><argument_list>(<argument><expr><name><name>funcExpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
														  <argument><expr><name><name>funcExpr</name><operator>-&gt;</operator><name>funcresulttype</name></name></expr></argument>,
														  <argument><expr><name>func_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>func_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>FixFunctionArgumentsWalker</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
