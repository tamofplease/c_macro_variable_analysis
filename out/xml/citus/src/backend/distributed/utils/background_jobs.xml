<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/citus/src/backend/distributed/utils/background_jobs.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * background_jobs.c
 *	  Background jobs run as a background worker, spawned from the
 *	  maintenance daemon. Jobs have tasks, tasks can depend on other
 *	  tasks before execution.
 *
 * This file contains the code for two separate background workers to
 * achieve the goal of running background tasks asynchronously from the
 * main database workload. This first background worker is the
 * Background Tasks Queue Monitor. This background worker keeps track of
 * tasks recorded in pg_dist_background_task and ensures execution based
 * on a statemachine. When a task needs to be executed it starts a
 * Background Task Executor that executes the sql statement defined in the
 * task. The output of the Executor is shared with the Monitor via a
 * shared memory queue.
 *
 * To make sure there is only ever exactly one monitor running per database
 * it takes an exclusive lock on the CITUS_BACKGROUND_TASK_MONITOR
 * operation. This lock is consulted from the maintenance daemon to only
 * spawn a new monitor when the lock is not held.
 *
 * Copyright (c) Citus Data, Inc.
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"safe_mem_lib.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/dbcommands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/hashfn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-fe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqmq.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/analyze.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/dsm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procarray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/shm_mq.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/shm_toc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/pquery.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgrprotos.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/hsearch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/portal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ps_status.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/resowner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timeout.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/background_jobs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_safe_lib.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/hash_helpers.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/maintenanced.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shard_cleaner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/resource_lock.h"</cpp:file></cpp:include>

<comment type="block">/* Table-of-contents constants for our dynamic shared memory segment. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CITUS_BACKGROUND_TASK_MAGIC</name></cpp:macro> <cpp:value>0x51028081</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CITUS_BACKGROUND_TASK_KEY_DATABASE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CITUS_BACKGROUND_TASK_KEY_USERNAME</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CITUS_BACKGROUND_TASK_KEY_COMMAND</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CITUS_BACKGROUND_TASK_KEY_QUEUE</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CITUS_BACKGROUND_TASK_KEY_TASK_ID</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CITUS_BACKGROUND_TASK_KEY_JOB_ID</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CITUS_BACKGROUND_TASK_NKEYS</name></cpp:macro> <cpp:value>6</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>BackgroundWorkerHandle</name> <modifier>*</modifier></type> <name>StartCitusBackgroundTaskExecutor</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>database</name></decl></parameter>,
																 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>user</name></decl></parameter>,
																 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>command</name></decl></parameter>,
																 <parameter><decl><type><name>int64</name></type> <name>taskId</name></decl></parameter>,
																 <parameter><decl><type><name>int64</name></type> <name>jobId</name></decl></parameter>,
																 <parameter><decl><type><name>dsm_segment</name> <modifier>*</modifier><modifier>*</modifier></type><name>pSegment</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecuteSqlString</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sql</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>shm_mq_result</name></type> <name>ConsumeTaskWorkerOutput</name><parameter_list>(<parameter><decl><type><name>shm_mq_handle</name> <modifier>*</modifier></type><name>responseq</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>message</name></decl></parameter>,
											 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>hadError</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>UpdateDependingTasks</name><parameter_list>(<parameter><decl><type><name>BackgroundTask</name> <modifier>*</modifier></type><name>task</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int64</name></type> <name>CalculateBackoffDelay</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>retryCount</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>NewExecutorExceedsCitusLimit</name><parameter_list>(
	<parameter><decl><type><name>QueueMonitorExecutionContext</name> <modifier>*</modifier></type><name>queueMonitorExecutionContext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>NewExecutorExceedsPgMaxWorkers</name><parameter_list>(<parameter><decl><type><name>BackgroundWorkerHandle</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>,
										   <parameter><decl><type><name>QueueMonitorExecutionContext</name> <modifier>*</modifier></type>
										   <name>queueMonitorExecutionContext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>AssignRunnableTaskToNewExecutor</name><parameter_list>(<parameter><decl><type><name>BackgroundTask</name> <modifier>*</modifier></type><name>runnableTask</name></decl></parameter>,
											<parameter><decl><type><name>QueueMonitorExecutionContext</name> <modifier>*</modifier></type>
											<name>queueMonitorExecutionContext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AssignRunnableTasks</name><parameter_list>(
	<parameter><decl><type><name>QueueMonitorExecutionContext</name> <modifier>*</modifier></type><name>queueMonitorExecutionContext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>GetRunningTaskEntries</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>currentExecutors</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>shm_mq_result</name></type> <name>ReadFromExecutorQueue</name><parameter_list>(
	<parameter><decl><type><name>BackgroundExecutorHashEntry</name> <modifier>*</modifier></type><name>backgroundExecutorHashEntry</name></decl></parameter>,
	<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>hadError</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CheckAndResetLastWorkerAllocationFailure</name><parameter_list>(
	<parameter><decl><type><name>QueueMonitorExecutionContext</name> <modifier>*</modifier></type><name>queueMonitorExecutionContext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TaskExecutionStatus</name></type> <name>TaskConcurrentCancelCheck</name><parameter_list>(
	<parameter><decl><type><name>TaskExecutionContext</name> <modifier>*</modifier></type><name>taskExecutionContext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TaskExecutionStatus</name></type> <name>ConsumeExecutorQueue</name><parameter_list>(
	<parameter><decl><type><name>TaskExecutionContext</name> <modifier>*</modifier></type><name>taskExecutionContext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>TaskHadError</name><parameter_list>(<parameter><decl><type><name>TaskExecutionContext</name> <modifier>*</modifier></type><name>taskExecutionContext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>TaskEnded</name><parameter_list>(<parameter><decl><type><name>TaskExecutionContext</name> <modifier>*</modifier></type><name>taskExecutionContext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>TerminateAllTaskExecutors</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>currentExecutors</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type> <name>GetRunningUniqueJobIds</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>currentExecutors</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CancelAllTaskExecutors</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>currentExecutors</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>MonitorGotTerminationOrCancellationRequest</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>QueueMonitorSigTermHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>QueueMonitorSigIntHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>QueueMonitorSigHupHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* flags set by signal handlers */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>sig_atomic_t</name></type> <name>GotSigterm</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>sig_atomic_t</name></type> <name>GotSigint</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>sig_atomic_t</name></type> <name>GotSighup</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>citus_job_cancel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>citus_job_wait</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<comment type="block">/*
 * pg_catalog.citus_job_cancel(jobid bigint) void
 *   cancels a scheduled/running job
 *
 * When cancelling a job there are two phases.
 *  1. scan all associated tasks and transition all tasks that are not already in their
 *     terminal state to cancelled. Except if the task is currently running.
 *  2. for all running tasks we send a cancelation signal to the backend running the
 *     query. The background executor/monitor will transition this task to cancelled.
 *
 * We apply the same policy checks as pg_cancel_backend to check if a user can cancel a
 * job.
 */</comment>
<function><type><name>Datum</name></type>
<name>citus_job_cancel</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EnsureCoordinator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int64</name></type> <name>jobid</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Cancel all tasks that were scheduled before */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>pids</name> <init>= <expr><call><name>CancelTasksForJob</name><argument_list>(<argument><expr><name>jobid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* send cancellation to any running backends */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>pid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_int</name><argument_list>(<argument>pid</argument>, <argument>pids</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type> <name>pidDatum</name> <init>= <expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type> <name>signalSuccessDatum</name> <init>= <expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>pg_cancel_backend</name></expr></argument>, <argument><expr><name>pidDatum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>signalSuccess</name> <init>= <expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><name>signalSuccessDatum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>signalSuccess</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not send signal to process %d: %m"</literal></expr></argument>, <argument><expr><name>pid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>UpdateBackgroundJob</name><argument_list>(<argument><expr><name>jobid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * pg_catalog.citus_job_wait(jobid bigint,
 *                            desired_status citus_job_status DEFAULT NULL) boolean
 *   waits till a job reaches a desired status, or can't reach the status anymore because
 *   it reached a (different) terminal state. When no desired_status is given it will
 *   assume any terminal state as its desired status. The function returns if the
 *   desired_state was reached.
 *
 * The current implementation is a polling implementation with an interval of 1 second.
 * Ideally we would have some synchronization between the background tasks queue monitor
 * and any backend calling this function to receive a signal when the job changes state.
 */</comment>
<function><type><name>Datum</name></type>
<name>citus_job_wait</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EnsureCoordinator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int64</name></type> <name>jobid</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* parse the optional desired_status argument */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>hasDesiredStatus</name> <init>= <expr><operator>!</operator><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BackgroundJobStatus</name></type> <name>desiredStatus</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>hasDesiredStatus</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>desiredStatus</name> <operator>=</operator> <call><name>BackgroundJobStatusByOid</name><argument_list>(<argument><expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>citus_job_wait_internal</name><argument_list>(<argument><expr><name>jobid</name></expr></argument>, <argument><expr><ternary><condition><expr><name>hasDesiredStatus</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name>desiredStatus</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * citus_job_wait_internal imaplements the waiting on a job for reuse in other areas where
 * we want to wait on jobs. eg the background rebalancer.
 *
 * When a desiredStatus is provided it will provide an error when a different state is
 * reached and the state cannot ever reach the desired state anymore.
 */</comment>
<function><type><name>void</name></type>
<name>citus_job_wait_internal</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>jobid</name></decl></parameter>, <parameter><decl><type><name>BackgroundJobStatus</name> <modifier>*</modifier></type><name>desiredStatus</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Since we are wait polling we will actually allocate memory on every poll. To make
	 * sure we don't put unneeded pressure on the memory we create a context that we clear
	 * every iteration.
	 */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>waitContext</name> <init>= <expr><call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
													  <argument><expr><literal type="string">"JobsWaitContext"</literal></expr></argument>,
													  <argument><expr><name>ALLOCSET_DEFAULT_MINSIZE</name></expr></argument>,
													  <argument><expr><name>ALLOCSET_DEFAULT_INITSIZE</name></expr></argument>,
													  <argument><expr><name>ALLOCSET_DEFAULT_MAXSIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>waitContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>waitContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>BackgroundJob</name> <modifier>*</modifier></type><name>job</name> <init>= <expr><call><name>GetBackgroundJobByJobId</name><argument_list>(<argument><expr><name>jobid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>job</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no job found for job with jobid: %ld"</literal></expr></argument>, <argument><expr><name>jobid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>desiredStatus</name> <operator>&amp;&amp;</operator> <name><name>job</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <operator>*</operator><name>desiredStatus</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* job has reached its desired status, done waiting */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsBackgroundJobStatusTerminal</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>desiredStatus</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * We have reached a terminal state, which is not the desired state we
				 * were waiting for, otherwise we would have escaped earlier. Since it is
				 * a terminal state we know that we can never reach the desired state.
				 */</comment>

				<decl_stmt><decl><type><name>Oid</name></type> <name>reachedStatusOid</name> <init>= <expr><call><name>BackgroundJobStatusOid</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Datum</name></type> <name>reachedStatusNameDatum</name> <init>= <expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>enum_out</name></expr></argument>,
																   <argument><expr><name>reachedStatusOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>reachedStatusName</name> <init>= <expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><name>reachedStatusNameDatum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<decl_stmt><decl><type><name>Oid</name></type> <name>desiredStatusOid</name> <init>= <expr><call><name>BackgroundJobStatusOid</name><argument_list>(<argument><expr><operator>*</operator><name>desiredStatus</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Datum</name></type> <name>desiredStatusNameDatum</name> <init>= <expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>enum_out</name></expr></argument>,
																   <argument><expr><name>desiredStatusOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>desiredStatusName</name> <init>= <expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><name>desiredStatusNameDatum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Job reached terminal state \"%s\" instead of desired "</literal>
								<literal type="string">"state \"%s\""</literal></expr></argument>, <argument><expr><name>reachedStatusName</name></expr></argument>, <argument><expr><name>desiredStatusName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* job has reached its terminal state, done waiting */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* sleep for a while, before rechecking the job status */</comment>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>long</name></type> <name>delay_ms</name> <init>= <expr><literal type="number">1000</literal></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>WaitLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>,
						 <argument><expr><name>WL_LATCH_SET</name> <operator>|</operator> <name>WL_TIMEOUT</name> <operator>|</operator> <name>WL_EXIT_ON_PM_DEATH</name></expr></argument>,
						 <argument><expr><name>delay_ms</name></expr></argument>,
						 <argument><expr><name>WAIT_EVENT_PG_SLEEP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>waitContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * StartCitusBackgroundTaskQueueMonitor spawns a new background worker connected to the
 * current database and owner. This background worker consumes the tasks that are ready
 * for execution.
 */</comment>
<function><type><name>BackgroundWorkerHandle</name> <modifier>*</modifier></type>
<name>StartCitusBackgroundTaskQueueMonitor</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>database</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>extensionOwner</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BackgroundWorker</name></type> <name>worker</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BackgroundWorkerHandle</name> <modifier>*</modifier></type><name>handle</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Configure a worker. */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>worker</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>worker</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SafeSnprintf</name><argument_list>(<argument><expr><name><name>worker</name><operator>.</operator><name>bgw_name</name></name></expr></argument>, <argument><expr><name>BGW_MAXLEN</name></expr></argument>,
				 <argument><expr><literal type="string">"Citus Background Task Queue Monitor: %u/%u"</literal></expr></argument>,
				 <argument><expr><name>database</name></expr></argument>, <argument><expr><name>extensionOwner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>worker</name><operator>.</operator><name>bgw_flags</name></name> <operator>=</operator>
		<name>BGWORKER_SHMEM_ACCESS</name> <operator>|</operator> <name>BGWORKER_BACKEND_DATABASE_CONNECTION</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>worker</name><operator>.</operator><name>bgw_start_time</name></name> <operator>=</operator> <name>BgWorkerStart_ConsistentState</name></expr>;</expr_stmt>

	<comment type="block">/* don't restart, we manage restarts from maintenance daemon */</comment>
	<expr_stmt><expr><name><name>worker</name><operator>.</operator><name>bgw_restart_time</name></name> <operator>=</operator> <name>BGW_NEVER_RESTART</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strcpy_s</name><argument_list>(<argument><expr><name><name>worker</name><operator>.</operator><name>bgw_library_name</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>worker</name><operator>.</operator><name>bgw_library_name</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"citus"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strcpy_s</name><argument_list>(<argument><expr><name><name>worker</name><operator>.</operator><name>bgw_function_name</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>worker</name><operator>.</operator><name>bgw_library_name</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,
			 <argument><expr><literal type="string">"CitusBackgroundTaskQueueMonitorMain"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>worker</name><operator>.</operator><name>bgw_main_arg</name></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy_s</name><argument_list>(<argument><expr><name><name>worker</name><operator>.</operator><name>bgw_extra</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>worker</name><operator>.</operator><name>bgw_extra</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>extensionOwner</name></expr></argument>,
			 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>worker</name><operator>.</operator><name>bgw_notify_pid</name></name> <operator>=</operator> <name>MyProcPid</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RegisterDynamicBackgroundWorker</name><argument_list>(<argument><expr><operator>&amp;</operator><name>worker</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>handle</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>pid_t</name></type> <name>pid</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>WaitForBackgroundWorkerStartup</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>handle</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * context for any log/error messages emitted from the background task queue monitor.
 */</comment>
<typedef>typedef <type><struct>struct <name>CitusBackgroundTaskQueueMonitorErrorCallbackContext</name>
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>database</name></decl>;</decl_stmt>
}</block></struct></type> <name>CitusBackgroundTaskQueueMonitorCallbackContext</name>;</typedef>


<comment type="block">/*
 * CitusBackgroundTaskQueueMonitorErrorCallback is a callback handler that gets called for
 * any ereport to add extra context to the message.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CitusBackgroundTaskQueueMonitorErrorCallback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CitusBackgroundTaskQueueMonitorCallbackContext</name> <modifier>*</modifier></type><name>context</name> <init>=
		<expr><operator>(</operator><name>CitusBackgroundTaskQueueMonitorCallbackContext</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"Citus Background Task Queue Monitor: %s"</literal></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>database</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * NewExecutorExceedsCitusLimit returns true if currently we reached Citus' max worker count.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>NewExecutorExceedsCitusLimit</name><parameter_list>(<parameter><decl><type><name>QueueMonitorExecutionContext</name> <modifier>*</modifier></type><name>queueMonitorExecutionContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>queueMonitorExecutionContext</name><operator>-&gt;</operator><name>currentExecutorCount</name></name> <operator>&gt;=</operator> <name>MaxBackgroundTaskExecutors</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * we hit to Citus' maximum task executor count. Warn for the first failure
		 * after a successful worker allocation happened, that is, we do not warn if
		 * we repeatedly come here without a successful worker allocation.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>queueMonitorExecutionContext</name><operator>-&gt;</operator><name>backgroundWorkerFailedStartTime</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unable to start background worker for "</literal>
									 <literal type="string">"background task execution"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							  <call><name>errdetail</name><argument_list>(
								  <argument><expr><literal type="string">"Already reached the maximum number of task "</literal>
								  <literal type="string">"executors: %ld/%d"</literal></expr></argument>,
								  <argument><expr><name><name>queueMonitorExecutionContext</name><operator>-&gt;</operator><name>currentExecutorCount</name></name></expr></argument>,
								  <argument><expr><name>MaxBackgroundTaskExecutors</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>queueMonitorExecutionContext</name><operator>-&gt;</operator><name>backgroundWorkerFailedStartTime</name></name> <operator>=</operator>
				<call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * NewExecutorExceedsPgMaxWorkers returns true if currently we reached Postgres' max worker count.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>NewExecutorExceedsPgMaxWorkers</name><parameter_list>(<parameter><decl><type><name>BackgroundWorkerHandle</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>,
							   <parameter><decl><type><name>QueueMonitorExecutionContext</name> <modifier>*</modifier></type><name>queueMonitorExecutionContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>handle</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * we are unable to start a background worker for the task execution.
		 * Probably we are out of background workers. Warn for the first failure
		 * after a successful worker allocation happened, that is, we do not warn if
		 * we repeatedly come here without a successful worker allocation.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>queueMonitorExecutionContext</name><operator>-&gt;</operator><name>backgroundWorkerFailedStartTime</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unable to start background worker for "</literal>
									 <literal type="string">"background task execution"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							  <call><name>errdetail</name><argument_list>(
								  <argument><expr><literal type="string">"Current number of task "</literal>
								  <literal type="string">"executors: %ld/%d"</literal></expr></argument>,
								  <argument><expr><name><name>queueMonitorExecutionContext</name><operator>-&gt;</operator><name>currentExecutorCount</name></name></expr></argument>,
								  <argument><expr><name>MaxBackgroundTaskExecutors</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>queueMonitorExecutionContext</name><operator>-&gt;</operator><name>backgroundWorkerFailedStartTime</name></name> <operator>=</operator>
				<call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AssignRunnableTaskToNewExecutor tries to assign given runnable task to a new task executor.
 * It reports the assignment status as return value.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>AssignRunnableTaskToNewExecutor</name><parameter_list>(<parameter><decl><type><name>BackgroundTask</name> <modifier>*</modifier></type><name>runnableTask</name></decl></parameter>,
								<parameter><decl><type><name>QueueMonitorExecutionContext</name> <modifier>*</modifier></type><name>queueMonitorExecutionContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>runnableTask</name> <operator>&amp;&amp;</operator> <name><name>runnableTask</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>BACKGROUND_TASK_STATUS_RUNNABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>NewExecutorExceedsCitusLimit</name><argument_list>(<argument><expr><name>queueMonitorExecutionContext</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* escape if we hit citus executor limit */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>databaseName</name> <init>= <expr><call><name>get_database_name</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>userName</name> <init>= <expr><call><name>GetUserNameFromId</name><argument_list>(<argument><expr><name><name>runnableTask</name><operator>-&gt;</operator><name>owner</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* try to create new executor and make it alive during queue monitor lifetime */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>queueMonitorExecutionContext</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dsm_segment</name> <modifier>*</modifier></type><name>seg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BackgroundWorkerHandle</name> <modifier>*</modifier></type><name>handle</name> <init>=
		<expr><call><name>StartCitusBackgroundTaskExecutor</name><argument_list>(<argument><expr><name>databaseName</name></expr></argument>, <argument><expr><name>userName</name></expr></argument>, <argument><expr><name><name>runnableTask</name><operator>-&gt;</operator><name>command</name></name></expr></argument>,
										 <argument><expr><name><name>runnableTask</name><operator>-&gt;</operator><name>taskid</name></name></expr></argument>, <argument><expr><name><name>runnableTask</name><operator>-&gt;</operator><name>jobid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>seg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>NewExecutorExceedsPgMaxWorkers</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>queueMonitorExecutionContext</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* escape if we hit pg worker limit */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* assign the allocated executor to the runnable task and increment total executor count */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>handleEntryFound</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BackgroundExecutorHashEntry</name> <modifier>*</modifier></type><name>handleEntry</name> <init>= <expr><call><name>hash_search</name><argument_list>(
		<argument><expr><name><name>queueMonitorExecutionContext</name><operator>-&gt;</operator><name>currentExecutors</name></name></expr></argument>,
		<argument><expr><operator>&amp;</operator><name><name>runnableTask</name><operator>-&gt;</operator><name>taskid</name></name></expr></argument>,
		<argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>handleEntryFound</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>handleEntryFound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>handleEntry</name><operator>-&gt;</operator><name>handle</name></name> <operator>=</operator> <name>handle</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>handleEntry</name><operator>-&gt;</operator><name>seg</name></name> <operator>=</operator> <name>seg</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>handleEntry</name><operator>-&gt;</operator><name>jobid</name></name> <operator>=</operator> <name><name>runnableTask</name><operator>-&gt;</operator><name>jobid</name></name></expr>;</expr_stmt>

	<comment type="block">/* reset worker allocation timestamp and log time elapsed since the last failure */</comment>
	<expr_stmt><expr><call><name>CheckAndResetLastWorkerAllocationFailure</name><argument_list>(<argument><expr><name>queueMonitorExecutionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* make message alive during queue monitor lifetime */</comment>
	<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>queueMonitorExecutionContext</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>handleEntry</name><operator>-&gt;</operator><name>message</name></name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* set runnable task's status as running */</comment>
	<expr_stmt><expr><name><name>runnableTask</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>BACKGROUND_TASK_STATUS_RUNNING</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UpdateBackgroundTask</name><argument_list>(<argument><expr><name>runnableTask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UpdateBackgroundJob</name><argument_list>(<argument><expr><name><name>runnableTask</name><operator>-&gt;</operator><name>jobid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>queueMonitorExecutionContext</name><operator>-&gt;</operator><name>currentExecutorCount</name></name><operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"task jobid/taskid started: %ld/%ld"</literal></expr></argument>,
						 <argument><expr><name><name>runnableTask</name><operator>-&gt;</operator><name>jobid</name></name></expr></argument>, <argument><expr><name><name>runnableTask</name><operator>-&gt;</operator><name>taskid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AssignRunnableTasks tries to assign all runnable tasks to a new task executor.
 * If an assignment fails, it stops in case we hit some limitation. We do not load
 * all the runnable tasks in memory at once as it can load memory much + we have
 * limited worker to which we can assign task.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AssignRunnableTasks</name><parameter_list>(<parameter><decl><type><name>QueueMonitorExecutionContext</name> <modifier>*</modifier></type><name>queueMonitorExecutionContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BackgroundTask</name> <modifier>*</modifier></type><name>runnableTask</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>taskAssigned</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<do>do <block>{<block_content>
		<comment type="block">/* fetch a runnable task from catalog */</comment>
		<expr_stmt><expr><name>runnableTask</name> <operator>=</operator> <call><name>GetRunnableBackgroundTask</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>runnableTask</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>taskAssigned</name> <operator>=</operator> <call><name>AssignRunnableTaskToNewExecutor</name><argument_list>(<argument><expr><name>runnableTask</name></expr></argument>,
														   <argument><expr><name>queueMonitorExecutionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>taskAssigned</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block> while <condition>(<expr><name>taskAssigned</name></expr>)</condition>;</do>
</block_content>}</block></function>


<comment type="block">/*
 * GetRunningTaskEntries returns list of BackgroundExecutorHashEntry from given hash table
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>GetRunningTaskEntries</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>currentExecutors</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>runningTaskEntries</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BackgroundExecutorHashEntry</name> <modifier>*</modifier></type><name>backgroundExecutorHashEntry</name></decl>;</decl_stmt>
	<macro><name>foreach_htab</name><argument_list>(<argument>backgroundExecutorHashEntry</argument>, <argument>&amp;status</argument>, <argument>currentExecutors</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>runningTaskEntries</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>runningTaskEntries</name></expr></argument>, <argument><expr><name>backgroundExecutorHashEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>runningTaskEntries</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CheckAndResetLastWorkerAllocationFailure checks the last time background worker allocation
 * is failed. If it is set, we print how long we have waited to successfully allocate the worker.
 * It also resets the failure timestamp.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CheckAndResetLastWorkerAllocationFailure</name><parameter_list>(
	<parameter><decl><type><name>QueueMonitorExecutionContext</name> <modifier>*</modifier></type><name>queueMonitorExecutionContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>queueMonitorExecutionContext</name><operator>-&gt;</operator><name>backgroundWorkerFailedStartTime</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * we had a delay in starting the background worker for task execution. Report
		 * the actual delay and reset the time. This allows a subsequent task to
		 * report again if it can't start a background worker directly.
		 */</comment>
		<decl_stmt><decl><type><name>long</name></type> <name>secs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>microsecs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>TimestampDifference</name><argument_list>(
			<argument><expr><name><name>queueMonitorExecutionContext</name><operator>-&gt;</operator>
			<name>backgroundWorkerFailedStartTime</name></name></expr></argument>,
			<argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>,
			<argument><expr><operator>&amp;</operator><name>secs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>microsecs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
						  <argument><expr><literal type="string">"able to start a background worker with %ld seconds "</literal>
						  <literal type="string">"delay"</literal></expr></argument>, <argument><expr><name>secs</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>queueMonitorExecutionContext</name><operator>-&gt;</operator><name>backgroundWorkerFailedStartTime</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * TaskConcurrentCancelCheck checks if concurrent task cancellation or removal happened by
 * taking Exclusive lock. It mutates task's pid and status. Returns execution status for the
 * task.
 */</comment>
<function><type><specifier>static</specifier> <name>TaskExecutionStatus</name></type>
<name>TaskConcurrentCancelCheck</name><parameter_list>(<parameter><decl><type><name>TaskExecutionContext</name> <modifier>*</modifier></type><name>taskExecutionContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * here we take exclusive lock on pg_dist_background_task table to prevent a
	 * concurrent modification. A separate process could have cancelled or removed
	 * the task by now, they would not see the pid and status update, so it is our
	 * responsibility to stop the backend and update the pid and status.
	 *
	 * The lock will release on transaction commit.
	 */</comment>
	<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><call><name>DistBackgroundTaskRelationId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>BackgroundExecutorHashEntry</name> <modifier>*</modifier></type><name>handleEntry</name> <init>= <expr><name><name>taskExecutionContext</name><operator>-&gt;</operator><name>handleEntry</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BackgroundTask</name> <modifier>*</modifier></type><name>task</name> <init>= <expr><call><name>GetBackgroundTaskByTaskId</name><argument_list>(<argument><expr><name><name>handleEntry</name><operator>-&gt;</operator><name>taskid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>taskExecutionContext</name><operator>-&gt;</operator><name>task</name></name> <operator>=</operator> <name>task</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>task</name> <operator>||</operator> <name><name>task</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>BACKGROUND_TASK_STATUS_CANCELLING</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * being in that step means that a concurrent cancel or removal happened. we should
		 * mark task status as cancelled. We also want to reflect cancel message by consuming
		 * task executor queue.
		 */</comment>
		<decl_stmt><decl><type><name>bool</name></type> <name>hadError</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ReadFromExecutorQueue</name><argument_list>(<argument><expr><name>handleEntry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hadError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
						  <argument><expr><literal type="string">"task jobid/taskid is cancelled: %ld/%ld"</literal></expr></argument>,
						  <argument><expr><name><name>task</name><operator>-&gt;</operator><name>jobid</name></name></expr></argument>, <argument><expr><name><name>task</name><operator>-&gt;</operator><name>taskid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>BACKGROUND_TASK_STATUS_CANCELLED</name></expr>;</expr_stmt>

		<return>return <expr><name>TASK_EXECUTION_STATUS_CANCELLED</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * now that we have verified the task has not been cancelled and still exist we
		 * update it to reflect the new state. If task is already in running status,
		 * the operation is idempotent. But for runnable tasks, we make their status
		 * as running.
		 */</comment>

		<decl_stmt><decl><type><name>pid_t</name></type> <name>pid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>GetBackgroundWorkerPid</name><argument_list>(<argument><expr><name><name>handleEntry</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>BACKGROUND_TASK_STATUS_RUNNING</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SET_NULLABLE_FIELD</name><argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Update task status to indicate it is running */</comment>
		<expr_stmt><expr><call><name>UpdateBackgroundTask</name><argument_list>(<argument><expr><name>task</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>UpdateBackgroundJob</name><argument_list>(<argument><expr><name><name>task</name><operator>-&gt;</operator><name>jobid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>TASK_EXECUTION_STATUS_RUNNING</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ConsumeExecutorQueue consumes executor's shared memory queue and returns execution status
 * for the task.
 */</comment>
<function><type><specifier>static</specifier> <name>TaskExecutionStatus</name></type>
<name>ConsumeExecutorQueue</name><parameter_list>(<parameter><decl><type><name>TaskExecutionContext</name> <modifier>*</modifier></type><name>taskExecutionContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BackgroundExecutorHashEntry</name> <modifier>*</modifier></type><name>handleEntry</name> <init>= <expr><name><name>taskExecutionContext</name><operator>-&gt;</operator><name>handleEntry</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BackgroundTask</name> <modifier>*</modifier></type><name>task</name> <init>= <expr><name><name>taskExecutionContext</name><operator>-&gt;</operator><name>task</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * we consume task executor response queue.
	 * possible response codes can lead us different steps below.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>hadError</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>shm_mq_result</name></type> <name>mq_res</name> <init>= <expr><call><name>ReadFromExecutorQueue</name><argument_list>(<argument><expr><name>handleEntry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hadError</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>hadError</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"task jobid/taskid failed: %ld/%ld"</literal></expr></argument>,
							 <argument><expr><name><name>task</name><operator>-&gt;</operator><name>jobid</name></name></expr></argument>, <argument><expr><name><name>task</name><operator>-&gt;</operator><name>taskid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>TASK_EXECUTION_STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>mq_res</name> <operator>==</operator> <name>SHM_MQ_DETACHED</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"task jobid/taskid succeeded: %ld/%ld"</literal></expr></argument>,
							 <argument><expr><name><name>task</name><operator>-&gt;</operator><name>jobid</name></name></expr></argument>, <argument><expr><name><name>task</name><operator>-&gt;</operator><name>taskid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* update task status as done. */</comment>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>BACKGROUND_TASK_STATUS_DONE</name></expr>;</expr_stmt>

		<return>return <expr><name>TASK_EXECUTION_STATUS_SUCCESS</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* still running the task */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>mq_res</name> <operator>==</operator> <name>SHM_MQ_WOULD_BLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>TASK_EXECUTION_STATUS_WOULDBLOCK</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * TaskHadError updates retry count of a failed task inside taskExecutionContext.
 * If maximum retry count is reached, task status is marked as failed. Otherwise, backoff
 * delay is calculated, notBefore time is updated and the task is marked as runnable.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>TaskHadError</name><parameter_list>(<parameter><decl><type><name>TaskExecutionContext</name> <modifier>*</modifier></type><name>taskExecutionContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BackgroundTask</name> <modifier>*</modifier></type><name>task</name> <init>= <expr><name><name>taskExecutionContext</name><operator>-&gt;</operator><name>task</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * when we had an error in response queue, we need to decide if we want to retry (keep the
	 * runnable state), or move to error state
	 */</comment>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>task</name><operator>-&gt;</operator><name>retry_count</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SET_NULLABLE_FIELD</name><argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><name>retry_count</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><operator>(</operator><operator>*</operator><name><name>task</name><operator>-&gt;</operator><name>retry_count</name></name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * based on the retry count we either transition the task to its error
	 * state, or we calculate a new backoff time for future execution.
	 */</comment>
	<decl_stmt><decl><type><name>int64</name></type> <name>delayMs</name> <init>= <expr><call><name>CalculateBackoffDelay</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name><name>task</name><operator>-&gt;</operator><name>retry_count</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>delayMs</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>BACKGROUND_TASK_STATUS_ERROR</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>UNSET_NULLABLE_FIELD</name><argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><name>not_before</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>TimestampTz</name></type> <name>notBefore</name> <init>= <expr><call><name>TimestampTzPlusMilliseconds</name><argument_list>(
			<argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>delayMs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>SET_NULLABLE_FIELD</name><argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><name>not_before</name></expr></argument>, <argument><expr><name>notBefore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>BACKGROUND_TASK_STATUS_RUNNABLE</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>TaskEnded</name><argument_list>(<argument><expr><name>taskExecutionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * TaskEnded updates task inside taskExecutionContext. It also updates depending
 * tasks and the job to which task belongs. At the end, it also updates executor map and
 * count inside queueMonitorExecutionContext after terminating the executor.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>TaskEnded</name><parameter_list>(<parameter><decl><type><name>TaskExecutionContext</name> <modifier>*</modifier></type><name>taskExecutionContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>QueueMonitorExecutionContext</name> <modifier>*</modifier></type><name>queueMonitorExecutionContext</name> <init>=
		<expr><name><name>taskExecutionContext</name><operator>-&gt;</operator><name>queueMonitorExecutionContext</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>currentExecutors</name> <init>= <expr><name><name>queueMonitorExecutionContext</name><operator>-&gt;</operator><name>currentExecutors</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BackgroundExecutorHashEntry</name> <modifier>*</modifier></type><name>handleEntry</name> <init>= <expr><name><name>taskExecutionContext</name><operator>-&gt;</operator><name>handleEntry</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BackgroundTask</name> <modifier>*</modifier></type><name>task</name> <init>= <expr><name><name>taskExecutionContext</name><operator>-&gt;</operator><name>task</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * we update task and job fields. We also update depending jobs.
	 * At the end, do cleanup.
	 */</comment>
	<expr_stmt><expr><call><name>UNSET_NULLABLE_FIELD</name><argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>message</name></name> <operator>=</operator> <name><name>handleEntry</name><operator>-&gt;</operator><name>message</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>UpdateBackgroundTask</name><argument_list>(<argument><expr><name>task</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UpdateDependingTasks</name><argument_list>(<argument><expr><name>task</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UpdateBackgroundJob</name><argument_list>(<argument><expr><name><name>task</name><operator>-&gt;</operator><name>jobid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* we are sure that at least one task did not block on current iteration */</comment>
	<expr_stmt><expr><name><name>queueMonitorExecutionContext</name><operator>-&gt;</operator><name>allTasksWouldBlock</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name>currentExecutors</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>task</name><operator>-&gt;</operator><name>taskid</name></name></expr></argument>,
				<argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TerminateBackgroundWorker</name><argument_list>(<argument><expr><name><name>handleEntry</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>dsm_detach</name><argument_list>(<argument><expr><name><name>handleEntry</name><operator>-&gt;</operator><name>seg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>queueMonitorExecutionContext</name><operator>-&gt;</operator><name>currentExecutorCount</name></name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * QueueMonitorSigHupHandler handles SIGHUP to update monitor related config params.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>QueueMonitorSigHupHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>saved_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>GotSighup</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>MyProc</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>procLatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>saved_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * MonitorGotTerminationOrCancellationRequest returns true if monitor had SIGTERM or SIGINT signals
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>MonitorGotTerminationOrCancellationRequest</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<return>return <expr><name>GotSigterm</name> <operator>||</operator> <name>GotSigint</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * QueueMonitorSigTermHandler handles SIGTERM by setting a flag to inform the monitor process
 * so that it can terminate active task executors properly. It also sets the latch to awake the
 * monitor if it waits on it.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>QueueMonitorSigTermHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>saved_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>GotSigterm</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>MyProc</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>procLatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>saved_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * QueueMonitorSigIntHandler handles SIGINT by setting a flag to inform the monitor process
 * so that it can terminate active task executors properly. It also sets the latch to awake the
 * monitor if it waits on it.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>QueueMonitorSigIntHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>saved_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>GotSigint</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>MyProc</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>procLatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>saved_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * TerminateAllTaskExecutors terminates task executors given in the hash map.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>TerminateAllTaskExecutors</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>currentExecutors</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BackgroundExecutorHashEntry</name> <modifier>*</modifier></type><name>backgroundExecutorHashEntry</name></decl>;</decl_stmt>
	<macro><name>foreach_htab</name><argument_list>(<argument>backgroundExecutorHashEntry</argument>, <argument>&amp;status</argument>, <argument>currentExecutors</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>TerminateBackgroundWorker</name><argument_list>(<argument><expr><name><name>backgroundExecutorHashEntry</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * GetRunningUniqueJobIds returns unique job ids from currentExecutors
 */</comment>
<function><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type>
<name>GetRunningUniqueJobIds</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>currentExecutors</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* create a set to store unique job ids for currently executing tasks */</comment>
	<decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>uniqueJobIds</name> <init>= <expr><call><name>CreateSimpleHashSetWithSize</name><argument_list>(<argument><expr><name>int64</name></expr></argument>, <argument><expr><name>MAX_BG_TASK_EXECUTORS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BackgroundExecutorHashEntry</name> <modifier>*</modifier></type><name>backgroundExecutorHashEntry</name></decl>;</decl_stmt>
	<macro><name>foreach_htab</name><argument_list>(<argument>backgroundExecutorHashEntry</argument>, <argument>&amp;status</argument>, <argument>currentExecutors</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name>uniqueJobIds</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>backgroundExecutorHashEntry</name><operator>-&gt;</operator><name>jobid</name></name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>uniqueJobIds</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CancelAllTaskExecutors cancels task executors given in the hash map.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CancelAllTaskExecutors</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>currentExecutors</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* get unique job id set for running tasks in currentExecutors */</comment>
	<decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>uniqueJobIds</name> <init>= <expr><call><name>GetRunningUniqueJobIds</name><argument_list>(<argument><expr><name>currentExecutors</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name> <modifier>*</modifier></type><name>uniqueJobId</name></decl>;</decl_stmt>
	<macro><name>foreach_htab</name><argument_list>(<argument>uniqueJobId</argument>, <argument>&amp;status</argument>, <argument>uniqueJobIds</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cancelling job: %ld"</literal></expr></argument>, <argument><expr><operator>*</operator><name>uniqueJobId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>Datum</name></type> <name>jobidDatum</name> <init>= <expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><operator>*</operator><name>uniqueJobId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>citus_job_cancel</name></expr></argument>, <argument><expr><name>jobidDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CitusBackgroundTaskQueueMonitorMain is the main entry point for the background worker
 * running the background tasks queue monitor.
 *
 * It's mainloop reads a runnable task from pg_dist_background_task and progressing the
 * tasks and jobs state machines associated with the task. When no new task can be found
 * it will exit(0) and lets the maintenance daemon poll for new tasks.
 *
 * The main loop is implemented as asynchronous loop stepping through the task
 * and update its state before going to the next. Loop assigns runnable tasks to new task
 * executors as much as possible. If the max task executor limit is hit, the tasks will be
 * waiting in runnable status until currently running tasks finish. Each parallel worker
 * executes one task at a time without blocking each other by using nonblocking api.
 */</comment>
<function><type><name>void</name></type>
<name>CitusBackgroundTaskQueueMonitorMain</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* handle SIGTERM to properly terminate active task executors */</comment>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>, <argument><expr><name>QueueMonitorSigTermHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* handle SIGINT to properly cancel active task executors */</comment>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>, <argument><expr><name>QueueMonitorSigIntHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* handle SIGHUP to update MaxBackgroundTaskExecutors */</comment>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGHUP</name></expr></argument>, <argument><expr><name>QueueMonitorSigHupHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* ready to handle signals */</comment>
	<expr_stmt><expr><call><name>BackgroundWorkerUnblockSignals</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>databaseOid</name> <init>= <expr><call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* extension owner is passed via bgw_extra */</comment>
	<decl_stmt><decl><type><name>Oid</name></type> <name>extensionOwner</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>memcpy_s</name><argument_list>(<argument><expr><operator>&amp;</operator><name>extensionOwner</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>extensionOwner</name></expr></argument>)</argument_list></sizeof></expr></argument>,
			 <argument><expr><name><name>MyBgworkerEntry</name><operator>-&gt;</operator><name>bgw_extra</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* connect to database, after that we can actually access catalogs */</comment>
	<expr_stmt><expr><call><name>BackgroundWorkerInitializeConnectionByOid</name><argument_list>(<argument><expr><name>databaseOid</name></expr></argument>, <argument><expr><name>extensionOwner</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * save old context until monitor loop exits, we use backgroundTaskContext for
	 * all allocations.
	 */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>firstContext</name> <init>= <expr><name>CurrentMemoryContext</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>backgroundTaskContext</name> <init>= <expr><call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
																<argument><expr><literal type="string">"BackgroundTaskContext"</literal></expr></argument>,
																<argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>databasename</name> <init>= <expr><call><name>get_database_name</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* make databasename alive during queue monitor lifetime */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>backgroundTaskContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>databasename</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>databasename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* setup error context to indicate the errors came from a running background task */</comment>
	<decl_stmt><decl><type><name>ErrorContextCallback</name></type> <name>errorCallback</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>CitusBackgroundTaskQueueMonitorErrorCallbackContext</name></name></type> <name>context</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>database</name> <operator>=</operator> <name>databasename</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>errorCallback</name><operator>.</operator><name>callback</name></name> <operator>=</operator> <name>CitusBackgroundTaskQueueMonitorErrorCallback</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errorCallback</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>context</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errorCallback</name><operator>.</operator><name>previous</name></name> <operator>=</operator> <name>error_context_stack</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <operator>&amp;</operator><name>errorCallback</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * There should be exactly one background task monitor running, running multiple would
	 * cause conflicts on processing the tasks in the catalog table as well as violate
	 * parallelism guarantees. To make sure there is at most, exactly one backend running
	 * we take a session lock on the CITUS_BACKGROUND_TASK_MONITOR operation.
	 */</comment>
	<decl_stmt><decl><type><name>LOCKTAG</name></type> <name>tag</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>SET_LOCKTAG_CITUS_OPERATION</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>CITUS_BACKGROUND_TASK_MONITOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>sessionLock</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>dontWait</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LockAcquireResult</name></type> <name>locked</name> <init>=
		<expr><call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>, <argument><expr><name>sessionLock</name></expr></argument>, <argument><expr><name>dontWait</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>locked</name> <operator>==</operator> <name>LOCKACQUIRE_NOT_AVAIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"background task queue monitor already running for "</literal>
							   <literal type="string">"database"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* make worker recognizable in pg_stat_activity */</comment>
	<expr_stmt><expr><call><name>pgstat_report_appname</name><argument_list>(<argument><expr><literal type="string">"citus background task queue monitor"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"started citus background task queue monitor"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * First we find all jobs that are running, we need to check if they are still running
	 * if not reset their state back to scheduled.
	 */</comment>
	<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ResetRunningBackgroundTasks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* create a map to store parallel task executors. Persist it in monitor memory context */</comment>
	<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>backgroundTaskContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>currentExecutors</name> <init>= <expr><call><name>CreateSimpleHashWithNameAndSize</name><argument_list>(<argument><expr><name>int64</name></expr></argument>,
															 <argument><expr><name>BackgroundExecutorHashEntry</name></expr></argument>,
															 <argument><expr><literal type="string">"Background Executor Hash"</literal></expr></argument>,
															 <argument><expr><name>MAX_BG_TASK_EXECUTORS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * monitor execution context that is useful during the monitor loop.
	 * we store current executor count, last background failure timestamp,
	 * currently executed task context and also a memory context to persist
	 * some allocations throughout the loop.
	 */</comment>
	<decl_stmt><decl><type><name>QueueMonitorExecutionContext</name></type> <name>queueMonitorExecutionContext</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>currentExecutorCount</name> <operator>=</operator> <literal type="number">0</literal></expr>,
		<expr><operator>.</operator><name>backgroundWorkerFailedStartTime</name> <operator>=</operator> <literal type="number">0</literal></expr>,
		<expr><operator>.</operator><name>allTasksWouldBlock</name> <operator>=</operator> <name>true</name></expr>,
		<expr><operator>.</operator><name>currentExecutors</name> <operator>=</operator> <name>currentExecutors</name></expr>,
		<expr><operator>.</operator><name>ctx</name> <operator>=</operator> <name>backgroundTaskContext</name></expr>
	}</block></expr></init></decl>;</decl_stmt>

	<comment type="block">/* flag to prevent duplicate termination and cancellation of task executors */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>terminateExecutorsStarted</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>cancelExecutorsStarted</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* loop exits if there is no running or runnable tasks left */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>hasAnyTask</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><name>hasAnyTask</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* handle signals */</comment>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * if the flag is set, we should terminate all task executor workers to prevent duplicate
		 * runs of the same task on the next start of the monitor, which is dangerous for non-idempotent
		 * tasks. We do not break the loop here as we want to reflect tasks' messages. Hence, we wait until
		 * all tasks finish and also do not allow new runnable tasks to start running. After all current tasks
		 * finish, we can exit the loop safely.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>GotSigterm</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>terminateExecutorsStarted</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"handling termination signal"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>terminateExecutorsStarted</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>TerminateAllTaskExecutors</name><argument_list>(<argument><expr><name><name>queueMonitorExecutionContext</name><operator>.</operator><name>currentExecutors</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>GotSigint</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>cancelExecutorsStarted</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"handling cancellation signal"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>cancelExecutorsStarted</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CancelAllTaskExecutors</name><argument_list>(<argument><expr><name><name>queueMonitorExecutionContext</name><operator>.</operator><name>currentExecutors</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>GotSighup</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>GotSighup</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<comment type="block">/* update max_background_task_executors if changed */</comment>
			<expr_stmt><expr><call><name>ProcessConfigFile</name><argument_list>(<argument><expr><name>PGC_SIGHUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* invalidate cache for new data in catalog */</comment>
		<expr_stmt><expr><call><name>InvalidateMetadataSystemCache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* assign runnable tasks, if any, to new task executors in a transaction if we do not have SIGTERM or SIGINT */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MonitorGotTerminationOrCancellationRequest</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>AssignRunnableTasks</name><argument_list>(<argument><expr><operator>&amp;</operator><name>queueMonitorExecutionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* get running task entries from hash table */</comment>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>runningTaskEntries</name> <init>= <expr><call><name>GetRunningTaskEntries</name><argument_list>(
			<argument><expr><name><name>queueMonitorExecutionContext</name><operator>.</operator><name>currentExecutors</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>hasAnyTask</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>runningTaskEntries</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<comment type="block">/* useful to sleep if all tasks ewouldblock on current iteration */</comment>
		<expr_stmt><expr><name><name>queueMonitorExecutionContext</name><operator>.</operator><name>allTasksWouldBlock</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="block">/* monitor executors inside transaction */</comment>
		<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* iterate over all handle entries and monitor each task's output */</comment>
		<decl_stmt><decl><type><name>BackgroundExecutorHashEntry</name> <modifier>*</modifier></type><name>handleEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>handleEntry</argument>, <argument>runningTaskEntries</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/* create task execution context and assign it to queueMonitorExecutionContext */</comment>
			<decl_stmt><decl><type><name>TaskExecutionContext</name></type> <name>taskExecutionContext</name> <init>= <expr><block>{
				<expr><operator>.</operator><name>queueMonitorExecutionContext</name> <operator>=</operator> <operator>&amp;</operator><name>queueMonitorExecutionContext</name></expr>,
				<expr><operator>.</operator><name>handleEntry</name> <operator>=</operator> <name>handleEntry</name></expr>,
				<expr><operator>.</operator><name>task</name> <operator>=</operator> <name>NULL</name></expr>
			}</block></expr></init></decl>;</decl_stmt>

			<comment type="block">/* check if concurrent cancellation occurred */</comment>
			<decl_stmt><decl><type><name>TaskExecutionStatus</name></type> <name>taskExecutionStatus</name> <init>= <expr><call><name>TaskConcurrentCancelCheck</name><argument_list>(
				<argument><expr><operator>&amp;</operator><name>taskExecutionContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * check task status. If it is cancelled, we do not need to consume queue
			 * as we already consumed the queue.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>taskExecutionStatus</name> <operator>==</operator> <name>TASK_EXECUTION_STATUS_CANCELLED</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>TaskEnded</name><argument_list>(<argument><expr><operator>&amp;</operator><name>taskExecutionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>taskExecutionStatus</name> <operator>=</operator> <call><name>ConsumeExecutorQueue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>taskExecutionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>taskExecutionStatus</name> <operator>==</operator> <name>TASK_EXECUTION_STATUS_ERROR</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>TaskHadError</name><argument_list>(<argument><expr><operator>&amp;</operator><name>taskExecutionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>taskExecutionStatus</name> <operator>==</operator> <name>TASK_EXECUTION_STATUS_SUCCESS</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>TaskEnded</name><argument_list>(<argument><expr><operator>&amp;</operator><name>taskExecutionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>queueMonitorExecutionContext</name><operator>.</operator><name>allTasksWouldBlock</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * sleep to lower cpu consumption if all tasks responded with EWOULD_BLOCK on the last iteration.
			 * That will also let those tasks to progress to generate some output probably.
			 */</comment>
			<decl_stmt><decl><type><specifier>const</specifier> <name>long</name></type> <name>delay_ms</name> <init>= <expr><literal type="number">1000</literal></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>WaitLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>, <argument><expr><name>WL_LATCH_SET</name> <operator>|</operator> <name>WL_TIMEOUT</name> <operator>|</operator>
							 <name>WL_EXIT_ON_PM_DEATH</name></expr></argument>,
							 <argument><expr><name>delay_ms</name></expr></argument>, <argument><expr><name>WAIT_EVENT_PG_SLEEP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>firstContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>backgroundTaskContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ReadFromExecutorQueue reads from task executor's response queue into the message.
 * It also sets hadError flag if an error response is encountered in the queue.
 */</comment>
<function><type><specifier>static</specifier> <name>shm_mq_result</name></type>
<name>ReadFromExecutorQueue</name><parameter_list>(<parameter><decl><type><name>BackgroundExecutorHashEntry</name> <modifier>*</modifier></type><name>backgroundExecutorHashEntry</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>hadError</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dsm_segment</name> <modifier>*</modifier></type><name>seg</name> <init>= <expr><name><name>backgroundExecutorHashEntry</name><operator>-&gt;</operator><name>seg</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>shm_toc</name> <modifier>*</modifier></type><name>toc</name> <init>= <expr><call><name>shm_toc_attach</name><argument_list>(<argument><expr><name>CITUS_BACKGROUND_TASK_MAGIC</name></expr></argument>,
								  <argument><expr><call><name>dsm_segment_address</name><argument_list>(<argument><expr><name>seg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>shm_mq</name> <modifier>*</modifier></type><name>mq</name> <init>= <expr><call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>CITUS_BACKGROUND_TASK_KEY_QUEUE</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>shm_mq_handle</name> <modifier>*</modifier></type><name>responseq</name> <init>= <expr><call><name>shm_mq_attach</name><argument_list>(<argument><expr><name>mq</name></expr></argument>, <argument><expr><name>seg</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Consume background executor's queue and get a response code.
	 */</comment>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>message</name> <init>= <expr><name><name>backgroundExecutorHashEntry</name><operator>-&gt;</operator><name>message</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>shm_mq_result</name></type> <name>mq_res</name> <init>= <expr><call><name>ConsumeTaskWorkerOutput</name><argument_list>(<argument><expr><name>responseq</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>hadError</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><name>mq_res</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CalculateBackoffDelay calculates the time to backoff between retries.
 *
 * Per try we increase the delay as follows:
 *   retry 1: 5 sec
 *   retry 2: 20 sec
 *   retry 3-32 (30 tries in total): 1 min
 *
 * returns -1 when retrying should stop.
 *
 * In the future we would like a callback on the job_type that could
 * distinguish the retry count and delay + potential jitter on a
 * job_type basis. For now we only assume this to be used by the
 * rebalancer and settled on the retry scheme above.
 */</comment>
<function><type><specifier>static</specifier> <name>int64</name></type>
<name>CalculateBackoffDelay</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>retryCount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>retryCount</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><literal type="number">5</literal> <operator>*</operator> <literal type="number">1000</literal></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>retryCount</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><literal type="number">20</literal> <operator>*</operator> <literal type="number">1000</literal></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>retryCount</name> <operator>&lt;=</operator> <literal type="number">32</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><literal type="number">60</literal> <operator>*</operator> <literal type="number">1000</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <name>PG_VERSION_15</name></expr></cpp:if>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>error_severity</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>elevel</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>DEBUG1</name></expr>:</case>
		<case>case <expr><name>DEBUG2</name></expr>:</case>
		<case>case <expr><name>DEBUG3</name></expr>:</case>
		<case>case <expr><name>DEBUG4</name></expr>:</case>
		<case>case <expr><name>DEBUG5</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><name>prefix</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"DEBUG"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>LOG</name></expr>:</case>
		<case>case <expr><name>LOG_SERVER_ONLY</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><name>prefix</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"LOG"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>INFO</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><name>prefix</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"INFO"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>NOTICE</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><name>prefix</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"NOTICE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>WARNING</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><name>prefix</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"WARNING"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <name>PG_VERSION_14</name></expr></cpp:if>
		<case>case <expr><name>WARNING_CLIENT_ONLY</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><name>prefix</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"WARNING"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<case>case <expr><name>ERROR</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><name>prefix</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"ERROR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>FATAL</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><name>prefix</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"FATAL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>PANIC</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><name>prefix</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"PANIC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<default>default:</default>
		<block>{<block_content>
			<expr_stmt><expr><name>prefix</name> <operator>=</operator> <literal type="string">"???"</literal></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>
	</block_content>}</block></switch>

	<return>return <expr><name>prefix</name></expr>;</return>
</block_content>}</block></function>


<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
 * bgw_generate_returned_message -
 *      generates the message to be inserted into the job_run_details table
 *      first part is comming from error_severity (elog.c)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>bgw_generate_returned_message</name><parameter_list>(<parameter><decl><type><name>StringInfoData</name> <modifier>*</modifier></type><name>display_msg</name></decl></parameter>, <parameter><decl><type><name>ErrorData</name></type> <name>edata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name> <init>= <expr><call><name>error_severity</name><argument_list>(<argument><expr><name><name>edata</name><operator>.</operator><name>elevel</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>display_msg</name></expr></argument>, <argument><expr><literal type="string">"%s: %s"</literal></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name><name>edata</name><operator>.</operator><name>message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>.</operator><name>detail</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>display_msg</name></expr></argument>, <argument><expr><literal type="string">"\nDETAIL: %s"</literal></expr></argument>, <argument><expr><name><name>edata</name><operator>.</operator><name>detail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>.</operator><name>hint</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>display_msg</name></expr></argument>, <argument><expr><literal type="string">"\nHINT: %s"</literal></expr></argument>, <argument><expr><name><name>edata</name><operator>.</operator><name>hint</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>.</operator><name>context</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>display_msg</name></expr></argument>, <argument><expr><literal type="string">"\nCONTEXT: %s"</literal></expr></argument>, <argument><expr><name><name>edata</name><operator>.</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * UpdateDependingTasks updates all depending tasks, based on the type of terminal state
 * the current task reached.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>UpdateDependingTasks</name><parameter_list>(<parameter><decl><type><name>BackgroundTask</name> <modifier>*</modifier></type><name>task</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name><name>task</name><operator>-&gt;</operator><name>status</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>BACKGROUND_TASK_STATUS_DONE</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><call><name>UnblockDependingBackgroundTasks</name><argument_list>(<argument><expr><name>task</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>BACKGROUND_TASK_STATUS_ERROR</name></expr>:</case>
		<block>{<block_content>
			<comment type="block">/* when we error this task, we need to unschedule all dependant tasks */</comment>
			<expr_stmt><expr><call><name>UnscheduleDependentTasks</name><argument_list>(<argument><expr><name>task</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<default>default:</default>
		<block>{<block_content>
			<comment type="block">/* nothing to do for other states */</comment>
			<break>break;</break>
		</block_content>}</block>
	</block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
 * ConsumeTaskWorkerOutput consumes the output of an executor and sets the message as
 * the last message read from the queue. It also sets hadError as true if executor had
 * error.
 */</comment>
<function><type><specifier>static</specifier> <name>shm_mq_result</name></type>
<name>ConsumeTaskWorkerOutput</name><parameter_list>(<parameter><decl><type><name>shm_mq_handle</name> <modifier>*</modifier></type><name>responseq</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>message</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>hadError</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>shm_mq_result</name></type> <name>res</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Message-parsing routines operate on a null-terminated StringInfo,
	 * so we must construct one.
	 */</comment>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>msg</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * non-blocking receive to not block other bg workers
		 */</comment>
		<decl_stmt><decl><type><name>Size</name></type> <name>nbytes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>noWait</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>shm_mq_receive</name><argument_list>(<argument><expr><name>responseq</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nbytes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><name>noWait</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <name>SHM_MQ_SUCCESS</name></expr>)</condition>
		<block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * msgtype seems to be documented on
		 * https://www.postgresql.org/docs/current/protocol-message-formats.html
		 *
		 * Here we mostly handle the same message types as supported in pg_cron as the
		 * executor is highly influenced by the implementation there.
		 */</comment>
		<decl_stmt><decl><type><name>char</name></type> <name>msgtype</name> <init>= <expr><call><name>pq_getmsgbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<switch>switch <condition>(<expr><name>msgtype</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="char">'E'</literal></expr>:</case> <comment type="block">/* ErrorResponse */</comment>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>hadError</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><operator>*</operator><name>hadError</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>

			<comment type="block">/* FALLTHROUGH */</comment>

			<case>case <expr><literal type="char">'N'</literal></expr>:</case> <comment type="block">/* NoticeResponse */</comment>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ErrorData</name></type> <name>edata</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>StringInfoData</name></type> <name>display_msg</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>pq_parse_errornotice</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>edata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>display_msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>bgw_generate_returned_message</name><argument_list>(<argument><expr><operator>&amp;</operator><name>display_msg</name></expr></argument>, <argument><expr><name>edata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* we keep only the last message */</comment>
				<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><name><name>display_msg</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>display_msg</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<break>break;</break>
			</block_content>}</block>

			<case>case <expr><literal type="char">'C'</literal></expr>:</case> <comment type="block">/* CommandComplete */</comment>
			<block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tag</name> <init>= <expr><call><name>pq_getmsgstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nonconst_tag</name> <init>= <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/* append the nonconst_tag to the task's message */</comment>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><name>nonconst_tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>nonconst_tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<break>break;</break>
			</block_content>}</block>

			<case>case <expr><literal type="char">'A'</literal></expr>:</case>
			<case>case <expr><literal type="char">'D'</literal></expr>:</case>
			<case>case <expr><literal type="char">'G'</literal></expr>:</case>
			<case>case <expr><literal type="char">'H'</literal></expr>:</case>
			<case>case <expr><literal type="char">'T'</literal></expr>:</case>
			<case>case <expr><literal type="char">'W'</literal></expr>:</case>
			<case>case <expr><literal type="char">'Z'</literal></expr>:</case>
			<block>{<block_content>
				<break>break;</break>
			</block_content>}</block>

			<default>default:</default>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"unknown message type: %c (%zu bytes)"</literal></expr></argument>,
					 <argument><expr><name><name>msg</name><operator>.</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>
		</block_content>}</block></switch>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>msg</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * StoreArgumentsInDSM creates a dynamic shared memory segment to pass the query and its
 * environment to the executor.
 */</comment>
<function><type><specifier>static</specifier> <name>dsm_segment</name> <modifier>*</modifier></type>
<name>StoreArgumentsInDSM</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>database</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>username</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>command</name></decl></parameter>,
					<parameter><decl><type><name>int64</name></type> <name>taskId</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>jobId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Create the shared memory that we will pass to the background
	 * worker process.  We use DSM_CREATE_NULL_IF_MAXSEGMENTS so that we
	 * do not ERROR here.  This way, we can mark the job as failed and
	 * keep the launcher process running normally.
	 */</comment>
	<decl_stmt><decl><type><name>shm_toc_estimator</name></type> <name>e</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>shm_toc_initialize_estimator</name><argument_list>(<argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>e</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>database</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>e</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>username</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>e</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QUEUE_SIZE</name></cpp:macro> <cpp:value>((Size) 65536)</cpp:value></cpp:define>
	<expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>e</name></expr></argument>, <argument><expr><name>QUEUE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>e</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>e</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_estimate_keys</name><argument_list>(<argument><expr><operator>&amp;</operator><name>e</name></expr></argument>, <argument><expr><name>CITUS_BACKGROUND_TASK_NKEYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Size</name></type> <name>segsize</name> <init>= <expr><call><name>shm_toc_estimate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>dsm_segment</name> <modifier>*</modifier></type><name>seg</name> <init>= <expr><call><name>dsm_create</name><argument_list>(<argument><expr><name>segsize</name></expr></argument>, <argument><expr><name>DSM_CREATE_NULL_IF_MAXSEGMENTS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>seg</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"max number of DSM segments may has been reached"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * when we have CurrentResourceOwner != NULL, segment will be released upon CurrentResourceOwner release,
	 * but we may consume the queue in segment even after CurrentResourceOwner released. 'dsm_pin_mapping' helps
	 * persisting the segment until the session ends or the segment is detached explicitly by 'dsm_detach'.
	 */</comment>
	<expr_stmt><expr><call><name>dsm_pin_mapping</name><argument_list>(<argument><expr><name>seg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>shm_toc</name> <modifier>*</modifier></type><name>toc</name> <init>= <expr><call><name>shm_toc_create</name><argument_list>(<argument><expr><name>CITUS_BACKGROUND_TASK_MAGIC</name></expr></argument>, <argument><expr><call><name>dsm_segment_address</name><argument_list>(<argument><expr><name>seg</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>segsize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Size</name></type> <name>size</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>database</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>databaseTarget</name> <init>= <expr><call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>strcpy_s</name><argument_list>(<argument><expr><name>databaseTarget</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>database</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>CITUS_BACKGROUND_TASK_KEY_DATABASE</name></expr></argument>, <argument><expr><name>databaseTarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>username</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>usernameTarget</name> <init>= <expr><call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>strcpy_s</name><argument_list>(<argument><expr><name>usernameTarget</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>username</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>CITUS_BACKGROUND_TASK_KEY_USERNAME</name></expr></argument>, <argument><expr><name>usernameTarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>commandTarget</name> <init>= <expr><call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>strcpy_s</name><argument_list>(<argument><expr><name>commandTarget</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>CITUS_BACKGROUND_TASK_KEY_COMMAND</name></expr></argument>, <argument><expr><name>commandTarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>shm_mq</name> <modifier>*</modifier></type><name>mq</name> <init>= <expr><call><name>shm_mq_create</name><argument_list>(<argument><expr><call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>QUEUE_SIZE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>QUEUE_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>CITUS_BACKGROUND_TASK_KEY_QUEUE</name></expr></argument>, <argument><expr><name>mq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_mq_set_receiver</name><argument_list>(<argument><expr><name>mq</name></expr></argument>, <argument><expr><name>MyProc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int64</name> <modifier>*</modifier></type><name>taskIdTarget</name> <init>= <expr><call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><operator>*</operator><name>taskIdTarget</name> <operator>=</operator> <name>taskId</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>CITUS_BACKGROUND_TASK_KEY_TASK_ID</name></expr></argument>, <argument><expr><name>taskIdTarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int64</name> <modifier>*</modifier></type><name>jobIdTarget</name> <init>= <expr><call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><operator>*</operator><name>jobIdTarget</name> <operator>=</operator> <name>jobId</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>CITUS_BACKGROUND_TASK_KEY_JOB_ID</name></expr></argument>, <argument><expr><name>jobIdTarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>shm_mq_attach</name><argument_list>(<argument><expr><name>mq</name></expr></argument>, <argument><expr><name>seg</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>seg</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * StartCitusBackgroundTaskExecutor start a new background worker for the execution of a
 * background task. Callers interested in the shared memory segment that is created
 * between the background worker and the current backend can pass in a segOut to get a
 * pointer to the dynamic shared memory.
 */</comment>
<function><type><specifier>static</specifier> <name>BackgroundWorkerHandle</name> <modifier>*</modifier></type>
<name>StartCitusBackgroundTaskExecutor</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>database</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>user</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>command</name></decl></parameter>,
								 <parameter><decl><type><name>int64</name></type> <name>taskId</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>jobId</name></decl></parameter>, <parameter><decl><type><name>dsm_segment</name> <modifier>*</modifier><modifier>*</modifier></type><name>pSegment</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dsm_segment</name> <modifier>*</modifier></type><name>seg</name> <init>= <expr><call><name>StoreArgumentsInDSM</name><argument_list>(<argument><expr><name>database</name></expr></argument>, <argument><expr><name>user</name></expr></argument>, <argument><expr><name>command</name></expr></argument>, <argument><expr><name>taskId</name></expr></argument>, <argument><expr><name>jobId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Configure a worker. */</comment>
	<decl_stmt><decl><type><name>BackgroundWorker</name></type> <name>worker</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>worker</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>worker</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SafeSnprintf</name><argument_list>(<argument><expr><name><name>worker</name><operator>.</operator><name>bgw_name</name></name></expr></argument>, <argument><expr><name>BGW_MAXLEN</name></expr></argument>,
				 <argument><expr><literal type="string">"Citus Background Task Queue Executor: %s/%s for (%ld/%ld)"</literal></expr></argument>,
				 <argument><expr><name>database</name></expr></argument>, <argument><expr><name>user</name></expr></argument>, <argument><expr><name>jobId</name></expr></argument>, <argument><expr><name>taskId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>worker</name><operator>.</operator><name>bgw_flags</name></name> <operator>=</operator> <name>BGWORKER_SHMEM_ACCESS</name> <operator>|</operator> <name>BGWORKER_BACKEND_DATABASE_CONNECTION</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>worker</name><operator>.</operator><name>bgw_start_time</name></name> <operator>=</operator> <name>BgWorkerStart_ConsistentState</name></expr>;</expr_stmt>

	<comment type="block">/* don't restart, we manage restarts from maintenance daemon */</comment>
	<expr_stmt><expr><name><name>worker</name><operator>.</operator><name>bgw_restart_time</name></name> <operator>=</operator> <name>BGW_NEVER_RESTART</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strcpy_s</name><argument_list>(<argument><expr><name><name>worker</name><operator>.</operator><name>bgw_library_name</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>worker</name><operator>.</operator><name>bgw_library_name</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"citus"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strcpy_s</name><argument_list>(<argument><expr><name><name>worker</name><operator>.</operator><name>bgw_function_name</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>worker</name><operator>.</operator><name>bgw_library_name</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,
			 <argument><expr><literal type="string">"CitusBackgroundTaskExecutor"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>worker</name><operator>.</operator><name>bgw_main_arg</name></name> <operator>=</operator> <call><name>UInt32GetDatum</name><argument_list>(<argument><expr><call><name>dsm_segment_handle</name><argument_list>(<argument><expr><name>seg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>worker</name><operator>.</operator><name>bgw_notify_pid</name></name> <operator>=</operator> <name>MyProcPid</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>BackgroundWorkerHandle</name> <modifier>*</modifier></type><name>handle</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RegisterDynamicBackgroundWorker</name><argument_list>(<argument><expr><operator>&amp;</operator><name>worker</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>handle</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>dsm_detach</name><argument_list>(<argument><expr><name>seg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>pid_t</name></type> <name>pid</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>WaitForBackgroundWorkerStartup</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>pSegment</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>pSegment</name> <operator>=</operator> <name>seg</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>handle</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * context for any log/error messages emitted from the background task executor.
 */</comment>
<typedef>typedef <type><struct>struct <name>CitusBackgroundJobExecutorErrorCallbackContext</name>
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>database</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>username</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>taskId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>jobId</name></decl>;</decl_stmt>
}</block></struct></type> <name>CitusBackgroundJobExecutorErrorCallbackContext</name>;</typedef>


<comment type="block">/*
 * CitusBackgroundJobExecutorErrorCallback is a callback handler that gets called for any
 * ereport to add extra context to the message.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CitusBackgroundJobExecutorErrorCallback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CitusBackgroundJobExecutorErrorCallbackContext</name> <modifier>*</modifier></type><name>context</name> <init>=
		<expr><operator>(</operator><name>CitusBackgroundJobExecutorErrorCallbackContext</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"Citus Background Task Queue Executor: %s/%s for (%ld/%ld)"</literal></expr></argument>,
			   <argument><expr><name><name>context</name><operator>-&gt;</operator><name>database</name></name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>username</name></name></expr></argument>,
			   <argument><expr><name><name>context</name><operator>-&gt;</operator><name>jobId</name></name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>taskId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CitusBackgroundTaskExecutor is the main function of the background tasks queue
 * executor. This backend attaches to a shared memory segment as identified by the
 * main_arg of the background worker.
 *
 * This is mostly based on the background worker logic in pg_cron
 */</comment>
<function><type><name>void</name></type>
<name>CitusBackgroundTaskExecutor</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>main_arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>BackgroundWorkerUnblockSignals</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set up a dynamic shared memory segment. */</comment>
	<decl_stmt><decl><type><name>dsm_segment</name> <modifier>*</modifier></type><name>seg</name> <init>= <expr><call><name>dsm_attach</name><argument_list>(<argument><expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>main_arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>seg</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unable to map dynamic shared memory segment"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>shm_toc</name> <modifier>*</modifier></type><name>toc</name> <init>= <expr><call><name>shm_toc_attach</name><argument_list>(<argument><expr><name>CITUS_BACKGROUND_TASK_MAGIC</name></expr></argument>, <argument><expr><call><name>dsm_segment_address</name><argument_list>(<argument><expr><name>seg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>toc</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"bad magic number in dynamic shared memory segment"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>database</name> <init>= <expr><call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>CITUS_BACKGROUND_TASK_KEY_DATABASE</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>username</name> <init>= <expr><call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>CITUS_BACKGROUND_TASK_KEY_USERNAME</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>command</name> <init>= <expr><call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>CITUS_BACKGROUND_TASK_KEY_COMMAND</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name> <modifier>*</modifier></type><name>taskId</name> <init>= <expr><call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>CITUS_BACKGROUND_TASK_KEY_TASK_ID</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name> <modifier>*</modifier></type><name>jobId</name> <init>= <expr><call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>CITUS_BACKGROUND_TASK_KEY_JOB_ID</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>shm_mq</name> <modifier>*</modifier></type><name>mq</name> <init>= <expr><call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>CITUS_BACKGROUND_TASK_KEY_QUEUE</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>shm_mq_set_sender</name><argument_list>(<argument><expr><name>mq</name></expr></argument>, <argument><expr><name>MyProc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>shm_mq_handle</name> <modifier>*</modifier></type><name>responseq</name> <init>= <expr><call><name>shm_mq_attach</name><argument_list>(<argument><expr><name>mq</name></expr></argument>, <argument><expr><name>seg</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>pq_redirect_to_shm_mq</name><argument_list>(<argument><expr><name>seg</name></expr></argument>, <argument><expr><name>responseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* setup error context to indicate the errors came from a running background task */</comment>
	<decl_stmt><decl><type><name>ErrorContextCallback</name></type> <name>errorCallback</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CitusBackgroundJobExecutorErrorCallbackContext</name></type> <name>context</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>database</name> <operator>=</operator> <name>database</name></expr>,
		<expr><operator>.</operator><name>username</name> <operator>=</operator> <name>username</name></expr>,
		<expr><operator>.</operator><name>taskId</name> <operator>=</operator> <operator>*</operator><name>taskId</name></expr>,
		<expr><operator>.</operator><name>jobId</name> <operator>=</operator> <operator>*</operator><name>jobId</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>errorCallback</name><operator>.</operator><name>callback</name></name> <operator>=</operator> <name>CitusBackgroundJobExecutorErrorCallback</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errorCallback</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>context</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errorCallback</name><operator>.</operator><name>previous</name></name> <operator>=</operator> <name>error_context_stack</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <operator>&amp;</operator><name>errorCallback</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>BackgroundWorkerInitializeConnection</name><argument_list>(<argument><expr><name>database</name></expr></argument>, <argument><expr><name>username</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* make sure we are the only backend running for this task */</comment>
	<decl_stmt><decl><type><name>LOCKTAG</name></type> <name>locktag</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>SET_LOCKTAG_BACKGROUND_TASK</name><argument_list>(<argument><expr><name>locktag</name></expr></argument>, <argument><expr><operator>*</operator><name>taskId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>sessionLock</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>dontWait</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LockAcquireResult</name></type> <name>locked</name> <init>=
		<expr><call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>locktag</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>, <argument><expr><name>sessionLock</name></expr></argument>, <argument><expr><name>dontWait</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>locked</name> <operator>==</operator> <name>LOCKACQUIRE_NOT_AVAIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unable to acquire background task lock for taskId: %ld"</literal></expr></argument>,
							   <argument><expr><operator>*</operator><name>taskId</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"this indicates that an other backend is already "</literal>
								  <literal type="string">"executing this task"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Prepare to execute the query. */</comment>
	<expr_stmt><expr><call><name>SetCurrentStatementStartTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>debug_query_string</name> <operator>=</operator> <name>command</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>appname</name> <init>= <expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"citus background task queue executor (%ld/%ld)"</literal></expr></argument>,
							 <argument><expr><operator>*</operator><name>jobId</name></expr></argument>, <argument><expr><operator>*</operator><name>taskId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>pgstat_report_appname</name><argument_list>(<argument><expr><name>appname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_report_activity</name><argument_list>(<argument><expr><name>STATE_RUNNING</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>StatementTimeout</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>enable_timeout_after</name><argument_list>(<argument><expr><name>STATEMENT_TIMEOUT</name></expr></argument>, <argument><expr><name>StatementTimeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>disable_timeout</name><argument_list>(<argument><expr><name>STATEMENT_TIMEOUT</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Execute the query. */</comment>
	<expr_stmt><expr><call><name>ExecuteSqlString</name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Post-execution cleanup. */</comment>
	<expr_stmt><expr><call><name>disable_timeout</name><argument_list>(<argument><expr><name>STATEMENT_TIMEOUT</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_report_activity</name><argument_list>(<argument><expr><name>STATE_IDLE</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_report_stat</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Signal that we are done. */</comment>
	<expr_stmt><expr><call><name>ReadyForQuery</name><argument_list>(<argument><expr><name>DestRemote</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>dsm_detach</name><argument_list>(<argument><expr><name>seg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Execute given SQL string without SPI or a libpq session.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecuteSqlString</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sql</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Parse the SQL string into a list of raw parse trees.
	 *
	 * Because we allow statements that perform internal transaction control,
	 * we can't do this in TopTransactionContext; the parse trees might get
	 * blown away before we're done executing them.
	 */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>parsecontext</name> <init>= <expr><call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
													   <argument><expr><literal type="string">"query parse/plan"</literal></expr></argument>,
													   <argument><expr><name>ALLOCSET_DEFAULT_MINSIZE</name></expr></argument>,
													   <argument><expr><name>ALLOCSET_DEFAULT_INITSIZE</name></expr></argument>,
													   <argument><expr><name>ALLOCSET_DEFAULT_MAXSIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>parsecontext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>raw_parsetree_list</name> <init>= <expr><call><name>pg_parse_query</name><argument_list>(<argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>commands_remaining</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>raw_parsetree_list</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isTopLevel</name> <init>= <expr><name>commands_remaining</name> <operator>==</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Do parse analysis, rule rewrite, planning, and execution for each raw
	 * parsetree.  We must fully execute each query before beginning parse
	 * analysis on the next one, since there may be interdependencies.
	 */</comment>
	<decl_stmt><decl><type><name>RawStmt</name> <modifier>*</modifier></type><name>parsetree</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>parsetree</argument>, <argument>raw_parsetree_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<comment type="block">/*
		 * We don't allow transaction-control commands like COMMIT and ABORT
		 * here.  The entire SQL statement is executed as a single transaction
		 * which commits if no errors are encountered.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>TransactionStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(
								<argument><expr><literal type="string">"transaction control statements are not allowed in background job"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Get the command name for use in status display (it also becomes the
		 * default completion tag, down inside PortalRun).  Set ps_status and
		 * do any special start-of-SQL-command processing needed by the
		 * destination.
		 */</comment>
		<decl_stmt><decl><type><name>CommandTag</name></type> <name>commandTag</name> <init>= <expr><call><name>CreateCommandTag</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>stmt</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><call><name>GetCommandTagName</name><argument_list>(<argument><expr><name>commandTag</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>BeginCommand</name><argument_list>(<argument><expr><name>commandTag</name></expr></argument>, <argument><expr><name>DestNone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Set up a snapshot if parse analysis/planning will need one. */</comment>
		<decl_stmt><decl><type><name>bool</name></type> <name>snapshot_set</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>analyze_requires_snapshot</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>snapshot_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * OK to analyze, rewrite, and plan this query.
		 *
		 * As with parsing, we need to make sure this data outlives the
		 * transaction, because of the possibility that the statement might
		 * perform internal transaction control.
		 */</comment>
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>parsecontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">150000</literal></expr></cpp:if>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>querytree_list</name> <init>=
			<expr><call><name>pg_analyze_and_rewrite_fixedparams</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>sql</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>querytree_list</name> <init>=
			<expr><call><name>pg_analyze_and_rewrite</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>sql</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>plantree_list</name> <init>= <expr><call><name>pg_plan_queries</name><argument_list>(<argument><expr><name>querytree_list</name></expr></argument>, <argument><expr><name>sql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Done with the snapshot used for parsing/planning */</comment>
		<if_stmt><if>if <condition>(<expr><name>snapshot_set</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* If we got a cancel signal in analysis or planning, quit */</comment>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Execute the query using the unnamed portal.
		 */</comment>
		<decl_stmt><decl><type><name>Portal</name></type> <name>portal</name> <init>= <expr><call><name>CreatePortal</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Don't display the portal in pg_cursors */</comment>
		<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>visible</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PortalDefineQuery</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>sql</name></expr></argument>, <argument><expr><name>commandTag</name></expr></argument>, <argument><expr><name>plantree_list</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PortalStart</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>InvalidSnapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>int16</name></type> <name><name>format</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="number">1</literal></expr> }</block></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>PortalSetResultFormat</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><call><name>lengthof</name><argument_list>(<argument><expr><name>format</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        <comment type="block">/* binary format */</comment>

		<expr_stmt><expr><name>commands_remaining</name><operator>--</operator></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>receiver</name> <init>= <expr><call><name>CreateDestReceiver</name><argument_list>(<argument><expr><name>DestNone</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Only once the portal and destreceiver have been established can
		 * we return to the transaction context.  All that stuff needs to
		 * survive an internal commit inside PortalRun!
		 */</comment>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Here's where we actually execute the command. */</comment>
		<decl_stmt><decl><type><name>QueryCompletion</name></type> <name>qc</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>PortalRun</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>FETCH_ALL</name></expr></argument>, <argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>receiver</name></expr></argument>, <argument><expr><name>receiver</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>qc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Clean up the receiver. */</comment>
		<expr_stmt><expr><call>(<modifier>*</modifier><name><name>receiver</name><operator>-&gt;</operator><name>rDestroy</name></name>)<argument_list>(<argument><expr><name>receiver</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Send a CommandComplete message even if we suppressed the query
		 * results.  The user backend will report these in the absence of
		 * any true query results.
		 */</comment>
		<expr_stmt><expr><call><name>EndCommand</name><argument_list>(<argument><expr><operator>&amp;</operator><name>qc</name></expr></argument>, <argument><expr><name>DestRemote</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Clean up the portal. */</comment>
		<expr_stmt><expr><call><name>PortalDrop</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Be sure to advance the command counter after the last script command */</comment>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
