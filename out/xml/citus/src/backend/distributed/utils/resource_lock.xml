<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/builded_projects/citus/src/backend/distributed/utils/resource_lock.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * resource_lock.c
 *	  Locking Infrastructure for Citus.
 *
 * To avoid introducing a new type of locktag - that then could not be
 * displayed by core functionality - we reuse advisory locks. If we'd just
 * reused them directly we'd run into danger conflicting with user-defined
 * advisory locks, but luckily advisory locks only two values for 'field4' in
 * the locktag.
 *
 * Copyright (c) Citus Data, Inc.
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"c.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablecmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/colocation_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/coordinator_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_sync.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_join_order.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_partitioning_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/distributed_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/relay_utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/reference_table_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/remote_commands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/resource_lock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shardinterval_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_transaction.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/utils/array_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/version_compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/local_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_shard_visibility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/varlena.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOCK_RELATION_IF_EXISTS</name></cpp:macro> \
	<cpp:value>"SELECT pg_catalog.lock_relation_if_exists(%s, %s);"</cpp:value></cpp:define>

<comment type="block">/* static definition and declarations */</comment>
<struct>struct <name>LockModeToStringType</name>
<block>{
	<decl_stmt><decl><type><name>LOCKMODE</name></type> <name>lockMode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
 * list of lock mode mappings, number of items need to be kept in sync
 * with lock_mode_to_string_map_count.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>LockModeToStringType</name></name></type> <name><name>lockmode_to_string_map</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{ <expr><name>NoLock</name></expr>, <expr><literal type="string">"NoLock"</literal></expr> }</block></expr>,
	<expr><block>{ <expr><name>AccessShareLock</name></expr>, <expr><literal type="string">"ACCESS SHARE"</literal></expr> }</block></expr>,
	<expr><block>{ <expr><name>RowShareLock</name></expr>, <expr><literal type="string">"ROW SHARE"</literal></expr> }</block></expr>,
	<expr><block>{ <expr><name>RowExclusiveLock</name></expr>, <expr><literal type="string">"ROW EXCLUSIVE"</literal></expr> }</block></expr>,
	<expr><block>{ <expr><name>ShareUpdateExclusiveLock</name></expr>, <expr><literal type="string">"SHARE UPDATE EXCLUSIVE"</literal></expr> }</block></expr>,
	<expr><block>{ <expr><name>ShareLock</name></expr>, <expr><literal type="string">"SHARE"</literal></expr> }</block></expr>,
	<expr><block>{ <expr><name>ShareRowExclusiveLock</name></expr>, <expr><literal type="string">"SHARE ROW EXCLUSIVE"</literal></expr> }</block></expr>,
	<expr><block>{ <expr><name>ExclusiveLock</name></expr>, <expr><literal type="string">"EXCLUSIVE"</literal></expr> }</block></expr>,
	<expr><block>{ <expr><name>AccessExclusiveLock</name></expr>, <expr><literal type="string">"ACCESS EXCLUSIVE"</literal></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>lock_mode_to_string_map_count</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>lockmode_to_string_map</name></expr></argument>)</argument_list></sizeof> <operator>/</operator>
												 <sizeof>sizeof<argument_list>(<argument><expr><name><name>lockmode_to_string_map</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * LockRelationRecord holds the oid of a relation to be locked
 * and a boolean inh to determine whether its decendants
 * should be locked as well
 */</comment>
<typedef>typedef <type><struct>struct <name>LockRelationRecord</name>
<block>{
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>inh</name></decl>;</decl_stmt>
}</block></struct></type> <name>LockRelationRecord</name>;</typedef>


<comment type="block">/* local function forward declarations */</comment>
<function_decl><type><specifier>static</specifier> <name>LOCKMODE</name></type> <name>IntToLockMode</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>LockReferencedReferenceShardResources</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockMode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>AnyTableReplicated</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardIntervalList</name></decl></parameter>,
							   <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>replicatedShardIntervalList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>LockShardListResources</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardIntervalList</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockMode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>LockShardListResourcesOnFirstWorker</name><parameter_list>(<parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>,
												<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardIntervalList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsFirstWorkerNode</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CitusRangeVarCallbackForLockTable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RangeVar</name> <modifier>*</modifier></type><name>rangeVar</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>,
											  <parameter><decl><type><name>Oid</name></type> <name>oldRelationId</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>AclResult</name></type> <name>CitusLockTableAclCheck</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>userId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SetLocktagForShardDistributionMetadata</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>shardId</name></decl></parameter>, <parameter><decl><type><name>LOCKTAG</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/* exports for SQL callable functions */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>lock_shard_metadata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>lock_shard_resources</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>lock_relation_if_exists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Config variable managed via guc.c */</comment>
<decl_stmt><decl><type><name>bool</name></type> <name>EnableAcquiringUnsafeLockFromWorkers</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>SkipAdvisoryLockPermissionChecks</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>


<comment type="block">/*
 * lock_shard_metadata allows the shard distribution metadata to be locked
 * remotely to block concurrent writes from workers in MX tables.
 *
 * This function does not sort the array to avoid deadlock, callers
 * must ensure a consistent order.
 */</comment>
<function><type><name>Datum</name></type>
<name>lock_shard_metadata</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>LOCKMODE</name></type> <name>lockMode</name> <init>= <expr><call><name>IntToLockMode</name><argument_list>(<argument><expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>shardIdArrayObject</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>shardIdArrayObject</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no locks specified"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>shardIdCount</name> <init>= <expr><call><name>ArrayObjectCount</name><argument_list>(<argument><expr><name>shardIdArrayObject</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>shardIdArrayDatum</name> <init>= <expr><call><name>DeconstructArrayObject</name><argument_list>(<argument><expr><name>shardIdArrayObject</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>shardIdIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>shardIdIndex</name> <operator>&lt;</operator> <name>shardIdCount</name></expr>;</condition> <incr><expr><name>shardIdIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int64</name></type> <name>shardId</name> <init>= <expr><call><name>DatumGetInt64</name><argument_list>(<argument><expr><name><name>shardIdArrayDatum</name><index>[<expr><name>shardIdIndex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * We don't want random users to block writes. The callers of this
		 * function either operates on all the colocated placements, such
		 * as shard moves, or requires superuser such as adding node.
		 * In other words, the coordinator initiated operations has already
		 * ensured table owner, we are preventing any malicious attempt to
		 * use this function.
		 */</comment>
		<decl_stmt><decl><type><name>bool</name></type> <name>missingOk</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>EnsureShardOwner</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LockShardDistributionMetadata</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>, <argument><expr><name>lockMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * EnsureShardOwner gets the shardId and reads pg_dist_partition to find
 * the corresponding relationId. If the relation does not exist, the function
 * returns. If the relation exists, the function ensures if the current
 * user is the owner of the table.
 *
 */</comment>
<function><type><name>void</name></type>
<name>EnsureShardOwner</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missingOk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>LookupShardRelationFromCatalog</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>missingOk</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * This could happen in two ways. First, a malicious user is trying
		 * to acquire locks on non-existing shards. Second, the metadata has
		 * not been synced (or not yet visible) to this node. In the second
		 * case, there is no point in locking the shards because no other
		 * transaction can be accessing the table.
		 */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>EnsureTableOwner</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * lock_shard_resources allows shard resources to be locked
 * remotely to serialise non-commutative writes on shards.
 *
 * This function does not sort the array to avoid deadlock, callers
 * must ensure a consistent order.
 */</comment>
<function><type><name>Datum</name></type>
<name>lock_shard_resources</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>LOCKMODE</name></type> <name>lockMode</name> <init>= <expr><call><name>IntToLockMode</name><argument_list>(<argument><expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>shardIdArrayObject</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>shardIdArrayObject</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no locks specified"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>shardIdCount</name> <init>= <expr><call><name>ArrayObjectCount</name><argument_list>(<argument><expr><name>shardIdArrayObject</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>shardIdArrayDatum</name> <init>= <expr><call><name>DeconstructArrayObject</name><argument_list>(<argument><expr><name>shardIdArrayObject</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * The executor calls this UDF for modification queries. So, any user
	 * who has the the rights to modify this table are actually able
	 * to call the UDF.
	 *
	 * So, at this point, we make sure that any malicious user who doesn't
	 * have modification privileges to call this UDF.
	 *
	 * Update/Delete/Truncate commands already acquires ExclusiveLock
	 * on the executor. However, for INSERTs, the user might have only
	 * INSERTs granted, so add a special case for it.
	 */</comment>
	<decl_stmt><decl><type><name>AclMode</name></type> <name>aclMask</name> <init>= <expr><name>ACL_UPDATE</name> <operator>|</operator> <name>ACL_DELETE</name> <operator>|</operator> <name>ACL_TRUNCATE</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>lockMode</name> <operator>==</operator> <name>RowExclusiveLock</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>aclMask</name> <operator>|=</operator> <name>ACL_INSERT</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>shardIdIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>shardIdIndex</name> <operator>&lt;</operator> <name>shardIdCount</name></expr>;</condition> <incr><expr><name>shardIdIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int64</name></type> <name>shardId</name> <init>= <expr><call><name>DatumGetInt64</name><argument_list>(<argument><expr><name><name>shardIdArrayDatum</name><index>[<expr><name>shardIdIndex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * We don't want random users to block writes. If the current user
		 * has privileges to modify the shard, then the user can already
		 * acquire the lock. So, we allow.
		 */</comment>
		<decl_stmt><decl><type><name>bool</name></type> <name>missingOk</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>LookupShardRelationFromCatalog</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>missingOk</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * This could happen in two ways. First, a malicious user is trying
			 * to acquire locks on non-existing shards. Second, the metadata has
			 * not been synced (or not yet visible) to this node. In the second
			 * case, there is no point in locking the shards because no other
			 * transaction can be accessing the table.
			 */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>SkipAdvisoryLockPermissionChecks</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>EnsureTablePermissions</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>aclMask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>LockShardResource</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>, <argument><expr><name>lockMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * LockShardListResourcesOnFirstWorker acquires the resource locks for the specified
 * shards on the first worker. Acquiring a lock with or without metadata does not
 * matter for us. So, worker does not have to be an MX node, acquiring the lock
 * on any worker node is enough. Note that the function does not sort the shard list,
 * therefore the caller should sort the shard list in order to avoid deadlocks.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>LockShardListResourcesOnFirstWorker</name><parameter_list>(<parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardIntervalList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>AllowModificationsFromWorkersToReplicatedTables</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Allowing modifications from worker nodes for replicated tables requires
		 * to serialize modifications, see AcquireExecutorShardLocksForExecution()
		 * for the details.
		 *
		 * If the user opted for disabling modifications from the workers, we do not
		 * need to acquire these remote locks. Returning early saves us from an additional
		 * network round-trip.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>AnyTableReplicated</name><argument_list>(<argument><expr><name>shardIntervalList</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>StringInfo</name></type> <name>lockCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>processedShardIntervalCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>totalShardIntervalCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>shardIntervalList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>firstWorkerNode</name> <init>= <expr><call><name>GetFirstPrimaryWorkerNode</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>connectionFlags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>currentUser</name> <init>= <expr><call><name>CurrentUserName</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>lockCommand</name></expr></argument>, <argument><expr><literal type="string">"SELECT lock_shard_resources(%d, ARRAY["</literal></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>shardInterval</argument>, <argument>shardIntervalList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int64</name></type> <name>shardId</name> <init>= <expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>lockCommand</name></expr></argument>, <argument><expr><literal type="string">"%lu"</literal></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>processedShardIntervalCount</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>processedShardIntervalCount</name> <operator>!=</operator> <name>totalShardIntervalCount</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>lockCommand</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>lockCommand</name></expr></argument>, <argument><expr><literal type="string">"])"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* need to hold the lock until commit */</comment>
	<expr_stmt><expr><call><name>UseCoordinatedTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Use the superuser connection to make sure we are allowed to lock.
	 * This also helps ensure we only use one connection.
	 */</comment>
	<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>firstWorkerConnection</name> <init>= <expr><call><name>GetNodeUserDatabaseConnection</name><argument_list>(
		<argument><expr><name>connectionFlags</name></expr></argument>,
		<argument><expr><name><name>firstWorkerNode</name>
		<operator>-&gt;</operator><name>workerName</name></name></expr></argument>,
		<argument><expr><name><name>firstWorkerNode</name>
		<operator>-&gt;</operator><name>workerPort</name></name></expr></argument>,
		<argument><expr><name>currentUser</name></expr></argument>,
		<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* the SELECT .. FOR UPDATE breaks if we lose the connection */</comment>
	<expr_stmt><expr><call><name>MarkRemoteTransactionCritical</name><argument_list>(<argument><expr><name>firstWorkerConnection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* make sure we are in a tranasaction block to hold the lock until commit */</comment>
	<expr_stmt><expr><call><name>RemoteTransactionBeginIfNecessary</name><argument_list>(<argument><expr><name>firstWorkerConnection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* grab the lock on the first worker node */</comment>
	<expr_stmt><expr><call><name>ExecuteCriticalRemoteCommand</name><argument_list>(<argument><expr><name>firstWorkerConnection</name></expr></argument>, <argument><expr><name><name>lockCommand</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * IsFirstWorkerNode checks whether the node is the first worker node sorted
 * according to the host name and port number.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsFirstWorkerNode</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>workerNodeList</name> <init>= <expr><call><name>ActivePrimaryNonCoordinatorNodeList</name><argument_list>(<argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>workerNodeList</name> <operator>=</operator> <call><name>SortList</name><argument_list>(<argument><expr><name>workerNodeList</name></expr></argument>, <argument><expr><name>CompareWorkerNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>workerNodeList</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>firstWorkerNode</name> <init>= <expr><operator>(</operator><name>WorkerNode</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>workerNodeList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>firstWorkerNode</name><operator>-&gt;</operator><name>groupId</name></name> <operator>==</operator> <call><name>GetLocalGroupId</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * LockShardListMetadataOnWorkers acquires the matadata locks for the specified shards on
 * metadata workers. Note that the function does not sort the shard list, therefore the
 * caller should sort the shard list in order to avoid deadlocks.
 */</comment>
<function><type><name>void</name></type>
<name>LockShardListMetadataOnWorkers</name><parameter_list>(<parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardIntervalList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>lockCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>processedShardIntervalCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>totalShardIntervalCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>shardIntervalList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>shardIntervalList</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>lockCommand</name></expr></argument>, <argument><expr><literal type="string">"SELECT lock_shard_metadata(%d, ARRAY["</literal></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>shardInterval</argument>, <argument>shardIntervalList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int64</name></type> <name>shardId</name> <init>= <expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>lockCommand</name></expr></argument>, <argument><expr><literal type="string">"%lu"</literal></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>processedShardIntervalCount</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>processedShardIntervalCount</name> <operator>!=</operator> <name>totalShardIntervalCount</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>lockCommand</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>lockCommand</name></expr></argument>, <argument><expr><literal type="string">"])"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SendCommandToWorkersWithMetadata</name><argument_list>(<argument><expr><name><name>lockCommand</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * IntToLockMode verifies whether the specified integer is an accepted lock mode
 * and returns it as a LOCKMODE enum.
 */</comment>
<function><type><specifier>static</specifier> <name>LOCKMODE</name></type>
<name>IntToLockMode</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>ExclusiveLock</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>ExclusiveLock</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>mode</name> <operator>==</operator> <name>ShareLock</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>ShareLock</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>mode</name> <operator>==</operator> <name>AccessShareLock</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>AccessShareLock</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>mode</name> <operator>==</operator> <name>RowExclusiveLock</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>RowExclusiveLock</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unsupported lockmode %d"</literal></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * LockColocationId returns after acquiring a co-location ID lock, typically used
 * for rebalancing and replication.
 */</comment>
<function><type><name>void</name></type>
<name>LockColocationId</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>colocationId</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockMode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKTAG</name></type> <name>tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>sessionLock</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>dontWait</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SET_LOCKTAG_REBALANCE_COLOCATION</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><operator>(</operator><name>int64</name><operator>)</operator> <name>colocationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>lockMode</name></expr></argument>, <argument><expr><name>sessionLock</name></expr></argument>, <argument><expr><name>dontWait</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * UnlockColocationId releases a co-location ID lock.
 */</comment>
<function><type><name>void</name></type>
<name>UnlockColocationId</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>colocationId</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockMode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKTAG</name></type> <name>tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>sessionLock</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SET_LOCKTAG_REBALANCE_COLOCATION</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><operator>(</operator><name>int64</name><operator>)</operator> <name>colocationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>lockMode</name></expr></argument>, <argument><expr><name>sessionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * LockShardDistributionMetadata returns after grabbing a lock for distribution
 * metadata related to the specified shard, blocking if required. Any locks
 * acquired using this method are released at transaction end.
 */</comment>
<function><type><name>void</name></type>
<name>LockShardDistributionMetadata</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>shardId</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockMode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKTAG</name></type> <name>tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>sessionLock</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>dontWait</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SetLocktagForShardDistributionMetadata</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>lockMode</name></expr></argument>, <argument><expr><name>sessionLock</name></expr></argument>, <argument><expr><name>dontWait</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>SetLocktagForShardDistributionMetadata</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>shardId</name></decl></parameter>, <parameter><decl><type><name>LOCKTAG</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><call><name>LoadShardInterval</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>citusTableId</name> <init>= <expr><name><name>shardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>citusTable</name> <init>= <expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name>citusTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>colocationId</name> <init>= <expr><name><name>citusTable</name><operator>-&gt;</operator><name>colocationId</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>colocationId</name> <operator>==</operator> <name>INVALID_COLOCATION_ID</name> <operator>||</operator>
		<operator>!</operator><call><name>IsCitusTableTypeCacheEntry</name><argument_list>(<argument><expr><name>citusTable</name></expr></argument>, <argument><expr><name>HASH_DISTRIBUTED</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SET_LOCKTAG_SHARD_METADATA_RESOURCE</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>MyDatabaseId</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>SET_LOCKTAG_COLOCATED_SHARDS_METADATA_RESOURCE</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>MyDatabaseId</name></expr></argument>, <argument><expr><name>colocationId</name></expr></argument>,
													   <argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardIndex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * LockPlacementCleanup takes an exclusive lock to ensure that only one process
 * can cleanup placements at the same time.
 */</comment>
<function><type><name>void</name></type>
<name>LockPlacementCleanup</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKTAG</name></type> <name>tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>sessionLock</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>dontWait</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Moves acquire lock with a constant operation id CITUS_SHARD_MOVE.
	 * This will change as we add support for parallel moves.
	 */</comment>
	<expr_stmt><expr><call><name>SET_LOCKTAG_CITUS_OPERATION</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>CITUS_SHARD_MOVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>, <argument><expr><name>sessionLock</name></expr></argument>, <argument><expr><name>dontWait</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * TryLockPlacementCleanup takes an exclusive lock to ensure that only one
 * process can cleanup placements at the same time.
 */</comment>
<function><type><name>bool</name></type>
<name>TryLockPlacementCleanup</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKTAG</name></type> <name>tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>sessionLock</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>dontWait</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Moves acquire lock with a constant operation id CITUS_SHARD_MOVE.
	 * This will change as we add support for parallel moves.
	 */</comment>
	<expr_stmt><expr><call><name>SET_LOCKTAG_CITUS_OPERATION</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>CITUS_SHARD_MOVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>lockAcquired</name> <init>= <expr><call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>, <argument><expr><name>sessionLock</name></expr></argument>, <argument><expr><name>dontWait</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><name>lockAcquired</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * LockReferencedReferenceShardDistributionMetadata acquires shard distribution
 * metadata locks with the given lock mode on the reference tables which has a
 * foreign key from the given relation.
 *
 * It also gets metadata locks on worker nodes to prevent concurrent write
 * operations on reference tables from metadata nodes.
 */</comment>
<function><type><name>void</name></type>
<name>LockReferencedReferenceShardDistributionMetadata</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockMode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>RelationIdForShard</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>cacheEntry</name> <init>= <expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>referencedRelationList</name> <init>= <expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>referencedRelationsViaForeignKey</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardIntervalList</name> <init>= <expr><call><name>GetSortedReferenceShardIntervals</name><argument_list>(<argument><expr><name>referencedRelationList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>shardIntervalList</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>ClusterHasKnownMetadataWorkers</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LockShardListMetadataOnWorkers</name><argument_list>(<argument><expr><name>lockMode</name></expr></argument>, <argument><expr><name>shardIntervalList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>shardInterval</argument>, <argument>shardIntervalList</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LockShardDistributionMetadata</name><argument_list>(<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>, <argument><expr><name>lockMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * LockReferencedReferenceShardResources acquires resource locks with the
 * given lock mode on the reference tables which has a foreign key from
 * the given relation.
 *
 * It also gets resource locks on worker nodes to prevent concurrent write
 * operations on reference tables from metadata nodes.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>LockReferencedReferenceShardResources</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockMode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>RelationIdForShard</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>cacheEntry</name> <init>= <expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Note that referencedRelationsViaForeignKey contains transitively referenced
	 * relations too.
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>referencedRelationList</name> <init>= <expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>referencedRelationsViaForeignKey</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>referencedShardIntervalList</name> <init>=
		<expr><call><name>GetSortedReferenceShardIntervals</name><argument_list>(<argument><expr><name>referencedRelationList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>referencedShardIntervalList</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<call><name>ClusterHasKnownMetadataWorkers</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>IsFirstWorkerNode</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * When there is metadata, all nodes can write to the reference table,
		 * but the writes need to be serialised. To achieve that, all nodes will
		 * take the shard resource lock on the first worker node via RPC, except
		 * for the first worker node which will just take it the regular way.
		 */</comment>
		<expr_stmt><expr><call><name>LockShardListResourcesOnFirstWorker</name><argument_list>(<argument><expr><name>lockMode</name></expr></argument>, <argument><expr><name>referencedShardIntervalList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>referencedShardInterval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>referencedShardInterval</argument>, <argument>referencedShardIntervalList</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LockShardResource</name><argument_list>(<argument><expr><name><name>referencedShardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>, <argument><expr><name>lockMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * GetSortedReferenceShardIntervals iterates through the given relation list,
 * lists the shards of reference tables, and returns the list after sorting.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>GetSortedReferenceShardIntervals</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>relationList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardIntervalList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>relationId</argument>, <argument>relationList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>REFERENCE_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>currentShardIntervalList</name> <init>= <expr><call><name>LoadShardIntervalList</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>shardIntervalList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>shardIntervalList</name></expr></argument>, <argument><expr><call><name>linitial</name><argument_list>(
										<argument><expr><name>currentShardIntervalList</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name>shardIntervalList</name> <operator>=</operator> <call><name>SortList</name><argument_list>(<argument><expr><name>shardIntervalList</name></expr></argument>, <argument><expr><name>CompareShardIntervalsById</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>shardIntervalList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * LockShardResource acquires a lock needed to modify data on a remote shard.
 * This task may be assigned to multiple backends at the same time, so the lock
 * manages any concurrency issues associated with shard file fetching and DML
 * command execution.
 */</comment>
<function><type><name>void</name></type>
<name>LockShardResource</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKTAG</name></type> <name>tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>sessionLock</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>dontWait</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SET_LOCKTAG_SHARD_RESOURCE</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>MyDatabaseId</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>sessionLock</name></expr></argument>, <argument><expr><name>dontWait</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* LockTransactionRecovery acquires a lock for transaction recovery */</comment>
<function><type><name>void</name></type>
<name>LockTransactionRecovery</name><parameter_list>(<parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKTAG</name></type> <name>tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>sessionLock</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>dontWait</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SET_LOCKTAG_CITUS_OPERATION</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>CITUS_TRANSACTION_RECOVERY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>sessionLock</name></expr></argument>, <argument><expr><name>dontWait</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * LockShardListMetadata takes shared locks on the metadata of all shards in
 * shardIntervalList to prevents concurrent placement changes.
 */</comment>
<function><type><name>void</name></type>
<name>LockShardListMetadata</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardIntervalList</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockMode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* lock shards in order of shard id to prevent deadlock */</comment>
	<expr_stmt><expr><name>shardIntervalList</name> <operator>=</operator> <call><name>SortList</name><argument_list>(<argument><expr><name>shardIntervalList</name></expr></argument>, <argument><expr><name>CompareShardIntervalsById</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>shardInterval</argument>, <argument>shardIntervalList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int64</name></type> <name>shardId</name> <init>= <expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>LockShardDistributionMetadata</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>, <argument><expr><name>lockMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * LockShardsInPlacementListMetadata takes locks on the metadata of all shards in
 * shardPlacementList to prevent concurrent placement changes.
 */</comment>
<function><type><name>void</name></type>
<name>LockShardsInPlacementListMetadata</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardPlacementList</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockMode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* lock shards in order of shard id to prevent deadlock */</comment>
	<expr_stmt><expr><name>shardPlacementList</name> <operator>=</operator>
		<call><name>SortList</name><argument_list>(<argument><expr><name>shardPlacementList</name></expr></argument>, <argument><expr><name>CompareShardPlacementsByShardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>GroupShardPlacement</name> <modifier>*</modifier></type><name>placement</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>placement</argument>, <argument>shardPlacementList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int64</name></type> <name>shardId</name> <init>= <expr><name><name>placement</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>LockShardDistributionMetadata</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>, <argument><expr><name>lockMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * SerializeNonCommutativeWrites acquires the required locks to prevent concurrent
 * writes on the given shards.
 *
 * If the modified shard is a reference table's shard and the cluster is an MX
 * cluster we need to get shard resource lock on the first worker node to
 * prevent divergence possibility between placements of the reference table.
 *
 * In other workers, by acquiring a lock on the first worker, we're serializing
 * non-commutative modifications to a reference table. If the node executing the
 * command is the first worker, defined via IsFirstWorker(), we skip acquiring
 * the lock remotely to avoid an extra round-trip and/or self-deadlocks.
 *
 * Finally, if we're not dealing with reference tables on MX cluster, we'll
 * always acquire the lock with LockShardListResources() call.
 */</comment>
<function><type><name>void</name></type>
<name>SerializeNonCommutativeWrites</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardIntervalList</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockMode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>shardIntervalList</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>replicatedShardList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>AnyTableReplicated</name><argument_list>(<argument><expr><name>shardIntervalList</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>replicatedShardList</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>ClusterHasKnownMetadataWorkers</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsFirstWorkerNode</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LockShardListResourcesOnFirstWorker</name><argument_list>(<argument><expr><name>lockMode</name></expr></argument>, <argument><expr><name>replicatedShardList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>firstShardInterval</name> <init>=
			<expr><operator>(</operator><name>ShardInterval</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>replicatedShardList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>ReferenceTableShardId</name><argument_list>(<argument><expr><name><name>firstShardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Referenced tables can cascade their changes to this table, and we
			 * want to serialize changes to keep different replicas consistent.
			 *
			 * We currently only support foreign keys to reference tables, which are
			 * single shard. So, getting the first shard should be sufficient here.
			 */</comment>
			<expr_stmt><expr><call><name>LockReferencedReferenceShardResources</name><argument_list>(<argument><expr><name><name>firstShardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>, <argument><expr><name>lockMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LockShardListResources</name><argument_list>(<argument><expr><name>shardIntervalList</name></expr></argument>, <argument><expr><name>lockMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * AnyTableReplicated iterates on the shard list and returns true
 * if any of the shard is a replicated table. We qualify replicated
 * tables as any reference table or any distributed table with
 * replication factor &gt; 1.
 *
 * If the optional replicatedShardIntervalList is passed, the function
 * fills it with the replicated shard intervals.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>AnyTableReplicated</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardIntervalList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>replicatedShardIntervalList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>localList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>shardInterval</argument>, <argument>shardIntervalList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int64</name></type> <name>shardId</name> <init>= <expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>RelationIdForShard</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>ReferenceTableShardId</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>localList</name> <operator>=</operator>
				<call><name>lappend</name><argument_list>(<argument><expr><name>localList</name></expr></argument>, <argument><expr><call><name>LoadShardInterval</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>SingleReplicatedTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>localList</name> <operator>=</operator>
				<call><name>lappend</name><argument_list>(<argument><expr><name>localList</name></expr></argument>, <argument><expr><call><name>LoadShardInterval</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>replicatedShardIntervalList</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>replicatedShardIntervalList</name> <operator>=</operator> <name>localList</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>list_length</name><argument_list>(<argument><expr><name>localList</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * LockShardListResources takes locks on all shards in shardIntervalList to
 * prevent concurrent DML statements on those shards.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>LockShardListResources</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardIntervalList</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockMode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* lock shards in order of shard id to prevent deadlock */</comment>
	<expr_stmt><expr><name>shardIntervalList</name> <operator>=</operator> <call><name>SortList</name><argument_list>(<argument><expr><name>shardIntervalList</name></expr></argument>, <argument><expr><name>CompareShardIntervalsById</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>shardInterval</argument>, <argument>shardIntervalList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int64</name></type> <name>shardId</name> <init>= <expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>LockShardResource</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>, <argument><expr><name>lockMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * LockRelationShardResources takes locks on all shards in a list of RelationShards
 * to prevent concurrent DML statements on those shards.
 */</comment>
<function><type><name>void</name></type>
<name>LockRelationShardResources</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>relationShardList</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockMode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>relationShardList</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardIntervalList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelationShard</name> <modifier>*</modifier></type><name>relationShard</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>relationShard</argument>, <argument>relationShardList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint64</name></type> <name>shardId</name> <init>= <expr><name><name>relationShard</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><call><name>LoadShardInterval</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>shardIntervalList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>shardIntervalList</name></expr></argument>, <argument><expr><name>shardInterval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* lock shards in a consistent order to prevent deadlock */</comment>
	<expr_stmt><expr><name>shardIntervalList</name> <operator>=</operator> <call><name>SortList</name><argument_list>(<argument><expr><name>shardIntervalList</name></expr></argument>, <argument><expr><name>CompareShardIntervalsById</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SerializeNonCommutativeWrites</name><argument_list>(<argument><expr><name>shardIntervalList</name></expr></argument>, <argument><expr><name>lockMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * LockParentShardResourceIfPartition checks whether the given shard belongs
 * to a partition. If it does, LockParentShardResourceIfPartition acquires a
 * shard resource lock on the colocated shard of the parent table.
 */</comment>
<function><type><name>void</name></type>
<name>LockParentShardResourceIfPartition</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardIntervalList</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockMode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>parentShardIntervalList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>shardInterval</argument>, <argument>shardIntervalList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name><name>shardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PartitionTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>shardIndex</name> <init>= <expr><call><name>ShardIndex</name><argument_list>(<argument><expr><name>shardInterval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type> <name>parentRelationId</name> <init>= <expr><call><name>PartitionParentOid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>uint64</name></type> <name>parentShardId</name> <init>= <expr><call><name>ColocatedShardIdInRelation</name><argument_list>(<argument><expr><name>parentRelationId</name></expr></argument>,
															  <argument><expr><name>shardIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>parentShardInterval</name> <init>= <expr><call><name>LoadShardInterval</name><argument_list>(<argument><expr><name>parentShardId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>parentShardIntervalList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>parentShardIntervalList</name></expr></argument>,
											  <argument><expr><name>parentShardInterval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>LockShardListResources</name><argument_list>(<argument><expr><name>parentShardIntervalList</name></expr></argument>, <argument><expr><name>lockMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * LockModeTextToLockMode gets a lockMode name and returns its corresponding LOCKMODE.
 * The function errors out if the input lock mode isn't defined in the PostgreSQL's
 * explicit locking table.
 */</comment>
<function><type><name>LOCKMODE</name></type>
<name>LockModeTextToLockMode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>lockModeName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKMODE</name></type> <name>lockMode</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>lockIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>lockIndex</name> <operator>&lt;</operator> <name>lock_mode_to_string_map_count</name></expr>;</condition> <incr><expr><name>lockIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>LockModeToStringType</name></name> <modifier>*</modifier></type><name>lockMap</name> <init>= <expr><name>lockmode_to_string_map</name> <operator>+</operator> <name>lockIndex</name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name><name>lockMap</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>lockModeName</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>lockMode</name> <operator>=</operator> <name><name>lockMap</name><operator>-&gt;</operator><name>lockMode</name></name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* we could not find the lock mode we are looking for */</comment>
	<if_stmt><if>if <condition>(<expr><name>lockMode</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_LOCK_NOT_AVAILABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unknown lock mode: %s"</literal></expr></argument>, <argument><expr><name>lockModeName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>lockMode</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * LockModeToLockModeText gets a lockMode enum and returns its corresponding text
 * representation.
 * The function errors out if the input lock mode isn't defined in the PostgreSQL's
 * explicit locking table.
 */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>LockModeToLockModeText</name><parameter_list>(<parameter><decl><type><name>LOCKMODE</name></type> <name>lockMode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>lockModeText</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>lockIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>lockIndex</name> <operator>&lt;</operator> <name>lock_mode_to_string_map_count</name></expr>;</condition> <incr><expr><name>lockIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>LockModeToStringType</name></name> <modifier>*</modifier></type><name>lockMap</name> <init>= <expr><name>lockmode_to_string_map</name> <operator>+</operator> <name>lockIndex</name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>lockMode</name> <operator>==</operator> <name><name>lockMap</name><operator>-&gt;</operator><name>lockMode</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>lockModeText</name> <operator>=</operator> <name><name>lockMap</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* we could not find the lock mode we are looking for */</comment>
	<if_stmt><if>if <condition>(<expr><name>lockModeText</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_LOCK_NOT_AVAILABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unknown lock mode enum: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>lockMode</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>lockModeText</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * lock_relation_if_exists gets a relation name and lock mode
 * and returns true if the relation exists and can be locked with
 * the given lock mode. If the relation doesn't exists, the function
 * return false.
 *
 * The relation name should be qualified with the schema name.
 *
 * The function errors out if the lockmode isn't defined in the PostgreSQL's
 * explicit locking table.
 */</comment>
<function><type><name>Datum</name></type>
<name>lock_relation_if_exists</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>lockModeText</name> <init>= <expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>lockModeCString</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><name>lockModeText</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* get the lock mode */</comment>
	<decl_stmt><decl><type><name>LOCKMODE</name></type> <name>lockMode</name> <init>= <expr><call><name>LockModeTextToLockMode</name><argument_list>(<argument><expr><name>lockModeCString</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* resolve relationId from passed in schema and relation name */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>relationNameList</name> <init>= <expr><call><name>textToQualifiedNameList</name><argument_list>(<argument><expr><name>relationName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>relation</name> <init>= <expr><call><name>makeRangeVarFromNameList</name><argument_list>(<argument><expr><name>relationNameList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* lock the relation with the lock mode */</comment>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>RangeVarGetRelidExtended</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>lockMode</name></expr></argument>, <argument><expr><name>RVR_MISSING_OK</name></expr></argument>,
											  <argument><expr><name>CitusRangeVarCallbackForLockTable</name></expr></argument>,
											  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>lockMode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>relationExists</name> <init>= <expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>relationExists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CitusRangeVarCallbackForLockTable is a callback for RangeVarGetRelidExtended used
 * to check whether the user has permission to lock a table in a particular mode.
 *
 * This function is a copy of RangeVarCallbackForLockTable in lockcmds.c adapted to
 * Citus code style.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CitusRangeVarCallbackForLockTable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RangeVar</name> <modifier>*</modifier></type><name>rangeVar</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>,
								  <parameter><decl><type><name>Oid</name></type> <name>oldRelationId</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKMODE</name></type> <name>lockmode</name> <init>= <expr><operator>*</operator><operator>(</operator><name>LOCKMODE</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* table doesn't exist, so no permissions check */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* we only allow tables, views and foreign tables to be locked */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RegularTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsForeignTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table"</literal></expr></argument>, <argument><expr><name><name>rangeVar</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* check permissions */</comment>
	<decl_stmt><decl><type><name>AclResult</name></type> <name>aclResult</name> <init>= <expr><call><name>CitusLockTableAclCheck</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>aclResult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclResult</name></expr></argument>, <argument><expr><call><name>get_relkind_objtype</name><argument_list>(<argument><expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><name><name>rangeVar</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CitusLockTableAclCheck checks whether a user has permission to lock a relation
 * in the given lock mode.
 *
 * This function is a copy of LockTableAclCheck in lockcmds.c adapted to Citus
 * code style.
 */</comment>
<function><type><specifier>static</specifier> <name>AclResult</name></type>
<name>CitusLockTableAclCheck</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>userId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AclMode</name></type> <name>aclMask</name></decl>;</decl_stmt>

	<comment type="block">/* verify adequate privilege */</comment>
	<if_stmt><if>if <condition>(<expr><name>lockmode</name> <operator>==</operator> <name>AccessShareLock</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>aclMask</name> <operator>=</operator> <name>ACL_SELECT</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>lockmode</name> <operator>==</operator> <name>RowExclusiveLock</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>aclMask</name> <operator>=</operator> <name>ACL_INSERT</name> <operator>|</operator> <name>ACL_UPDATE</name> <operator>|</operator> <name>ACL_DELETE</name> <operator>|</operator> <name>ACL_TRUNCATE</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>aclMask</name> <operator>=</operator> <name>ACL_UPDATE</name> <operator>|</operator> <name>ACL_DELETE</name> <operator>|</operator> <name>ACL_TRUNCATE</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<decl_stmt><decl><type><name>AclResult</name></type> <name>aclResult</name> <init>= <expr><call><name>pg_class_aclcheck</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>userId</name></expr></argument>, <argument><expr><name>aclMask</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>aclResult</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * EnsureCanAcquireLock checks if currect user has the permissions
 * to acquire a lock on the table and throws an error if the user does
 * not have the permissions
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>EnsureCanAcquireLock</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockMode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AclResult</name></type> <name>aclResult</name> <init>= <expr><call><name>CitusLockTableAclCheck</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>lockMode</name></expr></argument>,
												 <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>aclResult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclResult</name></expr></argument>,
					   <argument><expr><call><name>get_relkind_objtype</name><argument_list>(<argument><expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CreateLockTerminationString creates a string that can be appended to the
 * end of a partial lock command to properly terminate the command
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>CreateLockTerminationString</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>lockModeText</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>nowait</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>lockTerminationStringInfo</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>lockTerminationStringInfo</name></expr></argument>, <argument><expr><ternary><condition><expr><name>nowait</name></expr> ?</condition><then> <expr><literal type="string">" IN %s MODE NOWAIT;\n"</literal></expr> </then><else>:
					 <expr><literal type="string">" IN %s MODE;\n"</literal></expr></else></ternary></expr></argument>, <argument><expr><name>lockModeText</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>lockTerminationStringInfo</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FinishLockCommandIfNecessary appends the lock termination string if the lock command is partial.
 * Sets the partialLockCommand flag to false
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>FinishLockCommandIfNecessary</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>lockCommand</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>lockTerminationString</name></decl></parameter>,
							 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>partialLockCommand</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>partialLockCommand</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>lockCommand</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>lockTerminationString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>partialLockCommand</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * LockRelationRecordListMember checks if a relation id is present in the
 * LockRelationRecord list
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>LockRelationRecordListMember</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>lockRelationRecordList</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LockRelationRecord</name> <modifier>*</modifier></type><name>record</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>record</argument>, <argument>lockRelationRecordList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>relationId</name></name> <operator>==</operator> <name>relationId</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * MakeLockRelationRecord makes a LockRelationRecord using the relation oid
 * and the inh boolean while properly allocating the structure
 */</comment>
<function><type><specifier>static</specifier> <name>LockRelationRecord</name> <modifier>*</modifier></type>
<name>MakeLockRelationRecord</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>inh</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LockRelationRecord</name> <modifier>*</modifier></type><name>lockRelationRecord</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LockRelationRecord</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>lockRelationRecord</name><operator>-&gt;</operator><name>relationId</name></name> <operator>=</operator> <name>relationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lockRelationRecord</name><operator>-&gt;</operator><name>inh</name></name> <operator>=</operator> <name>inh</name></expr>;</expr_stmt>
	<return>return <expr><name>lockRelationRecord</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ConcatLockRelationRecordList concats a list of LockRelationRecord with
 * another list of LockRelationRecord created from a list of relation oid-s
 * which are not present in the first list and an inh bool which will be
 * applied across all LockRelationRecords
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>ConcatLockRelationRecordList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>lockRelationRecordList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>relationOidList</name></decl></parameter>, <parameter><decl><type><name>bool</name></type>
							 <name>inh</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>constructedList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>relationId</argument>, <argument>relationOidList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>LockRelationRecordListMember</name><argument_list>(<argument><expr><name>lockRelationRecordList</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>LockRelationRecord</name> <modifier>*</modifier></type><name>record</name> <init>= <expr><call><name>MakeLockRelationRecord</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>inh</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>constructedList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>constructedList</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><call><name>list_concat</name><argument_list>(<argument><expr><name>lockRelationRecordList</name></expr></argument>, <argument><expr><name>constructedList</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AcquireDistributedLockOnRelations_Internal acquire a distributed lock on worker nodes
 * for given list of relations ids. Worker node list is sorted so that the lock
 * is acquired in the same order regardless of which node it was run on.
 *
 * A nowait flag is used to require the locks to be available immediately
 * and if that is not the case, an error will be thrown
 *
 * Notice that no validation or filtering is done on the relationIds, that is the responsibility
 * of this function's caller.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AcquireDistributedLockOnRelations_Internal</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>lockRelationRecordList</name></decl></parameter>,
										   <parameter><decl><type><name>LOCKMODE</name></type> <name>lockMode</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>nowait</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>lockModeText</name> <init>= <expr><call><name>LockModeToLockModeText</name><argument_list>(<argument><expr><name>lockMode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>UseCoordinatedTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>StringInfo</name></type> <name>lockRelationsCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>lockRelationsCommand</name></expr></argument>, <argument><expr><literal type="string">"%s;\n"</literal></expr></argument>, <argument><expr><name>DISABLE_DDL_PROPAGATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * In the following loop, when there are foreign tables, we need to switch from
	 * LOCK * statement to lock_relation_if_exists() and vice versa since pg
	 * does not support using LOCK on foreign tables.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>startedLockCommand</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* create a lock termination string used to terminate a partial lock command */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>lockTerminationString</name> <init>= <expr><call><name>CreateLockTerminationString</name><argument_list>(<argument><expr><name>lockModeText</name></expr></argument>, <argument><expr><name>nowait</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>lockedRelations</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LockRelationRecord</name> <modifier>*</modifier></type><name>lockRelationRecord</name></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>lockRelationRecord</argument>, <argument>lockRelationRecordList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name><name>lockRelationRecord</name><operator>-&gt;</operator><name>relationId</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>lockDescendants</name> <init>= <expr><name><name>lockRelationRecord</name><operator>-&gt;</operator><name>inh</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>qualifiedRelationName</name> <init>= <expr><call><name>generate_qualified_relation_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * As of pg14 we cannot use LOCK to lock a FOREIGN TABLE
		 * so we have to use the lock_relation_if_exist udf
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>FinishLockCommandIfNecessary</name><argument_list>(<argument><expr><name>lockRelationsCommand</name></expr></argument>, <argument><expr><name>lockTerminationString</name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>startedLockCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * The user should not be able to trigger this codepath
			 * with nowait = true or lockDescendants = false since the
			 * only way to do that is calling LOCK * IN * MODE NOWAIT;
			 * and LOCK ONLY * IN * MODE; respectively but foreign tables
			 * cannot be locked with LOCK command as of pg14
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nowait</name> <operator>==</operator> <name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>lockDescendants</name> <operator>==</operator> <name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* use lock_relation_if_exits to lock foreign table */</comment>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>lockRelationsCommand</name></expr></argument>, <argument><expr><name>LOCK_RELATION_IF_EXISTS</name></expr></argument>,
							 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>qualifiedRelationName</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>lockModeText</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>lockRelationsCommand</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>startedLockCommand</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* append relation to partial lock statement */</comment>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>lockRelationsCommand</name></expr></argument>, <argument><expr><literal type="string">",%s%s"</literal></expr></argument>,
							 <argument><expr><ternary><condition><expr><name>lockDescendants</name></expr> ?</condition><then> <expr><literal type="string">" "</literal></expr> </then><else>: <expr><literal type="string">" ONLY "</literal></expr></else></ternary></expr></argument>,
							 <argument><expr><name>qualifiedRelationName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* start a new partial lock statement */</comment>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>lockRelationsCommand</name></expr></argument>, <argument><expr><literal type="string">"LOCK%s%s"</literal></expr></argument>,
							 <argument><expr><ternary><condition><expr><name>lockDescendants</name></expr> ?</condition><then> <expr><literal type="string">" "</literal></expr> </then><else>: <expr><literal type="string">" ONLY "</literal></expr></else></ternary></expr></argument>,
							 <argument><expr><name>qualifiedRelationName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>startedLockCommand</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>lockedRelations</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>lockedRelations</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>FinishLockCommandIfNecessary</name><argument_list>(<argument><expr><name>lockRelationsCommand</name></expr></argument>, <argument><expr><name>lockTerminationString</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>startedLockCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>lockRelationsCommand</name></expr></argument>, <argument><expr><name>ENABLE_DDL_PROPAGATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>lockCommand</name> <init>= <expr><name><name>lockRelationsCommand</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>workerNodeList</name> <init>= <expr><call><name>TargetWorkerSetNodeList</name><argument_list>(<argument><expr><name>METADATA_NODES</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We want to acquire locks in the same order across the nodes.
	 * Although relation ids may change, their ordering will not.
	 */</comment>
	<expr_stmt><expr><name>workerNodeList</name> <operator>=</operator> <call><name>SortList</name><argument_list>(<argument><expr><name>workerNodeList</name></expr></argument>, <argument><expr><name>CompareWorkerNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int32</name></type> <name>localGroupId</name> <init>= <expr><call><name>GetLocalGroupId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>currentUser</name> <init>= <expr><call><name>CurrentUserName</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>workerNode</argument>, <argument>workerNodeList</argument>)</argument_list></macro>
	<block>{<block_content>
		<comment type="block">/* if local node is one of the targets, acquire the lock locally */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>workerNode</name><operator>-&gt;</operator><name>groupId</name></name> <operator>==</operator> <name>localGroupId</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ExecuteUtilityCommand</name><argument_list>(<argument><expr><name>lockCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>SendMetadataCommandListToWorkerListInCoordinatedTransaction</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(
																		<argument><expr><name>workerNode</name></expr></argument>)</argument_list></call></expr></argument>,
																	<argument><expr><name>currentUser</name></expr></argument>,
																	<argument><expr><call><name>list_make1</name><argument_list>(
																		<argument><expr><name>lockCommand</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * AcquireDistributedLockOnRelations filters relations before passing them to
 * AcquireDistributedLockOnRelations_Internal to acquire the locks.
 *
 * Only tables, views, and foreign tables can be locked with this function. Other relations
 * will cause an error.
 *
 * Skips non distributed relations.
 * configs parameter is used to configure what relation will be locked and if the lock
 * should throw an error if it cannot be acquired immediately
 */</comment>
<function><type><name>void</name></type>
<name>AcquireDistributedLockOnRelations</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>relationList</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockMode</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>configs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ClusterHasKnownMetadataWorkers</name><argument_list>()</argument_list></call> <operator>||</operator> <operator>!</operator><name>EnableMetadataSync</name> <operator>||</operator> <operator>!</operator><name>EnableDDLPropagation</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* used to store the relations that will be locked */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>distributedRelationRecordsList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>nowait</name> <init>= <expr><operator>(</operator><name>configs</name> <operator>&amp;</operator> <name>DIST_LOCK_NOWAIT</name><operator>)</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>rangeVar</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>rangeVar</argument>, <argument>relationList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>rangeVar</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>LockRelationRecord</name> <modifier>*</modifier></type><name>lockRelationRecord</name> <init>= <expr><call><name>MakeLockRelationRecord</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>,
																		<argument><expr><name><name>rangeVar</name><operator>-&gt;</operator><name>inh</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Note that allowing the user to lock shards could lead to
		 * distributed deadlocks due to shards not being locked when
		 * a distributed table is locked.
		 * However, because citus.enable_manual_changes_to_shards
		 * is a guc which is not visible by default, whoever is using this
		 * guc will hopefully know what they're doing and avoid such scenarios.
		 */</comment>
		<expr_stmt><expr><call><name>ErrorIfIllegallyChangingKnownShard</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * we want to prevent under privileged users to trigger establishing connections,
		 * that's why we have this additional check. Otherwise, we'd get the errors as
		 * soon as we execute the command on any node
		 */</comment>
		<expr_stmt><expr><call><name>EnsureCanAcquireLock</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>lockMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>bool</name></type> <name>isView</name> <init>= <expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RELKIND_VIEW</name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>isView</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsViewDistributed</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
			<operator>(</operator><operator>!</operator><name>isView</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ShouldSyncTableMetadata</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>LockRelationRecordListMember</name><argument_list>(<argument><expr><name>distributedRelationRecordsList</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>distributedRelationRecordsList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>distributedRelationRecordsList</name></expr></argument>,
													 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>lockRelationRecord</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>char</name></type> <name>relkind</name> <init>= <expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>relationCanBeReferenced</name> <init>= <expr><operator>(</operator><name>relkind</name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
										<name>relkind</name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name><operator>)</operator></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>relationCanBeReferenced</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name>configs</name> <operator>&amp;</operator> <name>DIST_LOCK_REFERENCING_TABLES</name><operator>)</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>cacheEntry</name> <init>= <expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cacheEntry</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>referencingTableList</name> <init>= <expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>referencingRelationsViaForeignKey</name></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* remove the relations which should not be synced */</comment>
			<expr_stmt><expr><name>referencingTableList</name> <operator>=</operator> <call><name>list_filter_oid</name><argument_list>(<argument><expr><name>referencingTableList</name></expr></argument>,
												   <argument><expr><operator>&amp;</operator><name>ShouldSyncTableMetadata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>distributedRelationRecordsList</name> <operator>=</operator> <call><name>ConcatLockRelationRecordList</name><argument_list>(
				<argument><expr><name>distributedRelationRecordsList</name></expr></argument>, <argument><expr><name>referencingTableList</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>distributedRelationRecordsList</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCoordinator</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>CoordinatorAddedAsWorkerNode</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>!</operator><name>EnableAcquiringUnsafeLockFromWorkers</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
						 <argument><expr><literal type="string">"Cannot acquire a distributed lock from a worker node since the "</literal>
						 <literal type="string">"coordinator is not in the metadata."</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(
						 <argument><expr><literal type="string">"Either run this command on the coordinator or add the coordinator "</literal>
						 <literal type="string">"in the metadata by using: SELECT citus_set_coordinator_host('&lt;hostname&gt;', &lt;port&gt;);\n"</literal>
						 <literal type="string">"Alternatively, though it is not recommended, you can allow this command by running: "</literal>
						 <literal type="string">"SET citus.allow_unsafe_locks_from_workers TO 'on';"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>AcquireDistributedLockOnRelations_Internal</name><argument_list>(<argument><expr><name>distributedRelationRecordsList</name></expr></argument>,
												   <argument><expr><name>lockMode</name></expr></argument>, <argument><expr><name>nowait</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**
 * PreprocessLockStatement makes sure that the lock is allowed
 * before calling AcquireDistributedLockOnRelations on the locked tables/views
 * with flags DIST_LOCK_VIEWS_RECUR and DIST_LOCK_NOWAIT if nowait is true for
 * the lock statement
 */</comment>
<function><type><name>void</name></type>
<name>PreprocessLockStatement</name><parameter_list>(<parameter><decl><type><name>LockStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>ProcessUtilityContext</name></type> <name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>isTopLevel</name> <init>= <expr><name>context</name> <operator>==</operator> <name>PROCESS_UTILITY_TOPLEVEL</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>RequireTransactionBlock</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><literal type="string">"LOCK TABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>uint32</name></type> <name>nowaitFlag</name> <init>= <expr><ternary><condition><expr><name><name>stmt</name><operator>-&gt;</operator><name>nowait</name></name></expr> ?</condition><then> <expr><name>DIST_LOCK_NOWAIT</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>AcquireDistributedLockOnRelations</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relations</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>mode</name></name></expr></argument>, <argument><expr><name>nowaitFlag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
