<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/builded_projects/citus/src/backend/distributed/utils/enable_ssl.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * enable_ssl.c
 *    UDF and Utilities for enabling ssl during citus setup
 *
 * Copyright (c) Citus Data, Inc.
 *
 *-------------------------------------------------------------------------
 */</comment>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<comment type="block">/*
 * Make sure that functions marked as deprecated in OpenSSL 3.0 don't trigger
 * deprecation warnings by indicating that we're using the OpenSSL 1.0.1
 * compatibile API. Postgres does this by already in PG14, so we should not do
 * it otherwise we get warnings about redefining this value. This needs to be
 * done before including libpq.h.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_version_constants.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <name>PG_VERSION_14</name></expr></cpp:if>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>OPENSSL_API_COMPAT</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPENSSL_API_COMPAT</name></cpp:macro> <cpp:value>0x1000100L</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/connection_management.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/libpq.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/parsenodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/postmaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_OPENSSL</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"openssl/dsa.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"openssl/err.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"openssl/pem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"openssl/rsa.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"openssl/ssl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"openssl/x509.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENABLE_SSL_QUERY</name></cpp:macro> <cpp:value>"ALTER SYSTEM SET ssl TO on;"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RESET_CITUS_NODE_CONNINFO</name></cpp:macro> \
	<cpp:value>"ALTER SYSTEM SET citus.node_conninfo TO 'sslmode=prefer';"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CITUS_AUTO_SSL_COMMON_NAME</name></cpp:macro> <cpp:value>"citus-auto-ssl"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>X509_SUBJECT_COMMON_NAME</name></cpp:macro> <cpp:value>"CN"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POSTGRES_DEFAULT_SSL_CIPHERS</name></cpp:macro> <cpp:value>"HIGH:MEDIUM:+3DES:!aNULL"</cpp:value></cpp:define>

<comment type="block">/*
 * Microsoft approved cipher string.
 * This cipher string implicitely enables only TLSv1.2+, because these ciphers
 * were all added in TLSv1.2. This can be confirmed by running:
 * openssl -v &lt;below strings concatenated&gt;
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CITUS_DEFAULT_SSL_CIPHERS</name></cpp:macro> <cpp:value>"ECDHE-ECDSA-AES128-GCM-SHA256:" \
								  "ECDHE-ECDSA-AES256-GCM-SHA384:" \
								  "ECDHE-RSA-AES128-GCM-SHA256:" \
								  "ECDHE-RSA-AES256-GCM-SHA384:" \
								  "ECDHE-ECDSA-AES128-SHA256:" \
								  "ECDHE-ECDSA-AES256-SHA384:" \
								  "ECDHE-RSA-AES128-SHA256:" \
								  "ECDHE-RSA-AES256-SHA384"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_CITUS_SSL_CIPHERS_QUERY</name></cpp:macro> \
	<cpp:value>"ALTER SYSTEM SET ssl_ciphers TO '" CITUS_DEFAULT_SSL_CIPHERS "';"</cpp:value></cpp:define>


<comment type="block">/* forward declaration of helper functions */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>GloballyReloadConfig</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SSL</name></cpp:ifdef>

<comment type="block">/* forward declaration of functions used when compiled with ssl */</comment>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ShouldUseAutoSSL</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>CreateCertificatesWhenNeeded</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>EVP_PKEY</name> <modifier>*</modifier></type> <name>GeneratePrivateKey</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>X509</name> <modifier>*</modifier></type> <name>CreateCertificate</name><parameter_list>(<parameter><decl><type><name>EVP_PKEY</name> <modifier>*</modifier></type><name>privateKey</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>StoreCertificate</name><parameter_list>(<parameter><decl><type><name>EVP_PKEY</name> <modifier>*</modifier></type><name>privateKey</name></decl></parameter>, <parameter><decl><type><name>X509</name> <modifier>*</modifier></type><name>certificate</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_SSL */</comment>


<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>citus_setup_ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>citus_check_defaults_for_sslmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<comment type="block">/*
 * citus_setup_ssl is called during the first creation of a citus extension. It configures
 * postgres to use ssl if not already on. During this process it will create certificates
 * if they are not already installed in the configured location.
 */</comment>
<function><type><name>Datum</name></type>
<name>citus_setup_ssl</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>USE_SSL</name></cpp:ifndef>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"can not setup ssl on postgres that is not compiled with "</literal>
							 <literal type="string">"ssl support"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* USE_SSL */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>EnableSSL</name> <operator>&amp;&amp;</operator> <call><name>ShouldUseAutoSSL</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"citus extension created on postgres without ssl enabled, "</literal>
							 <literal type="string">"turning it on during creation of the extension"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* execute the alter system statement to enable ssl on within postgres */</comment>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>enableSSLParseTree</name> <init>= <expr><call><name>ParseTreeNode</name><argument_list>(<argument><expr><name>ENABLE_SSL_QUERY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>AlterSystemSetConfigFile</name><argument_list>(<argument><expr><operator>(</operator><name>AlterSystemStmt</name> <operator>*</operator><operator>)</operator> <name>enableSSLParseTree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>SSLCipherSuites</name></expr></argument>, <argument><expr><name>POSTGRES_DEFAULT_SSL_CIPHERS</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * postgres default cipher suite is configured, these allow TSL 1 and TLS 1.1,
			 * citus will upgrade to TLS1.2+HIGH and above.
			 */</comment>
			<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>citusSSLCiphersParseTree</name> <init>= <expr><call><name>ParseTreeNode</name><argument_list>(<argument><expr><name>SET_CITUS_SSL_CIPHERS_QUERY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>AlterSystemSetConfigFile</name><argument_list>(<argument><expr><operator>(</operator><name>AlterSystemStmt</name> <operator>*</operator><operator>)</operator> <name>citusSSLCiphersParseTree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * ssl=on requires that a key and certificate are present, since we have
		 * enabled ssl mode here chances are the user didn't install credentials already.
		 *
		 * This function will check if they are available and if not it will generate a
		 * self singed certificate.
		 */</comment>
		<expr_stmt><expr><call><name>CreateCertificatesWhenNeeded</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>GloballyReloadConfig</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_SSL */</comment>

	<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * citus_check_defaults_for_sslmode is called in the extension upgrade path when
 * users upgrade from a previous version to a version that has ssl enabled by default, and
 * only when the changed default value conflicts with the setup of the user.
 *
 * Once it is determined that the default value for citus.node_conninfo is used verbatim
 * with ssl not enabled on the cluster it will reinstate the old default value for
 * citus.node_conninfo.
 *
 * In effect this is to not impose the overhead of ssl on an already existing cluster that
 * didn't have it enabled already.
 */</comment>
<function><type><name>Datum</name></type>
<name>citus_check_defaults_for_sslmode</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>configChanged</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>EnableSSL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* since ssl is on we do not have to change any sslmode back to prefer */</comment>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * test if the node_conninfo setting is exactly set to the default value used when
	 * Citus started to enable SSL. This is to make sure upgrades restores the previous
	 * value so users will not have unexpected changes during upgrades.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>NodeConninfo</name></expr></argument>, <argument><expr><literal type="string">"sslmode=require"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* execute the alter system statement to reset node_conninfo to the old default */</comment>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"reset citus.node_conninfo to old default value as the new "</literal>
							 <literal type="string">"value is incompatible with the current ssl setting"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>resetCitusNodeConnInfoParseTree</name> <init>= <expr><call><name>ParseTreeNode</name><argument_list>(<argument><expr><name>RESET_CITUS_NODE_CONNINFO</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>AlterSystemSetConfigFile</name><argument_list>(<argument><expr><operator>(</operator><name>AlterSystemStmt</name> <operator>*</operator><operator>)</operator> <name>resetCitusNodeConnInfoParseTree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>configChanged</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>configChanged</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>GloballyReloadConfig</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * GloballyReloadConfig signals postmaster to reload the configuration as well as
 * reloading the configuration in the current backend. By reloading the configuration in
 * the current backend the changes will also be reflected in the current transaction.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>GloballyReloadConfig</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>kill</name><argument_list>(<argument><expr><name>PostmasterPid</name></expr></argument>, <argument><expr><name>SIGHUP</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failed to send signal to postmaster: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>ProcessConfigFile</name><argument_list>(<argument><expr><name>PGC_SIGHUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SSL</name></cpp:ifdef>


<comment type="block">/*
 * ShouldUseAutoSSL checks if citus should enable ssl based on the connection settings it
 * uses for outward connections. When the outward connection is configured to require ssl
 * it assumes the other nodes in the network have the same setting and therefore it will
 * automatically enable ssl during installation.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ShouldUseAutoSSL</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sslmode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>sslmode</name> <operator>=</operator> <call><name>GetConnParam</name><argument_list>(<argument><expr><literal type="string">"sslmode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>sslmode</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>sslmode</name></expr></argument>, <argument><expr><literal type="string">"require"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateCertificatesWhenNeeded checks if the certificates exists. When they don't exist
 * they will be created. The return value tells whether or not new certificates have been
 * created. After this function it is guaranteed that certificates are in place. It is not
 * guaranteed they have the right permissions as we will not touch the keys if they exist.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>CreateCertificatesWhenNeeded</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EVP_PKEY</name> <modifier>*</modifier></type><name>privateKey</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>X509</name> <modifier>*</modifier></type><name>certificate</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>certificateWritten</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SSL_CTX</name> <modifier>*</modifier></type><name>sslContext</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Since postgres might not have initialized ssl at this point we need to initialize
	 * it our self to be able to create a context. This code is less extensive then
	 * postgres' initialization but that will happen when postgres reloads its
	 * configuration with ssl enabled.
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_OPENSSL_INIT_SSL</name></cpp:ifdef>
	<expr_stmt><expr><call><name>OPENSSL_init_ssl</name><argument_list>(<argument><expr><name>OPENSSL_INIT_LOAD_CONFIG</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>SSL_library_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>sslContext</name> <operator>=</operator> <call><name>SSL_CTX_new</name><argument_list>(<argument><expr><call><name>SSLv23_method</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sslContext</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unable to create ssl context, please verify ssl "</literal>
								 <literal type="string">"settings for postgres"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						  <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Citus could not create the ssl context to verify "</literal>
									<literal type="string">"the ssl settings for postgres and possibly setup "</literal>
									<literal type="string">"certificates. Since Citus requires connections "</literal>
									<literal type="string">"between nodes to use ssl communication between "</literal>
									<literal type="string">"nodes might return an error until ssl is setup "</literal>
									<literal type="string">"correctly."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>EnsureReleaseResource</name><argument_list>(<argument><expr><operator>(</operator><name>MemoryContextCallbackFunction</name><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name>SSL_CTX_free</name><operator>)</operator></expr></argument>,
						  <argument><expr><name>sslContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * check if we can load the certificate, when we can we assume the certificates are in
	 * place. No need to create the certificates and we can exit the function.
	 *
	 * This also makes the whole ssl enabling idempotent as writing the certificate is the
	 * last step.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>SSL_CTX_use_certificate_chain_file</name><argument_list>(<argument><expr><name>sslContext</name></expr></argument>, <argument><expr><name>ssl_cert_file</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no certificate present, generating self signed certificate"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>privateKey</name> <operator>=</operator> <call><name>GeneratePrivateKey</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>privateKey</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"error while generating private key"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>certificate</name> <operator>=</operator> <call><name>CreateCertificate</name><argument_list>(<argument><expr><name>privateKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>certificate</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"error while generating certificate"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>certificateWritten</name> <operator>=</operator> <call><name>StoreCertificate</name><argument_list>(<argument><expr><name>privateKey</name></expr></argument>, <argument><expr><name>certificate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>certificateWritten</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"error while storing key and certificate"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GeneratePrivateKey uses open ssl functions to generate an RSA private key of 2048 bits.
 * All OpenSSL resources created during the process are added to the memory context active
 * when the function is called and therefore should not be freed by the caller.
 */</comment>
<function><type><specifier>static</specifier> <name>EVP_PKEY</name> <modifier>*</modifier></type>
<name>GeneratePrivateKey</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<comment type="block">/* Allocate memory for the EVP_PKEY structure. */</comment>
	<decl_stmt><decl><type><name>EVP_PKEY</name> <modifier>*</modifier></type><name>privateKey</name> <init>= <expr><call><name>EVP_PKEY_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>privateKey</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unable to allocate space for private key"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>EnsureReleaseResource</name><argument_list>(<argument><expr><operator>(</operator><name>MemoryContextCallbackFunction</name><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name>EVP_PKEY_free</name><operator>)</operator></expr></argument>,
						  <argument><expr><name>privateKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>BIGNUM</name> <modifier>*</modifier></type><name>exponent</name> <init>= <expr><call><name>BN_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>EnsureReleaseResource</name><argument_list>(<argument><expr><operator>(</operator><name>MemoryContextCallbackFunction</name><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name>BN_free</name><operator>)</operator></expr></argument>, <argument><expr><name>exponent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* load the exponent to use for the generation of the key */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>success</name> <init>= <expr><call><name>BN_set_word</name><argument_list>(<argument><expr><name>exponent</name></expr></argument>, <argument><expr><name>RSA_F4</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>success</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unable to prepare exponent for RSA algorithm"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>RSA</name> <modifier>*</modifier></type><name>rsa</name> <init>= <expr><call><name>RSA_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>RSA_generate_key_ex</name><argument_list>(<argument><expr><name>rsa</name></expr></argument>, <argument><expr><literal type="number">2048</literal></expr></argument>, <argument><expr><name>exponent</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>success</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unable to generate RSA key"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>EVP_PKEY_assign_RSA</name><argument_list>(<argument><expr><name>privateKey</name></expr></argument>, <argument><expr><name>rsa</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unable to assign RSA key to use as private key"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* The key has been generated, return it. */</comment>
	<return>return <expr><name>privateKey</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateCertificate creates a self signed certificate for citus to use. The certificate
 * will contain the public parts of the private key and will be signed in the end by the
 * private part to make it self signed.
 */</comment>
<function><type><specifier>static</specifier> <name>X509</name> <modifier>*</modifier></type>
<name>CreateCertificate</name><parameter_list>(<parameter><decl><type><name>EVP_PKEY</name> <modifier>*</modifier></type><name>privateKey</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>X509</name> <modifier>*</modifier></type><name>certificate</name> <init>= <expr><call><name>X509_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>certificate</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unable to allocate space for the x509 certificate"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>EnsureReleaseResource</name><argument_list>(<argument><expr><operator>(</operator><name>MemoryContextCallbackFunction</name><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name>X509_free</name><operator>)</operator></expr></argument>,
						  <argument><expr><name>certificate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set the serial number. */</comment>
	<expr_stmt><expr><call><name>ASN1_INTEGER_set</name><argument_list>(<argument><expr><call><name>X509_get_serialNumber</name><argument_list>(<argument><expr><name>certificate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set the expiry of the certificate.
	 *
	 * the functions X509_get_notBefore and X509_get_notAfter are deprecated, these are
	 * replaced with mutable and non-mutable variants in openssl 1.1, however they are
	 * better supported than the newer versions. In 1.1 they are aliasses to the mutable
	 * variant (X509_getm_notBefore, ...) that we actually need, so they will actually use
	 * the correct function in newer versions.
	 *
	 * Postgres does not check the validity on the certificates, but we can't omit the
	 * dates either to create a certificate that can be parsed. We settled on a validity
	 * of 0 seconds. When postgres would fix the validity check in a future version it
	 * would fail right after an upgrade. Instead of working until the certificate
	 * expiration date and then suddenly erroring out.
	 */</comment>
	<expr_stmt><expr><call><name>X509_gmtime_adj</name><argument_list>(<argument><expr><call><name>X509_get_notBefore</name><argument_list>(<argument><expr><name>certificate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>X509_gmtime_adj</name><argument_list>(<argument><expr><call><name>X509_get_notAfter</name><argument_list>(<argument><expr><name>certificate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set the public key for our certificate */</comment>
	<expr_stmt><expr><call><name>X509_set_pubkey</name><argument_list>(<argument><expr><name>certificate</name></expr></argument>, <argument><expr><name>privateKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set the common name for the certificate */</comment>
	<decl_stmt><decl><type><name>X509_NAME</name> <modifier>*</modifier></type><name>subjectName</name> <init>= <expr><call><name>X509_get_subject_name</name><argument_list>(<argument><expr><name>certificate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>X509_NAME_add_entry_by_txt</name><argument_list>(<argument><expr><name>subjectName</name></expr></argument>, <argument><expr><name>X509_SUBJECT_COMMON_NAME</name></expr></argument>, <argument><expr><name>MBSTRING_ASC</name></expr></argument>,
							   <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>CITUS_AUTO_SSL_COMMON_NAME</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
							   <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* For a self signed certificate we set the isser name to our own name */</comment>
	<expr_stmt><expr><call><name>X509_set_issuer_name</name><argument_list>(<argument><expr><name>certificate</name></expr></argument>, <argument><expr><name>subjectName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* With all information filled out we sign the certificate with our own key */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>X509_sign</name><argument_list>(<argument><expr><name>certificate</name></expr></argument>, <argument><expr><name>privateKey</name></expr></argument>, <argument><expr><call><name>EVP_sha256</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unable to create signature for the x509 certificate"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>certificate</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * StoreCertificate stores both the private key and its certificate to the files
 * configured in postgres.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>StoreCertificate</name><parameter_list>(<parameter><decl><type><name>EVP_PKEY</name> <modifier>*</modifier></type><name>privateKey</name></decl></parameter>, <parameter><decl><type><name>X509</name> <modifier>*</modifier></type><name>certificate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>privateKeyFilename</name> <init>= <expr><name>ssl_key_file</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>certificateFilename</name> <init>= <expr><name>ssl_cert_file</name></expr></init></decl>;</decl_stmt>


	<comment type="block">/* Open the private key file and write the private key in PEM format to it */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>privateKeyFileDescriptor</name> <init>= <expr><call><name>open</name><argument_list>(<argument><expr><name>privateKeyFilename</name></expr></argument>, <argument><expr><name>O_WRONLY</name> <operator>|</operator> <name>O_CREAT</name></expr></argument>, <argument><expr><literal type="number">0600</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>privateKeyFileDescriptor</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unable to open private key file '%s' for writing"</literal></expr></argument>,
							   <argument><expr><name>privateKeyFilename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>privateKeyFile</name> <init>= <expr><call><name>fdopen</name><argument_list>(<argument><expr><name>privateKeyFileDescriptor</name></expr></argument>, <argument><expr><literal type="string">"wb"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>privateKeyFile</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unable to open private key file '%s' for writing"</literal></expr></argument>,
							   <argument><expr><name>privateKeyFilename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>success</name> <init>= <expr><call><name>PEM_write_PrivateKey</name><argument_list>(<argument><expr><name>privateKeyFile</name></expr></argument>, <argument><expr><name>privateKey</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
									   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>privateKeyFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unable to store private key"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>certificateFileDescriptor</name> <init>= <expr><call><name>open</name><argument_list>(<argument><expr><name>certificateFilename</name></expr></argument>, <argument><expr><name>O_WRONLY</name> <operator>|</operator> <name>O_CREAT</name></expr></argument>, <argument><expr><literal type="number">0600</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>certificateFileDescriptor</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unable to open private key file '%s' for writing"</literal></expr></argument>,
							   <argument><expr><name>privateKeyFilename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Open the certificate file and write the certificate in the PEM format to it */</comment>
	<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>certificateFile</name> <init>= <expr><call><name>fdopen</name><argument_list>(<argument><expr><name>certificateFileDescriptor</name></expr></argument>, <argument><expr><literal type="string">"wb"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>certificateFile</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unable to open certificate file '%s' for writing"</literal></expr></argument>,
							   <argument><expr><name>certificateFilename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>PEM_write_X509</name><argument_list>(<argument><expr><name>certificateFile</name></expr></argument>, <argument><expr><name>certificate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>certificateFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unable to store certificate"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_SSL */</comment>
</unit>
