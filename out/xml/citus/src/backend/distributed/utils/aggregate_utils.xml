<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/builded_projects/citus/src/backend/distributed/utils/aggregate_utils.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * aggregate_utils.c
 *
 * Implementation of UDFs distributing execution of aggregates across workers.
 *
 * When an aggregate has a combinefunc, we use worker_partial_agg to skip
 * calling finalfunc on workers, instead passing state to coordinator where
 * it uses combinefunc in coord_combine_agg &amp; applying finalfunc only at end.
 *
 * Copyright Citus Data, Inc.
 *
 *-------------------------------------------------------------------------
 */</comment>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_aggregate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/version_compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_config_manual.h"</cpp:file></cpp:include>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>worker_partial_agg_sfunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>worker_partial_agg_ffunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>coord_combine_agg_sfunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>coord_combine_agg_ffunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
 * Holds information describing the structure of aggregation arguments
 * and helps to efficiently handle both a single argument and multiple
 * arguments wrapped in a tuple/record. It exploits the fact that
 * aggregation argument types do not change between subsequent
 * calls to SFUNC.
 */</comment>
<typedef>typedef <type><struct>struct <name>AggregationArgumentContext</name>
<block>{
	<comment type="block">/* immutable fields */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>argumentCount</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl>;</decl_stmt>

	<comment type="block">/* mutable fields */</comment>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
}</block></struct></type> <name>AggregationArgumentContext</name>;</typedef>

<comment type="block">/*
 * internal type for support aggregates to pass transition state alongside
 * aggregation bookkeeping
 */</comment>
<typedef>typedef <type><struct>struct <name>StypeBox</name>
<block>{
	<decl_stmt><decl><type><name>Datum</name></type> <name>value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>agg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>transtype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16_t</name></type> <name>transtypeLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>transtypeByVal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>valueNull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>valueInit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AggregationArgumentContext</name> <modifier>*</modifier></type><name>aggregationArgumentContext</name></decl>;</decl_stmt>
}</block></struct></type> <name>StypeBox</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>HeapTuple</name></type> <name>GetAggregateForm</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>, <parameter><decl><type><name>Form_pg_aggregate</name> <modifier>*</modifier></type><name>form</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HeapTuple</name></type> <name>GetProcForm</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>, <parameter><decl><type><name>Form_pg_proc</name> <modifier>*</modifier></type><name>form</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HeapTuple</name></type> <name>GetTypeForm</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>, <parameter><decl><type><name>Form_pg_type</name> <modifier>*</modifier></type><name>form</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type> <name>pallocInAggContext</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>aclcheckAggregate</name><parameter_list>(<parameter><decl><type><name>ObjectType</name></type> <name>objectType</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>userOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>funcOid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>GetAggInitVal</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>textInitVal</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>transtype</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>InitializeStypeBox</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>StypeBox</name> <modifier>*</modifier></type><name>box</name></decl></parameter>,
							   <parameter><decl><type><name>HeapTuple</name></type> <name>aggTuple</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>transtype</name></decl></parameter>,
							   <parameter><decl><type><name>AggregationArgumentContext</name> <modifier>*</modifier></type><name>aggregationArgumentContext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>StypeBox</name> <modifier>*</modifier></type> <name>TryCreateStypeBoxFromFcinfoAggref</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>AggregationArgumentContext</name> <modifier>*</modifier></type> <name>CreateAggregationArgumentContext</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type>
																	 <name>fcinfo</name></decl></parameter>,
																	 <parameter><decl><type><name>int</name></type> <name>argumentIndex</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExtractAggregationValues</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argumentIndex</name></decl></parameter>,
									 <parameter><decl><type><name>AggregationArgumentContext</name>
									 <modifier>*</modifier></type><name>aggregationArgumentContext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>HandleTransition</name><parameter_list>(<parameter><decl><type><name>StypeBox</name> <modifier>*</modifier></type><name>box</name></decl></parameter>, <parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>,
							 <parameter><decl><type><name>FunctionCallInfo</name></type> <name>innerFcinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>HandleStrictUninit</name><parameter_list>(<parameter><decl><type><name>StypeBox</name> <modifier>*</modifier></type><name>box</name></decl></parameter>, <parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>TypecheckWorkerPartialAggArgType</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>StypeBox</name> <modifier>*</modifier></type><name>box</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>TypecheckCoordCombineAggReturnType</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>ffunc</name></decl></parameter>,
											   <parameter><decl><type><name>StypeBox</name> <modifier>*</modifier></type><name>box</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * GetAggregateForm loads corresponding tuple &amp; Form_pg_aggregate for oid
 */</comment>
<function><type><specifier>static</specifier> <name>HeapTuple</name></type>
<name>GetAggregateForm</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>, <parameter><decl><type><name>Form_pg_aggregate</name> <modifier>*</modifier></type><name>form</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name> <init>= <expr><call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>AGGFNOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"citus cache lookup failed for aggregate %u"</literal></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>form</name> <operator>=</operator> <operator>(</operator><name>Form_pg_aggregate</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>tuple</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetProcForm loads corresponding tuple &amp; Form_pg_proc for oid
 */</comment>
<function><type><specifier>static</specifier> <name>HeapTuple</name></type>
<name>GetProcForm</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>, <parameter><decl><type><name>Form_pg_proc</name> <modifier>*</modifier></type><name>form</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name> <init>= <expr><call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"citus cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>form</name> <operator>=</operator> <operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>tuple</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetTypeForm loads corresponding tuple &amp; Form_pg_type for oid
 */</comment>
<function><type><specifier>static</specifier> <name>HeapTuple</name></type>
<name>GetTypeForm</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>, <parameter><decl><type><name>Form_pg_type</name> <modifier>*</modifier></type><name>form</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name> <init>= <expr><call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"citus cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>form</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>tuple</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * pallocInAggContext calls palloc in fcinfo's aggregate context
 */</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>pallocInAggContext</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>aggregateContext</name></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AggCheckCallContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aggregateContext</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Aggregate function called without an aggregate context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>aggregateContext</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * aclcheckAggregate verifies that the given user has ACL_EXECUTE to the given proc
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>aclcheckAggregate</name><parameter_list>(<parameter><decl><type><name>ObjectType</name></type> <name>objectType</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>userOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>funcOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AclResult</name></type> <name>aclresult</name></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>funcOid</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_proc_aclcheck</name><argument_list>(<argument><expr><name>funcOid</name></expr></argument>, <argument><expr><name>userOid</name></expr></argument>, <argument><expr><name>ACL_EXECUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>objectType</name></expr></argument>, <argument><expr><call><name>get_func_name</name><argument_list>(<argument><expr><name>funcOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/* Copied from nodeAgg.c */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>GetAggInitVal</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>textInitVal</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>transtype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* *INDENT-OFF* */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typinput</name></decl>,
				<decl><type ref="prev"/><name>typioparam</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>strInitVal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>initVal</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>getTypeInputInfo</name><argument_list>(<argument><expr><name>transtype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typinput</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typioparam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>strInitVal</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>textInitVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>initVal</name> <operator>=</operator> <call><name>OidInputFunctionCall</name><argument_list>(<argument><expr><name>typinput</name></expr></argument>, <argument><expr><name>strInitVal</name></expr></argument>,
								   <argument><expr><name>typioparam</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>strInitVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>initVal</name></expr>;</return>
	<comment type="block">/* *INDENT-ON* */</comment>
</block_content>}</block></function>


<comment type="block">/*
 * InitializeStypeBox fills in the rest of an StypeBox's fields besides agg,
 * handling both permission checking &amp; setting up the initial transition state.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>InitializeStypeBox</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>StypeBox</name> <modifier>*</modifier></type><name>box</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>aggTuple</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type>
				   <name>transtype</name></decl></parameter>, <parameter><decl><type><name>AggregationArgumentContext</name> <modifier>*</modifier></type><name>aggregationArgumentContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_aggregate</name></type> <name>aggform</name> <init>= <expr><operator>(</operator><name>Form_pg_aggregate</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>aggTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>userId</name> <init>= <expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* First we make ACL_EXECUTE checks as would be done in nodeAgg.c */</comment>
	<expr_stmt><expr><call><name>aclcheckAggregate</name><argument_list>(<argument><expr><name>OBJECT_AGGREGATE</name></expr></argument>, <argument><expr><name>userId</name></expr></argument>, <argument><expr><name><name>aggform</name><operator>-&gt;</operator><name>aggfnoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>aclcheckAggregate</name><argument_list>(<argument><expr><name>OBJECT_FUNCTION</name></expr></argument>, <argument><expr><name>userId</name></expr></argument>, <argument><expr><name><name>aggform</name><operator>-&gt;</operator><name>aggfinalfn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>aclcheckAggregate</name><argument_list>(<argument><expr><name>OBJECT_FUNCTION</name></expr></argument>, <argument><expr><name>userId</name></expr></argument>, <argument><expr><name><name>aggform</name><operator>-&gt;</operator><name>aggtransfn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>aclcheckAggregate</name><argument_list>(<argument><expr><name>OBJECT_FUNCTION</name></expr></argument>, <argument><expr><name>userId</name></expr></argument>, <argument><expr><name><name>aggform</name><operator>-&gt;</operator><name>aggdeserialfn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>aclcheckAggregate</name><argument_list>(<argument><expr><name>OBJECT_FUNCTION</name></expr></argument>, <argument><expr><name>userId</name></expr></argument>, <argument><expr><name><name>aggform</name><operator>-&gt;</operator><name>aggserialfn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>aclcheckAggregate</name><argument_list>(<argument><expr><name>OBJECT_FUNCTION</name></expr></argument>, <argument><expr><name>userId</name></expr></argument>, <argument><expr><name><name>aggform</name><operator>-&gt;</operator><name>aggcombinefn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Datum</name></type> <name>textInitVal</name> <init>= <expr><call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>AGGFNOID</name></expr></argument>, <argument><expr><name>aggTuple</name></expr></argument>,
										<argument><expr><name>Anum_pg_aggregate_agginitval</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name><name>box</name><operator>-&gt;</operator><name>valueNull</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>box</name><operator>-&gt;</operator><name>transtype</name></name> <operator>=</operator> <name>transtype</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>box</name><operator>-&gt;</operator><name>valueInit</name></name> <operator>=</operator> <operator>!</operator><name><name>box</name><operator>-&gt;</operator><name>valueNull</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>box</name><operator>-&gt;</operator><name>aggregationArgumentContext</name></name> <operator>=</operator> <name>aggregationArgumentContext</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>box</name><operator>-&gt;</operator><name>valueNull</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>box</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>aggregateContext</name></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AggCheckCallContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aggregateContext</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"InitializeStypeBox called from non aggregate context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>aggregateContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>box</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <call><name>GetAggInitVal</name><argument_list>(<argument><expr><name>textInitVal</name></expr></argument>, <argument><expr><name>transtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * TryCreateStypeBoxFromFcinfoAggref attempts to initialize an StypeBox through
 * introspection of the fcinfo's Aggref from AggGetAggref. This is required
 * when we receive no intermediate rows.
 *
 * Returns NULL if the Aggref isn't our expected shape.
 */</comment>
<function><type><specifier>static</specifier> <name>StypeBox</name> <modifier>*</modifier></type>
<name>TryCreateStypeBoxFromFcinfoAggref</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>aggref</name> <init>= <expr><call><name>AggGetAggref</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>aggref</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>aggref</name><operator>-&gt;</operator><name>args</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>aggArg</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>aggArg</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>aggConst</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name><name>aggArg</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>aggConst</name><operator>-&gt;</operator><name>consttype</name></name> <operator>!=</operator> <name>OIDOID</name> <operator>&amp;&amp;</operator> <name><name>aggConst</name><operator>-&gt;</operator><name>consttype</name></name> <operator>!=</operator> <name>REGPROCEDUREOID</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Form_pg_aggregate</name></type> <name>aggform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StypeBox</name> <modifier>*</modifier></type><name>box</name> <init>= <expr><call><name>pallocInAggContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>StypeBox</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>box</name><operator>-&gt;</operator><name>agg</name></name> <operator>=</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name><name>aggConst</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>aggTuple</name> <init>= <expr><call><name>GetAggregateForm</name><argument_list>(<argument><expr><name><name>box</name><operator>-&gt;</operator><name>agg</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aggform</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>InitializeStypeBox</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>box</name></expr></argument>, <argument><expr><name>aggTuple</name></expr></argument>, <argument><expr><name><name>aggform</name><operator>-&gt;</operator><name>aggtranstype</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>aggTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>box</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateAggregationArgumentContext creates an AggregationArgumentContext tailored
 * to handling the aggregation of input arguments identical to type at
 * 'argumentIndex' in 'fcinfo'.
 */</comment>
<function><type><specifier>static</specifier> <name>AggregationArgumentContext</name> <modifier>*</modifier></type>
<name>CreateAggregationArgumentContext</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argumentIndex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AggregationArgumentContext</name> <modifier>*</modifier></type><name>aggregationArgumentContext</name> <init>=
		<expr><call><name>pallocInAggContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AggregationArgumentContext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* check if input comes combined into tuple/record */</comment>
	<if_stmt><if>if <condition>(<expr><name>RECORDOID</name> <operator>==</operator> <call><name>get_fn_expr_argtype</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>, <argument><expr><name>argumentIndex</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* initialize context to handle aggregation argument combined into tuple */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>fcGetArgNull</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>argumentIndex</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"worker_partial_agg_sfunc: null record input"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Elements of record may be null"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* retrieve tuple header */</comment>
		<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>tupleHeader</name> <init>= <expr><call><name>PG_GETARG_HEAPTUPLEHEADER</name><argument_list>(<argument><expr><name>argumentIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* extract type info from the tuple */</comment>
		<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name> <init>=
			<expr><call><name>lookup_rowtype_tupdesc</name><argument_list>(<argument><expr><call><name>HeapTupleHeaderGetTypeId</name><argument_list>(<argument><expr><name>tupleHeader</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><call><name>HeapTupleHeaderGetTypMod</name><argument_list>(<argument><expr><name>tupleHeader</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* create a copy we can keep */</comment>
		<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDescCopy</name> <init>= <expr><call><name>pallocInAggContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><call><name>TupleDescSize</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>TupleDescCopy</name><argument_list>(<argument><expr><name>tupleDescCopy</name></expr></argument>, <argument><expr><name>tupleDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseTupleDesc</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* build a HeapTuple control structure */</comment>
		<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name> <init>= <expr><call><name>pallocInAggContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HeapTupleData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_tableOid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>

		<comment type="block">/* initialize context to handle multiple aggregation arguments */</comment>
		<expr_stmt><expr><name><name>aggregationArgumentContext</name><operator>-&gt;</operator><name>argumentCount</name></name> <operator>=</operator> <name><name>tupleDescCopy</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>aggregationArgumentContext</name><operator>-&gt;</operator><name>values</name></name> <operator>=</operator>
			<call><name>pallocInAggContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name><name>tupleDescCopy</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>aggregationArgumentContext</name><operator>-&gt;</operator><name>nulls</name></name> <operator>=</operator>
			<call><name>pallocInAggContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name><name>tupleDescCopy</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>aggregationArgumentContext</name><operator>-&gt;</operator><name>isTuple</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>aggregationArgumentContext</name><operator>-&gt;</operator><name>tupleDesc</name></name> <operator>=</operator> <name>tupleDescCopy</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>aggregationArgumentContext</name><operator>-&gt;</operator><name>tuple</name></name> <operator>=</operator> <name>tuple</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* initialize context to handle single aggregation argument */</comment>
		<expr_stmt><expr><name><name>aggregationArgumentContext</name><operator>-&gt;</operator><name>argumentCount</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>aggregationArgumentContext</name><operator>-&gt;</operator><name>values</name></name> <operator>=</operator> <call><name>pallocInAggContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>aggregationArgumentContext</name><operator>-&gt;</operator><name>nulls</name></name> <operator>=</operator> <call><name>pallocInAggContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>aggregationArgumentContext</name><operator>-&gt;</operator><name>isTuple</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>aggregationArgumentContext</name><operator>-&gt;</operator><name>tupleDesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>aggregationArgumentContext</name><operator>-&gt;</operator><name>tuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>aggregationArgumentContext</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExtractAggregationValues extracts aggregation argument values and stores them in
 * the mutable fields of AggregationArgumentContext.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExtractAggregationValues</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argumentIndex</name></decl></parameter>,
						 <parameter><decl><type><name>AggregationArgumentContext</name> <modifier>*</modifier></type><name>aggregationArgumentContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>aggregationArgumentContext</name><operator>-&gt;</operator><name>isTuple</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>fcGetArgNull</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>argumentIndex</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* handle null record input */</comment>
			<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>aggregationArgumentContext</name><operator>-&gt;</operator><name>argumentCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name><name>aggregationArgumentContext</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>aggregationArgumentContext</name><operator>-&gt;</operator><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* handle tuple/record input */</comment>
			<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>tupleHeader</name> <init>=
				<expr><call><name>DatumGetHeapTupleHeader</name><argument_list>(<argument><expr><call><name>fcGetArgValue</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>argumentIndex</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>HeapTupleHeaderGetNatts</name><argument_list>(<argument><expr><name>tupleHeader</name></expr></argument>)</argument_list></call> <operator>!=</operator>
				<name><name>aggregationArgumentContext</name><operator>-&gt;</operator><name>argumentCount</name></name> <operator>||</operator>
				<call><name>HeapTupleHeaderGetTypeId</name><argument_list>(<argument><expr><name>tupleHeader</name></expr></argument>)</argument_list></call> <operator>!=</operator>
				<name><name>aggregationArgumentContext</name><operator>-&gt;</operator><name>tupleDesc</name><operator>-&gt;</operator><name>tdtypeid</name></name> <operator>||</operator>
				<call><name>HeapTupleHeaderGetTypMod</name><argument_list>(<argument><expr><name>tupleHeader</name></expr></argument>)</argument_list></call> <operator>!=</operator>
				<name><name>aggregationArgumentContext</name><operator>-&gt;</operator><name>tupleDesc</name><operator>-&gt;</operator><name>tdtypmod</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"worker_partial_agg_sfunc received "</literal>
									   <literal type="string">"incompatible record"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name><name>aggregationArgumentContext</name><operator>-&gt;</operator><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name> <operator>=</operator>
				<call><name>HeapTupleHeaderGetDatumLength</name><argument_list>(<argument><expr><name>tupleHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>aggregationArgumentContext</name><operator>-&gt;</operator><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name> <operator>=</operator> <name>tupleHeader</name></expr>;</expr_stmt>

			<comment type="block">/* break down the tuple into fields */</comment>
			<expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(
				<argument><expr><name><name>aggregationArgumentContext</name><operator>-&gt;</operator><name>tuple</name></name></expr></argument>,
				<argument><expr><name><name>aggregationArgumentContext</name><operator>-&gt;</operator><name>tupleDesc</name></name></expr></argument>,
				<argument><expr><name><name>aggregationArgumentContext</name><operator>-&gt;</operator><name>values</name></name></expr></argument>,
				<argument><expr><name><name>aggregationArgumentContext</name><operator>-&gt;</operator><name>nulls</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* extract single argument value */</comment>
		<expr_stmt><expr><name><name>aggregationArgumentContext</name><operator>-&gt;</operator><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>fcGetArgValue</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>argumentIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>aggregationArgumentContext</name><operator>-&gt;</operator><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>fcGetArgNull</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>argumentIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * HandleTransition copies logic used in nodeAgg's advance_transition_function
 * for handling result of transition function.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>HandleTransition</name><parameter_list>(<parameter><decl><type><name>StypeBox</name> <modifier>*</modifier></type><name>box</name></decl></parameter>, <parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>FunctionCallInfo</name></type> <name>innerFcinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type> <name>newVal</name> <init>= <expr><call><name>FunctionCallInvoke</name><argument_list>(<argument><expr><name>innerFcinfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>newValIsNull</name> <init>= <expr><name><name>innerFcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>box</name><operator>-&gt;</operator><name>transtypeByVal</name></name> <operator>&amp;&amp;</operator>
		<call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>newVal</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>box</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>newValIsNull</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MemoryContext</name></type> <name>aggregateContext</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AggCheckCallContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aggregateContext</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					 <argument><expr><literal type="string">"HandleTransition called from non aggregate context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>aggregateContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>DatumIsReadWriteExpandedObject</name><argument_list>(<argument><expr><name>newVal</name></expr></argument>,
												 <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>box</name><operator>-&gt;</operator><name>transtypeLen</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				  <call><name>MemoryContextGetParent</name><argument_list>(<argument><expr><call><name>DatumGetEOHP</name><argument_list>(<argument><expr><name>newVal</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>eoh_context</name></expr></argument>)</argument_list></call> <operator>==</operator>
				  <name>CurrentMemoryContext</name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>newVal</name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name>newVal</name></expr></argument>, <argument><expr><name><name>box</name><operator>-&gt;</operator><name>transtypeByVal</name></name></expr></argument>, <argument><expr><name><name>box</name><operator>-&gt;</operator><name>transtypeLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>box</name><operator>-&gt;</operator><name>valueNull</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>DatumIsReadWriteExpandedObject</name><argument_list>(<argument><expr><name><name>box</name><operator>-&gt;</operator><name>value</name></name></expr></argument>,
											   <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>box</name><operator>-&gt;</operator><name>transtypeLen</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>DeleteExpandedObject</name><argument_list>(<argument><expr><name><name>box</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>box</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>box</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name>newVal</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>box</name><operator>-&gt;</operator><name>valueNull</name></name> <operator>=</operator> <name>newValIsNull</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * HandleStrictUninit handles initialization of state for when
 * transition function is strict &amp; state has not yet been initialized.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>HandleStrictUninit</name><parameter_list>(<parameter><decl><type><name>StypeBox</name> <modifier>*</modifier></type><name>box</name></decl></parameter>, <parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>aggregateContext</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AggCheckCallContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aggregateContext</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"HandleStrictUninit called from non aggregate context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>aggregateContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>box</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name><name>box</name><operator>-&gt;</operator><name>transtypeByVal</name></name></expr></argument>, <argument><expr><name><name>box</name><operator>-&gt;</operator><name>transtypeLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>box</name><operator>-&gt;</operator><name>valueNull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>box</name><operator>-&gt;</operator><name>valueInit</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * worker_partial_agg_sfunc advances transition state,
 * essentially implementing the following pseudocode:
 *
 * (box, agg, ...) -&gt; box
 * box.agg = agg;
 * box.value = agg.sfunc(box.value, ...);
 * return box
 */</comment>
<function><type><name>Datum</name></type>
<name>worker_partial_agg_sfunc</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StypeBox</name> <modifier>*</modifier></type><name>box</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_aggregate</name></type> <name>aggform</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>LOCAL_FCINFO</name><argument_list>(<argument><expr><name>innerFcinfo</name></expr></argument>, <argument><expr><name>FUNC_MAX_ARGS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name></type> <name>info</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>argumentIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>initialCall</name> <init>= <expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>initialCall</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"worker_partial_agg_sfunc received invalid null "</literal>
								   <literal type="string">"input for second argument"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>box</name> <operator>=</operator> <call><name>pallocInAggContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>StypeBox</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>box</name><operator>-&gt;</operator><name>agg</name></name> <operator>=</operator> <call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>box</name><operator>-&gt;</operator><name>aggregationArgumentContext</name></name> <operator>=</operator> <call><name>CreateAggregationArgumentContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TypecheckWorkerPartialAggArgType</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>box</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"worker_partial_agg_sfunc could not confirm type "</literal>
								   <literal type="string">"correctness"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>box</name> <operator>=</operator> <operator>(</operator><name>StypeBox</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>box</name><operator>-&gt;</operator><name>agg</name></name> <operator>==</operator> <call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>aggtuple</name> <init>= <expr><call><name>GetAggregateForm</name><argument_list>(<argument><expr><name><name>box</name><operator>-&gt;</operator><name>agg</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aggform</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>aggsfunc</name> <init>= <expr><name><name>aggform</name><operator>-&gt;</operator><name>aggtransfn</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>initialCall</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>InitializeStypeBox</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>box</name></expr></argument>, <argument><expr><name>aggtuple</name></expr></argument>, <argument><expr><name><name>aggform</name><operator>-&gt;</operator><name>aggtranstype</name></name></expr></argument>,
						   <argument><expr><name><name>box</name><operator>-&gt;</operator><name>aggregationArgumentContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>aggtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>initialCall</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>get_typlenbyval</name><argument_list>(<argument><expr><name><name>box</name><operator>-&gt;</operator><name>transtype</name></name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name><name>box</name><operator>-&gt;</operator><name>transtypeLen</name></name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name><name>box</name><operator>-&gt;</operator><name>transtypeByVal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Get aggregation values, which may be either wrapped in a
	 * tuple (multi-argument case) or a singular, unwrapped value.
	 */</comment>
	<expr_stmt><expr><call><name>ExtractAggregationValues</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>box</name><operator>-&gt;</operator><name>aggregationArgumentContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>aggsfunc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>.</operator><name>fn_strict</name></name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>argumentIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init>
			 <condition><expr><name>argumentIndex</name> <operator>&lt;</operator> <name><name>box</name><operator>-&gt;</operator><name>aggregationArgumentContext</name><operator>-&gt;</operator><name>argumentCount</name></name></expr>;</condition>
			 <incr><expr><name>argumentIndex</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>box</name><operator>-&gt;</operator><name>aggregationArgumentContext</name><operator>-&gt;</operator><name>nulls</name><index>[<expr><name>argumentIndex</name></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>box</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>box</name><operator>-&gt;</operator><name>valueInit</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* For 'strict' transition functions, if the initial state value is null
			 * then the first argument value of the first row with all-nonnull input
			 * values replaces the state value.
			 */</comment>
			<decl_stmt><decl><type><name>Datum</name></type> <name>stateValue</name> <init>= <expr><name><name>box</name><operator>-&gt;</operator><name>aggregationArgumentContext</name><operator>-&gt;</operator><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>HandleStrictUninit</name><argument_list>(<argument><expr><name>box</name></expr></argument>, <argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>stateValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>box</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>box</name><operator>-&gt;</operator><name>valueNull</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>box</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* if aggregate function has N parameters, corresponding SFUNC has N+1 */</comment>
	<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name>innerFcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>,
							 <argument><expr><name><name>box</name><operator>-&gt;</operator><name>aggregationArgumentContext</name><operator>-&gt;</operator><name>argumentCount</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
							 <argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>fncollation</name></name></expr></argument>,
							 <argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>resultinfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fcSetArgExt</name><argument_list>(<argument><expr><name>innerFcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>box</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><name><name>box</name><operator>-&gt;</operator><name>valueNull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<for>for <control>(<init><expr><name>argumentIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init>
		 <condition><expr><name>argumentIndex</name> <operator>&lt;</operator> <name><name>box</name><operator>-&gt;</operator><name>aggregationArgumentContext</name><operator>-&gt;</operator><name>argumentCount</name></name></expr>;</condition>
		 <incr><expr><name>argumentIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fcSetArgExt</name><argument_list>(<argument><expr><name>innerFcinfo</name></expr></argument>, <argument><expr><name>argumentIndex</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
					<argument><expr><name><name>box</name><operator>-&gt;</operator><name>aggregationArgumentContext</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>argumentIndex</name></expr>]</index></name></expr></argument>,
					<argument><expr><name><name>box</name><operator>-&gt;</operator><name>aggregationArgumentContext</name><operator>-&gt;</operator><name>nulls</name><index>[<expr><name>argumentIndex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>HandleTransition</name><argument_list>(<argument><expr><name>box</name></expr></argument>, <argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>innerFcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>box</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * worker_partial_agg_ffunc serializes transition state,
 * essentially implementing the following pseudocode:
 *
 * (box) -&gt; text
 * return box.agg.stype.output(box.value)
 */</comment>
<function><type><name>Datum</name></type>
<name>worker_partial_agg_ffunc</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LOCAL_FCINFO</name><argument_list>(<argument><expr><name>innerFcinfo</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name></type> <name>info</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StypeBox</name> <modifier>*</modifier></type><name>box</name> <init>= <expr><operator>(</operator><name>StypeBox</name> <operator>*</operator><operator>)</operator> <operator>(</operator><ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_aggregate</name></type> <name>aggform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>typoutput</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>typIsVarlena</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>box</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>box</name> <operator>=</operator> <call><name>TryCreateStypeBoxFromFcinfoAggref</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>box</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>box</name><operator>-&gt;</operator><name>valueNull</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>aggtuple</name> <init>= <expr><call><name>GetAggregateForm</name><argument_list>(<argument><expr><name><name>box</name><operator>-&gt;</operator><name>agg</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aggform</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>aggform</name><operator>-&gt;</operator><name>aggcombinefn</name></name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
							<argument><expr><literal type="string">"worker_partial_agg_ffunc expects an aggregate with COMBINEFUNC"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>aggform</name><operator>-&gt;</operator><name>aggtranstype</name></name> <operator>==</operator> <name>INTERNALOID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
					 <argument><expr><literal type="string">"worker_partial_agg_ffunc does not support aggregates with INTERNAL transition state"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>transtype</name> <init>= <expr><name><name>aggform</name><operator>-&gt;</operator><name>aggtranstype</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>aggtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name>transtype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typoutput</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typIsVarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>typoutput</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name>innerFcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>fncollation</name></name></expr></argument>,
							 <argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>resultinfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fcSetArgExt</name><argument_list>(<argument><expr><name>innerFcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>box</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><name><name>box</name><operator>-&gt;</operator><name>valueNull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Datum</name></type> <name>result</name> <init>= <expr><call><name>FunctionCallInvoke</name><argument_list>(<argument><expr><name>innerFcinfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>innerFcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * coord_combine_agg_sfunc deserializes transition state from worker
 * &amp; advances transition state using combinefunc,
 * essentially implementing the following pseudocode:
 *
 * (box, agg, text) -&gt; box
 * box.agg = agg
 * box.value = agg.combine(box.value, agg.stype.input(text))
 * return box
 */</comment>
<function><type><name>Datum</name></type>
<name>coord_combine_agg_sfunc</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LOCAL_FCINFO</name><argument_list>(<argument><expr><name>innerFcinfo</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name></type> <name>info</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_aggregate</name></type> <name>aggform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>transtypeform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StypeBox</name> <modifier>*</modifier></type><name>box</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>box</name> <operator>=</operator> <call><name>pallocInAggContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>StypeBox</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>box</name><operator>-&gt;</operator><name>agg</name></name> <operator>=</operator> <call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>box</name> <operator>=</operator> <operator>(</operator><name>StypeBox</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>box</name><operator>-&gt;</operator><name>agg</name></name> <operator>==</operator> <call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>aggtuple</name> <init>= <expr><call><name>GetAggregateForm</name><argument_list>(<argument><expr><name><name>box</name><operator>-&gt;</operator><name>agg</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aggform</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>aggform</name><operator>-&gt;</operator><name>aggcombinefn</name></name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
							<argument><expr><literal type="string">"coord_combine_agg_sfunc expects an aggregate with COMBINEFUNC"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>aggform</name><operator>-&gt;</operator><name>aggtranstype</name></name> <operator>==</operator> <name>INTERNALOID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
					 <argument><expr><literal type="string">"coord_combine_agg_sfunc does not support aggregates with INTERNAL transition state"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>combine</name> <init>= <expr><name><name>aggform</name><operator>-&gt;</operator><name>aggcombinefn</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>InitializeStypeBox</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>box</name></expr></argument>, <argument><expr><name>aggtuple</name></expr></argument>, <argument><expr><name><name>aggform</name><operator>-&gt;</operator><name>aggtranstype</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>aggtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>get_typlenbyval</name><argument_list>(<argument><expr><name><name>box</name><operator>-&gt;</operator><name>transtype</name></name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name><name>box</name><operator>-&gt;</operator><name>transtypeLen</name></name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name><name>box</name><operator>-&gt;</operator><name>transtypeByVal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>valueNull</name> <init>= <expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>transtypetuple</name> <init>= <expr><call><name>GetTypeForm</name><argument_list>(<argument><expr><name><name>box</name><operator>-&gt;</operator><name>transtype</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>transtypeform</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>ioparam</name> <init>= <expr><call><name>getTypeIOParam</name><argument_list>(<argument><expr><name>transtypetuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>deserial</name> <init>= <expr><name><name>transtypeform</name><operator>-&gt;</operator><name>typinput</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>transtypetuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>deserial</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>valueNull</name> <operator>&amp;&amp;</operator> <name><name>info</name><operator>.</operator><name>fn_strict</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>value</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name>innerFcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>fncollation</name></name></expr></argument>,
								 <argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>resultinfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fcSetArgExt</name><argument_list>(<argument><expr><name>innerFcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>valueNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fcSetArg</name><argument_list>(<argument><expr><name>innerFcinfo</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>ioparam</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fcSetArg</name><argument_list>(<argument><expr><name>innerFcinfo</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* typmod */</comment>

		<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>FunctionCallInvoke</name><argument_list>(<argument><expr><name>innerFcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>valueNull</name> <operator>=</operator> <name><name>innerFcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>combine</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>.</operator><name>fn_strict</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>valueNull</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>box</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>box</name><operator>-&gt;</operator><name>valueInit</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>HandleStrictUninit</name><argument_list>(<argument><expr><name>box</name></expr></argument>, <argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>box</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>box</name><operator>-&gt;</operator><name>valueNull</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>box</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name>innerFcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>fncollation</name></name></expr></argument>,
							 <argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>resultinfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fcSetArgExt</name><argument_list>(<argument><expr><name>innerFcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>box</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><name><name>box</name><operator>-&gt;</operator><name>valueNull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fcSetArgExt</name><argument_list>(<argument><expr><name>innerFcinfo</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>valueNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>HandleTransition</name><argument_list>(<argument><expr><name>box</name></expr></argument>, <argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>innerFcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>box</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * coord_combine_agg_ffunc applies finalfunc of aggregate to state,
 * essentially implementing the following pseudocode:
 *
 * (box, ...) -&gt; fval
 * return box.agg.ffunc(box.value)
 */</comment>
<function><type><name>Datum</name></type>
<name>coord_combine_agg_ffunc</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StypeBox</name> <modifier>*</modifier></type><name>box</name> <init>= <expr><operator>(</operator><name>StypeBox</name> <operator>*</operator><operator>)</operator> <operator>(</operator><ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>LOCAL_FCINFO</name><argument_list>(<argument><expr><name>innerFcinfo</name></expr></argument>, <argument><expr><name>FUNC_MAX_ARGS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name></type> <name>info</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>innerNargs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_aggregate</name></type> <name>aggform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>ffuncform</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>box</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>box</name> <operator>=</operator> <call><name>TryCreateStypeBoxFromFcinfoAggref</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>box</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>aggtuple</name> <init>= <expr><call><name>GetAggregateForm</name><argument_list>(<argument><expr><name><name>box</name><operator>-&gt;</operator><name>agg</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aggform</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>ffunc</name> <init>= <expr><name><name>aggform</name><operator>-&gt;</operator><name>aggfinalfn</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>fextra</name> <init>= <expr><name><name>aggform</name><operator>-&gt;</operator><name>aggfinalextra</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>aggtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TypecheckCoordCombineAggReturnType</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>ffunc</name></expr></argument>, <argument><expr><name>box</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
							<argument><expr><literal type="string">"coord_combine_agg_ffunc could not confirm type correctness"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>ffunc</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>box</name><operator>-&gt;</operator><name>valueNull</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><name><name>box</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>ffunctuple</name> <init>= <expr><call><name>GetProcForm</name><argument_list>(<argument><expr><name>ffunc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ffuncform</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>finalStrict</name> <init>= <expr><name><name>ffuncform</name><operator>-&gt;</operator><name>proisstrict</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>ffunctuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>finalStrict</name> <operator>&amp;&amp;</operator> <name><name>box</name><operator>-&gt;</operator><name>valueNull</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>fextra</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>innerNargs</name> <operator>=</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>nargs</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>innerNargs</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>ffunc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name>innerFcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>, <argument><expr><name>innerNargs</name></expr></argument>, <argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>fncollation</name></name></expr></argument>,
							 <argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>resultinfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fcSetArgExt</name><argument_list>(<argument><expr><name>innerFcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>box</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><name><name>box</name><operator>-&gt;</operator><name>valueNull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>argumentIndex</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>argumentIndex</name> <operator>&lt;</operator> <name>innerNargs</name></expr>;</condition> <incr><expr><name>argumentIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fcSetArgNull</name><argument_list>(<argument><expr><name>innerFcinfo</name></expr></argument>, <argument><expr><name>argumentIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<decl_stmt><decl><type><name>Datum</name></type> <name>result</name> <init>= <expr><call><name>FunctionCallInvoke</name><argument_list>(<argument><expr><name>innerFcinfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name><name>innerFcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * TypecheckWorkerPartialAggArgType returns whether the arguments being passed to
 * worker_partial_agg match the arguments expected by the aggregate being distributed.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>TypecheckWorkerPartialAggArgType</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>StypeBox</name> <modifier>*</modifier></type><name>box</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>aggref</name> <init>= <expr><call><name>AggGetAggref</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>aggref</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>aggarg</name> <init>= <expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>argtypesNull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>proctuple</name> <init>= <expr><call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>box</name><operator>-&gt;</operator><name>agg</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>proctuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Datum</name></type> <name>argtypes</name> <init>= <expr><call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><name>proctuple</name></expr></argument>,
									 <argument><expr><name>Anum_pg_proc_proargtypes</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>argtypesNull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>argtypesNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>proctuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>argtypes</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"worker_partial_agg_sfunc cannot type check aggregates "</literal>
					<literal type="string">"taking multi-dimensional arguments"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>aggregateArgCount</name> <init>= <expr><call><name>ARR_DIMS</name><argument_list>(<argument><expr><call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>argtypes</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr></init></decl>;</decl_stmt>

	<comment type="block">/* we expect aggregate function to have at least a single parameter */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>box</name><operator>-&gt;</operator><name>aggregationArgumentContext</name><operator>-&gt;</operator><name>argumentCount</name></name> <operator>!=</operator> <name>aggregateArgCount</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>aggregateArgIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>argType</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>box</name><operator>-&gt;</operator><name>aggregationArgumentContext</name><operator>-&gt;</operator><name>isTuple</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* check if record element types match aggregate input parameters */</comment>
		<for>for <control>(<init><expr><name>aggregateArgIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>aggregateArgIndex</name> <operator>&lt;</operator> <name>aggregateArgCount</name></expr>;</condition>
			 <incr><expr><name>aggregateArgIndex</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>argType</name> <operator>=</operator> <call><name>array_get_element</name><argument_list>(<argument><expr><name>argtypes</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>aggregateArgIndex</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>,
										<argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>argtypesNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>argtypesNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name> <init>= <expr><name><name>box</name><operator>-&gt;</operator><name>aggregationArgumentContext</name><operator>-&gt;</operator><name>tupleDesc</name></name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>argType</name> <operator>!=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>aggregateArgIndex</name></expr>]</index></name><operator>.</operator><name>atttypid</name></expr>)</condition>
			<block>{<block_content>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>argType</name> <operator>=</operator> <call><name>array_get_element</name><argument_list>(<argument><expr><name>argtypes</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>aggregateArgIndex</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>,
									<argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>argtypesNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>argtypesNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>aggarg</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name>argType</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * TypecheckCoordCombineAggReturnType returns whether the return type of the aggregate
 * being distributed by coord_combine_agg matches the null constant used to inform postgres
 * what the aggregate's expected return type is.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>TypecheckCoordCombineAggReturnType</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>ffunc</name></decl></parameter>, <parameter><decl><type><name>StypeBox</name> <modifier>*</modifier></type><name>box</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>aggref</name> <init>= <expr><call><name>AggGetAggref</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>aggref</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>finalType</name> <init>= <expr><ternary><condition><expr><name>ffunc</name> <operator>==</operator> <name>InvalidOid</name></expr> ?</condition><then>
					<expr><name><name>box</name><operator>-&gt;</operator><name>transtype</name></name></expr> </then><else>: <expr><call><name>get_func_rettype</name><argument_list>(<argument><expr><name>ffunc</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>nulltag</name> <init>= <expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>nulltag</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>nulltag</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		   <operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name><name>nulltag</name><operator>-&gt;</operator><name>expr</name></name><operator>)</operator><operator>-&gt;</operator><name>consttype</name> <operator>==</operator> <name>finalType</name></expr>;</return>
</block_content>}</block></function>
</unit>
