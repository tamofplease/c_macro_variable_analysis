<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/citus/src/backend/distributed/utils/citus_outfuncs.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * citus_outfuncs.c
 *	  Output functions for Citus tree nodes.
 *
 * Portions Copyright (c) 1996-2014, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 * Portions Copyright (c) Citus Data, Inc.
 *
 * NOTES
 *	  This is a wrapper around postgres' nodeToString() that additionally
 *	  supports Citus node types.
 *
 *    Keep as closely aligned with the upstream version as possible.
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_version_constants.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_nodefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_nodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/coordinator_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/errormessage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/log_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_logical_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_physical_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/distributed_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_server_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/stringinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/plannodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pathnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>


<comment type="block">/*
 * Macros to simplify output of different kinds of fields.  Use these
 * wherever possible to reduce the chance for silly typos.  Note that these
 * hard-wire conventions about the names of the local variables in an Out
 * routine.
 */</comment>

<comment type="block">/* Store const reference to raw input node in local named 'node' */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_LOCALS</name><parameter_list>(<parameter><type><name>nodeTypeName</name></type></parameter>)</parameter_list></cpp:macro> \
		<cpp:value>const nodeTypeName *node = (const nodeTypeName *) raw_node</cpp:value></cpp:define>

<comment type="block">/* Write the label for the node type */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_NODE_TYPE</name><parameter_list>(<parameter><type><name>nodelabel</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(void) 0</cpp:value></cpp:define>

<comment type="block">/* Write an integer field (anything written as ":fldname %d") */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_INT_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>appendStringInfo(str, " :" CppAsString(fldname) " %d", node-&gt;fldname)</cpp:value></cpp:define>

<comment type="block">/* Write an 64-bit integer field (anything written as ":fldname %d") */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_INT64_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>appendStringInfo(str, " :" CppAsString(fldname) " " INT64_FORMAT, node-&gt;fldname)</cpp:value></cpp:define>


<comment type="block">/* Write an unsigned integer field (anything written as ":fldname %u") */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_UINT_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>appendStringInfo(str, " :" CppAsString(fldname) " %u", node-&gt;fldname)</cpp:value></cpp:define>

<comment type="block">/* XXX: Citus: Write an unsigned 64-bit integer field */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_UINT64_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>appendStringInfo(str, " :" CppAsString(fldname) " " UINT64_FORMAT, node-&gt;fldname)</cpp:value></cpp:define>

<comment type="block">/* Write an OID field (don't hard-wire assumption that OID is same as uint) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_OID_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>appendStringInfo(str, " :" CppAsString(fldname) " %u", node-&gt;fldname)</cpp:value></cpp:define>

<comment type="block">/* Write a char field (ie, one ascii character) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_CHAR_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>appendStringInfo(str, " :" CppAsString(fldname) " %c", node-&gt;fldname)</cpp:value></cpp:define>

<comment type="block">/* Write an enumerated-type field as an integer code */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_ENUM_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>, <parameter><type><name>enumtype</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>appendStringInfo(str, " :" CppAsString(fldname) " %d", \
					 (int) node-&gt;fldname)</cpp:value></cpp:define>

<comment type="block">/* Write a float field --- caller must give format to define precision */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_FLOAT_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>,<parameter><type><name>format</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>appendStringInfo(str, " :" CppAsString(fldname) " " format, node-&gt;fldname)</cpp:value></cpp:define>

<comment type="block">/* Write a boolean field */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_BOOL_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>appendStringInfo(str, " :" CppAsString(fldname) " %s", \
					 booltostr(node-&gt;fldname))</cpp:value></cpp:define>

<comment type="block">/* Write a character-string (possibly NULL) field */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_STRING_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(appendStringInfo(str, " :" CppAsString(fldname) " "), \
	 outToken(str, node-&gt;fldname))</cpp:value></cpp:define>

<comment type="block">/* Write a parse location field (actually same as INT case) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_LOCATION_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>appendStringInfo(str, " :" CppAsString(fldname) " %d", node-&gt;fldname)</cpp:value></cpp:define>

<comment type="block">/* Write a Node field */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_NODE_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(appendStringInfo(str, " :" CppAsString(fldname) " "), \
	 outNode(str, node-&gt;fldname))</cpp:value></cpp:define>

<comment type="block">/* Write a bitmapset field */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_BITMAPSET_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(appendStringInfo(str, " :" CppAsString(fldname) " "), \
	 _outBitmapset(str, node-&gt;fldname))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_CUSTOM_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>, <parameter><type><name>fldvalue</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(appendStringInfo(str, " :" CppAsString(fldname) " "), \
	appendStringInfoString(str, (fldvalue)))</cpp:value></cpp:define>


<comment type="block">/* Write an integer array (anything written as ":fldname (%d, %d") */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_INT_ARRAY</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>, <parameter><type><name>count</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>appendStringInfo(str, " :" CppAsString(fldname) " ("); \
	{ \
		int i;\
		for (i = 0; i &lt; count; i++) \
		{ \
			if (i &gt; 0) \
			{ \
				appendStringInfo(str, ", "); \
			} \
			appendStringInfo(str, "%d", node-&gt;fldname[i]); \
		}\
	}\
	appendStringInfo(str, ")")</cpp:value></cpp:define>


<comment type="block">/* Write an enum array (anything written as ":fldname (%d, %d") */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_ENUM_ARRAY</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>, <parameter><type><name>count</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>WRITE_INT_ARRAY(fldname, count)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>booltostr</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>((x) ? "true" : "false")</cpp:value></cpp:define>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WriteTaskQuery</name><parameter_list>(<parameter><decl><type><name>OUTFUNC_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block" format="doxygen">/*****************************************************************************
 *	Output routines for Citus node types
 *****************************************************************************/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>OutMultiUnaryNodeFields</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>MultiUnaryNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>childNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>OutMultiBinaryNodeFields</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>MultiBinaryNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>leftChildNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>rightChildNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>OutMultiNode</name><parameter_list>(<parameter><decl><type><name>OUTFUNC_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"MULTINODE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>OutMultiTreeRoot</name><parameter_list>(<parameter><decl><type><name>OUTFUNC_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_LOCALS</name><argument_list>(<argument><expr><name>MultiTreeRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"MULTITREEROOT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>OutMultiUnaryNodeFields</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>OutDistributedPlan</name><parameter_list>(<parameter><decl><type><name>OUTFUNC_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_LOCALS</name><argument_list>(<argument><expr><name>DistributedPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"DISTRIBUTEDPLAN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_UINT64_FIELD</name><argument_list>(<argument><expr><name>planId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>modLevel</name></expr></argument>, <argument><expr><name>RowModifyLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>expectResults</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>workerJob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>combineQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT64_FIELD</name><argument_list>(<argument><expr><name>queryId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>relationIdList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>targetRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>insertSelectQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>intermediateResultIdPrefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subPlanList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>usedSubPlanNodeList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>fastPathRouterPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>numberOfTimesExecuted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>planningError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>OutDistributedSubPlan</name><parameter_list>(<parameter><decl><type><name>OUTFUNC_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_LOCALS</name><argument_list>(<argument><expr><name>DistributedSubPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"DISTRIBUTEDSUBPLAN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>subPlanId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>OutUsedDistributedSubPlan</name><parameter_list>(<parameter><decl><type><name>OUTFUNC_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_LOCALS</name><argument_list>(<argument><expr><name>UsedDistributedSubPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"USEDDISTRIBUTEDSUBPLAN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>subPlanId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>accessType</name></expr></argument>, <argument><expr><name>SubPlanAccessType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>OutMultiProject</name><parameter_list>(<parameter><decl><type><name>OUTFUNC_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_LOCALS</name><argument_list>(<argument><expr><name>MultiProject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"MULTIPROJECT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>columnList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>OutMultiUnaryNodeFields</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>OutMultiCollect</name><parameter_list>(<parameter><decl><type><name>OUTFUNC_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_LOCALS</name><argument_list>(<argument><expr><name>MultiCollect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"MULTICOLLECT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>OutMultiUnaryNodeFields</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>OutMultiSelect</name><parameter_list>(<parameter><decl><type><name>OUTFUNC_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_LOCALS</name><argument_list>(<argument><expr><name>MultiSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"MULTISELECT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>selectClauseList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>OutMultiUnaryNodeFields</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>OutMultiTable</name><parameter_list>(<parameter><decl><type><name>OUTFUNC_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_LOCALS</name><argument_list>(<argument><expr><name>MultiTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"MULTITABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>rangeTableId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>OutMultiUnaryNodeFields</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>OutMultiJoin</name><parameter_list>(<parameter><decl><type><name>OUTFUNC_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_LOCALS</name><argument_list>(<argument><expr><name>MultiJoin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"MULTIJOIN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>joinClauseList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>joinRuleType</name></expr></argument>, <argument><expr><name>JoinRuleType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>joinType</name></expr></argument>, <argument><expr><name>JoinType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>OutMultiBinaryNodeFields</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>MultiBinaryNode</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>OutMultiPartition</name><parameter_list>(<parameter><decl><type><name>OUTFUNC_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_LOCALS</name><argument_list>(<argument><expr><name>MultiPartition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"MULTIPARTITION"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>partitionColumn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>OutMultiUnaryNodeFields</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>OutMultiCartesianProduct</name><parameter_list>(<parameter><decl><type><name>OUTFUNC_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_LOCALS</name><argument_list>(<argument><expr><name>MultiCartesianProduct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"MULTICARTESIANPRODUCT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>OutMultiBinaryNodeFields</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>MultiBinaryNode</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><name>void</name></type>
<name>OutMultiExtendedOp</name><parameter_list>(<parameter><decl><type><name>OUTFUNC_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_LOCALS</name><argument_list>(<argument><expr><name>MultiExtendedOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"MULTIEXTENDEDOP"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>targetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>groupClauseList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>sortClauseList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>limitCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>limitOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>limitOption</name></expr></argument>, <argument><expr><name>LimitOption</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>havingQual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasDistinctOn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>distinctClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasWindowFuncs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>onlyPushableWindowFunctions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>windowClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>OutMultiUnaryNodeFields</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>OutJobFields</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Job</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_UINT64_FIELD</name><argument_list>(<argument><expr><name>jobId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>jobQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>dependentJobList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>subqueryPushdown</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>requiresCoordinatorEvaluation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>deferredPruning</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>partitionKeyValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>localPlannedStatements</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>parametersInJobQueryResolved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>OutJob</name><parameter_list>(<parameter><decl><type><name>OUTFUNC_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_LOCALS</name><argument_list>(<argument><expr><name>Job</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"JOB"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>OutJobFields</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>OutShardInterval</name><parameter_list>(<parameter><decl><type><name>OUTFUNC_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_LOCALS</name><argument_list>(<argument><expr><name>ShardInterval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"SHARDINTERVAL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_CHAR_FIELD</name><argument_list>(<argument><expr><name>storageType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>valueTypeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>valueTypeLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>valueByVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>minValueExists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>maxValueExists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :minValue "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>minValueExists</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"&lt;&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>outDatum</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>minValue</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>valueTypeLen</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>valueByVal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :maxValue "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>maxValueExists</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"&lt;&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>outDatum</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>maxValue</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>valueTypeLen</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>valueByVal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>WRITE_UINT64_FIELD</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>shardIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>OutMapMergeJob</name><parameter_list>(<parameter><decl><type><name>OUTFUNC_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_LOCALS</name><argument_list>(<argument><expr><name>MapMergeJob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>arrayLength</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>sortedShardIntervalArrayLength</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"MAPMERGEJOB"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>OutJobFields</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><name>Job</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>partitionType</name></expr></argument>, <argument><expr><name>PartitionType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>partitionColumn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>partitionCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>sortedShardIntervalArrayLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>arrayLength</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>outNode</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>sortedShardIntervalArray</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>mapTaskList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>mergeTaskList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>OutShardPlacement</name><parameter_list>(<parameter><decl><type><name>OUTFUNC_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_LOCALS</name><argument_list>(<argument><expr><name>ShardPlacement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"SHARDPLACEMENT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_UINT64_FIELD</name><argument_list>(<argument><expr><name>placementId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT64_FIELD</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT64_FIELD</name><argument_list>(<argument><expr><name>shardLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>shardState</name></expr></argument>, <argument><expr><name>ShardState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>groupId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>nodeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>nodePort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>nodeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* so we can deal with 0 */</comment>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>partitionMethod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>colocationGroupId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>representativeValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>OutGroupShardPlacement</name><parameter_list>(<parameter><decl><type><name>OUTFUNC_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_LOCALS</name><argument_list>(<argument><expr><name>GroupShardPlacement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"GROUPSHARDPLACEMENT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_UINT64_FIELD</name><argument_list>(<argument><expr><name>placementId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT64_FIELD</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT64_FIELD</name><argument_list>(<argument><expr><name>shardLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>shardState</name></expr></argument>, <argument><expr><name>ShardState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>groupId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>OutRelationShard</name><parameter_list>(<parameter><decl><type><name>OUTFUNC_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_LOCALS</name><argument_list>(<argument><expr><name>RelationShard</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"RELATIONSHARD"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT64_FIELD</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>OutRelationRowLock</name><parameter_list>(<parameter><decl><type><name>OUTFUNC_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_LOCALS</name><argument_list>(<argument><expr><name>RelationRowLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"RELATIONROWLOCK"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>rowLockStrength</name></expr></argument>, <argument><expr><name>LockClauseStrength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>WriteTaskQuery</name><parameter_list>(<parameter><decl><type><name>OUTFUNC_ARGS</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_LOCALS</name><argument_list>(<argument><expr><name>Task</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name><name>taskQuery</name><operator>.</operator><name>queryType</name></name></expr></argument>, <argument><expr><name>TaskQueryType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>taskQuery</name><operator>.</operator><name>queryType</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>TASK_QUERY_TEXT</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name><name>taskQuery</name><operator>.</operator><name>data</name><operator>.</operator><name>queryStringLazy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>TASK_QUERY_OBJECT</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name><name>taskQuery</name><operator>.</operator><name>data</name><operator>.</operator><name>jobQueryReferenceForLazyDeparsing</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>TASK_QUERY_TEXT_LIST</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name><name>taskQuery</name><operator>.</operator><name>data</name><operator>.</operator><name>queryStringList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<default>default:</default>
		<block>{<block_content>
			<break>break;</break>
		</block_content>}</block>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>OutTask</name><parameter_list>(<parameter><decl><type><name>OUTFUNC_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_LOCALS</name><argument_list>(<argument><expr><name>Task</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"TASK"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>taskType</name></expr></argument>, <argument><expr><name>TaskType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT64_FIELD</name><argument_list>(<argument><expr><name>jobId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>taskId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WriteTaskQuery</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>raw_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>anchorDistributedTableId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT64_FIELD</name><argument_list>(<argument><expr><name>anchorShardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>taskPlacementList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>dependentTaskList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>partitionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>upstreamTaskId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>shardInterval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>assignmentConstrained</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_CHAR_FIELD</name><argument_list>(<argument><expr><name>replicationModel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>modifyWithSubquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>relationShardList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>relationRowLockList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>rowValuesLists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>partiallyLocalOrRemote</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>parametersInQueryStringResolved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>queryCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT64_FIELD</name><argument_list>(<argument><expr><name>totalReceivedTupleData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>fetchedExplainAnalyzePlacementIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>fetchedExplainAnalyzePlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>fetchedExplainAnalyzeExecutionDuration</name></expr></argument>, <argument><expr><literal type="string">"%.2f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>isLocalTableModification</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>cannotBeExecutedInTransction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>OutLocalPlannedStatement</name><parameter_list>(<parameter><decl><type><name>OUTFUNC_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_LOCALS</name><argument_list>(<argument><expr><name>LocalPlannedStatement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"LocalPlannedStatement"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_UINT64_FIELD</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>localGroupId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>localPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>OutDeferredErrorMessage</name><parameter_list>(<parameter><decl><type><name>OUTFUNC_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_LOCALS</name><argument_list>(<argument><expr><name>DeferredErrorMessage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"DEFERREDERRORMESSAGE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>detail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>hint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>linenumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>functionname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>OutTableDDLCommand</name><parameter_list>(<parameter><decl><type><name>OUTFUNC_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_LOCALS</name><argument_list>(<argument><expr><name>TableDDLCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"TableDDLCommand"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>TABLE_DDL_COMMAND_STRING</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>commandStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>TABLE_DDL_COMMAND_FUNCTION</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>example</name> <init>= <expr><call><name><name>node</name><operator>-&gt;</operator><name>function</name><operator>.</operator><name>function</name></name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>function</name><operator>.</operator><name>context</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>WRITE_CUSTOM_FIELD</name><argument_list>(<argument><expr><name>function</name></expr></argument>, <argument><expr><name>example</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>
	</block_content>}</block></switch>
</block_content>}</block></function>
</unit>
