<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/builded_projects/citus/src/backend/distributed/transaction/distributed_deadlock_detection.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * distributed_deadlock_detection.c
 *
 *  Functions for performing distributed deadlock detection.
 *
 * Copyright (c) Citus Data, Inc.
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/backend_data.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/errormessage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/distributed_deadlock_detection.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/errormessage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/hash_helpers.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/lock_graph.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/log_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/transaction_identifier.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pg_list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/hsearch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timestamp.h"</cpp:file></cpp:include>


<comment type="block">/* used only for finding the deadlock cycle path */</comment>
<typedef>typedef <type><struct>struct <name>QueuedTransactionNode</name>
<block>{
	<decl_stmt><decl><type><name>TransactionNode</name> <modifier>*</modifier></type><name>transactionNode</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>currentStackDepth</name></decl>;</decl_stmt>
}</block></struct></type> <name>QueuedTransactionNode</name>;</typedef>


<comment type="block">/* GUC, determining whether debug messages for deadlock detection sent to LOG */</comment>
<decl_stmt><decl><type><name>bool</name></type> <name>LogDistributedDeadlockDetection</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>


<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>CheckDeadlockForTransactionNode</name><parameter_list>(<parameter><decl><type><name>TransactionNode</name> <modifier>*</modifier></type><name>startingTransactionNode</name></decl></parameter>,
											<parameter><decl><type><name>int</name></type> <name>maxStackDepth</name></decl></parameter>,
											<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>deadlockPath</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>PrependOutgoingNodesToQueue</name><parameter_list>(<parameter><decl><type><name>TransactionNode</name> <modifier>*</modifier></type><name>queuedTransactionNode</name></decl></parameter>,
										<parameter><decl><type><name>int</name></type> <name>currentStackDepth</name></decl></parameter>,
										<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>toBeVisitedNodes</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>BuildDeadlockPathList</name><parameter_list>(<parameter><decl><type><name>QueuedTransactionNode</name> <modifier>*</modifier></type><name>cycledTransactionNode</name></decl></parameter>,
								  <parameter><decl><type><name>TransactionNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>transactionNodeStack</name></decl></parameter>,
								  <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>deadlockPath</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ResetVisitedFields</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>adjacencyList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>AssociateDistributedTransactionWithBackendProc</name><parameter_list>(<parameter><decl><type><name>TransactionNode</name> <modifier>*</modifier></type>
														   <name>transactionNode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TransactionNode</name> <modifier>*</modifier></type> <name>GetOrCreateTransactionNode</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>adjacencyList</name></decl></parameter>,
													<parameter><decl><type><name>DistributedTransactionId</name> <modifier>*</modifier></type>
													<name>transactionId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint32</name></type> <name>DistributedTransactionIdHash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>DistributedTransactionIdCompare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>LogCancellingBackend</name><parameter_list>(<parameter><decl><type><name>TransactionNode</name> <modifier>*</modifier></type><name>transactionNode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>LogTransactionNode</name><parameter_list>(<parameter><decl><type><name>TransactionNode</name> <modifier>*</modifier></type><name>transactionNode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>LogDistributedDeadlockDebugMessage</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>errorMessage</name></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>check_distributed_deadlocks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<comment type="block">/*
 * check_distributed_deadlocks is the external API for manually
 * checking for distributed deadlocks. For the details, see
 * CheckForDistributedDeadlocks().
 */</comment>
<function><type><name>Datum</name></type>
<name>check_distributed_deadlocks</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>deadlockFound</name> <init>= <expr><call><name>CheckForDistributedDeadlocks</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>deadlockFound</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CheckForDistributedDeadlocks is the entry point for detecting
 * distributed deadlocks.
 *
 * In plain words, the function first builds a wait graph by
 * adding the wait edges from the local node and then adding the
 * remote wait edges to form a global wait graph. Later, the wait
 * graph is converted into another graph representation (adjacency
 * lists) for more efficient searches. Finally, a DFS is done on
 * the adjacency lists. Finding a cycle in the graph unveils a
 * distributed deadlock. Upon finding a deadlock, the youngest
 * participant backend is cancelled.
 *
 * The complexity of the algorithm is O(N) for each distributed
 * transaction that's checked for deadlocks. Note that there exists
 *  0 to MaxBackends number of transactions.
 *
 * The function returns true if a deadlock is found. Otherwise, returns
 * false.
 */</comment>
<function><type><name>bool</name></type>
<name>CheckForDistributedDeadlocks</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionNode</name> <modifier>*</modifier></type><name>transactionNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>localGroupId</name> <init>= <expr><call><name>GetLocalGroupId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>workerNodeList</name> <init>= <expr><call><name>ActiveReadableNodeList</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We don't need to do any distributed deadlock checking if there
	 * are no worker nodes. This might even be problematic for a non-mx
	 * worker node which has the same group id with its master (i.e., 0),
	 * which may erroneously decide to kill the deadlocks happening on it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>workerNodeList</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* distributed deadlock detection only considers distributed txs */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>onlyDistributedTx</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WaitGraph</name> <modifier>*</modifier></type><name>waitGraph</name> <init>= <expr><call><name>BuildGlobalWaitGraph</name><argument_list>(<argument><expr><name>onlyDistributedTx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>adjacencyLists</name> <init>= <expr><call><name>BuildAdjacencyListsForWaitGraph</name><argument_list>(<argument><expr><name>waitGraph</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>edgeCount</name> <init>= <expr><name><name>waitGraph</name><operator>-&gt;</operator><name>edgeCount</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We iterate on transaction nodes and search for deadlocks where the
	 * starting node is the given transaction node.
	 */</comment>
	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>adjacencyLists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>transactionNode</name> <operator>=</operator> <operator>(</operator><name>TransactionNode</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>deadlockPath</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Since we only see nodes which are waiting or being waited upon it's not
		 * possible to have more than edgeCount + 1 nodes.
		 */</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>maxStackDepth</name> <init>= <expr><name>edgeCount</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/* we're only interested in finding deadlocks originating from this node */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>transactionNode</name><operator>-&gt;</operator><name>transactionId</name><operator>.</operator><name>initiatorNodeIdentifier</name></name> <operator>!=</operator> <name>localGroupId</name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ResetVisitedFields</name><argument_list>(<argument><expr><name>adjacencyLists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>bool</name></type> <name>deadlockFound</name> <init>= <expr><call><name>CheckDeadlockForTransactionNode</name><argument_list>(<argument><expr><name>transactionNode</name></expr></argument>,
															 <argument><expr><name>maxStackDepth</name></expr></argument>,
															 <argument><expr><operator>&amp;</operator><name>deadlockPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>deadlockFound</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TransactionNode</name> <modifier>*</modifier></type><name>youngestAliveTransaction</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * There should generally be at least two transactions to get into a
			 * deadlock. However, in case Citus gets into a self-deadlock, we may
			 * find a deadlock with a single transaction.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>deadlockPath</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>LogDistributedDeadlockDebugMessage</name><argument_list>(<argument><expr><literal type="string">"Distributed deadlock found among the "</literal>
											   <literal type="string">"following distributed transactions:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * We search for the youngest participant for two reasons
			 * (i) predictable results (ii) cancel the youngest transaction
			 * (i.e., if a DDL continues for 1 hour and deadlocks with a
			 * SELECT continues for 10 msec, we prefer to cancel the SELECT).
			 *
			 * We're also searching for the youngest transactions initiated by
			 * this node.
			 */</comment>
			<decl_stmt><decl><type><name>TransactionNode</name> <modifier>*</modifier></type><name>currentNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<macro><name>foreach_ptr</name><argument_list>(<argument>currentNode</argument>, <argument>deadlockPath</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>bool</name></type> <name>transactionAssociatedWithProc</name> <init>=
					<expr><call><name>AssociateDistributedTransactionWithBackendProc</name><argument_list>(<argument><expr><name>currentNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>LogTransactionNode</name><argument_list>(<argument><expr><name>currentNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* we couldn't find the backend process originated the transaction */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>transactionAssociatedWithProc</name></expr>)</condition>
				<block>{<block_content>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>youngestAliveTransaction</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>youngestAliveTransaction</name> <operator>=</operator> <name>currentNode</name></expr>;</expr_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>

				<decl_stmt><decl><type><name>TimestampTz</name></type> <name>youngestTimestamp</name> <init>=
					<expr><name><name>youngestAliveTransaction</name><operator>-&gt;</operator><name>transactionId</name><operator>.</operator><name>timestamp</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>TimestampTz</name></type> <name>currentTimestamp</name> <init>= <expr><name><name>currentNode</name><operator>-&gt;</operator><name>transactionId</name><operator>.</operator><name>timestamp</name></name></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>timestamptz_cmp_internal</name><argument_list>(<argument><expr><name>currentTimestamp</name></expr></argument>, <argument><expr><name>youngestTimestamp</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>youngestAliveTransaction</name> <operator>=</operator> <name>currentNode</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>

			<comment type="block">/* we found the deadlock and its associated proc exists */</comment>
			<if_stmt><if>if <condition>(<expr><name>youngestAliveTransaction</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>CancelTransactionDueToDeadlock</name><argument_list>(<argument><expr><name><name>youngestAliveTransaction</name><operator>-&gt;</operator><name>initiatorProc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>LogCancellingBackend</name><argument_list>(<argument><expr><name>youngestAliveTransaction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>hash_seq_term</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CheckDeadlockForTransactionNode does a DFS starting with the given
 * transaction node and checks for a cycle (i.e., the node can be reached again
 * while traversing the graph).
 *
 * Finding a cycle indicates a distributed deadlock and the function returns
 * true on that case. Also, the deadlockPath is filled with the transaction
 * nodes that form the cycle.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>CheckDeadlockForTransactionNode</name><parameter_list>(<parameter><decl><type><name>TransactionNode</name> <modifier>*</modifier></type><name>startingTransactionNode</name></decl></parameter>,
								<parameter><decl><type><name>int</name></type> <name>maxStackDepth</name></decl></parameter>,
								<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>deadlockPath</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>toBeVisitedNodes</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>rootStackDepth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>transactionNodeStack</name> <init>=
		<expr><call><name>palloc0</name><argument_list>(<argument><expr><name>maxStackDepth</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionNode</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We keep transactionNodeStack to keep track of the deadlock paths. At this point,
	 * adjust the depth of the starting node and set the stack's first element with
	 * the starting node.
	 */</comment>
	<expr_stmt><expr><name><name>transactionNodeStack</name><index>[<expr><name>rootStackDepth</name></expr>]</index></name> <operator>=</operator> <name>startingTransactionNode</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PrependOutgoingNodesToQueue</name><argument_list>(<argument><expr><name>startingTransactionNode</name></expr></argument>, <argument><expr><name>rootStackDepth</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>toBeVisitedNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* traverse the graph and search for the deadlocks */</comment>
	<while>while <condition>(<expr><name>toBeVisitedNodes</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>QueuedTransactionNode</name> <modifier>*</modifier></type><name>queuedTransactionNode</name> <init>=
			<expr><operator>(</operator><name>QueuedTransactionNode</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>toBeVisitedNodes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TransactionNode</name> <modifier>*</modifier></type><name>currentTransactionNode</name> <init>= <expr><name><name>queuedTransactionNode</name><operator>-&gt;</operator><name>transactionNode</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>toBeVisitedNodes</name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name>toBeVisitedNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* cycle found, let the caller know about the cycle */</comment>
		<if_stmt><if>if <condition>(<expr><name>currentTransactionNode</name> <operator>==</operator> <name>startingTransactionNode</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>BuildDeadlockPathList</name><argument_list>(<argument><expr><name>queuedTransactionNode</name></expr></argument>, <argument><expr><name>transactionNodeStack</name></expr></argument>,
								  <argument><expr><name>deadlockPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>transactionNodeStack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* don't need to revisit the node again */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>currentTransactionNode</name><operator>-&gt;</operator><name>transactionVisited</name></name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>currentTransactionNode</name><operator>-&gt;</operator><name>transactionVisited</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="block">/* set the stack's corresponding element with the current node */</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>currentStackDepth</name> <init>= <expr><name><name>queuedTransactionNode</name><operator>-&gt;</operator><name>currentStackDepth</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>currentStackDepth</name> <operator>&lt;</operator> <name>maxStackDepth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>transactionNodeStack</name><index>[<expr><name>currentStackDepth</name></expr>]</index></name> <operator>=</operator> <name>currentTransactionNode</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PrependOutgoingNodesToQueue</name><argument_list>(<argument><expr><name>currentTransactionNode</name></expr></argument>, <argument><expr><name>currentStackDepth</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>toBeVisitedNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>transactionNodeStack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PrependOutgoingNodesToQueue prepends the waiters of the input transaction nodes to the
 * toBeVisitedNodes.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>PrependOutgoingNodesToQueue</name><parameter_list>(<parameter><decl><type><name>TransactionNode</name> <modifier>*</modifier></type><name>transactionNode</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>currentStackDepth</name></decl></parameter>,
							<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>toBeVisitedNodes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* as we traverse outgoing edges, increment the depth */</comment>
	<expr_stmt><expr><name>currentStackDepth</name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/* prepend to the list to continue depth-first search */</comment>
	<decl_stmt><decl><type><name>TransactionNode</name> <modifier>*</modifier></type><name>waitForTransaction</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>waitForTransaction</argument>, <argument>transactionNode-&gt;waitsFor</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>QueuedTransactionNode</name> <modifier>*</modifier></type><name>queuedNode</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>QueuedTransactionNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>queuedNode</name><operator>-&gt;</operator><name>transactionNode</name></name> <operator>=</operator> <name>waitForTransaction</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>queuedNode</name><operator>-&gt;</operator><name>currentStackDepth</name></name> <operator>=</operator> <name>currentStackDepth</name></expr>;</expr_stmt>

		<expr_stmt><expr><operator>*</operator><name>toBeVisitedNodes</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>queuedNode</name></expr></argument>, <argument><expr><operator>*</operator><name>toBeVisitedNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * BuildDeadlockPathList fills deadlockPath with a list of transactions involved
 * in a distributed deadlock (i.e. a cycle in the graph).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>BuildDeadlockPathList</name><parameter_list>(<parameter><decl><type><name>QueuedTransactionNode</name> <modifier>*</modifier></type><name>cycledTransactionNode</name></decl></parameter>,
					  <parameter><decl><type><name>TransactionNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>transactionNodeStack</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>deadlockPath</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>deadlockStackDepth</name> <init>= <expr><name><name>cycledTransactionNode</name><operator>-&gt;</operator><name>currentStackDepth</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>deadlockPath</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>stackIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>stackIndex</name> <operator>&lt;</operator> <name>deadlockStackDepth</name></expr>;</condition> <incr><expr><name>stackIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>deadlockPath</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>deadlockPath</name></expr></argument>, <argument><expr><name><name>transactionNodeStack</name><index>[<expr><name>stackIndex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>


<comment type="block">/*
 * ResetVisitedFields goes over all the elements of the input adjacency list
 * and sets transactionVisited to false.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ResetVisitedFields</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>adjacencyList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionNode</name> <modifier>*</modifier></type><name>resetNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* reset all visited fields */</comment>
	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>adjacencyList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>resetNode</name> <operator>=</operator> <operator>(</operator><name>TransactionNode</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>resetNode</name><operator>-&gt;</operator><name>transactionVisited</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>


<comment type="block">/*
 * AssociateDistributedTransactionWithBackendProc gets a transaction node
 * and searches the corresponding backend. Once found, transactionNodes'
 * initiatorProc is set to it.
 *
 * The function goes over all the backends, checks for the backend with
 * the same transaction number as the given transaction node.
 *
 * If the transaction cannot be associated with a backend process, the function
 * returns false. Otherwise, the function returns true.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>AssociateDistributedTransactionWithBackendProc</name><parameter_list>(<parameter><decl><type><name>TransactionNode</name> <modifier>*</modifier></type><name>transactionNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name> <name>localGroupId</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name> <init>= <expr><call><name>GetLocalGroupId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>backendIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>backendIndex</name> <operator>&lt;</operator> <name>MaxBackends</name></expr>;</condition> <incr><expr><operator>++</operator><name>backendIndex</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>currentProc</name> <init>= <expr><operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>allProcs</name><index>[<expr><name>backendIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BackendData</name></type> <name>currentBackendData</name></decl>;</decl_stmt>

		<comment type="block">/* we're not interested in processes that are not active or waiting on a lock */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>currentProc</name><operator>-&gt;</operator><name>pid</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>GetBackendDataForProc</name><argument_list>(<argument><expr><name>currentProc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>currentBackendData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* we're only interested in distribtued transactions */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsInDistributedTransaction</name><argument_list>(<argument><expr><operator>&amp;</operator><name>currentBackendData</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>DistributedTransactionId</name> <modifier>*</modifier></type><name>currentTransactionId</name> <init>=
			<expr><operator>&amp;</operator><name><name>currentBackendData</name><operator>.</operator><name>transactionId</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>currentTransactionId</name><operator>-&gt;</operator><name>transactionNumber</name></name> <operator>!=</operator>
			<name><name>transactionNode</name><operator>-&gt;</operator><name>transactionId</name><operator>.</operator><name>transactionNumber</name></name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* we're only interested in transactions started on this node */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>currentTransactionId</name><operator>-&gt;</operator><name>transactionOriginator</name></name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* at the point we should only have transactions initiated by this node */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>currentTransactionId</name><operator>-&gt;</operator><name>initiatorNodeIdentifier</name></name> <operator>==</operator> <name>localGroupId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>transactionNode</name><operator>-&gt;</operator><name>initiatorProc</name></name> <operator>=</operator> <name>currentProc</name></expr>;</expr_stmt>

		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></for>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * BuildAdjacencyListsForWaitGraph converts the input wait graph to
 * an adjacency list for further processing.
 *
 * The input wait graph consists of set of wait edges between all
 * backends in the Citus cluster.
 *
 * We represent the adjacency list with an HTAB structure. Each node is
 * represented with a DistributedTransactionId and each edge is represented with
 * a TransactionNode structure.
 *
 * While iterating over the input wait edges, we follow the algorithm
 * below:
 *    for each edge in waitGraph:
 *      - find the corresponding nodes for waiting and
 *        blocking transactions in the adjacency list
 *          - if not found, add new node(s) to the list
 *      - Add blocking transaction to the waiting transaction's waitFor
 *        list
 *
 *  The format of the adjacency list becomes the following:
 *      [transactionId] = [transactionNode-&gt;waitsFor {list of waiting transaction nodes}]
 */</comment>
<function><type><specifier>extern</specifier> <name>HTAB</name> <modifier>*</modifier></type>
<name>BuildAdjacencyListsForWaitGraph</name><parameter_list>(<parameter><decl><type><name>WaitGraph</name> <modifier>*</modifier></type><name>waitGraph</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASHCTL</name></type> <name>info</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>edgeCount</name> <init>= <expr><name><name>waitGraph</name><operator>-&gt;</operator><name>edgeCount</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>info</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DistributedTransactionId</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionNode</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>hash</name></name> <operator>=</operator> <name>DistributedTransactionIdHash</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>match</name></name> <operator>=</operator> <name>DistributedTransactionIdCompare</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>hashFlags</name> <init>= <expr><operator>(</operator><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_FUNCTION</name> <operator>|</operator> <name>HASH_CONTEXT</name> <operator>|</operator> <name>HASH_COMPARE</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>adjacencyList</name> <init>= <expr><call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"distributed deadlock detection"</literal></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>,
									  <argument><expr><name>hashFlags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>edgeIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>edgeIndex</name> <operator>&lt;</operator> <name>edgeCount</name></expr>;</condition> <incr><expr><name>edgeIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WaitEdge</name> <modifier>*</modifier></type><name>edge</name> <init>= <expr><operator>&amp;</operator><name><name>waitGraph</name><operator>-&gt;</operator><name>edges</name><index>[<expr><name>edgeIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>transactionOriginator</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>DistributedTransactionId</name></type> <name>waitingId</name> <init>= <expr><block>{
			<expr><name><name>edge</name><operator>-&gt;</operator><name>waitingNodeId</name></name></expr>,
			<expr><name>transactionOriginator</name></expr>,
			<expr><name><name>edge</name><operator>-&gt;</operator><name>waitingTransactionNum</name></name></expr>,
			<expr><name><name>edge</name><operator>-&gt;</operator><name>waitingTransactionStamp</name></name></expr>
		}</block></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>DistributedTransactionId</name></type> <name>blockingId</name> <init>= <expr><block>{
			<expr><name><name>edge</name><operator>-&gt;</operator><name>blockingNodeId</name></name></expr>,
			<expr><name>transactionOriginator</name></expr>,
			<expr><name><name>edge</name><operator>-&gt;</operator><name>blockingTransactionNum</name></name></expr>,
			<expr><name><name>edge</name><operator>-&gt;</operator><name>blockingTransactionStamp</name></name></expr>
		}</block></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>TransactionNode</name> <modifier>*</modifier></type><name>waitingTransaction</name> <init>=
			<expr><call><name>GetOrCreateTransactionNode</name><argument_list>(<argument><expr><name>adjacencyList</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>waitingId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TransactionNode</name> <modifier>*</modifier></type><name>blockingTransaction</name> <init>=
			<expr><call><name>GetOrCreateTransactionNode</name><argument_list>(<argument><expr><name>adjacencyList</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blockingId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>waitingTransaction</name><operator>-&gt;</operator><name>waitsFor</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>waitingTransaction</name><operator>-&gt;</operator><name>waitsFor</name></name></expr></argument>,
											   <argument><expr><name>blockingTransaction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>adjacencyList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetOrCreateTransactionNode searches distributedTransactionHash for the given
 * given transactionId. If the transaction is not found, a new transaction node
 * with the given transaction identifier is added.
 */</comment>
<function><type><specifier>static</specifier> <name>TransactionNode</name> <modifier>*</modifier></type>
<name>GetOrCreateTransactionNode</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>adjacencyList</name></decl></parameter>, <parameter><decl><type><name>DistributedTransactionId</name> <modifier>*</modifier></type><name>transactionId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>TransactionNode</name> <modifier>*</modifier></type><name>transactionNode</name> <init>= <expr><operator>(</operator><name>TransactionNode</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>adjacencyList</name></expr></argument>,
																	   <argument><expr><name>transactionId</name></expr></argument>,
																	   <argument><expr><name>HASH_ENTER</name></expr></argument>,
																	   <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>transactionNode</name><operator>-&gt;</operator><name>waitsFor</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>transactionNode</name><operator>-&gt;</operator><name>initiatorProc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>transactionNode</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DistributedTransactionIdHash returns hashed value for a given distributed
 * transaction id.
 */</comment>
<function><type><specifier>static</specifier> <name>uint32</name></type>
<name>DistributedTransactionIdHash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DistributedTransactionId</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><operator>(</operator><name>DistributedTransactionId</name> <operator>*</operator><operator>)</operator> <name>key</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint32</name></type> <name>hash</name> <init>= <expr><call><name>hash_uint32</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>initiatorNodeIdentifier</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>hash_combine</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><call><name>hash_any</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>transactionNumber</name></name></expr></argument>,
									   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>hash_combine</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><call><name>hash_any</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>timestamp</name></name></expr></argument>,
									   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TimestampTz</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>hash</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DistributedTransactionIdCompare compares DistributedTransactionId's a and b
 * and returns -1 if a &lt; b, 1 if a &gt; b, 0 if they are equal.
 *
 * DistributedTransactionId are first compared by their timestamp, then transaction
 * number, then node identifier.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>DistributedTransactionIdCompare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DistributedTransactionId</name> <modifier>*</modifier></type><name>xactIdA</name> <init>= <expr><operator>(</operator><name>DistributedTransactionId</name> <operator>*</operator><operator>)</operator> <name>a</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DistributedTransactionId</name> <modifier>*</modifier></type><name>xactIdB</name> <init>= <expr><operator>(</operator><name>DistributedTransactionId</name> <operator>*</operator><operator>)</operator> <name>b</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TimestampDifferenceExceeds</name><argument_list>(<argument><expr><name><name>xactIdB</name><operator>-&gt;</operator><name>timestamp</name></name></expr></argument>, <argument><expr><name><name>xactIdA</name><operator>-&gt;</operator><name>timestamp</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* ! (B &lt;= A) = A &lt; B */</comment>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>TimestampDifferenceExceeds</name><argument_list>(<argument><expr><name><name>xactIdA</name><operator>-&gt;</operator><name>timestamp</name></name></expr></argument>, <argument><expr><name><name>xactIdB</name><operator>-&gt;</operator><name>timestamp</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* ! (A &lt;= B) = A &gt; B */</comment>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>xactIdA</name><operator>-&gt;</operator><name>transactionNumber</name></name> <operator>&lt;</operator> <name><name>xactIdB</name><operator>-&gt;</operator><name>transactionNumber</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>xactIdA</name><operator>-&gt;</operator><name>transactionNumber</name></name> <operator>&gt;</operator> <name><name>xactIdB</name><operator>-&gt;</operator><name>transactionNumber</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>xactIdA</name><operator>-&gt;</operator><name>initiatorNodeIdentifier</name></name> <operator>&lt;</operator> <name><name>xactIdB</name><operator>-&gt;</operator><name>initiatorNodeIdentifier</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>xactIdA</name><operator>-&gt;</operator><name>initiatorNodeIdentifier</name></name> <operator>&gt;</operator> <name><name>xactIdB</name><operator>-&gt;</operator><name>initiatorNodeIdentifier</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * LogCancellingBackend should only be called when a distributed transaction's
 * backend is cancelled due to distributed deadlocks. It sends which transaction
 * is cancelled and its corresponding pid to the log.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>LogCancellingBackend</name><parameter_list>(<parameter><decl><type><name>TransactionNode</name> <modifier>*</modifier></type><name>transactionNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>LogDistributedDeadlockDetection</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>StringInfo</name></type> <name>logMessage</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>logMessage</name></expr></argument>, <argument><expr><literal type="string">"Cancelling the following backend "</literal>
								 <literal type="string">"to resolve distributed deadlock "</literal>
								 <literal type="string">"(transaction number = "</literal> <name>UINT64_FORMAT</name> <literal type="string">", pid = %d)"</literal></expr></argument>,
					 <argument><expr><name><name>transactionNode</name><operator>-&gt;</operator><name>transactionId</name><operator>.</operator><name>transactionNumber</name></name></expr></argument>,
					 <argument><expr><name><name>transactionNode</name><operator>-&gt;</operator><name>initiatorProc</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LogDistributedDeadlockDebugMessage</name><argument_list>(<argument><expr><name><name>logMessage</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * LogTransactionNode converts the transaction node to a human readable form
 * and sends to the logs via LogDistributedDeadlockDebugMessage().
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>LogTransactionNode</name><parameter_list>(<parameter><decl><type><name>TransactionNode</name> <modifier>*</modifier></type><name>transactionNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>LogDistributedDeadlockDetection</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>StringInfo</name></type> <name>logMessage</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DistributedTransactionId</name> <modifier>*</modifier></type><name>transactionId</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>transactionNode</name><operator>-&gt;</operator><name>transactionId</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>logMessage</name></expr></argument>,
					 <argument><expr><literal type="string">"[DistributedTransactionId: (%d, "</literal> <name>UINT64_FORMAT</name> <literal type="string">", %s)] = "</literal></expr></argument>,
					 <argument><expr><name><name>transactionId</name><operator>-&gt;</operator><name>initiatorNodeIdentifier</name></name></expr></argument>,
					 <argument><expr><name><name>transactionId</name><operator>-&gt;</operator><name>transactionNumber</name></name></expr></argument>,
					 <argument><expr><call><name>timestamptz_to_str</name><argument_list>(<argument><expr><name><name>transactionId</name><operator>-&gt;</operator><name>timestamp</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>logMessage</name></expr></argument>, <argument><expr><literal type="string">"[WaitsFor transaction numbers: %s]"</literal></expr></argument>,
					 <argument><expr><call><name>WaitsForToString</name><argument_list>(<argument><expr><name><name>transactionNode</name><operator>-&gt;</operator><name>waitsFor</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* log the backend query if the proc is associated with the transaction */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>transactionNode</name><operator>-&gt;</operator><name>initiatorProc</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>backendQuery</name> <init>=
			<expr><call><name>pgstat_get_backend_current_activity</name><argument_list>(<argument><expr><name><name>transactionNode</name><operator>-&gt;</operator><name>initiatorProc</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>,
												<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>logMessage</name></expr></argument>, <argument><expr><literal type="string">"[Backend Query: %s]"</literal></expr></argument>, <argument><expr><name>backendQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LogDistributedDeadlockDebugMessage</name><argument_list>(<argument><expr><name><name>logMessage</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * LogDistributedDeadlockDebugMessage checks EnableDistributedDeadlockDebugging flag. If
 * it is true, the input message is sent to the logs with LOG level. Also, current timestamp
 * is prepanded to the message.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>LogDistributedDeadlockDebugMessage</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>errorMessage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>LogDistributedDeadlockDetection</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"[%s] %s"</literal></expr></argument>, <argument><expr><call><name>timestamptz_to_str</name><argument_list>(<argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name>errorMessage</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * WaitsForToString is only intended for testing and debugging. It gets a
 * waitsForList and returns the list of transaction nodes' transactionNumber
 * in a string.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>WaitsForToString</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>waitsFor</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>transactionIdStr</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>TransactionNode</name> <modifier>*</modifier></type><name>waitingNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>waitingNode</argument>, <argument>waitsFor</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>transactionIdStr</name><operator>-&gt;</operator><name>len</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>transactionIdStr</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>transactionIdStr</name></expr></argument>, <argument><expr><name>UINT64_FORMAT</name></expr></argument>,
						 <argument><expr><name><name>waitingNode</name><operator>-&gt;</operator><name>transactionId</name><operator>.</operator><name>transactionNumber</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name><name>transactionIdStr</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>
</unit>
