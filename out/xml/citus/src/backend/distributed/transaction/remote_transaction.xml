<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/citus/src/backend/distributed/transaction/remote_transaction.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * remote_transaction.c
 *   Management of transaction spanning more than one node.
 *
 *   Since the functions defined in this file mostly allocate in
 *   CitusXactCallbackContext, we mostly try doing allocations on stack.
 *   And when it's hard to do so, we at least try freeing the heap memory
 *   immediately after an object becomes useless.
 *
 * Copyright (c) Citus Data, Inc.
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-fe.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/backend_data.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_safe_lib.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/connection_management.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/placement_connection.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/remote_commands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/remote_transaction.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/transaction_identifier.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/transaction_management.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/transaction_recovery.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_manager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/hsearch.h"</cpp:file></cpp:include>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PREPARED_TRANSACTION_NAME_FORMAT</name></cpp:macro> <cpp:value>"citus_%u_%u_"UINT64_FORMAT "_%u"</cpp:value></cpp:define>


<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>BeginTransactionCommand</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>AssignDistributedTransactionIdCommand</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>StartRemoteTransactionSavepointBegin</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>,
												 <parameter><decl><type><name>SubTransactionId</name></type> <name>subId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>FinishRemoteTransactionSavepointBegin</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>,
												  <parameter><decl><type><name>SubTransactionId</name></type> <name>subId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>StartRemoteTransactionSavepointRelease</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>,
												   <parameter><decl><type><name>SubTransactionId</name></type> <name>subId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>FinishRemoteTransactionSavepointRelease</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>,
													<parameter><decl><type><name>SubTransactionId</name></type> <name>subId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>StartRemoteTransactionSavepointRollback</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>,
													<parameter><decl><type><name>SubTransactionId</name></type> <name>subId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>FinishRemoteTransactionSavepointRollback</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>,
													 <parameter><decl><type><name>SubTransactionId</name></type> <name>subId</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>Assign2PCIdentifier</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>)</parameter_list>;</function_decl>


<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name><name>IsolationLevelName</name><index>[]</index></name> <init>= <expr><block>{
	<expr><literal type="string">"READ UNCOMMITTED"</literal></expr>,
	<expr><literal type="string">"READ COMMITTED"</literal></expr>,
	<expr><literal type="string">"REPEATABLE READ"</literal></expr>,
	<expr><literal type="string">"SERIALIZABLE"</literal></expr>
}</block></expr></init></decl>;</decl_stmt>


<comment type="block">/*
 * StartRemoteTransactionBegin initiates beginning the remote transaction in
 * a non-blocking manner. The function sends "BEGIN" followed by
 * assign_distributed_transaction_id() to assign the distributed transaction
 * id on the remote node.
 */</comment>
<function><type><name>void</name></type>
<name>StartRemoteTransactionBegin</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>MultiConnection</name></name> <modifier>*</modifier></type><name>connection</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RemoteTransaction</name> <modifier>*</modifier></type><name>transaction</name> <init>= <expr><operator>&amp;</operator><name><name>connection</name><operator>-&gt;</operator><name>remoteTransaction</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>==</operator> <name>REMOTE_TRANS_NOT_STARTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* remember transaction as being in-progress */</comment>
	<expr_stmt><expr><call><name>dlist_push_tail</name><argument_list>(<argument><expr><operator>&amp;</operator><name>InProgressTransactions</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>connection</name><operator>-&gt;</operator><name>transactionNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>=</operator> <name>REMOTE_TRANS_STARTING</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>StringInfo</name></type> <name>beginAndSetDistributedTransactionId</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Explicitly specify READ COMMITTED, the default on the remote
	 * side might have been changed, and that would cause problematic
	 * behaviour.
	 */</comment>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>beginAndSetDistributedTransactionId</name></expr></argument>,
						   <argument><expr><call><name>BeginTransactionCommand</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* append context for in-progress SAVEPOINTs for this transaction */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>activeSubXacts</name> <init>= <expr><call><name>ActiveSubXactContexts</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>transaction</name><operator>-&gt;</operator><name>lastSuccessfulSubXact</name></name> <operator>=</operator> <name>TopSubTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>transaction</name><operator>-&gt;</operator><name>lastQueuedSubXact</name></name> <operator>=</operator> <name>TopSubTransactionId</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>SubXactContext</name> <modifier>*</modifier></type><name>subXactState</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>subXactState</argument>, <argument>activeSubXacts</argument>)</argument_list></macro>
	<block>{<block_content>
		<comment type="block">/* append SET LOCAL state from when SAVEPOINT was encountered... */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>subXactState</name><operator>-&gt;</operator><name>setLocalCmds</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>beginAndSetDistributedTransactionId</name></expr></argument>,
								   <argument><expr><name><name>subXactState</name><operator>-&gt;</operator><name>setLocalCmds</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* ... then append SAVEPOINT to enter this subxact */</comment>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>beginAndSetDistributedTransactionId</name></expr></argument>,
						 <argument><expr><literal type="string">"SAVEPOINT savepoint_%u;"</literal></expr></argument>, <argument><expr><name><name>subXactState</name><operator>-&gt;</operator><name>subId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>transaction</name><operator>-&gt;</operator><name>lastQueuedSubXact</name></name> <operator>=</operator> <name><name>subXactState</name><operator>-&gt;</operator><name>subId</name></name></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* we've pushed into deepest subxact: apply in-progress SET context */</comment>
	<if_stmt><if>if <condition>(<expr><name>activeSetStmts</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>beginAndSetDistributedTransactionId</name></expr></argument>, <argument><expr><name><name>activeSetStmts</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>assignDistributedTransactionIdCommand</name> <init>= <expr><call><name>AssignDistributedTransactionIdCommand</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* add SELECT assign_distributed_transaction_id ... */</comment>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>beginAndSetDistributedTransactionId</name></expr></argument>,
						   <argument><expr><name>assignDistributedTransactionIdCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>assignDistributedTransactionIdCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>success</name> <init>= <expr><call><name>SendRemoteCommand</name><argument_list>(<argument><expr><name>connection</name></expr></argument>,
									 <argument><expr><name><name>beginAndSetDistributedTransactionId</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>beginAndSetDistributedTransactionId</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>beginAndSetDistributedTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>raiseErrors</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>HandleRemoteTransactionConnectionError</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>raiseErrors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>transaction</name><operator>-&gt;</operator><name>beginSent</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * BeginAndSetDistributedTransactionIdCommand returns a command which starts
 * a transaction and assigns the current distributed transaction id.
 */</comment>
<function><type><name>StringInfo</name></type>
<name>BeginAndSetDistributedTransactionIdCommand</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>beginAndSetDistributedTransactionId</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Explicitly specify READ COMMITTED, the default on the remote
	 * side might have been changed, and that would cause problematic
	 * behaviour.
	 */</comment>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>beginAndSetDistributedTransactionId</name></expr></argument>,
						   <argument><expr><call><name>BeginTransactionCommand</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>beginAndSetDistributedTransactionId</name></expr></argument>,
						   <argument><expr><call><name>AssignDistributedTransactionIdCommand</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>beginAndSetDistributedTransactionId</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * BeginTransactionCommand returns the BEGIN command to use for the current isolation
 * level.
 *
 * Transactions have 3 properties that we care about here:
 * - XactIsoLevel (isolation level)
 * - XactDeferrable (deferrable)
 * - XactReadOnly (read only)
 *
 * These properties can be set in several ways:
 * - via BEGIN TRANSACTION ISOLATION LEVEL ...
 * - via default_transaction_isolation, ...
 * - via SET TRANSACTION .. (or plain SET transaction_isolation ...)
 *
 * We want to make sure that the properties that are passed to the worker nodes
 * match the coordinator as much as possible. However, we do not want to waste
 * bytes repeating the current values ad infinitum.
 *
 * The trade-off we make is that we send the isolation level in all cases,
 * but only set deferrable and read-only if they were explicitly specified
 * in the BEGIN by the user. The implication is that we may not follow the
 * default_transaction_* settings on the coordinator if they differ on the
 * worker.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>BeginTransactionCommand</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>beginCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * XactIsoLevel can only be set at the start of the transaction, before the
	 * first query. Since Citus does not send BEGIN until the first query, we
	 * can simply use the current values, and they will match the values for the
	 * outer transaction after any BEGIN and SET TRANSACTION that may have occurred.
	 */</comment>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>beginCommand</name></expr></argument>, <argument><expr><literal type="string">"BEGIN TRANSACTION ISOLATION LEVEL %s"</literal></expr></argument>,
					 <argument><expr><name><name>IsolationLevelName</name><index>[<expr><name>XactIsoLevel</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>BeginXactDeferrable</name> <operator>==</operator> <name>BeginXactDeferrable_Enabled</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>beginCommand</name></expr></argument>, <argument><expr><literal type="string">" DEFERRABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>BeginXactDeferrable</name> <operator>==</operator> <name>BeginXactDeferrable_Disabled</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>beginCommand</name></expr></argument>, <argument><expr><literal type="string">" NOT DEFERRABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>BeginXactReadOnly</name> <operator>==</operator> <name>BeginXactReadOnly_Enabled</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>beginCommand</name></expr></argument>, <argument><expr><literal type="string">" READ ONLY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>BeginXactReadOnly</name> <operator>==</operator> <name>BeginXactReadOnly_Disabled</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>beginCommand</name></expr></argument>, <argument><expr><literal type="string">" READ WRITE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>beginCommand</name></expr></argument>, <argument><expr><literal type="char">';'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>beginCommand</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AssignDistributedTransactionIdCommand returns a command to set the local
 * distributed transaction ID on a remote transaction.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>AssignDistributedTransactionIdCommand</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>assignDistributedTransactionId</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Append BEGIN and assign_distributed_transaction_id() statements into a single command
	 * and send both in one step. The reason is purely performance, we don't want
	 * seperate roundtrips for these two statements.
	 */</comment>
	<decl_stmt><decl><type><name>DistributedTransactionId</name> <modifier>*</modifier></type><name>distributedTransactionId</name> <init>=
		<expr><call><name>GetCurrentDistributedTransactionId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>timestamp</name> <init>= <expr><call><name>timestamptz_to_str</name><argument_list>(<argument><expr><name><name>distributedTransactionId</name><operator>-&gt;</operator><name>timestamp</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>assignDistributedTransactionId</name></expr></argument>,
					 <argument><expr><literal type="string">"SELECT assign_distributed_transaction_id(%d, "</literal> <name>UINT64_FORMAT</name>
					 <literal type="string">", '%s');"</literal></expr></argument>,
					 <argument><expr><name><name>distributedTransactionId</name><operator>-&gt;</operator><name>initiatorNodeIdentifier</name></name></expr></argument>,
					 <argument><expr><name><name>distributedTransactionId</name><operator>-&gt;</operator><name>transactionNumber</name></name></expr></argument>,
					 <argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* free the StringInfo but not the buffer itself */</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>command</name> <init>= <expr><name><name>assignDistributedTransactionId</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>assignDistributedTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>command</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FinishRemoteTransactionBegin finishes the work StartRemoteTransactionBegin
 * initiated. It blocks if necessary (i.e. if PQisBusy() would return true).
 */</comment>
<function><type><name>void</name></type>
<name>FinishRemoteTransactionBegin</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>MultiConnection</name></name> <modifier>*</modifier></type><name>connection</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RemoteTransaction</name> <modifier>*</modifier></type><name>transaction</name> <init>= <expr><operator>&amp;</operator><name><name>connection</name><operator>-&gt;</operator><name>remoteTransaction</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>raiseErrors</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>==</operator> <name>REMOTE_TRANS_STARTING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>clearSuccessful</name> <init>= <expr><call><name>ClearResults</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>raiseErrors</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>clearSuccessful</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>=</operator> <name>REMOTE_TRANS_STARTED</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>transaction</name><operator>-&gt;</operator><name>lastSuccessfulSubXact</name></name> <operator>=</operator> <name><name>transaction</name><operator>-&gt;</operator><name>lastQueuedSubXact</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>transaction</name><operator>-&gt;</operator><name>transactionFailed</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PQtransactionStatus</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PQTRANS_INTRANS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * RemoteTransactionBegin begins a remote transaction in a blocking manner.
 */</comment>
<function><type><name>void</name></type>
<name>RemoteTransactionBegin</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>MultiConnection</name></name> <modifier>*</modifier></type><name>connection</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>StartRemoteTransactionBegin</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FinishRemoteTransactionBegin</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * RemoteTransactionListBegin sends BEGIN over all connections in the
 * given connection list and waits for all of them to finish.
 */</comment>
<function><type><name>void</name></type>
<name>RemoteTransactionListBegin</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>connectionList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* send BEGIN to all nodes */</comment>
	<macro><name>foreach_ptr</name><argument_list>(<argument>connection</argument>, <argument>connectionList</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>StartRemoteTransactionBegin</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* wait for BEGIN to finish on all nodes */</comment>
	<macro><name>foreach_ptr</name><argument_list>(<argument>connection</argument>, <argument>connectionList</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>FinishRemoteTransactionBegin</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * StartRemoteTransactionCommit initiates transaction commit in a non-blocking
 * manner.  If the transaction is in a failed state, it'll instead get rolled
 * back.
 */</comment>
<function><type><name>void</name></type>
<name>StartRemoteTransactionCommit</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RemoteTransaction</name> <modifier>*</modifier></type><name>transaction</name> <init>= <expr><operator>&amp;</operator><name><name>connection</name><operator>-&gt;</operator><name>remoteTransaction</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>raiseErrors</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* can only commit if transaction is in progress */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>!=</operator> <name>REMOTE_TRANS_NOT_STARTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* can't commit if we already started to commit or abort */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>&lt;</operator> <name>REMOTE_TRANS_1PC_ABORTING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionFailed</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* abort the transaction if it failed */</comment>
		<expr_stmt><expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>=</operator> <name>REMOTE_TRANS_1PC_ABORTING</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Try sending an ROLLBACK; Depending on the state that won't
		 * succeed, but let's try.  Have to clear previous results
		 * first.
		 */</comment>
		<expr_stmt><expr><call><name>ForgetResults</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* try to clear pending stuff */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SendRemoteCommand</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><literal type="string">"ROLLBACK"</literal></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* no point in reporting a likely redundant message */</comment>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>==</operator> <name>REMOTE_TRANS_PREPARED</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Commit the prepared transaction.
		 *
		 * We need to allocate 420 bytes for command buffer (including '\0'):
		 *  - len("COMMIT PREPARED ") = 16
		 *  - maximum quoted length of transaction-&gt;preparedName = 2 * 200 + 3 = 403
		 */</comment>
		<decl_stmt><decl><type><name>char</name></type> <name><name>command</name><index>[<expr><literal type="number">420</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>quotedPrepName</name> <init>= <expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name><name>transaction</name><operator>-&gt;</operator><name>preparedName</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>SafeSnprintf</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"COMMIT PREPARED %s"</literal></expr></argument>, <argument><expr><name>quotedPrepName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>quotedPrepName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>=</operator> <name>REMOTE_TRANS_2PC_COMMITTING</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SendRemoteCommand</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>HandleRemoteTransactionConnectionError</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>raiseErrors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* initiate remote transaction commit */</comment>
		<expr_stmt><expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>=</operator> <name>REMOTE_TRANS_1PC_COMMITTING</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SendRemoteCommand</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><literal type="string">"COMMIT"</literal></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * For a moment there I thought we were in trouble.
			 *
			 * Failing in this state means that we don't know whether the
			 * commit has succeeded.
			 */</comment>
			<expr_stmt><expr><call><name>HandleRemoteTransactionConnectionError</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>raiseErrors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * FinishRemoteTransactionCommit finishes the work
 * StartRemoteTransactionCommit initiated. It blocks if necessary (i.e. if
 * PQisBusy() would return true).
 */</comment>
<function><type><name>void</name></type>
<name>FinishRemoteTransactionCommit</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RemoteTransaction</name> <modifier>*</modifier></type><name>transaction</name> <init>= <expr><operator>&amp;</operator><name><name>connection</name><operator>-&gt;</operator><name>remoteTransaction</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>raiseErrors</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>==</operator> <name>REMOTE_TRANS_1PC_ABORTING</name> <operator>||</operator>
		   <name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>==</operator> <name>REMOTE_TRANS_1PC_COMMITTING</name> <operator>||</operator>
		   <name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>==</operator> <name>REMOTE_TRANS_2PC_COMMITTING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>GetRemoteCommandResult</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>raiseErrors</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsResponseOK</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>HandleRemoteTransactionResultError</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>raiseErrors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Failing in this state means that we will often not know whether
		 * the commit has succeeded (particularly in case of network
		 * troubles).
		 *
		 * XXX: It might be worthwhile to discern cases where we got a
		 * proper error back from postgres (i.e. COMMIT was received but
		 * produced an error) from cases where the connection failed
		 * before getting a reply.
		 */</comment>

		<if_stmt><if>if <condition>(<expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>==</operator> <name>REMOTE_TRANS_1PC_COMMITTING</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failed to commit transaction on %s:%d"</literal></expr></argument>,
									 <argument><expr><name><name>connection</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>, <argument><expr><name><name>connection</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>==</operator> <name>REMOTE_TRANS_2PC_COMMITTING</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failed to commit transaction on %s:%d"</literal></expr></argument>,
									 <argument><expr><name><name>connection</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>, <argument><expr><name><name>connection</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>==</operator> <name>REMOTE_TRANS_1PC_ABORTING</name> <operator>||</operator>
			 <name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>==</operator> <name>REMOTE_TRANS_2PC_ABORTING</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>=</operator> <name>REMOTE_TRANS_ABORTED</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>=</operator> <name>REMOTE_TRANS_COMMITTED</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ForgetResults</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * RemoteTransactionCommit commits (or aborts, if the transaction failed) a
 * remote transaction in a blocking manner.
 */</comment>
<function><type><name>void</name></type>
<name>RemoteTransactionCommit</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>StartRemoteTransactionCommit</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FinishRemoteTransactionCommit</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * StartRemoteTransactionAbort initiates abortin the transaction in a
 * non-blocking manner.
 */</comment>
<function><type><name>void</name></type>
<name>StartRemoteTransactionAbort</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RemoteTransaction</name> <modifier>*</modifier></type><name>transaction</name> <init>= <expr><operator>&amp;</operator><name><name>connection</name><operator>-&gt;</operator><name>remoteTransaction</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>raiseErrors</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>!=</operator> <name>REMOTE_TRANS_NOT_STARTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Clear previous results, so we have a better chance to send ROLLBACK
	 * [PREPARED]. If we've previously sent a PREPARE TRANSACTION, we always
	 * want to wait for that result, as that shouldn't take long and will
	 * reserve resources.  But if there's another query running, we don't want
	 * to wait, because a long running statement may be running, so force it to
	 * be killed in that case.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>==</operator> <name>REMOTE_TRANS_PREPARING</name> <operator>||</operator>
		<name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>==</operator> <name>REMOTE_TRANS_PREPARED</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ForgetResults</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Await PREPARE TRANSACTION results, closing the connection would leave it dangling.
		 *
		 * We need to allocate 422 bytes for command buffer (including '\0'):
		 *  - len("ROLLBACK PREPARED ") = 18
		 *  - maximum quoted length of transaction-&gt;preparedName = 2 * 200 + 3 = 403
		 */</comment>
		<decl_stmt><decl><type><name>char</name></type> <name><name>command</name><index>[<expr><literal type="number">422</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>quotedPrepName</name> <init>= <expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name><name>transaction</name><operator>-&gt;</operator><name>preparedName</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>SafeSnprintf</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"ROLLBACK PREPARED %s"</literal></expr></argument>, <argument><expr><name>quotedPrepName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>quotedPrepName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SendRemoteCommand</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>HandleRemoteTransactionConnectionError</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>raiseErrors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>=</operator> <name>REMOTE_TRANS_2PC_ABORTING</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * In case of a cancellation, the connection might still be working
		 * on some commands. Try to consume the results such that the
		 * connection can be reused, but do not want to wait for commands
		 * to finish. Instead we just close the connection if the command
		 * is still busy.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ClearResultsIfReady</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ShutdownConnection</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* FinishRemoteTransactionAbort will emit warning */</comment>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SendRemoteCommand</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><literal type="string">"ROLLBACK"</literal></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* no point in reporting a likely redundant message */</comment>
			<expr_stmt><expr><call><name>MarkRemoteTransactionFailed</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>raiseErrors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>=</operator> <name>REMOTE_TRANS_1PC_ABORTING</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * FinishRemoteTransactionAbort finishes the work StartRemoteTransactionAbort
 * initiated. It blocks if necessary (i.e. if PQisBusy() would return true).
 */</comment>
<function><type><name>void</name></type>
<name>FinishRemoteTransactionAbort</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RemoteTransaction</name> <modifier>*</modifier></type><name>transaction</name> <init>= <expr><operator>&amp;</operator><name><name>connection</name><operator>-&gt;</operator><name>remoteTransaction</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>raiseErrors</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>==</operator> <name>REMOTE_TRANS_2PC_ABORTING</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>GetRemoteCommandResult</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>raiseErrors</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsResponseOK</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>HandleRemoteTransactionResultError</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>raiseErrors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Try to consume results of any in-progress commands. In the 1PC case
	 * this is also where we consume the result of the ROLLBACK.
	 *
	 * If we don't succeed the connection will be in a bad state, so we close it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ClearResults</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>raiseErrors</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ShutdownConnection</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>=</operator> <name>REMOTE_TRANS_ABORTED</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * RemoteTransactionAbort aborts a remote transaction in a blocking manner.
 */</comment>
<function><type><name>void</name></type>
<name>RemoteTransactionAbort</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>StartRemoteTransactionAbort</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FinishRemoteTransactionAbort</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * StartRemoteTransactionPrepare initiates preparing the transaction in a
 * non-blocking manner.
 */</comment>
<function><type><name>void</name></type>
<name>StartRemoteTransactionPrepare</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>MultiConnection</name></name> <modifier>*</modifier></type><name>connection</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RemoteTransaction</name> <modifier>*</modifier></type><name>transaction</name> <init>= <expr><operator>&amp;</operator><name><name>connection</name><operator>-&gt;</operator><name>remoteTransaction</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>raiseErrors</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* can't prepare a nonexistant transaction */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>!=</operator> <name>REMOTE_TRANS_NOT_STARTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* can't prepare in a failed transaction */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>transaction</name><operator>-&gt;</operator><name>transactionFailed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* can't prepare if already started to prepare/abort/commit */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>&lt;</operator> <name>REMOTE_TRANS_PREPARING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assign2PCIdentifier</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* log transactions to workers in pg_dist_transaction */</comment>
	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><call><name>FindWorkerNode</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>, <argument><expr><name><name>connection</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>workerNode</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LogTransactionRecord</name><argument_list>(<argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>, <argument><expr><name><name>transaction</name><operator>-&gt;</operator><name>preparedName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We need to allocate 424 bytes for command buffer (including '\0'):
	 *  - len("PREPARE TRANSACTION ") = 20
	 *  - maximum quoted length of transaction-&gt;preparedName = 2 * 200 + 3 = 403
	 */</comment>
	<decl_stmt><decl><type><name>char</name></type> <name><name>command</name><index>[<expr><literal type="number">424</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>quotedPrepName</name> <init>= <expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name><name>transaction</name><operator>-&gt;</operator><name>preparedName</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>SafeSnprintf</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"PREPARE TRANSACTION %s"</literal></expr></argument>, <argument><expr><name>quotedPrepName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>quotedPrepName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SendRemoteCommand</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>HandleRemoteTransactionConnectionError</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>raiseErrors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>=</operator> <name>REMOTE_TRANS_PREPARING</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * FinishRemoteTransactionPrepare finishes the work
 * StartRemoteTransactionPrepare initiated. It blocks if necessary (i.e. if
 * PQisBusy() would return true).
 */</comment>
<function><type><name>void</name></type>
<name>FinishRemoteTransactionPrepare</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>MultiConnection</name></name> <modifier>*</modifier></type><name>connection</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RemoteTransaction</name> <modifier>*</modifier></type><name>transaction</name> <init>= <expr><operator>&amp;</operator><name><name>connection</name><operator>-&gt;</operator><name>remoteTransaction</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>raiseErrors</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>==</operator> <name>REMOTE_TRANS_PREPARING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>GetRemoteCommandResult</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>raiseErrors</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsResponseOK</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>=</operator> <name>REMOTE_TRANS_ABORTED</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>HandleRemoteTransactionResultError</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>raiseErrors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>=</operator> <name>REMOTE_TRANS_PREPARED</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Try to consume results of PREPARE TRANSACTION command. If we don't
	 * succeed, rollback the transaction. Note that we've not committed on
	 * any node yet, and we're not sure about the state of the worker node.
	 * So rollbacking seems to be the safest action if the worker is
	 * in a state where it can actually rollback.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ClearResults</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>raiseErrors</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failed to prepare transaction '%s' on host %s:%d"</literal></expr></argument>,
							   <argument><expr><name><name>transaction</name><operator>-&gt;</operator><name>preparedName</name></name></expr></argument>, <argument><expr><name><name>connection</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>,
							   <argument><expr><name><name>connection</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Try re-running the command."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * RemoteTransactionBeginIfNecessary is a convenience wrapper around
 * RemoteTransactionsBeginIfNecessary(), for a single connection.
 */</comment>
<function><type><name>void</name></type>
<name>RemoteTransactionBeginIfNecessary</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* just delegate */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>InCoordinatedTransaction</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>connectionList</name> <init>= <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>RemoteTransactionsBeginIfNecessary</name><argument_list>(<argument><expr><name>connectionList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>connectionList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * RemoteTransactionsBeginIfNecessary begins, if necessary according to this
 * session's coordinated transaction state, and the remote transaction's
 * state, an explicit transaction on all the connections.  This is done in
 * parallel, to lessen latency penalties.
 */</comment>
<function><type><name>void</name></type>
<name>RemoteTransactionsBeginIfNecessary</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>connectionList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Don't do anything if not in a coordinated transaction. That allows the
	 * same code to work both in situations that uses transactions, and when
	 * not.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>InCoordinatedTransaction</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* issue BEGIN to all connections needing it */</comment>
	<macro><name>foreach_ptr</name><argument_list>(<argument>connection</argument>, <argument>connectionList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RemoteTransaction</name> <modifier>*</modifier></type><name>transaction</name> <init>= <expr><operator>&amp;</operator><name><name>connection</name><operator>-&gt;</operator><name>remoteTransaction</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* can't send BEGIN if a command already is in progress */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PQtransactionStatus</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PQTRANS_ACTIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If a transaction already is in progress (including having failed),
		 * don't start it again. That's quite normal if a piece of code allows
		 * cached connections.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>!=</operator> <name>REMOTE_TRANS_NOT_STARTED</name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>StartRemoteTransactionBegin</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<decl_stmt><decl><type><name>bool</name></type> <name>raiseInterrupts</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>WaitForAllConnections</name><argument_list>(<argument><expr><name>connectionList</name></expr></argument>, <argument><expr><name>raiseInterrupts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* get result of all the BEGINs */</comment>
	<macro><name>foreach_ptr</name><argument_list>(<argument>connection</argument>, <argument>connectionList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RemoteTransaction</name> <modifier>*</modifier></type><name>transaction</name> <init>= <expr><operator>&amp;</operator><name><name>connection</name><operator>-&gt;</operator><name>remoteTransaction</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Only handle BEGIN results on connections that are in process of
		 * starting a transaction, and haven't already failed (e.g. by not
		 * being able to send BEGIN due to a network failure).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionFailed</name></name> <operator>||</operator>
			<name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>!=</operator> <name>REMOTE_TRANS_STARTING</name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>FinishRemoteTransactionBegin</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * HandleRemoteTransactionConnectionError records a transaction as having failed
 * and throws a connection error if the transaction was critical and raiseErrors
 * is true, or a warning otherwise.
 */</comment>
<function><type><name>void</name></type>
<name>HandleRemoteTransactionConnectionError</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>raiseErrors</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RemoteTransaction</name> <modifier>*</modifier></type><name>transaction</name> <init>= <expr><operator>&amp;</operator><name><name>connection</name><operator>-&gt;</operator><name>remoteTransaction</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionFailed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionCritical</name></name> <operator>&amp;&amp;</operator> <name>raiseErrors</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReportConnectionError</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReportConnectionError</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>WARNING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * HandleRemoteTransactionResultError records a transaction as having failed
 * and throws a result error if the transaction was critical and raiseErrors
 * is true, or a warning otherwise.
 */</comment>
<function><type><name>void</name></type>
<name>HandleRemoteTransactionResultError</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>, <parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>bool</name></type>
								   <name>raiseErrors</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RemoteTransaction</name> <modifier>*</modifier></type><name>transaction</name> <init>= <expr><operator>&amp;</operator><name><name>connection</name><operator>-&gt;</operator><name>remoteTransaction</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionFailed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionCritical</name></name> <operator>&amp;&amp;</operator> <name>raiseErrors</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReportResultError</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReportResultError</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>WARNING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * MarkRemoteTransactionFailed records a transaction as having failed.
 *
 * If the connection is marked as critical, and allowErrorPromotion is true,
 * this routine will ERROR out. The allowErrorPromotion case is primarily
 * required for the transaction management code itself. Usually it is helpful
 * to fail as soon as possible. If !allowErrorPromotion transaction commit
 * will instead issue an error before committing on any node.
 */</comment>
<function><type><name>void</name></type>
<name>MarkRemoteTransactionFailed</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>allowErrorPromotion</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RemoteTransaction</name> <modifier>*</modifier></type><name>transaction</name> <init>= <expr><operator>&amp;</operator><name><name>connection</name><operator>-&gt;</operator><name>remoteTransaction</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionFailed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the connection is marked as critical, fail the entire coordinated
	 * transaction. If allowed.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionCritical</name></name> <operator>&amp;&amp;</operator> <name>allowErrorPromotion</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failure on connection marked as essential: %s:%d"</literal></expr></argument>,
							   <argument><expr><name><name>connection</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>, <argument><expr><name><name>connection</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * MarkRemoteTransactionCritical signals that failures on this remote
 * transaction should fail the entire coordinated transaction.
 */</comment>
<function><type><name>void</name></type>
<name>MarkRemoteTransactionCritical</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>MultiConnection</name></name> <modifier>*</modifier></type><name>connection</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RemoteTransaction</name> <modifier>*</modifier></type><name>transaction</name> <init>= <expr><operator>&amp;</operator><name><name>connection</name><operator>-&gt;</operator><name>remoteTransaction</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionCritical</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ResetRemoteTransaction resets the state of the transaction after the end of
 * the main transaction, if the connection is being reused.
 */</comment>
<function><type><name>void</name></type>
<name>ResetRemoteTransaction</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>MultiConnection</name></name> <modifier>*</modifier></type><name>connection</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RemoteTransaction</name> <modifier>*</modifier></type><name>transaction</name> <init>= <expr><operator>&amp;</operator><name><name>connection</name><operator>-&gt;</operator><name>remoteTransaction</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* unlink from list of open transactions, if necessary */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>!=</operator> <name>REMOTE_TRANS_NOT_STARTED</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* XXX: Should we error out for a critical transaction? */</comment>

		<expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>connection</name><operator>-&gt;</operator><name>transactionNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* just reset the entire state, relying on 0 being invalid/false */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>transaction</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>transaction</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ResetShardPlacementAssociation</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* reset copy state */</comment>
	<expr_stmt><expr><name><name>connection</name><operator>-&gt;</operator><name>copyBytesWrittenSinceLastFlush</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CoordinatedRemoteTransactionsPrepare PREPAREs a 2PC transaction on all
 * non-failed transactions participating in the coordinated transaction.
 */</comment>
<function><type><name>void</name></type>
<name>CoordinatedRemoteTransactionsPrepare</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dlist_iter</name></type> <name>iter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>connectionList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* issue PREPARE TRANSACTION; to all relevant remote nodes */</comment>

	<comment type="block">/* asynchronously send PREPARE */</comment>
	<macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;InProgressTransactions</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>MultiConnection</name></expr></argument>, <argument><expr><name>transactionNode</name></expr></argument>,
													  <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RemoteTransaction</name> <modifier>*</modifier></type><name>transaction</name> <init>= <expr><operator>&amp;</operator><name><name>connection</name><operator>-&gt;</operator><name>remoteTransaction</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>!=</operator> <name>REMOTE_TRANS_NOT_STARTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* can't PREPARE a transaction that failed */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionFailed</name></name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Check if any DML or DDL is executed over the connection on any
		 * placement/table. If yes, we start preparing the transaction, otherwise
		 * we skip prepare since the connection didn't perform any write (read-only)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>ConnectionModifiedPlacement</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>StartRemoteTransactionPrepare</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>connectionList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>connectionList</name></expr></argument>, <argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<decl_stmt><decl><type><name>bool</name></type> <name>raiseInterrupts</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>WaitForAllConnections</name><argument_list>(<argument><expr><name>connectionList</name></expr></argument>, <argument><expr><name>raiseInterrupts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Wait for result */</comment>
	<macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;InProgressTransactions</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>MultiConnection</name></expr></argument>, <argument><expr><name>transactionNode</name></expr></argument>,
													  <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RemoteTransaction</name> <modifier>*</modifier></type><name>transaction</name> <init>= <expr><operator>&amp;</operator><name><name>connection</name><operator>-&gt;</operator><name>remoteTransaction</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>!=</operator> <name>REMOTE_TRANS_PREPARING</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Verify that either the transaction failed, hence we couldn't prepare
			 * or the connection didn't modify any placement
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionFailed</name></name> <operator>||</operator>
				   <operator>!</operator><call><name>ConnectionModifiedPlacement</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>FinishRemoteTransactionPrepare</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name>CurrentCoordinatedTransactionState</name> <operator>=</operator> <name>COORD_TRANS_PREPARED</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>connectionList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CoordinatedRemoteTransactionsCommit performs distributed transactions
 * handling at commit time. This will be called at XACT_EVENT_PRE_COMMIT if
 * 1PC commits are used - so shards can still be invalidated - and at
 * XACT_EVENT_COMMIT if 2PC is being used.
 *
 * Note that this routine has to issue rollbacks for failed transactions.
 */</comment>
<function><type><name>void</name></type>
<name>CoordinatedRemoteTransactionsCommit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dlist_iter</name></type> <name>iter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>connectionList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Issue appropriate transaction commands to remote nodes. If everything
	 * went well that's going to be COMMIT or COMMIT PREPARED, if individual
	 * connections had errors, some or all of them might require a ROLLBACK.
	 *
	 * First send the command asynchronously over all connections.
	 */</comment>
	<macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;InProgressTransactions</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>MultiConnection</name></expr></argument>, <argument><expr><name>transactionNode</name></expr></argument>,
													  <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RemoteTransaction</name> <modifier>*</modifier></type><name>transaction</name> <init>= <expr><operator>&amp;</operator><name><name>connection</name><operator>-&gt;</operator><name>remoteTransaction</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>==</operator> <name>REMOTE_TRANS_NOT_STARTED</name> <operator>||</operator>
			<name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>==</operator> <name>REMOTE_TRANS_1PC_COMMITTING</name> <operator>||</operator>
			<name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>==</operator> <name>REMOTE_TRANS_2PC_COMMITTING</name> <operator>||</operator>
			<name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>==</operator> <name>REMOTE_TRANS_COMMITTED</name> <operator>||</operator>
			<name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>==</operator> <name>REMOTE_TRANS_ABORTED</name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>StartRemoteTransactionCommit</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>connectionList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>connectionList</name></expr></argument>, <argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<decl_stmt><decl><type><name>bool</name></type> <name>raiseInterrupts</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>WaitForAllConnections</name><argument_list>(<argument><expr><name>connectionList</name></expr></argument>, <argument><expr><name>raiseInterrupts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* wait for the replies to the commands to come in */</comment>
	<macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;InProgressTransactions</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>MultiConnection</name></expr></argument>, <argument><expr><name>transactionNode</name></expr></argument>,
													  <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RemoteTransaction</name> <modifier>*</modifier></type><name>transaction</name> <init>= <expr><operator>&amp;</operator><name><name>connection</name><operator>-&gt;</operator><name>remoteTransaction</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* nothing to do if not committing / aborting */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>!=</operator> <name>REMOTE_TRANS_1PC_COMMITTING</name> <operator>&amp;&amp;</operator>
			<name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>!=</operator> <name>REMOTE_TRANS_2PC_COMMITTING</name> <operator>&amp;&amp;</operator>
			<name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>!=</operator> <name>REMOTE_TRANS_1PC_ABORTING</name> <operator>&amp;&amp;</operator>
			<name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>!=</operator> <name>REMOTE_TRANS_2PC_ABORTING</name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>FinishRemoteTransactionCommit</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>connectionList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CoordinatedRemoteTransactionsAbort performs distributed transactions
 * handling at abort time.
 *
 * This issues ROLLBACKS and ROLLBACK PREPARED depending on whether the remote
 * transaction has been prepared or not.
 */</comment>
<function><type><name>void</name></type>
<name>CoordinatedRemoteTransactionsAbort</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dlist_iter</name></type> <name>iter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>connectionList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* asynchronously send ROLLBACK [PREPARED] */</comment>
	<macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;InProgressTransactions</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>MultiConnection</name></expr></argument>, <argument><expr><name>transactionNode</name></expr></argument>,
													  <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RemoteTransaction</name> <modifier>*</modifier></type><name>transaction</name> <init>= <expr><operator>&amp;</operator><name><name>connection</name><operator>-&gt;</operator><name>remoteTransaction</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>==</operator> <name>REMOTE_TRANS_NOT_STARTED</name> <operator>||</operator>
			<name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>==</operator> <name>REMOTE_TRANS_1PC_ABORTING</name> <operator>||</operator>
			<name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>==</operator> <name>REMOTE_TRANS_2PC_ABORTING</name> <operator>||</operator>
			<name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>==</operator> <name>REMOTE_TRANS_ABORTED</name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>StartRemoteTransactionAbort</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>connectionList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>connectionList</name></expr></argument>, <argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<decl_stmt><decl><type><name>bool</name></type> <name>raiseInterrupts</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>WaitForAllConnections</name><argument_list>(<argument><expr><name>connectionList</name></expr></argument>, <argument><expr><name>raiseInterrupts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* and wait for the results */</comment>
	<macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;InProgressTransactions</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>MultiConnection</name></expr></argument>, <argument><expr><name>transactionNode</name></expr></argument>,
													  <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RemoteTransaction</name> <modifier>*</modifier></type><name>transaction</name> <init>= <expr><operator>&amp;</operator><name><name>connection</name><operator>-&gt;</operator><name>remoteTransaction</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>!=</operator> <name>REMOTE_TRANS_1PC_ABORTING</name> <operator>&amp;&amp;</operator>
			<name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>!=</operator> <name>REMOTE_TRANS_2PC_ABORTING</name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>FinishRemoteTransactionAbort</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>connectionList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CoordinatedRemoteTransactionsSavepointBegin sends the SAVEPOINT command for
 * the given sub-transaction id to all connections participating in the current
 * transaction.
 */</comment>
<function><type><name>void</name></type>
<name>CoordinatedRemoteTransactionsSavepointBegin</name><parameter_list>(<parameter><decl><type><name>SubTransactionId</name></type> <name>subId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dlist_iter</name></type> <name>iter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>raiseInterrupts</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>connectionList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* asynchronously send SAVEPOINT */</comment>
	<macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;InProgressTransactions</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>MultiConnection</name></expr></argument>, <argument><expr><name>transactionNode</name></expr></argument>,
													  <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RemoteTransaction</name> <modifier>*</modifier></type><name>transaction</name> <init>= <expr><operator>&amp;</operator><name><name>connection</name><operator>-&gt;</operator><name>remoteTransaction</name></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionFailed</name></name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>StartRemoteTransactionSavepointBegin</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>subId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>connectionList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>connectionList</name></expr></argument>, <argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>WaitForAllConnections</name><argument_list>(<argument><expr><name>connectionList</name></expr></argument>, <argument><expr><name>raiseInterrupts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* and wait for the results */</comment>
	<macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;InProgressTransactions</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>MultiConnection</name></expr></argument>, <argument><expr><name>transactionNode</name></expr></argument>,
													  <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RemoteTransaction</name> <modifier>*</modifier></type><name>transaction</name> <init>= <expr><operator>&amp;</operator><name><name>connection</name><operator>-&gt;</operator><name>remoteTransaction</name></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionFailed</name></name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>FinishRemoteTransactionSavepointBegin</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>subId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>transaction</name><operator>-&gt;</operator><name>transactionFailed</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>transaction</name><operator>-&gt;</operator><name>lastSuccessfulSubXact</name></name> <operator>=</operator> <name>subId</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>connectionList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CoordinatedRemoteTransactionsSavepointRelease sends the RELEASE SAVEPOINT
 * command for the given sub-transaction id to all connections participating in
 * the current transaction.
 */</comment>
<function><type><name>void</name></type>
<name>CoordinatedRemoteTransactionsSavepointRelease</name><parameter_list>(<parameter><decl><type><name>SubTransactionId</name></type> <name>subId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dlist_iter</name></type> <name>iter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>raiseInterrupts</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>connectionList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* asynchronously send RELEASE SAVEPOINT */</comment>
	<macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;InProgressTransactions</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>MultiConnection</name></expr></argument>, <argument><expr><name>transactionNode</name></expr></argument>,
													  <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RemoteTransaction</name> <modifier>*</modifier></type><name>transaction</name> <init>= <expr><operator>&amp;</operator><name><name>connection</name><operator>-&gt;</operator><name>remoteTransaction</name></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionFailed</name></name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>StartRemoteTransactionSavepointRelease</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>subId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>connectionList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>connectionList</name></expr></argument>, <argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>WaitForAllConnections</name><argument_list>(<argument><expr><name>connectionList</name></expr></argument>, <argument><expr><name>raiseInterrupts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* and wait for the results */</comment>
	<macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;InProgressTransactions</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>MultiConnection</name></expr></argument>, <argument><expr><name>transactionNode</name></expr></argument>,
													  <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RemoteTransaction</name> <modifier>*</modifier></type><name>transaction</name> <init>= <expr><operator>&amp;</operator><name><name>connection</name><operator>-&gt;</operator><name>remoteTransaction</name></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionFailed</name></name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>FinishRemoteTransactionSavepointRelease</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>subId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>connectionList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CoordinatedRemoteTransactionsSavepointRollback sends the ROLLBACK TO SAVEPOINT
 * command for the given sub-transaction id to all connections participating in
 * the current transaction.
 */</comment>
<function><type><name>void</name></type>
<name>CoordinatedRemoteTransactionsSavepointRollback</name><parameter_list>(<parameter><decl><type><name>SubTransactionId</name></type> <name>subId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dlist_iter</name></type> <name>iter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>raiseInterrupts</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>connectionList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* asynchronously send ROLLBACK TO SAVEPOINT */</comment>
	<macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;InProgressTransactions</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>MultiConnection</name></expr></argument>, <argument><expr><name>transactionNode</name></expr></argument>,
													  <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RemoteTransaction</name> <modifier>*</modifier></type><name>transaction</name> <init>= <expr><operator>&amp;</operator><name><name>connection</name><operator>-&gt;</operator><name>remoteTransaction</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* cancel any ongoing queries before issuing rollback */</comment>
		<expr_stmt><expr><call><name>SendCancelationRequest</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* clear results, but don't show cancelation warning messages from workers. */</comment>
		<expr_stmt><expr><call><name>ClearResultsDiscardWarnings</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>raiseInterrupts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionFailed</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>transaction</name><operator>-&gt;</operator><name>lastSuccessfulSubXact</name></name> <operator>&lt;=</operator> <name>subId</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionRecovering</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * Clear the results of the failed query so we can send the ROLLBACK
				 * TO SAVEPOINT command for a savepoint that can recover the transaction
				 * from failure.
				 */</comment>
				<expr_stmt><expr><call><name>ForgetResults</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<continue>continue;</continue>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>StartRemoteTransactionSavepointRollback</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>subId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>connectionList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>connectionList</name></expr></argument>, <argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>WaitForAllConnections</name><argument_list>(<argument><expr><name>connectionList</name></expr></argument>, <argument><expr><name>raiseInterrupts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* and wait for the results */</comment>
	<macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;InProgressTransactions</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>MultiConnection</name></expr></argument>, <argument><expr><name>transactionNode</name></expr></argument>,
													  <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RemoteTransaction</name> <modifier>*</modifier></type><name>transaction</name> <init>= <expr><operator>&amp;</operator><name><name>connection</name><operator>-&gt;</operator><name>remoteTransaction</name></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionFailed</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>transaction</name><operator>-&gt;</operator><name>transactionRecovering</name></name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>FinishRemoteTransactionSavepointRollback</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>subId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We unclaim the connection now so it can be used again when
		 * continuing after the ROLLBACK TO SAVEPOINT.
		 * XXX: We do not undo our hadDML/hadDDL flags. This could result in
		 * some queries not being allowed on Citus that would actually be fine
		 * to execute.  Changing this would require us to keep track for each
		 * savepoint which placement connections had DDL/DML executed at that
		 * point and if they were already. We also do not call
		 * ResetShardPlacementAssociation. This might result in suboptimal
		 * parallelism, because of placement associations that are not really
		 * necessary anymore because of ROLLBACK TO SAVEPOINT. To change this
		 * we would need to keep track of when a connection becomes associated
		 * to a placement.
		 */</comment>
		<expr_stmt><expr><call><name>UnclaimConnection</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>connectionList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * StartRemoteTransactionSavepointBegin initiates SAVEPOINT command for the given
 * subtransaction id in a non-blocking manner.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>StartRemoteTransactionSavepointBegin</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>, <parameter><decl><type><name>SubTransactionId</name></type> <name>subId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>raiseErrors</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We need to allocate 31 bytes for command buffer (including '\0'):
	 *  - len("SAVEPOINT savepoint_") = 20
	 *  - maximum length of str(subId) = 10
	 */</comment>
	<decl_stmt><decl><type><name>char</name></type> <name><name>savepointCommand</name><index>[<expr><literal type="number">31</literal></expr>]</index></name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>SafeSnprintf</name><argument_list>(<argument><expr><name>savepointCommand</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>savepointCommand</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"SAVEPOINT savepoint_%u"</literal></expr></argument>,
				 <argument><expr><name>subId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SendRemoteCommand</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>savepointCommand</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>HandleRemoteTransactionConnectionError</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>raiseErrors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * FinishRemoteTransactionSavepointBegin finishes the work
 * StartRemoteTransactionSavepointBegin initiated. It blocks if necessary (i.e.
 * if PQisBusy() would return true).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>FinishRemoteTransactionSavepointBegin</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>, <parameter><decl><type><name>SubTransactionId</name></type> <name>subId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>raiseErrors</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>GetRemoteCommandResult</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>raiseErrors</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsResponseOK</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>HandleRemoteTransactionResultError</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>raiseErrors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ForgetResults</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * StartRemoteTransactionSavepointRelease initiates RELEASE SAVEPOINT command for
 * the given subtransaction id in a non-blocking manner.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>StartRemoteTransactionSavepointRelease</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>,
									   <parameter><decl><type><name>SubTransactionId</name></type> <name>subId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>raiseErrors</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We need to allocate 39 bytes for command buffer (including '\0'):
	 *  - len("RELEASE SAVEPOINT savepoint_") = 28
	 *  - maximum length of str(subId) = 10
	 */</comment>
	<decl_stmt><decl><type><name>char</name></type> <name><name>savepointCommand</name><index>[<expr><literal type="number">39</literal></expr>]</index></name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>SafeSnprintf</name><argument_list>(<argument><expr><name>savepointCommand</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>savepointCommand</name></expr></argument>)</argument_list></sizeof></expr></argument>,
				 <argument><expr><literal type="string">"RELEASE SAVEPOINT savepoint_%u"</literal></expr></argument>, <argument><expr><name>subId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SendRemoteCommand</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>savepointCommand</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>HandleRemoteTransactionConnectionError</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>raiseErrors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * FinishRemoteTransactionSavepointRelease finishes the work
 * StartRemoteTransactionSavepointRelease initiated. It blocks if necessary (i.e.
 * if PQisBusy() would return true).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>FinishRemoteTransactionSavepointRelease</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>,
										<parameter><decl><type><name>SubTransactionId</name></type> <name>subId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>raiseErrors</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>GetRemoteCommandResult</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>raiseErrors</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsResponseOK</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>HandleRemoteTransactionResultError</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>raiseErrors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ForgetResults</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * StartRemoteTransactionSavepointRollback initiates ROLLBACK TO SAVEPOINT command
 * for the given subtransaction id in a non-blocking manner.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>StartRemoteTransactionSavepointRollback</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>,
										<parameter><decl><type><name>SubTransactionId</name></type> <name>subId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>raiseErrors</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We need to allocate 43 bytes for command buffer (including '\0'):
	 *  - len("ROLLBACK TO SAVEPOINT savepoint_") = 32
	 *  - maximum length of str(subId) = 10
	 */</comment>
	<decl_stmt><decl><type><name>char</name></type> <name><name>savepointCommand</name><index>[<expr><literal type="number">43</literal></expr>]</index></name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>SafeSnprintf</name><argument_list>(<argument><expr><name>savepointCommand</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>savepointCommand</name></expr></argument>)</argument_list></sizeof></expr></argument>,
				 <argument><expr><literal type="string">"ROLLBACK TO SAVEPOINT savepoint_%u"</literal></expr></argument>, <argument><expr><name>subId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SendRemoteCommand</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>savepointCommand</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>HandleRemoteTransactionConnectionError</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>raiseErrors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * FinishRemoteTransactionSavepointRollback finishes the work
 * StartRemoteTransactionSavepointRollback initiated. It blocks if necessary (i.e.
 * if PQisBusy() would return true). It also recovers the transaction from failure
 * if transaction is recovering and the rollback command succeeds.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>FinishRemoteTransactionSavepointRollback</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>, <parameter><decl><type><name>SubTransactionId</name></type>
										 <name>subId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>raiseErrors</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RemoteTransaction</name> <modifier>*</modifier></type><name>transaction</name> <init>= <expr><operator>&amp;</operator><name><name>connection</name><operator>-&gt;</operator><name>remoteTransaction</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>GetRemoteCommandResult</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>raiseErrors</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsResponseOK</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>HandleRemoteTransactionResultError</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>raiseErrors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>

	<comment type="block">/* ROLLBACK TO SAVEPOINT succeeded, check if it recovers the transaction */</comment>
	<if type="elseif">else if <condition>(<expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionRecovering</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionFailed</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionRecovering</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ForgetResults</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* reset transaction state so the executor can accept next commands in transaction */</comment>
	<expr_stmt><expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionState</name></name> <operator>=</operator> <name>REMOTE_TRANS_STARTED</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CheckRemoteTransactionsHealth checks if any of the participating transactions in a
 * coordinated transaction failed, and what consequence that should have.
 * This needs to be called before the coordinated transaction commits (but
 * after they've been PREPAREd if 2PC is in use).
 */</comment>
<function><type><name>void</name></type>
<name>CheckRemoteTransactionsHealth</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dlist_iter</name></type> <name>iter</name></decl>;</decl_stmt>

	<macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;InProgressTransactions</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>MultiConnection</name></expr></argument>, <argument><expr><name>transactionNode</name></expr></argument>,
													  <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RemoteTransaction</name> <modifier>*</modifier></type><name>transaction</name> <init>= <expr><operator>&amp;</operator><name><name>connection</name><operator>-&gt;</operator><name>remoteTransaction</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGTransactionStatusType</name></type> <name>status</name> <init>= <expr><call><name>PQtransactionStatus</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* if the connection is in a bad state, so is the transaction's state */</comment>
		<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>PQTRANS_INERROR</name> <operator>||</operator> <name>status</name> <operator>==</operator> <name>PQTRANS_UNKNOWN</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionFailed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If a critical connection is marked as failed (and no error has been
		 * raised yet) do so now.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>transaction</name><operator>-&gt;</operator><name>transactionFailed</name></name> <operator>&amp;&amp;</operator> <name><name>transaction</name><operator>-&gt;</operator><name>transactionCritical</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failure on connection marked as essential: %s:%d"</literal></expr></argument>,
								   <argument><expr><name><name>connection</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>, <argument><expr><name><name>connection</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * Assign2PCIdentifier computes the 2PC transaction name to use for a
 * transaction. Every prepared transaction should get a new name, i.e. this
 * function will need to be called again.
 *
 * The format of the name is:
 *
 * citus_&lt;source group&gt;_&lt;pid&gt;_&lt;distributed transaction number&gt;_&lt;connection number&gt;
 *
 * (at most 5+1+10+1+10+1+20+1+10 = 59 characters, while limit is 64)
 *
 * The source group is used to distinguish 2PCs started by different
 * coordinators. A coordinator will only attempt to recover its own 2PCs.
 *
 * The pid is used to distinguish different processes on the coordinator, mainly
 * to provide some entropy across restarts.
 *
 * The distributed transaction number is used to distinguish different
 * transactions originating from the same node (since restart).
 *
 * The connection number is used to distinguish connections made to a node
 * within the same transaction.
 *
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>Assign2PCIdentifier</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* local sequence number used to distinguish different connections */</comment>
	<decl_stmt><decl><type><specifier>static</specifier> <name>uint32</name></type> <name>connectionNumber</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* transaction identifier that is unique across processes */</comment>
	<decl_stmt><decl><type><name>uint64</name></type> <name>transactionNumber</name> <init>= <expr><call><name>CurrentDistributedTransactionNumber</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* print all numbers as unsigned to guarantee no minus symbols appear in the name */</comment>
	<expr_stmt><expr><call><name>SafeSnprintf</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>remoteTransaction</name><operator>.</operator><name>preparedName</name></name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>,
				 <argument><expr><name>PREPARED_TRANSACTION_NAME_FORMAT</name></expr></argument>, <argument><expr><call><name>GetLocalGroupId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>,
				 <argument><expr><name>transactionNumber</name></expr></argument>, <argument><expr><name>connectionNumber</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ParsePreparedTransactionName parses a prepared transaction name to extract
 * the initiator group ID, initiator process ID, distributed transaction number,
 * and the connection number. If the transaction name does not match the expected
 * format ParsePreparedTransactionName returns false, and true otherwise.
 */</comment>
<function><type><name>bool</name></type>
<name>ParsePreparedTransactionName</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>preparedTransactionName</name></decl></parameter>,
							 <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>groupId</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>procId</name></decl></parameter>,
							 <parameter><decl><type><name>uint64</name> <modifier>*</modifier></type><name>transactionNumber</name></decl></parameter>,
							 <parameter><decl><type><name>uint32</name> <modifier>*</modifier></type><name>connectionNumber</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>currentCharPointer</name> <init>= <expr><name>preparedTransactionName</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>currentCharPointer</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>currentCharPointer</name></expr></argument>, <argument><expr><literal type="char">'_'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>currentCharPointer</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* step ahead of the current '_' character */</comment>
	<expr_stmt><expr><operator>++</operator><name>currentCharPointer</name></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>groupId</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>currentCharPointer</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>groupId</name> <operator>==</operator> <name>COORDINATOR_GROUP_ID</name> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>EINVAL</name><operator>)</operator> <operator>||</operator>
		<operator>(</operator><operator>*</operator><name>groupId</name> <operator>==</operator> <name>INT_MAX</name> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>ERANGE</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>currentCharPointer</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>currentCharPointer</name></expr></argument>, <argument><expr><literal type="char">'_'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>currentCharPointer</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* step ahead of the current '_' character */</comment>
	<expr_stmt><expr><operator>++</operator><name>currentCharPointer</name></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>procId</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>currentCharPointer</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>procId</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>EINVAL</name><operator>)</operator> <operator>||</operator>
		<operator>(</operator><operator>*</operator><name>procId</name> <operator>==</operator> <name>INT_MAX</name> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>ERANGE</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>currentCharPointer</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>currentCharPointer</name></expr></argument>, <argument><expr><literal type="char">'_'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>currentCharPointer</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* step ahead of the current '_' character */</comment>
	<expr_stmt><expr><operator>++</operator><name>currentCharPointer</name></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>transactionNumber</name> <operator>=</operator> <call><name>strtou64</name><argument_list>(<argument><expr><name>currentCharPointer</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>transactionNumber</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
		<operator>(</operator><operator>*</operator><name>transactionNumber</name> <operator>==</operator> <name>ULLONG_MAX</name> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>ERANGE</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>currentCharPointer</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>currentCharPointer</name></expr></argument>, <argument><expr><literal type="char">'_'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>currentCharPointer</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* step ahead of the current '_' character */</comment>
	<expr_stmt><expr><operator>++</operator><name>currentCharPointer</name></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>connectionNumber</name> <operator>=</operator> <call><name>strtoul</name><argument_list>(<argument><expr><name>currentCharPointer</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>connectionNumber</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>EINVAL</name><operator>)</operator> <operator>||</operator>
		<operator>(</operator><operator>*</operator><name>connectionNumber</name> <operator>==</operator> <name>UINT_MAX</name> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>ERANGE</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>
</unit>
