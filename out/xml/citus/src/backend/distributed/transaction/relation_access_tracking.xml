<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/builded_projects/citus/src/backend/distributed/transaction/relation_access_tracking.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * relation_access_tracking.c
 *
 *   Transaction access tracking for Citus. The functions in this file
 *   are intended to track the relation accesses within a transaction. The
 *   logic here is mostly useful when a reference table is referred by
 *   a distributed table via a foreign key. Whenever such a pair of tables
 *   are accessed inside a transaction, Citus should detect and act
 *   accordingly.
 *
 * Copyright (c) Citus Data, Inc.
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_version_constants.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/colocation_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/hash_helpers.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_join_order.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_partitioning_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/relation_access_tracking.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/hsearch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/hashfn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>


<comment type="block">/* Config variables managed via guc.c */</comment>
<decl_stmt><decl><type><name>bool</name></type> <name>EnforceForeignKeyRestrictions</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_MODE_FLAG_OFFSET</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>

<comment type="block">/* simply set parallel bits as defined below for select, dml and ddl */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_ACCESS_MASK</name></cpp:macro> <cpp:value>(int) (0 | \
									(1 &lt;&lt; (PLACEMENT_ACCESS_SELECT + \
										   PARALLEL_MODE_FLAG_OFFSET)) | \
									(1 &lt;&lt; (PLACEMENT_ACCESS_DML + \
										   PARALLEL_MODE_FLAG_OFFSET)) | \
									(1 &lt;&lt; (PLACEMENT_ACCESS_DDL + \
										   PARALLEL_MODE_FLAG_OFFSET)))</cpp:value></cpp:define>

<decl_stmt><decl><type><name>MemoryContext</name></type> <name>RelationAcessContext</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>


<comment type="block">/*
 * Hash table mapping relations to the
 *      (relationId) = (relationAccessType and relationAccessMode)
 *
 * RelationAccessHash is used to keep track of relation accesses types (e.g., select,
 * dml or ddl) along with access modes (e.g., no access, sequential access or
 * parallel access).
 *
 * We keep an integer per relation and use some of the bits to identify the access types
 * and access modes.
 *
 * We store the access types in the first 3 bits:
 *  - 0th bit is set for SELECT accesses to a relation
 *  - 1st bit is set for DML accesses to a relation
 *  - 2nd bit is set for DDL accesses to a relation
 *
 * and, access modes in the next 3 bits:
 *  - 3rd bit is set for PARALLEL SELECT accesses to a relation
 *  - 4th bit is set for PARALLEL DML accesses to a relation
 *  - 5th bit is set for PARALLEL DDL accesses to a relation
 *
 */</comment>
<typedef>typedef <type><struct>struct <name>RelationAccessHashKey</name>
<block>{
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name></decl>;</decl_stmt>
}</block></struct></type> <name>RelationAccessHashKey</name>;</typedef>

<typedef>typedef <type><struct>struct <name>RelationAccessHashEntry</name>
<block>{
	<decl_stmt><decl><type><name>RelationAccessHashKey</name></type> <name>key</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>relationAccessMode</name></decl>;</decl_stmt>
}</block></struct></type> <name>RelationAccessHashEntry</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>RelationAccessHash</name></decl>;</decl_stmt>

<comment type="block">/* functions related to access recording */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AllocateRelationAccessHash</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RecordRelationAccessBase</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>ShardPlacementAccessType</name></type> <name>accessType</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RecordPlacementAccessToCache</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>,
										 <parameter><decl><type><name>ShardPlacementAccessType</name></type> <name>accessType</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RecordRelationParallelSelectAccessForTask</name><parameter_list>(<parameter><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RecordRelationParallelModifyAccessForTask</name><parameter_list>(<parameter><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RecordRelationParallelDDLAccessForTask</name><parameter_list>(<parameter><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>RelationAccessMode</name></type> <name>GetRelationAccessMode</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>,
												<parameter><decl><type><name>ShardPlacementAccessType</name></type> <name>accessType</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RecordParallelRelationAccess</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>ShardPlacementAccessType</name></type>
										 <name>placementAccess</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RecordParallelRelationAccessToCache</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>,
												<parameter><decl><type><name>ShardPlacementAccessType</name></type> <name>placementAccess</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* functions related to access conflict checks */</comment>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>PlacementAccessTypeToText</name><parameter_list>(<parameter><decl><type><name>ShardPlacementAccessType</name></type> <name>accessType</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CheckConflictingRelationAccesses</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>,
											 <parameter><decl><type><name>ShardPlacementAccessType</name></type> <name>accessType</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>HoldsConflictingLockWithReferencingRelations</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>,
														 <parameter><decl><type><name>ShardPlacementAccessType</name></type>
														 <name>placementAccess</name></decl></parameter>,
														 <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>conflictingRelationId</name></decl></parameter>,
														 <parameter><decl><type><name>ShardPlacementAccessType</name> <modifier>*</modifier></type>
														 <name>conflictingAccessMode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CheckConflictingParallelRelationAccesses</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>,
													 <parameter><decl><type><name>ShardPlacementAccessType</name></type>
													 <name>accessType</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>HoldsConflictingLockWithReferencedRelations</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>,
														<parameter><decl><type><name>ShardPlacementAccessType</name></type>
														<name>placementAccess</name></decl></parameter>,
														<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>conflictingRelationId</name></decl></parameter>,
														<parameter><decl><type><name>ShardPlacementAccessType</name> <modifier>*</modifier></type>
														<name>conflictingAccessMode</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * InitRelationAccessHash performs initialization of the
 * infrastructure in this file at backend start.
 */</comment>
<function><type><name>void</name></type>
<name>InitRelationAccessHash</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* allocate (relationId) = [relationAccessMode] hash */</comment>
	<expr_stmt><expr><call><name>AllocateRelationAccessHash</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Empty RelationAccessHash, without destroying the hash table itself.
 */</comment>
<function><type><name>void</name></type>
<name>ResetRelationAccessHash</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>hash_delete_all</name><argument_list>(<argument><expr><name>RelationAccessHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Allocate RelationAccessHash.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AllocateRelationAccessHash</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Create a single context for relation access related memory
	 * management. Doing so, instead of allocating in TopMemoryContext, makes
	 * it easier to associate used memory.
	 */</comment>
	<expr_stmt><expr><name>RelationAcessContext</name> <operator>=</operator> <call><name>AllocSetContextCreateInternal</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
														 <argument><expr><literal type="string">"Relation Access Context"</literal></expr></argument>,
														 <argument><expr><name>ALLOCSET_DEFAULT_MINSIZE</name></expr></argument>,
														 <argument><expr><name>ALLOCSET_DEFAULT_INITSIZE</name></expr></argument>,
														 <argument><expr><name>ALLOCSET_DEFAULT_MAXSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>HASHCTL</name></type> <name>info</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>info</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RelationAccessHashKey</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RelationAccessHashEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>hash</name></name> <operator>=</operator> <name>tag_hash</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name>RelationAcessContext</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>hashFlags</name> <init>= <expr><operator>(</operator><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name> <operator>|</operator> <name>HASH_CONTEXT</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>RelationAccessHash</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"citus relation access cache (relationid)"</literal></expr></argument>,
									 <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>, <argument><expr><name>hashFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * RecordRelationAccessIfNonDistTable marks the relation accessed if it is a
 * reference relation.
 *
 * The function is a wrapper around RecordRelationAccessBase().
 */</comment>
<function><type><name>void</name></type>
<name>RecordRelationAccessIfNonDistTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>ShardPlacementAccessType</name></type> <name>accessType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ShouldRecordRelationAccess</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We keep track of relation accesses for the purposes of foreign keys to
	 * reference tables. So, other distributed tables are not relevant for now.
	 * Additionally, partitioned tables with lots of partitions might require
	 * recursively calling RecordRelationAccessBase(), so becareful about
	 * removing this check.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>CITUS_TABLE_WITH_NO_DIST_KEY</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>RecordRelationAccessBase</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>accessType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * PlacementAccessTypeToText converts ShardPlacementAccessType to
 * text representation.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>PlacementAccessTypeToText</name><parameter_list>(<parameter><decl><type><name>ShardPlacementAccessType</name></type> <name>accessType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>accessType</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PLACEMENT_ACCESS_SELECT</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><literal type="string">"SELECT"</literal></expr>;</return>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>PLACEMENT_ACCESS_DML</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><literal type="string">"DML"</literal></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>PLACEMENT_ACCESS_DDL</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><literal type="string">"DDL"</literal></expr>;</return>
		</block_content>}</block>

		<default>default:</default>
		<block>{<block_content>
			<return>return <expr><literal type="string">"None"</literal></expr>;</return>
			<break>break;</break>
		</block_content>}</block>
	</block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
 * RecordRelationAccessBase associates the access to the distributed relation. The
 * function takes partitioned relations into account as well.
 *
 * We implemented this function to prevent accessing placement metadata during
 * recursive calls of the function itself (e.g., avoid
 * RecordRelationAccessBase()).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RecordRelationAccessBase</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>ShardPlacementAccessType</name></type> <name>accessType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>REFERENCE_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We don't support partitioned reference tables.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>PartitionedTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>PartitionTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* make sure that this is not a conflicting access */</comment>
	<expr_stmt><expr><call><name>CheckConflictingRelationAccesses</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>accessType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* always record the relation that is being considered */</comment>
	<expr_stmt><expr><call><name>RecordPlacementAccessToCache</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>accessType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * RecordPlacementAccessToCache is a utility function which saves the given
 * relation id's access to the RelationAccessHash.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RecordPlacementAccessToCache</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>ShardPlacementAccessType</name></type> <name>accessType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelationAccessHashKey</name></type> <name>hashKey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>hashKey</name><operator>.</operator><name>relationId</name></name> <operator>=</operator> <name>relationId</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>RelationAccessHashEntry</name> <modifier>*</modifier></type><name>hashEntry</name> <init>= <expr><call><name>hash_search</name><argument_list>(<argument><expr><name>RelationAccessHash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hashKey</name></expr></argument>,
													 <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>hashEntry</name><operator>-&gt;</operator><name>relationAccessMode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* set the bit representing the access type */</comment>
	<expr_stmt><expr><name><name>hashEntry</name><operator>-&gt;</operator><name>relationAccessMode</name></name> <operator>|=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>accessType</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * RecordParallelRelationAccessForTaskList gets a task list and records
 * the necessary parallel relation accesses for the task list.
 *
 * This function is used to enforce foreign keys from distributed
 * tables to reference tables.
 */</comment>
<function><type><name>void</name></type>
<name>RecordParallelRelationAccessForTaskList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>MultiShardConnectionType</name> <operator>==</operator> <name>SEQUENTIAL_CONNECTION</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* sequential mode prevents parallel access */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* single shard task doesn't mean parallel access in our definition */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Since all the tasks in a task list is expected to operate on the same
	 * distributed table(s), we only need to process the first task.
	 */</comment>
	<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>firstTask</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>firstTask</name><operator>-&gt;</operator><name>taskType</name></name> <operator>==</operator> <name>READ_TASK</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>RecordRelationParallelSelectAccessForTask</name><argument_list>(<argument><expr><name>firstTask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>firstTask</name><operator>-&gt;</operator><name>taskType</name></name> <operator>==</operator> <name>MODIFY_TASK</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>firstTask</name><operator>-&gt;</operator><name>rowValuesLists</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We always run multi-row INSERTs in a sequential
			 * mode (hard-coded). Thus, we do not mark as parallel
			 * access even if the prerequisites hold.
			 */</comment>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * We prefer to mark with all remaining multi-shard modifications
			 * with both modify and select accesses.
			 */</comment>
			<expr_stmt><expr><call><name>RecordRelationParallelModifyAccessForTask</name><argument_list>(<argument><expr><name>firstTask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>RecordRelationParallelSelectAccessForTask</name><argument_list>(<argument><expr><name>firstTask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>RecordRelationParallelDDLAccessForTask</name><argument_list>(<argument><expr><name>firstTask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * RecordRelationParallelSelectAccessForTask goes over all the relations
 * in the relationShardList and records the select access per each table.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RecordRelationParallelSelectAccessForTask</name><parameter_list>(<parameter><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>lastRelationId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* no point in recoding accesses in non-transaction blocks, skip the loop */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ShouldRecordRelationAccess</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>relationShardList</name> <init>= <expr><name><name>task</name><operator>-&gt;</operator><name>relationShardList</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>RelationShard</name> <modifier>*</modifier></type><name>relationShard</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>relationShard</argument>, <argument>relationShardList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>currentRelationId</name> <init>= <expr><name><name>relationShard</name><operator>-&gt;</operator><name>relationId</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * An optimization, skip going to hash table if we've already
		 * recorded the relation.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>currentRelationId</name> <operator>==</operator> <name>lastRelationId</name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>RecordParallelSelectAccess</name><argument_list>(<argument><expr><name>currentRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>lastRelationId</name> <operator>=</operator> <name>currentRelationId</name></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * RecordRelationParallelModifyAccessForTask gets a task and records
 * the accesses. Note that the target relation is recorded with modify access
 * where as the subqueries inside the modify query is recorded with select
 * access.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RecordRelationParallelModifyAccessForTask</name><parameter_list>(<parameter><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>relationShardList</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>lastRelationId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* no point in recoding accesses in non-transaction blocks, skip the loop */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ShouldRecordRelationAccess</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* anchor shard is always associated with modify access */</comment>
	<expr_stmt><expr><call><name>RecordParallelModifyAccess</name><argument_list>(<argument><expr><call><name>RelationIdForShard</name><argument_list>(<argument><expr><name><name>task</name><operator>-&gt;</operator><name>anchorShardId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>task</name><operator>-&gt;</operator><name>modifyWithSubquery</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>relationShardList</name> <operator>=</operator> <name><name>task</name><operator>-&gt;</operator><name>relationShardList</name></name></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>RelationShard</name> <modifier>*</modifier></type><name>relationShard</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>relationShard</argument>, <argument>relationShardList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type> <name>currentRelationId</name> <init>= <expr><name><name>relationShard</name><operator>-&gt;</operator><name>relationId</name></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * An optimization, skip going to hash table if we've already
			 * recorded the relation.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>currentRelationId</name> <operator>==</operator> <name>lastRelationId</name></expr>)</condition>
			<block>{<block_content>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>RecordParallelSelectAccess</name><argument_list>(<argument><expr><name>currentRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>lastRelationId</name> <operator>=</operator> <name>currentRelationId</name></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * RecordRelationParallelDDLAccessForTask marks all the relationShards
 * with parallel DDL access if exists. That case is valid for inter-shard
 * DDL commands such as foreign key creation. The function also records
 * the relation that anchorShardId belongs to.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RecordRelationParallelDDLAccessForTask</name><parameter_list>(<parameter><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>relationShardList</name> <init>= <expr><name><name>task</name><operator>-&gt;</operator><name>relationShardList</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>lastRelationId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>RelationShard</name> <modifier>*</modifier></type><name>relationShard</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>relationShard</argument>, <argument>relationShardList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>currentRelationId</name> <init>= <expr><name><name>relationShard</name><operator>-&gt;</operator><name>relationId</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * An optimization, skip going to hash table if we've already
		 * recorded the relation.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>currentRelationId</name> <operator>==</operator> <name>lastRelationId</name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>RecordParallelDDLAccess</name><argument_list>(<argument><expr><name>currentRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>lastRelationId</name> <operator>=</operator> <name>currentRelationId</name></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name><name>task</name><operator>-&gt;</operator><name>anchorShardId</name></name> <operator>!=</operator> <name>INVALID_SHARD_ID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>RecordParallelDDLAccess</name><argument_list>(<argument><expr><call><name>RelationIdForShard</name><argument_list>(<argument><expr><name><name>task</name><operator>-&gt;</operator><name>anchorShardId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * RecordParallelSelectAccess is a wrapper around RecordParallelRelationAccess()
 */</comment>
<function><type><name>void</name></type>
<name>RecordParallelSelectAccess</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>RecordParallelRelationAccess</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>PLACEMENT_ACCESS_SELECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * RecordParallelModifyAccess is a wrapper around RecordParallelRelationAccess()
 */</comment>
<function><type><name>void</name></type>
<name>RecordParallelModifyAccess</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>RecordParallelRelationAccess</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>PLACEMENT_ACCESS_DML</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * RecordParallelDDLAccess is a wrapper around RecordParallelRelationAccess()
 */</comment>
<function><type><name>void</name></type>
<name>RecordParallelDDLAccess</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>RecordParallelRelationAccess</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>PLACEMENT_ACCESS_DDL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * RecordParallelRelationAccess records the relation access mode as parallel
 * for the given access type (e.g., select, dml or ddl) in the RelationAccessHash.
 *
 * The function also takes partitions and partitioned tables into account.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RecordParallelRelationAccess</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>ShardPlacementAccessType</name></type> <name>placementAccess</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ShouldRecordRelationAccess</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* act accordingly if it's a conflicting access */</comment>
	<expr_stmt><expr><call><name>CheckConflictingParallelRelationAccesses</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>placementAccess</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * CheckConflictingParallelRelationAccesses might switch to sequential
	 * execution. If that's the case, no need to continue because the executor
	 * would take the necessary actions to switch to sequential execution
	 * immediately.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>MultiShardConnectionType</name> <operator>==</operator> <name>SEQUENTIAL_CONNECTION</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If a relation is partitioned, record accesses to all of its partitions as well. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PartitionedTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>partitionList</name> <init>= <expr><call><name>PartitionList</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Oid</name></type> <name>partitionOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_oid</name><argument_list>(<argument>partitionOid</argument>, <argument>partitionList</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/* recursively record all relation accesses of its partitions */</comment>
			<expr_stmt><expr><call><name>RecordParallelRelationAccess</name><argument_list>(<argument><expr><name>partitionOid</name></expr></argument>, <argument><expr><name>placementAccess</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>PartitionTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>parentOid</name> <init>= <expr><call><name>PartitionParentOid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* only record the parent */</comment>
		<expr_stmt><expr><call><name>RecordParallelRelationAccessToCache</name><argument_list>(<argument><expr><name>parentOid</name></expr></argument>, <argument><expr><name>placementAccess</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>RecordParallelRelationAccessToCache</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>placementAccess</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * RecordParallelRelationAccessToCache is a utility function which saves the given
 * relation id's access to the RelationAccessHash.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RecordParallelRelationAccessToCache</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>,
									<parameter><decl><type><name>ShardPlacementAccessType</name></type> <name>placementAccess</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelationAccessHashKey</name></type> <name>hashKey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>hashKey</name><operator>.</operator><name>relationId</name></name> <operator>=</operator> <name>relationId</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>RelationAccessHashEntry</name> <modifier>*</modifier></type><name>hashEntry</name> <init>= <expr><call><name>hash_search</name><argument_list>(<argument><expr><name>RelationAccessHash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hashKey</name></expr></argument>,
													 <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>hashEntry</name><operator>-&gt;</operator><name>relationAccessMode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* set the bit representing the access type */</comment>
	<expr_stmt><expr><name><name>hashEntry</name><operator>-&gt;</operator><name>relationAccessMode</name></name> <operator>|=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>placementAccess</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* set the bit representing access mode */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>parallelRelationAccessBit</name> <init>= <expr><name>placementAccess</name> <operator>+</operator> <name>PARALLEL_MODE_FLAG_OFFSET</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>hashEntry</name><operator>-&gt;</operator><name>relationAccessMode</name></name> <operator>|=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>parallelRelationAccessBit</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ParallelQueryExecutedInTransaction returns true if any parallel query
 * is executed in the current transaction.
 */</comment>
<function><type><name>bool</name></type>
<name>ParallelQueryExecutedInTransaction</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ShouldRecordRelationAccess</name><argument_list>()</argument_list></call> <operator>||</operator> <name>RelationAccessHash</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>RelationAccessHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>RelationAccessHashEntry</name> <modifier>*</modifier></type><name>hashEntry</name> <init>= <expr><operator>(</operator><name>RelationAccessHashEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(
		<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><name>hashEntry</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>relationAccessMode</name> <init>= <expr><name><name>hashEntry</name><operator>-&gt;</operator><name>relationAccessMode</name></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>relationAccessMode</name> <operator>&amp;</operator> <name>PARALLEL_ACCESS_MASK</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>hash_seq_term</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>hashEntry</name> <operator>=</operator> <operator>(</operator><name>RelationAccessHashEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetRelationSelectAccessMode is a wrapper around GetRelationAccessMode.
 */</comment>
<function><type><name>RelationAccessMode</name></type>
<name>GetRelationSelectAccessMode</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>GetRelationAccessMode</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>PLACEMENT_ACCESS_SELECT</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetRelationDMLAccessMode is a wrapper around GetRelationAccessMode.
 */</comment>
<function><type><name>RelationAccessMode</name></type>
<name>GetRelationDMLAccessMode</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>GetRelationAccessMode</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>PLACEMENT_ACCESS_DML</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetRelationDDLAccessMode is a wrapper around GetRelationAccessMode.
 */</comment>
<function><type><name>RelationAccessMode</name></type>
<name>GetRelationDDLAccessMode</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>GetRelationAccessMode</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>PLACEMENT_ACCESS_DDL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetRelationAccessMode returns the relation access mode (e.g., none, sequential
 * or parallel) for the given access type (e.g., select, dml or ddl).
 */</comment>
<function><type><specifier>static</specifier> <name>RelationAccessMode</name></type>
<name>GetRelationAccessMode</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>ShardPlacementAccessType</name></type> <name>accessType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelationAccessHashKey</name></type> <name>hashKey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>parallelRelationAccessBit</name> <init>= <expr><name>accessType</name> <operator>+</operator> <name>PARALLEL_MODE_FLAG_OFFSET</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* no point in getting the mode when not inside a transaction block */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ShouldRecordRelationAccess</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>RELATION_NOT_ACCESSED</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>hashKey</name><operator>.</operator><name>relationId</name></name> <operator>=</operator> <name>relationId</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>RelationAccessHashEntry</name> <modifier>*</modifier></type><name>hashEntry</name> <init>= <expr><call><name>hash_search</name><argument_list>(<argument><expr><name>RelationAccessHash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hashKey</name></expr></argument>,
													 <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* relation not accessed at all */</comment>
		<return>return <expr><name>RELATION_NOT_ACCESSED</name></expr>;</return>
	</block_content>}</block></if></if_stmt>


	<decl_stmt><decl><type><name>int</name></type> <name>relationAcessMode</name> <init>= <expr><name><name>hashEntry</name><operator>-&gt;</operator><name>relationAccessMode</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>relationAcessMode</name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>accessType</name><operator>)</operator><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* relation not accessed with the given access type */</comment>
		<return>return <expr><name>RELATION_NOT_ACCESSED</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>relationAcessMode</name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>parallelRelationAccessBit</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>RELATION_PARALLEL_ACCESSED</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<return>return <expr><name>RELATION_REFERENCE_ACCESSED</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ShouldRecordRelationAccess returns true when we should keep track
 * of the relation accesses.
 *
 * In many cases, we'd only need IsMultiStatementTransaction(), however, for some
 * cases such as CTEs, where Citus uses the same connections across multiple queries,
 * we should still record the relation accesses even not inside an explicit transaction
 * block. Thus, keeping track of the relation accesses inside coordinated transactions
 * is also required.
 */</comment>
<function><type><name>bool</name></type>
<name>ShouldRecordRelationAccess</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>EnforceForeignKeyRestrictions</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><call><name>IsMultiStatementTransaction</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>InCoordinatedTransaction</name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CheckConflictingRelationAccesses is mostly a wrapper around
 * HoldsConflictingLockWithReferencingRelations(). We're only interested in
 * accesses to reference tables and citus local tables that are referenced via
 * a foreign constraint by a hash distributed table.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CheckConflictingRelationAccesses</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>ShardPlacementAccessType</name></type> <name>accessType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>conflictingReferencingRelationId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ShardPlacementAccessType</name></type> <name>conflictingAccessType</name> <init>= <expr><name>PLACEMENT_ACCESS_SELECT</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>EnforceForeignKeyRestrictions</name> <operator>||</operator> <operator>!</operator><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>cacheEntry</name> <init>= <expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>IsCitusTableTypeCacheEntry</name><argument_list>(<argument><expr><name>cacheEntry</name></expr></argument>, <argument><expr><name>CITUS_TABLE_WITH_NO_DIST_KEY</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		  <name><name>cacheEntry</name><operator>-&gt;</operator><name>referencingRelationsViaForeignKey</name></name> <operator>!=</operator> <name>NIL</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>HoldsConflictingLockWithReferencingRelations</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>accessType</name></expr></argument>,
													 <argument><expr><operator>&amp;</operator><name>conflictingReferencingRelationId</name></expr></argument>,
													 <argument><expr><operator>&amp;</operator><name>conflictingAccessType</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>conflictingRelationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>conflictingReferencingRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>accessTypeText</name> <init>= <expr><call><name>PlacementAccessTypeToText</name><argument_list>(<argument><expr><name>accessType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>conflictingAccessTypeText</name> <init>=
			<expr><call><name>PlacementAccessTypeToText</name><argument_list>(<argument><expr><name>conflictingAccessType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Relation could already be dropped if the accessType is DDL and the
		 * command that we were executing were a DROP command. In that case,
		 * as this function is executed via DROP trigger, standard_ProcessUtility
		 * had already dropped the table from PostgreSQL's perspective. Hence, it
		 * returns NULL pointer for the name of the relation.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>relationName</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot execute %s on table because there was "</literal>
								   <literal type="string">"a parallel %s access to distributed table "</literal>
								   <literal type="string">"\"%s\" in the same transaction"</literal></expr></argument>,
								   <argument><expr><name>accessTypeText</name></expr></argument>, <argument><expr><name>conflictingAccessTypeText</name></expr></argument>,
								   <argument><expr><name>conflictingRelationName</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Try re-running the transaction with "</literal>
									<literal type="string">"\"SET LOCAL citus.multi_shard_modify_mode TO "</literal>
									<literal type="string">"\'sequential\';\""</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot execute %s on table \"%s\" because "</literal>
								   <literal type="string">"there was a parallel %s access to distributed "</literal>
								   <literal type="string">"table \"%s\" in the same transaction"</literal></expr></argument>,
								   <argument><expr><name>accessTypeText</name></expr></argument>, <argument><expr><name>relationName</name></expr></argument>,
								   <argument><expr><name>conflictingAccessTypeText</name></expr></argument>,
								   <argument><expr><name>conflictingRelationName</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Try re-running the transaction with "</literal>
									<literal type="string">"\"SET LOCAL citus.multi_shard_modify_mode TO "</literal>
									<literal type="string">"\'sequential\';\""</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>referencingRelationsViaForeignKey</name></name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator>
			 <name>accessType</name> <operator>&gt;</operator> <name>PLACEMENT_ACCESS_SELECT</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>ParallelQueryExecutedInTransaction</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If there has already been a parallel query executed, the sequential mode
			 * would still use the already opened parallel connections to the workers,
			 * thus contradicting our purpose of using sequential mode.
			 */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot modify table \"%s\" because there was "</literal>
								   <literal type="string">"a parallel operation on a distributed table"</literal></expr></argument>,
								   <argument><expr><name>relationName</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"When there is a foreign key to a reference "</literal>
									  <literal type="string">"table or to a local table, Citus needs "</literal>
									  <literal type="string">"to perform all operations over a single "</literal>
									  <literal type="string">"connection per node to ensure consistency."</literal></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Try re-running the transaction with "</literal>
									<literal type="string">"\"SET LOCAL citus.multi_shard_modify_mode TO "</literal>
									<literal type="string">"\'sequential\';\""</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>MultiShardConnectionType</name> <operator>==</operator> <name>PARALLEL_CONNECTION</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We can still continue with multi-shard queries in sequential mode, so
			 * set it.
			 */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"switching to sequential query execution mode"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errdetail</name><argument_list>(
								 <argument><expr><literal type="string">"Table \"%s\" is modified, which might lead to data "</literal>
								 <literal type="string">"inconsistencies or distributed deadlocks via "</literal>
								 <literal type="string">"parallel accesses to hash distributed tables due to "</literal>
								 <literal type="string">"foreign keys. Any parallel modification to "</literal>
								 <literal type="string">"those hash distributed tables in the same "</literal>
								 <literal type="string">"transaction can only be executed in sequential query "</literal>
								 <literal type="string">"execution mode"</literal></expr></argument>,
								 <argument><expr><ternary><condition><expr><name>relationName</name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>relationName</name></expr> </then><else>: <expr><literal type="string">"&lt;dropped&gt;"</literal></expr></else></ternary></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Switching to sequential mode is admittedly confusing and, could be useless
			 * and less performant in some cases. However, if we do not switch to
			 * sequential mode at this point, we'd lose the opportunity to do so
			 * later when a parallel query is executed on the hash distributed relations
			 * that are referencing this reference table.
			 */</comment>
			<expr_stmt><expr><call><name>SetLocalMultiShardModifyModeToSequential</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CheckConflictingParallelRelationAccesses is mostly a wrapper around
 * HoldsConflictingLockWithReferencedRelations().  We're only interested in parallel
 * accesses to distributed tables that refers reference tables via foreign constraint.
 *
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CheckConflictingParallelRelationAccesses</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>ShardPlacementAccessType</name></type>
										 <name>accessType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>conflictingReferencingRelationId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ShardPlacementAccessType</name></type> <name>conflictingAccessType</name> <init>= <expr><name>PLACEMENT_ACCESS_SELECT</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>EnforceForeignKeyRestrictions</name> <operator>||</operator> <operator>!</operator><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>cacheEntry</name> <init>= <expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>IsCitusTableTypeCacheEntry</name><argument_list>(<argument><expr><name>cacheEntry</name></expr></argument>, <argument><expr><name>HASH_DISTRIBUTED</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		  <name><name>cacheEntry</name><operator>-&gt;</operator><name>referencedRelationsViaForeignKey</name></name> <operator>!=</operator> <name>NIL</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>MultiShardConnectionType</name> <operator>==</operator> <name>PARALLEL_CONNECTION</name> <operator>&amp;&amp;</operator>
		<call><name>HoldsConflictingLockWithReferencedRelations</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>accessType</name></expr></argument>,
													<argument><expr><operator>&amp;</operator><name>conflictingReferencingRelationId</name></expr></argument>,
													<argument><expr><operator>&amp;</operator><name>conflictingAccessType</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>conflictingRelationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>conflictingReferencingRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>accessTypeText</name> <init>= <expr><call><name>PlacementAccessTypeToText</name><argument_list>(<argument><expr><name>accessType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>conflictingAccessTypeText</name> <init>=
			<expr><call><name>PlacementAccessTypeToText</name><argument_list>(<argument><expr><name>conflictingAccessType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>ParallelQueryExecutedInTransaction</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If there has already been a parallel query executed, the sequential mode
			 * would still use the already opened parallel connections to the workers,
			 * thus contradicting our purpose of using sequential mode.
			 */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot execute parallel %s on table \"%s\" "</literal>
								   <literal type="string">"after %s command on reference table "</literal>
								   <literal type="string">"\"%s\" because there is a foreign key between "</literal>
								   <literal type="string">"them and \"%s\" has been accessed in this transaction"</literal></expr></argument>,
								   <argument><expr><name>accessTypeText</name></expr></argument>, <argument><expr><name>relationName</name></expr></argument>,
								   <argument><expr><name>conflictingAccessTypeText</name></expr></argument>, <argument><expr><name>conflictingRelationName</name></expr></argument>,
								   <argument><expr><name>conflictingRelationName</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"When there is a foreign key to a reference "</literal>
									  <literal type="string">"table, Citus needs to perform all operations "</literal>
									  <literal type="string">"over a single connection per node to ensure "</literal>
									  <literal type="string">"consistency."</literal></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Try re-running the transaction with "</literal>
									<literal type="string">"\"SET LOCAL citus.multi_shard_modify_mode TO "</literal>
									<literal type="string">"\'sequential\';\""</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"switching to sequential query execution mode"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"cannot execute parallel %s on table \"%s\" "</literal>
									   <literal type="string">"after %s command on reference table "</literal>
									   <literal type="string">"\"%s\" because there is a foreign key between "</literal>
									   <literal type="string">"them and \"%s\" has been accessed in this transaction"</literal></expr></argument>,
									   <argument><expr><name>accessTypeText</name></expr></argument>, <argument><expr><name>relationName</name></expr></argument>,
									   <argument><expr><name>conflictingAccessTypeText</name></expr></argument>, <argument><expr><name>conflictingRelationName</name></expr></argument>,
									   <argument><expr><name>conflictingRelationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>SetLocalMultiShardModifyModeToSequential</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * HoldsConflictingLockWithReferencedRelations returns true if the input relationId is a
 * hash distributed table and it holds any conflicting locks with the reference tables that
 * the distributed table has a foreign key to the reference table.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>HoldsConflictingLockWithReferencedRelations</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>ShardPlacementAccessType</name></type>
											<name>placementAccess</name></decl></parameter>,
											<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>conflictingRelationId</name></decl></parameter>,

											<parameter><decl><type><name>ShardPlacementAccessType</name> <modifier>*</modifier></type>
											<name>conflictingAccessMode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>cacheEntry</name> <init>= <expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>referencedRelation</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>referencedRelation</argument>, <argument>cacheEntry-&gt;referencedRelationsViaForeignKey</argument>)</argument_list></macro>
	<block>{<block_content>
		<comment type="block">/*
		 * We're only interested in foreign keys to reference tables and citus
		 * local tables.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>referencedRelation</name></expr></argument>, <argument><expr><name>CITUS_TABLE_WITH_NO_DIST_KEY</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * A select on a reference table could conflict with a DDL
		 * on a distributed table.
		 */</comment>
		<decl_stmt><decl><type><name>RelationAccessMode</name></type> <name>selectMode</name> <init>= <expr><call><name>GetRelationSelectAccessMode</name><argument_list>(<argument><expr><name>referencedRelation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>placementAccess</name> <operator>==</operator> <name>PLACEMENT_ACCESS_DDL</name> <operator>&amp;&amp;</operator>
			<name>selectMode</name> <operator>!=</operator> <name>RELATION_NOT_ACCESSED</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>conflictingRelationId</name> <operator>=</operator> <name>referencedRelation</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>conflictingAccessMode</name> <operator>=</operator> <name>PLACEMENT_ACCESS_SELECT</name></expr>;</expr_stmt>

			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Both DML and DDL operations on a reference table conflicts with
		 * any parallel operation on distributed tables.
		 */</comment>
		<decl_stmt><decl><type><name>RelationAccessMode</name></type> <name>dmlMode</name> <init>= <expr><call><name>GetRelationDMLAccessMode</name><argument_list>(<argument><expr><name>referencedRelation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>dmlMode</name> <operator>!=</operator> <name>RELATION_NOT_ACCESSED</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>conflictingRelationId</name> <operator>=</operator> <name>referencedRelation</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>conflictingAccessMode</name> <operator>=</operator> <name>PLACEMENT_ACCESS_DML</name></expr>;</expr_stmt>

			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>RelationAccessMode</name></type> <name>ddlMode</name> <init>= <expr><call><name>GetRelationDDLAccessMode</name><argument_list>(<argument><expr><name>referencedRelation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>ddlMode</name> <operator>!=</operator> <name>RELATION_NOT_ACCESSED</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>conflictingRelationId</name> <operator>=</operator> <name>referencedRelation</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>conflictingAccessMode</name> <operator>=</operator> <name>PLACEMENT_ACCESS_DDL</name></expr>;</expr_stmt>

			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * HoldsConflictingLockWithReferencingRelations returns true when the input relationId is a
 * reference table and it holds any conflicting locks with the distributed tables where
 * the distributed table has a foreign key to the reference table.
 *
 * If returns true, the referencing relation and conflictingAccessMode are also set.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>HoldsConflictingLockWithReferencingRelations</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>ShardPlacementAccessType</name></type>
											 <name>placementAccess</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>conflictingRelationId</name></decl></parameter>,
											 <parameter><decl><type><name>ShardPlacementAccessType</name> <modifier>*</modifier></type>
											 <name>conflictingAccessMode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>cacheEntry</name> <init>= <expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>holdsConflictingLocks</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsCitusTableTypeCacheEntry</name><argument_list>(<argument><expr><name>cacheEntry</name></expr></argument>, <argument><expr><name>CITUS_TABLE_WITH_NO_DIST_KEY</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>referencingRelation</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>referencingRelation</argument>, <argument>cacheEntry-&gt;referencingRelationsViaForeignKey</argument>)</argument_list></macro>
	<block>{<block_content>
		<comment type="block">/*
		 * We're only interested in foreign keys to reference tables from
		 * hash distributed tables.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>referencingRelation</name></expr></argument>, <argument><expr><name>HASH_DISTRIBUTED</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Rules that we apply:
		 *      - SELECT on a reference might table conflict with
		 *        a previous parallel DDL on a distributed table
		 *      - DML on a reference table might conflict with
		 *        a previous parallel DML or DDL on a distributed
		 *        table
		 *      - DDL on a reference table might conflict with
		 *        a parellel SELECT, DML or DDL on a distributed
		 *        table
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>placementAccess</name> <operator>==</operator> <name>PLACEMENT_ACCESS_SELECT</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RelationAccessMode</name></type> <name>ddlMode</name> <init>= <expr><call><name>GetRelationDDLAccessMode</name><argument_list>(<argument><expr><name>referencingRelation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>ddlMode</name> <operator>==</operator> <name>RELATION_PARALLEL_ACCESSED</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* SELECT on a distributed table conflicts with DDL / TRUNCATE */</comment>
				<expr_stmt><expr><name>holdsConflictingLocks</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>conflictingAccessMode</name> <operator>=</operator> <name>PLACEMENT_ACCESS_DDL</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>placementAccess</name> <operator>==</operator> <name>PLACEMENT_ACCESS_DML</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RelationAccessMode</name></type> <name>dmlMode</name> <init>= <expr><call><name>GetRelationDMLAccessMode</name><argument_list>(<argument><expr><name>referencingRelation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>dmlMode</name> <operator>==</operator> <name>RELATION_PARALLEL_ACCESSED</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>holdsConflictingLocks</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>conflictingAccessMode</name> <operator>=</operator> <name>PLACEMENT_ACCESS_DML</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<decl_stmt><decl><type><name>RelationAccessMode</name></type> <name>ddlMode</name> <init>= <expr><call><name>GetRelationDDLAccessMode</name><argument_list>(<argument><expr><name>referencingRelation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>ddlMode</name> <operator>==</operator> <name>RELATION_PARALLEL_ACCESSED</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* SELECT on a distributed table conflicts with DDL / TRUNCATE */</comment>
				<expr_stmt><expr><name>holdsConflictingLocks</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>conflictingAccessMode</name> <operator>=</operator> <name>PLACEMENT_ACCESS_DDL</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>placementAccess</name> <operator>==</operator> <name>PLACEMENT_ACCESS_DDL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RelationAccessMode</name></type> <name>selectMode</name> <init>= <expr><call><name>GetRelationSelectAccessMode</name><argument_list>(
				<argument><expr><name>referencingRelation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>selectMode</name> <operator>==</operator> <name>RELATION_PARALLEL_ACCESSED</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>holdsConflictingLocks</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>conflictingAccessMode</name> <operator>=</operator> <name>PLACEMENT_ACCESS_SELECT</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<decl_stmt><decl><type><name>RelationAccessMode</name></type> <name>dmlMode</name> <init>= <expr><call><name>GetRelationDMLAccessMode</name><argument_list>(<argument><expr><name>referencingRelation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>dmlMode</name> <operator>==</operator> <name>RELATION_PARALLEL_ACCESSED</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>holdsConflictingLocks</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>conflictingAccessMode</name> <operator>=</operator> <name>PLACEMENT_ACCESS_DML</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<decl_stmt><decl><type><name>RelationAccessMode</name></type> <name>ddlMode</name> <init>= <expr><call><name>GetRelationDDLAccessMode</name><argument_list>(<argument><expr><name>referencingRelation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>ddlMode</name> <operator>==</operator> <name>RELATION_PARALLEL_ACCESSED</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>holdsConflictingLocks</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>conflictingAccessMode</name> <operator>=</operator> <name>PLACEMENT_ACCESS_DDL</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>holdsConflictingLocks</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>conflictingRelationId</name> <operator>=</operator> <name>referencingRelation</name></expr>;</expr_stmt>

			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>
</unit>
