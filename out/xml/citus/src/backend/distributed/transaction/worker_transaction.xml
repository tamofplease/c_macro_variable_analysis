<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/builded_projects/citus/src/backend/distributed/transaction/worker_transaction.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * worker_transaction.c
 *
 * Routines for performing transactions across all workers.
 *
 * Copyright (c) Citus Data, Inc.
 *
 * $Id$
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-fe.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/connection_management.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/resource_lock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_sync.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/remote_commands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_dist_node.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_dist_transaction.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/transaction_recovery.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_manager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_transaction.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/jsonbutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SendCommandToMetadataWorkersParams</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>command</name></decl></parameter>,
											   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>user</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>parameterCount</name></decl></parameter>,
											   <parameter><decl><type><specifier>const</specifier> <name>Oid</name> <modifier>*</modifier></type><name>parameterTypes</name></decl></parameter>,
											   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>parameterValues</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SendCommandToWorkersParamsInternal</name><parameter_list>(<parameter><decl><type><name>TargetWorkerSet</name></type> <name>targetWorkerSet</name></decl></parameter>,
											   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>command</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>user</name></decl></parameter>,
											   <parameter><decl><type><name>int</name></type> <name>parameterCount</name></decl></parameter>,
											   <parameter><decl><type><specifier>const</specifier> <name>Oid</name> <modifier>*</modifier></type><name>parameterTypes</name></decl></parameter>,
											   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>parameterValues</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ErrorIfAnyMetadataNodeOutOfSync</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>metadataNodeList</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * SendCommandToWorker sends a command to a particular worker as part of the
 * 2PC.
 */</comment>
<function><type><name>void</name></type>
<name>SendCommandToWorker</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nodeName</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>nodePort</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>command</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nodeUser</name> <init>= <expr><call><name>CurrentUserName</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>SendCommandToWorkerAsUser</name><argument_list>(<argument><expr><name>nodeName</name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>, <argument><expr><name>nodeUser</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * SendCommandToWorkersAsUser sends a command to targetWorkerSet as a particular user
 * as part of the 2PC.
 */</comment>
<function><type><name>void</name></type>
<name>SendCommandToWorkersAsUser</name><parameter_list>(<parameter><decl><type><name>TargetWorkerSet</name></type> <name>targetWorkerSet</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nodeUser</name></decl></parameter>,
						   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>command</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>workerNodeList</name> <init>= <expr><call><name>TargetWorkerSetNodeList</name><argument_list>(<argument><expr><name>targetWorkerSet</name></expr></argument>, <argument><expr><name>RowShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* run commands serially */</comment>
	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>workerNode</argument>, <argument>workerNodeList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nodeName</name> <init>= <expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>nodePort</name> <init>= <expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>SendCommandToWorkerAsUser</name><argument_list>(<argument><expr><name>nodeName</name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>, <argument><expr><name>nodeUser</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * SendCommandToWorkerAsUser sends a command to a particular worker as a particular user
 * as part of the 2PC.
 */</comment>
<function><type><name>void</name></type>
<name>SendCommandToWorkerAsUser</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nodeName</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>nodePort</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nodeUser</name></decl></parameter>,
						  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>command</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>connectionFlags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>UseCoordinatedTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Use2PCForCoordinatedTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>transactionConnection</name> <init>= <expr><call><name>GetNodeUserDatabaseConnection</name><argument_list>(
		<argument><expr><name>connectionFlags</name></expr></argument>, <argument><expr><name>nodeName</name></expr></argument>,
		<argument><expr><name>nodePort</name></expr></argument>,
		<argument><expr><name>nodeUser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>MarkRemoteTransactionCritical</name><argument_list>(<argument><expr><name>transactionConnection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RemoteTransactionBeginIfNecessary</name><argument_list>(<argument><expr><name>transactionConnection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecuteCriticalRemoteCommand</name><argument_list>(<argument><expr><name>transactionConnection</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * SendCommandToWorkers sends a command to all workers in
 * parallel. Commands are committed on the workers when the local
 * transaction commits.
 */</comment>
<function><type><name>void</name></type>
<name>SendCommandToWorkersWithMetadata</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>command</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>SendCommandToMetadataWorkersParams</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><call><name>CurrentUserName</name><argument_list>()</argument_list></call></expr></argument>,
									   <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * SendCommandToWorkersWithMetadataViaSuperUser sends a command to all workers in
 * parallel by opening a super user connection. Commands are committed on the workers
 * when the local transaction commits. The connection are made as the extension
 * owner to ensure write access to the Citus metadata tables.
 *
 * Since we prevent to open superuser connections for metadata tables, it is
 * discourated to use it. Consider using it only for propagating pg_dist_object
 * tuples for dependent objects.
 */</comment>
<function><type><name>void</name></type>
<name>SendCommandToWorkersWithMetadataViaSuperUser</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>command</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>SendCommandToMetadataWorkersParams</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><call><name>CitusExtensionOwnerName</name><argument_list>()</argument_list></call></expr></argument>,
									   <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * TargetWorkerSetNodeList returns a list of WorkerNode's that satisfies the
 * TargetWorkerSet.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>TargetWorkerSetNodeList</name><parameter_list>(<parameter><decl><type><name>TargetWorkerSet</name></type> <name>targetWorkerSet</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockMode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>workerNodeList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>targetWorkerSet</name> <operator>==</operator> <name>ALL_SHARD_NODES</name> <operator>||</operator> <name>targetWorkerSet</name> <operator>==</operator> <name>METADATA_NODES</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>workerNodeList</name> <operator>=</operator> <call><name>ActivePrimaryNodeList</name><argument_list>(<argument><expr><name>lockMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>workerNodeList</name> <operator>=</operator> <call><name>ActivePrimaryNonCoordinatorNodeList</name><argument_list>(<argument><expr><name>lockMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>workerNode</argument>, <argument>workerNodeList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>targetWorkerSet</name> <operator>==</operator> <name>NON_COORDINATOR_METADATA_NODES</name> <operator>||</operator> <name>targetWorkerSet</name> <operator>==</operator>
			 <name>METADATA_NODES</name><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>!</operator><name><name>workerNode</name><operator>-&gt;</operator><name>hasMetadata</name></name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>workerNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SendBareCommandListToMetadataWorkers sends a list of commands to metadata
 * workers in serial. Commands are committed immediately: new connections are
 * always used and no transaction block is used (hence "bare"). The connections
 * are made as the extension owner to ensure write access to the Citus metadata
 * tables. Primarly useful for INDEX commands using CONCURRENTLY.
 */</comment>
<function><type><name>void</name></type>
<name>SendBareCommandListToMetadataWorkers</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>commandList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TargetWorkerSet</name></type> <name>targetWorkerSet</name> <init>= <expr><name>NON_COORDINATOR_METADATA_NODES</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>workerNodeList</name> <init>= <expr><call><name>TargetWorkerSetNodeList</name><argument_list>(<argument><expr><name>targetWorkerSet</name></expr></argument>, <argument><expr><name>RowShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nodeUser</name> <init>= <expr><call><name>CurrentUserName</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ErrorIfAnyMetadataNodeOutOfSync</name><argument_list>(<argument><expr><name>workerNodeList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* run commands serially */</comment>
	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>workerNode</argument>, <argument>workerNodeList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nodeName</name> <init>= <expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>nodePort</name> <init>= <expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>connectionFlags</name> <init>= <expr><name>FORCE_NEW_CONNECTION</name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>workerConnection</name> <init>= <expr><call><name>GetNodeUserDatabaseConnection</name><argument_list>(<argument><expr><name>connectionFlags</name></expr></argument>,
																		  <argument><expr><name>nodeName</name></expr></argument>,
																		  <argument><expr><name>nodePort</name></expr></argument>,
																		  <argument><expr><name>nodeUser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* iterate over the commands and execute them in the same connection */</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>commandString</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>commandString</argument>, <argument>commandList</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ExecuteCriticalRemoteCommand</name><argument_list>(<argument><expr><name>workerConnection</name></expr></argument>, <argument><expr><name>commandString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><call><name>CloseConnection</name><argument_list>(<argument><expr><name>workerConnection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * SendCommandToMetadataWorkersParams is a wrapper around
 * SendCommandToWorkersParamsInternal() enforcing some extra checks.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SendCommandToMetadataWorkersParams</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>command</name></decl></parameter>,
								   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>user</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>parameterCount</name></decl></parameter>,
								   <parameter><decl><type><specifier>const</specifier> <name>Oid</name> <modifier>*</modifier></type><name>parameterTypes</name></decl></parameter>,
								   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>parameterValues</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>workerNodeList</name> <init>= <expr><call><name>TargetWorkerSetNodeList</name><argument_list>(<argument><expr><name>NON_COORDINATOR_METADATA_NODES</name></expr></argument>,
												   <argument><expr><name>RowShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ErrorIfAnyMetadataNodeOutOfSync</name><argument_list>(<argument><expr><name>workerNodeList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SendCommandToWorkersParamsInternal</name><argument_list>(<argument><expr><name>NON_COORDINATOR_METADATA_NODES</name></expr></argument>, <argument><expr><name>command</name></expr></argument>, <argument><expr><name>user</name></expr></argument>,
									   <argument><expr><name>parameterCount</name></expr></argument>, <argument><expr><name>parameterTypes</name></expr></argument>,
									   <argument><expr><name>parameterValues</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * SendCommandToWorkersParamsInternal sends a command to all workers in parallel.
 * Commands are committed on the workers when the local transaction commits. The
 * connection are made as the extension owner to ensure write access to the Citus
 * metadata tables. Parameters can be specified as for PQexecParams, except that
 * paramLengths, paramFormats and resultFormat are hard-coded to NULL, NULL and 0
 * respectively.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SendCommandToWorkersParamsInternal</name><parameter_list>(<parameter><decl><type><name>TargetWorkerSet</name></type> <name>targetWorkerSet</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>command</name></decl></parameter>,
								   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>user</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>parameterCount</name></decl></parameter>,
								   <parameter><decl><type><specifier>const</specifier> <name>Oid</name> <modifier>*</modifier></type><name>parameterTypes</name></decl></parameter>,
								   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>parameterValues</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>connectionList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>workerNodeList</name> <init>= <expr><call><name>TargetWorkerSetNodeList</name><argument_list>(<argument><expr><name>targetWorkerSet</name></expr></argument>, <argument><expr><name>RowShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>UseCoordinatedTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Use2PCForCoordinatedTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* open connections in parallel */</comment>
	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>workerNode</argument>, <argument>workerNodeList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nodeName</name> <init>= <expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>nodePort</name> <init>= <expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type> <name>connectionFlags</name> <init>= <expr><name>REQUIRE_METADATA_CONNECTION</name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><call><name>StartNodeUserDatabaseConnection</name><argument_list>(<argument><expr><name>connectionFlags</name></expr></argument>,
																	  <argument><expr><name>nodeName</name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>,
																	  <argument><expr><name>user</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * connection can only be NULL for optional connections, which we don't
		 * support in this codepath.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>connectionFlags</name> <operator>&amp;</operator> <name>OPTIONAL_CONNECTION</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>connection</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MarkRemoteTransactionCritical</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>connectionList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>connectionList</name></expr></argument>, <argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* finish opening connections */</comment>
	<expr_stmt><expr><call><name>FinishConnectionListEstablishment</name><argument_list>(<argument><expr><name>connectionList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>RemoteTransactionsBeginIfNecessary</name><argument_list>(<argument><expr><name>connectionList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* send commands in parallel */</comment>
	<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>connection</argument>, <argument>connectionList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>querySent</name> <init>= <expr><call><name>SendRemoteCommandParams</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>command</name></expr></argument>, <argument><expr><name>parameterCount</name></expr></argument>,
												<argument><expr><name>parameterTypes</name></expr></argument>, <argument><expr><name>parameterValues</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>querySent</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ReportConnectionError</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* get results */</comment>
	<macro><name>foreach_ptr</name><argument_list>(<argument>connection</argument>, <argument>connectionList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>GetRemoteCommandResult</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsResponseOK</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ReportResultError</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ForgetResults</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * EnsureNoModificationsHaveBeenDone reports an error if we have performed any
 * modification in the current transaction to prevent opening a connection is such cases.
 */</comment>
<function><type><name>void</name></type>
<name>EnsureNoModificationsHaveBeenDone</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>XactModificationLevel</name> <operator>&gt;</operator> <name>XACT_MODIFICATION_NONE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ACTIVE_SQL_TRANSACTION</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot open new connections after the first modification "</literal>
							   <literal type="string">"command within a transaction"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * SendCommandListToWorkerOutsideTransaction forces to open a new connection
 * to the node with the given nodeName and nodePort. Then, the connection starts
 * a transaction on the remote node and executes the commands in the transaction.
 * The function raises error if any of the queries fails.
 */</comment>
<function><type><name>void</name></type>
<name>SendCommandListToWorkerOutsideTransaction</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nodeName</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>nodePort</name></decl></parameter>,
										  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nodeUser</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>commandList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>connectionFlags</name> <init>= <expr><name>FORCE_NEW_CONNECTION</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>workerConnection</name> <init>= <expr><call><name>GetNodeUserDatabaseConnection</name><argument_list>(<argument><expr><name>connectionFlags</name></expr></argument>,
																	  <argument><expr><name>nodeName</name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>,
																	  <argument><expr><name>nodeUser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SendCommandListToWorkerOutsideTransactionWithConnection</name><argument_list>(<argument><expr><name>workerConnection</name></expr></argument>,
															<argument><expr><name>commandList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CloseConnection</name><argument_list>(<argument><expr><name>workerConnection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * SendCommandListToWorkerOutsideTransactionWithConnection sends the command list
 * over the specified connection. This opens a new transaction on the
 * connection, thus it's important that no transaction is currently open.
 * This function is mainly useful to avoid opening an closing
 * connections excessively by allowing reusing a single connection to send
 * multiple separately committing transactions. The function raises an error if
 * any of the queries fail.
 */</comment>
<function><type><name>void</name></type>
<name>SendCommandListToWorkerOutsideTransactionWithConnection</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>workerConnection</name></decl></parameter>,
														<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>commandList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>MarkRemoteTransactionCritical</name><argument_list>(<argument><expr><name>workerConnection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RemoteTransactionBegin</name><argument_list>(<argument><expr><name>workerConnection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* iterate over the commands and execute them in the same connection */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>commandString</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>commandString</argument>, <argument>commandList</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecuteCriticalRemoteCommand</name><argument_list>(<argument><expr><name>workerConnection</name></expr></argument>, <argument><expr><name>commandString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>RemoteTransactionCommit</name><argument_list>(<argument><expr><name>workerConnection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ResetRemoteTransaction</name><argument_list>(<argument><expr><name>workerConnection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * SendCommandListToWorkerInCoordinatedTransaction opens connection to the node
 * with the given nodeName and nodePort. The commands are sent as part of the
 * coordinated transaction. Any failures aborts the coordinated transaction.
 */</comment>
<function><type><name>void</name></type>
<name>SendMetadataCommandListToWorkerListInCoordinatedTransaction</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>workerNodeList</name></decl></parameter>,
															<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nodeUser</name></decl></parameter>,
															<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>commandList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>commandList</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>workerNodeList</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* nothing to do */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>UseCoordinatedTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>connectionList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>workerNode</argument>, <argument>workerNodeList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nodeName</name> <init>= <expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>nodePort</name> <init>= <expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>connectionFlags</name> <init>= <expr><name>REQUIRE_METADATA_CONNECTION</name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>=
			<expr><call><name>StartNodeConnection</name><argument_list>(<argument><expr><name>connectionFlags</name></expr></argument>, <argument><expr><name>nodeName</name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>MarkRemoteTransactionCritical</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * connection can only be NULL for optional connections, which we don't
		 * support in this codepath.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>connectionFlags</name> <operator>&amp;</operator> <name>OPTIONAL_CONNECTION</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>connection</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>connectionList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>connectionList</name></expr></argument>, <argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>FinishConnectionListEstablishment</name><argument_list>(<argument><expr><name>connectionList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* must open transaction blocks to use intermediate results */</comment>
	<expr_stmt><expr><call><name>RemoteTransactionsBeginIfNecessary</name><argument_list>(<argument><expr><name>connectionList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * In order to avoid round-trips per query in queryStringList,
	 * we join the string and send as a single command. Also,
	 * if there is only a single command, avoid additional call to
	 * StringJoin given that some strings can be quite large.
	 */</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>stringToSend</name> <init>= <expr><ternary><condition><expr><operator>(</operator><call><name>list_length</name><argument_list>(<argument><expr><name>commandList</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then>
						 <expr><call><name>linitial</name><argument_list>(<argument><expr><name>commandList</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>StringJoin</name><argument_list>(<argument><expr><name>commandList</name></expr></argument>, <argument><expr><literal type="char">';'</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<comment type="block">/* send commands in parallel */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>failOnError</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>connection</argument>, <argument>connectionList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>querySent</name> <init>= <expr><call><name>SendRemoteCommand</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>stringToSend</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>querySent</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ReportConnectionError</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<macro><name>foreach_ptr</name><argument_list>(<argument>connection</argument>, <argument>connectionList</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ClearResults</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>failOnError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * SendOptionalCommandListToWorkerOutsideTransactionWithConnection sends the
 * given command list over a specified connection in a single transaction that
 * is outside of the coordinated tranaction.
 *
 * If any of the commands fail, it rollbacks the transaction, and otherwise commits.
 * A successful commit is indicated by returning true, and a failed commit by returning
 * false.
 */</comment>
<function><type><name>bool</name></type>
<name>SendOptionalCommandListToWorkerOutsideTransactionWithConnection</name><parameter_list>(
	<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>workerConnection</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>commandList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>PQstatus</name><argument_list>(<argument><expr><name><name>workerConnection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CONNECTION_OK</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>RemoteTransactionBegin</name><argument_list>(<argument><expr><name>workerConnection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* iterate over the commands and execute them in the same connection */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>failed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>commandString</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>commandString</argument>, <argument>commandList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>ExecuteOptionalRemoteCommand</name><argument_list>(<argument><expr><name>workerConnection</name></expr></argument>, <argument><expr><name>commandString</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>failed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>failed</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>RemoteTransactionAbort</name><argument_list>(<argument><expr><name>workerConnection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>RemoteTransactionCommit</name><argument_list>(<argument><expr><name>workerConnection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>ResetRemoteTransaction</name><argument_list>(<argument><expr><name>workerConnection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>!</operator><name>failed</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SendOptionalCommandListToWorkerOutsideTransaction sends the given command
 * list to the given worker in a single transaction that is outside of the
 * coordinated tranaction. If any of the commands fail, it rollbacks the
 * transaction, and otherwise commits.
 */</comment>
<function><type><name>bool</name></type>
<name>SendOptionalCommandListToWorkerOutsideTransaction</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nodeName</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>nodePort</name></decl></parameter>,
												  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nodeUser</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>commandList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>connectionFlags</name> <init>= <expr><name>FORCE_NEW_CONNECTION</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>workerConnection</name> <init>= <expr><call><name>GetNodeUserDatabaseConnection</name><argument_list>(<argument><expr><name>connectionFlags</name></expr></argument>,
																	  <argument><expr><name>nodeName</name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>,
																	  <argument><expr><name>nodeUser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>failed</name> <init>= <expr><call><name>SendOptionalCommandListToWorkerOutsideTransactionWithConnection</name><argument_list>(
		<argument><expr><name>workerConnection</name></expr></argument>,
		<argument><expr><name>commandList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>CloseConnection</name><argument_list>(<argument><expr><name>workerConnection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>!</operator><name>failed</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SendOptionalMetadataCommandListToWorkerInCoordinatedTransaction sends the given
 * command list to the given worker as part of the coordinated transaction.
 * If any of the commands fail, the function returns false.
 */</comment>
<function><type><name>bool</name></type>
<name>SendOptionalMetadataCommandListToWorkerInCoordinatedTransaction</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nodeName</name></decl></parameter>,
																<parameter><decl><type><name>int32</name></type> <name>nodePort</name></decl></parameter>,
																<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nodeUser</name></decl></parameter>,
																<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>commandList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>connectionFlags</name> <init>= <expr><name>REQUIRE_METADATA_CONNECTION</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>failed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>UseCoordinatedTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>workerConnection</name> <init>=
		<expr><call><name>GetNodeUserDatabaseConnection</name><argument_list>(<argument><expr><name>connectionFlags</name></expr></argument>, <argument><expr><name>nodeName</name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>,
									  <argument><expr><name>nodeUser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PQstatus</name><argument_list>(<argument><expr><name><name>workerConnection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CONNECTION_OK</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>RemoteTransactionsBeginIfNecessary</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>workerConnection</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* iterate over the commands and execute them in the same connection */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>commandString</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>commandString</argument>, <argument>commandList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>ExecuteOptionalRemoteCommand</name><argument_list>(<argument><expr><name>workerConnection</name></expr></argument>, <argument><expr><name>commandString</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator>
			<name>RESPONSE_OKAY</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>failed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<decl_stmt><decl><type><name>bool</name></type> <name>raiseErrors</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>MarkRemoteTransactionFailed</name><argument_list>(<argument><expr><name>workerConnection</name></expr></argument>, <argument><expr><name>raiseErrors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><operator>!</operator><name>failed</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ErrorIfAnyMetadataNodeOutOfSync raises an error if any of the given
 * metadata nodes are out of sync. It is safer to avoid metadata changing
 * commands (e.g. DDL or node addition) until all metadata nodes have
 * been synced.
 *
 * An example of we could get in a bad situation without doing so is:
 *  1. Create a reference table
 *  2. After the node becomes out of sync, add a new active node
 *  3. Insert into the reference table from the out of sync node
 *
 * Since the out-of-sync might not know about the new node, it won't propagate
 * the changes to the new node and replicas will be in an inconsistent state.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ErrorIfAnyMetadataNodeOutOfSync</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>metadataNodeList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>metadataNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>metadataNode</argument>, <argument>metadataNodeList</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>metadataNode</name><operator>-&gt;</operator><name>hasMetadata</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>metadataNode</name><operator>-&gt;</operator><name>metadataSynced</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>workerName</name> <init>= <expr><name><name>metadataNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>workerPort</name> <init>= <expr><name><name>metadataNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s:%d is a metadata node, but is out of sync"</literal></expr></argument>,
								   <argument><expr><name>workerName</name></expr></argument>, <argument><expr><name>workerPort</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"If the node is up, wait until metadata"</literal>
									<literal type="string">" gets synced to it and try again."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * IsWorkerTheCurrentNode checks if the given worker refers to the
 * the current node by comparing the server id of the worker and of the
 * current nodefrom pg_dist_node_metadata
 */</comment>
<function><type><name>bool</name></type>
<name>IsWorkerTheCurrentNode</name><parameter_list>(<parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>connectionFlags</name> <init>= <expr><name>REQUIRE_METADATA_CONNECTION</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>workerConnection</name> <init>=
		<expr><call><name>GetNodeUserDatabaseConnection</name><argument_list>(<argument><expr><name>connectionFlags</name></expr></argument>,
									  <argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>,
									  <argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>,
									  <argument><expr><call><name>CurrentUserName</name><argument_list>()</argument_list></call></expr></argument>,
									  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>command</name> <init>=
		<expr><literal type="string">"SELECT metadata -&gt;&gt; 'server_id' AS server_id FROM pg_dist_node_metadata"</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>resultCode</name> <init>= <expr><call><name>SendRemoteCommand</name><argument_list>(<argument><expr><name>workerConnection</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>resultCode</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CloseConnection</name><argument_list>(<argument><expr><name>workerConnection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>GetRemoteCommandResult</name><argument_list>(<argument><expr><name>workerConnection</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commandResult</name> <init>= <expr><call><name>ReadFirstColumnAsText</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ForgetResults</name><argument_list>(<argument><expr><name>workerConnection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>list_length</name><argument_list>(<argument><expr><name>commandResult</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>StringInfo</name></type> <name>resultInfo</name> <init>= <expr><operator>(</operator><name>StringInfo</name><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>commandResult</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>workerServerId</name> <init>= <expr><name><name>resultInfo</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Datum</name></type> <name>metadata</name> <init>= <expr><call><name>DistNodeMetadata</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>currentServerIdTextP</name> <init>= <expr><call><name>ExtractFieldTextP</name><argument_list>(<argument><expr><name>metadata</name></expr></argument>, <argument><expr><literal type="string">"server_id"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>currentServerIdTextP</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>currentServerId</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><name>currentServerIdTextP</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>workerServerId</name></expr></argument>, <argument><expr><name>currentServerId</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
</unit>
