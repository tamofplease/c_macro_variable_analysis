<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/citus/src/backend/distributed/transaction/lock_graph.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * lock_graph.c
 *
 *  Functions for obtaining local and global lock graphs in which each
 *  node is a distributed transaction, and an edge represent a waiting-for
 *  relationship.
 *
 * Copyright (c) Citus Data, Inc.
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-fe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/backend_data.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/connection_management.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/hash_helpers.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/lock_graph.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/remote_commands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/tuplestore.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/hsearch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timestamp.h"</cpp:file></cpp:include>


<comment type="block">/*
 * PROCStack is a stack of PGPROC pointers used to perform a depth-first search
 * through the lock graph. It also keeps track of which processes have been
 * added to the stack to avoid visiting the same process multiple times.
 */</comment>
<typedef>typedef <type><struct>struct <name>PROCStack</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>procCount</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGPROC</name> <modifier>*</modifier><modifier>*</modifier></type><name>procs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>procAdded</name></decl>;</decl_stmt>
}</block></struct></type> <name>PROCStack</name>;</typedef>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AddWaitEdgeFromResult</name><parameter_list>(<parameter><decl><type><name>WaitGraph</name> <modifier>*</modifier></type><name>waitGraph</name></decl></parameter>, <parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rowIndex</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReturnWaitGraph</name><parameter_list>(<parameter><decl><type><name>WaitGraph</name> <modifier>*</modifier></type><name>waitGraph</name></decl></parameter>, <parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AddWaitEdgeFromBlockedProcessResult</name><parameter_list>(<parameter><decl><type><name>WaitGraph</name> <modifier>*</modifier></type><name>waitGraph</name></decl></parameter>, <parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>result</name></decl></parameter>,
												<parameter><decl><type><name>int</name></type> <name>rowIndex</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReturnBlockedProcessGraph</name><parameter_list>(<parameter><decl><type><name>WaitGraph</name> <modifier>*</modifier></type><name>waitGraph</name></decl></parameter>, <parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>WaitGraph</name> <modifier>*</modifier></type> <name>BuildLocalWaitGraph</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>onlyDistributedTx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsProcessWaitingForSafeOperations</name><parameter_list>(<parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>LockLockData</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>UnlockLockData</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AddEdgesForLockWaits</name><parameter_list>(<parameter><decl><type><name>WaitGraph</name> <modifier>*</modifier></type><name>waitGraph</name></decl></parameter>, <parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>waitingProc</name></decl></parameter>,
								 <parameter><decl><type><name>PROCStack</name> <modifier>*</modifier></type><name>remaining</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AddEdgesForWaitQueue</name><parameter_list>(<parameter><decl><type><name>WaitGraph</name> <modifier>*</modifier></type><name>waitGraph</name></decl></parameter>, <parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>waitingProc</name></decl></parameter>,
								 <parameter><decl><type><name>PROCStack</name> <modifier>*</modifier></type><name>remaining</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AddWaitEdge</name><parameter_list>(<parameter><decl><type><name>WaitGraph</name> <modifier>*</modifier></type><name>waitGraph</name></decl></parameter>, <parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>waitingProc</name></decl></parameter>, <parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>blockingProc</name></decl></parameter>,
						<parameter><decl><type><name>PROCStack</name> <modifier>*</modifier></type><name>remaining</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>WaitEdge</name> <modifier>*</modifier></type> <name>AllocWaitEdge</name><parameter_list>(<parameter><decl><type><name>WaitGraph</name> <modifier>*</modifier></type><name>waitGraph</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AddProcToVisit</name><parameter_list>(<parameter><decl><type><name>PROCStack</name> <modifier>*</modifier></type><name>remaining</name></decl></parameter>, <parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsSameLockGroup</name><parameter_list>(<parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>leftProc</name></decl></parameter>, <parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>rightProc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsConflictingLockMask</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>holdMask</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>conflictMask</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * We almost have 2 sets of identical functions. The first set (e.g., dump_wait_edges)
 * functions are intended for distributed deadlock detection purposes.
 *
 * The second set of functions (e.g., citus_internal_local_blocked_processes) are
 * intended for citus_lock_waits view.
 *
 * The main difference is that the former functions only show processes that are blocked
 * inside a distributed transaction (e.g., see AssignDistributedTransactionId()).
 * The latter functions return a superset, where any blocked process is returned.
 *
 * We kept two different set of functions for two purposes. First, the deadlock detection
 * is a performance critical code-path happening very frequently and we don't add any
 * performance overhead. Secondly, to be able to do rolling upgrades, we cannot change
 * the API of dump_global_wait_edges/dump_local_wait_edges such that they take a boolean
 * parameter. If we do that, until all nodes are upgraded, the deadlock detection would fail,
 * which is not acceptable.
 */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>dump_local_wait_edges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>dump_global_wait_edges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>citus_internal_local_blocked_processes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>citus_internal_global_blocked_processes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<comment type="block">/*
 * dump_global_wait_edges returns global wait edges for distributed transactions
 * originating from the node on which it is started.
 */</comment>
<function><type><name>Datum</name></type>
<name>dump_global_wait_edges</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>onlyDistributedTx</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>WaitGraph</name> <modifier>*</modifier></type><name>waitGraph</name> <init>= <expr><call><name>BuildGlobalWaitGraph</name><argument_list>(<argument><expr><name>onlyDistributedTx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ReturnWaitGraph</name><argument_list>(<argument><expr><name>waitGraph</name></expr></argument>, <argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * citus_internal_global_blocked_processes returns global wait edges
 * including all processes running on the cluster.
 */</comment>
<function><type><name>Datum</name></type>
<name>citus_internal_global_blocked_processes</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>onlyDistributedTx</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>WaitGraph</name> <modifier>*</modifier></type><name>waitGraph</name> <init>= <expr><call><name>BuildGlobalWaitGraph</name><argument_list>(<argument><expr><name>onlyDistributedTx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ReturnBlockedProcessGraph</name><argument_list>(<argument><expr><name>waitGraph</name></expr></argument>, <argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * BuildGlobalWaitGraph builds a wait graph for distributed transactions
 * that originate from this node, including edges from all (other) worker
 * nodes.
 *
 *
 * If onlyDistributedTx is true, we only return distributed transactions
 * (e.g., AssignDistributedTransaction() or assign_distributed_transactions())
 * has been called for the process. Distributed deadlock detection only
 * interested in these processes.
 */</comment>
<function><type><name>WaitGraph</name> <modifier>*</modifier></type>
<name>BuildGlobalWaitGraph</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>onlyDistributedTx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>workerNodeList</name> <init>= <expr><call><name>ActiveReadableNodeList</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nodeUser</name> <init>= <expr><call><name>CitusExtensionOwnerName</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>connectionList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>localGroupId</name> <init>= <expr><call><name>GetLocalGroupId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* deadlock detection is only interested in distributed transactions */</comment>
	<decl_stmt><decl><type><name>WaitGraph</name> <modifier>*</modifier></type><name>waitGraph</name> <init>= <expr><call><name>BuildLocalWaitGraph</name><argument_list>(<argument><expr><name>onlyDistributedTx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* open connections in parallel */</comment>
	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>workerNode</argument>, <argument>workerNodeList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nodeName</name> <init>= <expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>nodePort</name> <init>= <expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>connectionFlags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>workerNode</name><operator>-&gt;</operator><name>groupId</name></name> <operator>==</operator> <name>localGroupId</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* we already have local wait edges */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><call><name>StartNodeUserDatabaseConnection</name><argument_list>(<argument><expr><name>connectionFlags</name></expr></argument>,
																	  <argument><expr><name>nodeName</name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>,
																	  <argument><expr><name>nodeUser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>connectionList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>connectionList</name></expr></argument>, <argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>FinishConnectionListEstablishment</name><argument_list>(<argument><expr><name>connectionList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* send commands in parallel */</comment>
	<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>connection</argument>, <argument>connectionList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>StringInfo</name></type> <name>queryString</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>onlyDistributedTx</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>queryString</name></expr></argument>,
							 <argument><expr><literal type="string">"SELECT waiting_pid, waiting_node_id, "</literal>
							 <literal type="string">"waiting_transaction_num, waiting_transaction_stamp, "</literal>
							 <literal type="string">"blocking_pid, blocking_node_id, blocking_transaction_num, "</literal>
							 <literal type="string">"blocking_transaction_stamp, blocking_transaction_waiting "</literal>
							 <literal type="string">"FROM dump_local_wait_edges()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>queryString</name></expr></argument>,
							 <argument><expr><literal type="string">"SELECT waiting_global_pid, waiting_pid, "</literal>
							 <literal type="string">"waiting_node_id, waiting_transaction_num, waiting_transaction_stamp, "</literal>
							 <literal type="string">"blocking_global_pid,blocking_pid, blocking_node_id, "</literal>
							 <literal type="string">"blocking_transaction_num, blocking_transaction_stamp, blocking_transaction_waiting "</literal>
							 <literal type="string">"FROM citus_internal_local_blocked_processes()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<decl_stmt><decl><type><name>int</name></type> <name>querySent</name> <init>= <expr><call><name>SendRemoteCommand</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name><name>queryString</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>querySent</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ReportConnectionError</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>WARNING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* receive dump_local_wait_edges results */</comment>
	<macro><name>foreach_ptr</name><argument_list>(<argument>connection</argument>, <argument>connectionList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>raiseInterrupts</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>GetRemoteCommandResult</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>raiseInterrupts</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsResponseOK</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ReportResultError</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>WARNING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>int64</name></type> <name>rowCount</name> <init>= <expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int64</name></type> <name>colCount</name> <init>= <expr><call><name>PQnfields</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>onlyDistributedTx</name> <operator>&amp;&amp;</operator> <name>colCount</name> <operator>!=</operator> <literal type="number">9</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected number of columns from "</literal>
									 <literal type="string">"dump_local_wait_edges"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><name>onlyDistributedTx</name> <operator>&amp;&amp;</operator> <name>colCount</name> <operator>!=</operator> <literal type="number">11</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected number of columns from "</literal>
									 <literal type="string">"citus_internal_local_blocked_processes"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<for>for <control>(<init><decl><type><name>int64</name></type> <name>rowIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>rowIndex</name> <operator>&lt;</operator> <name>rowCount</name></expr>;</condition> <incr><expr><name>rowIndex</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>onlyDistributedTx</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>AddWaitEdgeFromResult</name><argument_list>(<argument><expr><name>waitGraph</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>AddWaitEdgeFromBlockedProcessResult</name><argument_list>(<argument><expr><name>waitGraph</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ForgetResults</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>waitGraph</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AddWaitEdgeFromResult adds an edge to the wait graph that is read from
 * a PGresult.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AddWaitEdgeFromResult</name><parameter_list>(<parameter><decl><type><name>WaitGraph</name> <modifier>*</modifier></type><name>waitGraph</name></decl></parameter>, <parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rowIndex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WaitEdge</name> <modifier>*</modifier></type><name>waitEdge</name> <init>= <expr><call><name>AllocWaitEdge</name><argument_list>(<argument><expr><name>waitGraph</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>waitEdge</name><operator>-&gt;</operator><name>waitingGPid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* not requested for deadlock detection */</comment>
	<expr_stmt><expr><name><name>waitEdge</name><operator>-&gt;</operator><name>waitingPid</name></name> <operator>=</operator> <call><name>ParseIntField</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>waitEdge</name><operator>-&gt;</operator><name>waitingNodeId</name></name> <operator>=</operator> <call><name>ParseIntField</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>waitEdge</name><operator>-&gt;</operator><name>waitingTransactionNum</name></name> <operator>=</operator> <call><name>ParseIntField</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>waitEdge</name><operator>-&gt;</operator><name>waitingTransactionStamp</name></name> <operator>=</operator> <call><name>ParseTimestampTzField</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>waitEdge</name><operator>-&gt;</operator><name>blockingGPid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* not requested for deadlock detection */</comment>
	<expr_stmt><expr><name><name>waitEdge</name><operator>-&gt;</operator><name>blockingPid</name></name> <operator>=</operator> <call><name>ParseIntField</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>waitEdge</name><operator>-&gt;</operator><name>blockingNodeId</name></name> <operator>=</operator> <call><name>ParseIntField</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>waitEdge</name><operator>-&gt;</operator><name>blockingTransactionNum</name></name> <operator>=</operator> <call><name>ParseIntField</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>waitEdge</name><operator>-&gt;</operator><name>blockingTransactionStamp</name></name> <operator>=</operator> <call><name>ParseTimestampTzField</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>waitEdge</name><operator>-&gt;</operator><name>isBlockingXactWaiting</name></name> <operator>=</operator> <call><name>ParseBoolField</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * AddWaitEdgeFromBlockedProcessResult adds an edge to the wait graph that
 * is read from a PGresult.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AddWaitEdgeFromBlockedProcessResult</name><parameter_list>(<parameter><decl><type><name>WaitGraph</name> <modifier>*</modifier></type><name>waitGraph</name></decl></parameter>, <parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rowIndex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WaitEdge</name> <modifier>*</modifier></type><name>waitEdge</name> <init>= <expr><call><name>AllocWaitEdge</name><argument_list>(<argument><expr><name>waitGraph</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>waitEdge</name><operator>-&gt;</operator><name>waitingGPid</name></name> <operator>=</operator> <call><name>ParseIntField</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>waitEdge</name><operator>-&gt;</operator><name>waitingPid</name></name> <operator>=</operator> <call><name>ParseIntField</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>waitEdge</name><operator>-&gt;</operator><name>waitingNodeId</name></name> <operator>=</operator> <call><name>ParseIntField</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>waitEdge</name><operator>-&gt;</operator><name>waitingTransactionNum</name></name> <operator>=</operator> <call><name>ParseIntField</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>waitEdge</name><operator>-&gt;</operator><name>waitingTransactionStamp</name></name> <operator>=</operator> <call><name>ParseTimestampTzField</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>waitEdge</name><operator>-&gt;</operator><name>blockingGPid</name></name> <operator>=</operator> <call><name>ParseIntField</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>waitEdge</name><operator>-&gt;</operator><name>blockingPid</name></name> <operator>=</operator> <call><name>ParseIntField</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>waitEdge</name><operator>-&gt;</operator><name>blockingNodeId</name></name> <operator>=</operator> <call><name>ParseIntField</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>waitEdge</name><operator>-&gt;</operator><name>blockingTransactionNum</name></name> <operator>=</operator> <call><name>ParseIntField</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>waitEdge</name><operator>-&gt;</operator><name>blockingTransactionStamp</name></name> <operator>=</operator> <call><name>ParseTimestampTzField</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>waitEdge</name><operator>-&gt;</operator><name>isBlockingXactWaiting</name></name> <operator>=</operator> <call><name>ParseBoolField</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ParseIntField parses a int64 from a remote result or returns 0 if the
 * result is NULL.
 */</comment>
<function><type><name>int64</name></type>
<name>ParseIntField</name><parameter_list>(<parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rowIndex</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>colIndex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><name>colIndex</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>resultString</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><name>colIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>strtou64</name><argument_list>(<argument><expr><name>resultString</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ParseBoolField parses a bool from a remote result or returns false if the
 * result is NULL.
 */</comment>
<function><type><name>bool</name></type>
<name>ParseBoolField</name><parameter_list>(<parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rowIndex</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>colIndex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><name>colIndex</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>resultString</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><name>colIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>resultString</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>resultString</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'t'</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ParseTimestampTzField parses a timestamptz from a remote result or returns
 * 0 if the result is NULL.
 */</comment>
<function><type><name>TimestampTz</name></type>
<name>ParseTimestampTzField</name><parameter_list>(<parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rowIndex</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>colIndex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><name>colIndex</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>DT_NOBEGIN</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>resultString</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><name>colIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>resultStringDatum</name> <init>= <expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>resultString</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>timestampDatum</name> <init>= <expr><call><name>DirectFunctionCall3</name><argument_list>(<argument><expr><name>timestamptz_in</name></expr></argument>, <argument><expr><name>resultStringDatum</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>DatumGetTimestampTz</name><argument_list>(<argument><expr><name>timestampDatum</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * dump_local_wait_edges returns wait edges for distributed transactions
 * running on the node on which it is called, which originate from the source node.
 */</comment>
<function><type><name>Datum</name></type>
<name>dump_local_wait_edges</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>onlyDistributedTx</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>WaitGraph</name> <modifier>*</modifier></type><name>waitGraph</name> <init>= <expr><call><name>BuildLocalWaitGraph</name><argument_list>(<argument><expr><name>onlyDistributedTx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ReturnWaitGraph</name><argument_list>(<argument><expr><name>waitGraph</name></expr></argument>, <argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * citus_internal_local_blocked_processes returns global wait edges
 * including all processes running on the node.
 */</comment>
<function><type><name>Datum</name></type>
<name>citus_internal_local_blocked_processes</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>onlyDistributedTx</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>WaitGraph</name> <modifier>*</modifier></type><name>waitGraph</name> <init>= <expr><call><name>BuildLocalWaitGraph</name><argument_list>(<argument><expr><name>onlyDistributedTx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ReturnBlockedProcessGraph</name><argument_list>(<argument><expr><name>waitGraph</name></expr></argument>, <argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ReturnWaitGraph returns a wait graph for a set returning function.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReturnWaitGraph</name><parameter_list>(<parameter><decl><type><name>WaitGraph</name> <modifier>*</modifier></type><name>waitGraph</name></decl></parameter>, <parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tupleStore</name> <init>= <expr><call><name>SetupTuplestore</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupleDesc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Columns:
	 * 00: waiting_pid
	 * 01: waiting_node_id
	 * 02: waiting_transaction_num
	 * 03: waiting_transaction_stamp
	 * 04: blocking_pid
	 * 05: blocking__node_id
	 * 06: blocking_transaction_num
	 * 07: blocking_transaction_stamp
	 * 08: blocking_transaction_waiting
	 */</comment>
	<for>for <control>(<init><decl><type><name>size_t</name></type> <name>curEdgeNum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>curEdgeNum</name> <operator>&lt;</operator> <name><name>waitGraph</name><operator>-&gt;</operator><name>edgeCount</name></name></expr>;</condition> <incr><expr><name>curEdgeNum</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type> <name><name>values</name><index>[<expr><literal type="number">9</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name><name>nulls</name><index>[<expr><literal type="number">9</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>WaitEdge</name> <modifier>*</modifier></type><name>curEdge</name> <init>= <expr><operator>&amp;</operator><name><name>waitGraph</name><operator>-&gt;</operator><name>edges</name><index>[<expr><name>curEdgeNum</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>curEdge</name><operator>-&gt;</operator><name>waitingPid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>curEdge</name><operator>-&gt;</operator><name>waitingNodeId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>curEdge</name><operator>-&gt;</operator><name>waitingTransactionNum</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>curEdge</name><operator>-&gt;</operator><name>waitingTransactionNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>TimestampTzGetDatum</name><argument_list>(<argument><expr><name><name>curEdge</name><operator>-&gt;</operator><name>waitingTransactionStamp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>curEdge</name><operator>-&gt;</operator><name>blockingPid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>curEdge</name><operator>-&gt;</operator><name>blockingNodeId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>curEdge</name><operator>-&gt;</operator><name>blockingTransactionNum</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>curEdge</name><operator>-&gt;</operator><name>blockingTransactionNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <call><name>TimestampTzGetDatum</name><argument_list>(<argument><expr><name><name>curEdge</name><operator>-&gt;</operator><name>blockingTransactionStamp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>curEdge</name><operator>-&gt;</operator><name>isBlockingXactWaiting</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>tuplestore_putvalues</name><argument_list>(<argument><expr><name>tupleStore</name></expr></argument>, <argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>


<comment type="block">/*
 * ReturnBlockedProcessGraph returns a wait graph for a set returning function.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReturnBlockedProcessGraph</name><parameter_list>(<parameter><decl><type><name>WaitGraph</name> <modifier>*</modifier></type><name>waitGraph</name></decl></parameter>, <parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tupleStore</name> <init>= <expr><call><name>SetupTuplestore</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupleDesc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Columns:
	 * 00: waiting_global_pid
	 * 01: waiting_pid
	 * 02: waiting_node_id
	 * 03: waiting_transaction_num
	 * 04: waiting_transaction_stamp
	 * 05: blocking_global_pid
	 * 06: blocking_pid
	 * 07: blocking__node_id
	 * 08: blocking_transaction_num
	 * 09: blocking_transaction_stamp
	 * 10: blocking_transaction_waiting
	 */</comment>
	<for>for <control>(<init><decl><type><name>size_t</name></type> <name>curEdgeNum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>curEdgeNum</name> <operator>&lt;</operator> <name><name>waitGraph</name><operator>-&gt;</operator><name>edgeCount</name></name></expr>;</condition> <incr><expr><name>curEdgeNum</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type> <name><name>values</name><index>[<expr><literal type="number">11</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name><name>nulls</name><index>[<expr><literal type="number">11</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>WaitEdge</name> <modifier>*</modifier></type><name>curEdge</name> <init>= <expr><operator>&amp;</operator><name><name>waitGraph</name><operator>-&gt;</operator><name>edges</name><index>[<expr><name>curEdgeNum</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>UInt64GetDatum</name><argument_list>(<argument><expr><name><name>curEdge</name><operator>-&gt;</operator><name>waitingGPid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>curEdge</name><operator>-&gt;</operator><name>waitingPid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>curEdge</name><operator>-&gt;</operator><name>waitingNodeId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>curEdge</name><operator>-&gt;</operator><name>waitingTransactionNum</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>curEdge</name><operator>-&gt;</operator><name>waitingTransactionNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <call><name>TimestampTzGetDatum</name><argument_list>(<argument><expr><name><name>curEdge</name><operator>-&gt;</operator><name>waitingTransactionStamp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <call><name>UInt64GetDatum</name><argument_list>(<argument><expr><name><name>curEdge</name><operator>-&gt;</operator><name>blockingGPid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>curEdge</name><operator>-&gt;</operator><name>blockingPid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>curEdge</name><operator>-&gt;</operator><name>blockingNodeId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>curEdge</name><operator>-&gt;</operator><name>blockingTransactionNum</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>curEdge</name><operator>-&gt;</operator><name>blockingTransactionNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>=</operator> <call><name>TimestampTzGetDatum</name><argument_list>(<argument><expr><name><name>curEdge</name><operator>-&gt;</operator><name>blockingTransactionStamp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>curEdge</name><operator>-&gt;</operator><name>isBlockingXactWaiting</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>tuplestore_putvalues</name><argument_list>(<argument><expr><name>tupleStore</name></expr></argument>, <argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>


<comment type="block">/*
 * BuildLocalWaitGraph builds a wait graph for distributed transactions
 * that originate from the local node.
 *
 * If onlyDistributedTx is true, we only return distributed transactions
 * (e.g., AssignDistributedTransaction() or assign_distributed_transactions())
 * has been called for the process. Distributed deadlock detection only
 * interested in these processes.
 */</comment>
<function><type><specifier>static</specifier> <name>WaitGraph</name> <modifier>*</modifier></type>
<name>BuildLocalWaitGraph</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>onlyDistributedTx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PROCStack</name></type> <name>remaining</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>totalProcs</name> <init>= <expr><call><name>TotalProcCount</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Try hard to avoid allocations while holding lock. Thus we pre-allocate
	 * space for locks in large batches - for common scenarios this should be
	 * more than enough space to build the list of wait edges without a single
	 * allocation.
	 */</comment>
	<decl_stmt><decl><type><name>WaitGraph</name> <modifier>*</modifier></type><name>waitGraph</name> <init>= <expr><operator>(</operator><name>WaitGraph</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WaitGraph</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>waitGraph</name><operator>-&gt;</operator><name>localNodeId</name></name> <operator>=</operator> <call><name>GetLocalGroupId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>waitGraph</name><operator>-&gt;</operator><name>allocatedSize</name></name> <operator>=</operator> <name>totalProcs</name> <operator>*</operator> <literal type="number">3</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>waitGraph</name><operator>-&gt;</operator><name>edgeCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>waitGraph</name><operator>-&gt;</operator><name>edges</name></name> <operator>=</operator> <operator>(</operator><name>WaitEdge</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>waitGraph</name><operator>-&gt;</operator><name>allocatedSize</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>WaitEdge</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>remaining</name><operator>.</operator><name>procs</name></name> <operator>=</operator> <operator>(</operator><name>PGPROC</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PGPROC</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>totalProcs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>remaining</name><operator>.</operator><name>procAdded</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>totalProcs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>remaining</name><operator>.</operator><name>procCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LockLockData</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Build lock-graph.  We do so by first finding all procs which we are
	 * interested in (in a distributed transaction, and blocked).  Once
	 * those are collected, do depth first search over all procs blocking
	 * those.
	 */</comment>

	<comment type="block">/* build list of starting procs */</comment>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>curBackend</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>curBackend</name> <operator>&lt;</operator> <name>totalProcs</name></expr>;</condition> <incr><expr><name>curBackend</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>currentProc</name> <init>= <expr><operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>allProcs</name><index>[<expr><name>curBackend</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BackendData</name></type> <name>currentBackendData</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>currentProc</name><operator>-&gt;</operator><name>pid</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* skip if the PGPROC slot is unused */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>GetBackendDataForProc</name><argument_list>(<argument><expr><name>currentProc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>currentBackendData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>currentBackendData</name><operator>.</operator><name>activeBackend</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Skip if the PGPROC slot is unused. We should normally use
			 * IsBackendPid() to be able to skip reliably all the exited
			 * processes. However, that is a costly operation. Instead, we
			 * keep track of activeBackend in Citus code.
			 */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Only start searching from distributed transactions, since we only
		 * care about distributed transactions for the purpose of distributed
		 * deadlock detection.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>onlyDistributedTx</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>IsInDistributedTransaction</name><argument_list>(<argument><expr><operator>&amp;</operator><name>currentBackendData</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* skip if the process is not blocked */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsProcessWaitingForLock</name><argument_list>(<argument><expr><name>currentProc</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* skip if the process is blocked for relation extension */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsProcessWaitingForSafeOperations</name><argument_list>(<argument><expr><name>currentProc</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>AddProcToVisit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>remaining</name></expr></argument>, <argument><expr><name>currentProc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<while>while <condition>(<expr><name><name>remaining</name><operator>.</operator><name>procCount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>waitingProc</name> <init>= <expr><name><name>remaining</name><operator>.</operator><name>procs</name><index>[<expr><operator>--</operator><name><name>remaining</name><operator>.</operator><name>procCount</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* only blocked processes result in wait edges */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsProcessWaitingForLock</name><argument_list>(<argument><expr><name>waitingProc</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* skip if the process is blocked for relation extension */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsProcessWaitingForSafeOperations</name><argument_list>(<argument><expr><name>waitingProc</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Record an edge for everyone already holding the lock in a
		 * conflicting manner ("hard edges" in postgres parlance).
		 */</comment>
		<expr_stmt><expr><call><name>AddEdgesForLockWaits</name><argument_list>(<argument><expr><name>waitGraph</name></expr></argument>, <argument><expr><name>waitingProc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>remaining</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Record an edge for everyone in front of us in the wait-queue
		 * for the lock ("soft edges" in postgres parlance).
		 */</comment>
		<expr_stmt><expr><call><name>AddEdgesForWaitQueue</name><argument_list>(<argument><expr><name>waitGraph</name></expr></argument>, <argument><expr><name>waitingProc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>remaining</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>UnlockLockData</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>waitGraph</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsProcessWaitingForSafeOperations returns true if the given PROC
 * waiting on relation extension locks, page locks or speculative locks.
 *
 * The function also returns true if the waiting process is an autovacuum
 * process given that autovacuum cannot contribute to any distributed
 * deadlocks.
 *
 * In general for the purpose of distributed deadlock detection, we should
 * skip if the process blocked on the locks that may not be part of deadlocks.
 * Those locks are held for a short duration while the relation or the index
 * is actually extended on the disk and released as soon as the extension is
 * done, even before the execution of the command that triggered the extension
 * finishes. Thus, recording such waits on our lock graphs could yield detecting
 * wrong distributed deadlocks.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsProcessWaitingForSafeOperations</name><parameter_list>(<parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>waitStatus</name></name> <operator>!=</operator> <name>PROC_WAIT_STATUS_WAITING</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>pgproc_statusflags_compat</name><argument_list>(<argument><expr><name>proc</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>PROC_IS_AUTOVACUUM</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>PROCLOCK</name> <modifier>*</modifier></type><name>waitProcLock</name> <init>= <expr><name><name>proc</name><operator>-&gt;</operator><name>waitProcLock</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCK</name> <modifier>*</modifier></type><name>waitLock</name> <init>= <expr><name><name>waitProcLock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>myLock</name></name></expr></init></decl>;</decl_stmt>

	<return>return <expr><name><name>waitLock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>locktag_type</name></name> <operator>==</operator> <name>LOCKTAG_RELATION_EXTEND</name> <operator>||</operator>
		   <name><name>waitLock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>locktag_type</name></name> <operator>==</operator> <name>LOCKTAG_PAGE</name> <operator>||</operator>
		   <name><name>waitLock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>locktag_type</name></name> <operator>==</operator> <name>LOCKTAG_SPECULATIVE_TOKEN</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * LockLockData takes locks the shared lock data structure, which prevents
 * concurrent lock acquisitions/releases.
 *
 * The function also acquires lock on the backend shared memory to prevent
 * new backends to start.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>LockLockData</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LockBackendSharedMemory</name><argument_list>(<argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>partitionNum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>partitionNum</name> <operator>&lt;</operator> <name>NUM_LOCK_PARTITIONS</name></expr>;</condition> <incr><expr><name>partitionNum</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><call><name>LockHashPartitionLockByIndex</name><argument_list>(<argument><expr><name>partitionNum</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>


<comment type="block">/*
 * UnlockLockData unlocks the locks on the shared lock data structure in reverse
 * order since LWLockRelease searches the given lock from the end of the
 * held_lwlocks array.
 *
 * The function also releases the shared memory lock to allow new backends to
 * start.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>UnlockLockData</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>partitionNum</name> <init>= <expr><name>NUM_LOCK_PARTITIONS</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>partitionNum</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>partitionNum</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>LockHashPartitionLockByIndex</name><argument_list>(<argument><expr><name>partitionNum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>UnlockBackendSharedMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * AddEdgesForLockWaits adds an edge to the wait graph for every granted lock
 * that waitingProc is waiting for.
 *
 * This function iterates over the procLocks data structure in shared memory,
 * which also contains entries for locks which have not been granted yet, but
 * it does not reflect the order of the wait queue. We therefore handle the
 * wait queue separately.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AddEdgesForLockWaits</name><parameter_list>(<parameter><decl><type><name>WaitGraph</name> <modifier>*</modifier></type><name>waitGraph</name></decl></parameter>, <parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>waitingProc</name></decl></parameter>, <parameter><decl><type><name>PROCStack</name> <modifier>*</modifier></type><name>remaining</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* the lock for which this process is waiting */</comment>
	<decl_stmt><decl><type><name>LOCK</name> <modifier>*</modifier></type><name>waitLock</name> <init>= <expr><name><name>waitingProc</name><operator>-&gt;</operator><name>waitLock</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* determine the conflict mask for the lock level used by the process */</comment>
	<decl_stmt><decl><type><name>LockMethod</name></type> <name>lockMethodTable</name> <init>= <expr><call><name>GetLocksMethodTable</name><argument_list>(<argument><expr><name>waitLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>conflictMask</name> <init>= <expr><name><name>lockMethodTable</name><operator>-&gt;</operator><name>conflictTab</name><index>[<expr><name><name>waitingProc</name><operator>-&gt;</operator><name>waitLockMode</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* iterate through the queue of processes holding the lock */</comment>
	<decl_stmt><decl><type><name>SHM_QUEUE</name> <modifier>*</modifier></type><name>procLocks</name> <init>= <expr><operator>&amp;</operator><name><name>waitLock</name><operator>-&gt;</operator><name>procLocks</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PROCLOCK</name> <modifier>*</modifier></type><name>procLock</name> <init>= <expr><operator>(</operator><name>PROCLOCK</name> <operator>*</operator><operator>)</operator> <call><name>SHMQueueNext</name><argument_list>(<argument><expr><name>procLocks</name></expr></argument>, <argument><expr><name>procLocks</name></expr></argument>,
												   <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PROCLOCK</name></expr></argument>, <argument><expr><name>lockLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>procLock</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>currentProc</name> <init>= <expr><name><name>procLock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>myProc</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Skip processes from the same lock group, processes that don't conflict,
		 * and processes that are waiting on safe operations.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsSameLockGroup</name><argument_list>(<argument><expr><name>waitingProc</name></expr></argument>, <argument><expr><name>currentProc</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>IsConflictingLockMask</name><argument_list>(<argument><expr><name><name>procLock</name><operator>-&gt;</operator><name>holdMask</name></name></expr></argument>, <argument><expr><name>conflictMask</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>IsProcessWaitingForSafeOperations</name><argument_list>(<argument><expr><name>currentProc</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>AddWaitEdge</name><argument_list>(<argument><expr><name>waitGraph</name></expr></argument>, <argument><expr><name>waitingProc</name></expr></argument>, <argument><expr><name>currentProc</name></expr></argument>, <argument><expr><name>remaining</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>procLock</name> <operator>=</operator> <operator>(</operator><name>PROCLOCK</name> <operator>*</operator><operator>)</operator> <call><name>SHMQueueNext</name><argument_list>(<argument><expr><name>procLocks</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>procLock</name><operator>-&gt;</operator><name>lockLink</name></name></expr></argument>,
											 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PROCLOCK</name></expr></argument>, <argument><expr><name>lockLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>


<comment type="block">/*
 * AddEdgesForWaitQueue adds an edge to the wait graph for processes in front of
 * waitingProc in the wait queue that are trying to acquire a conflicting lock.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AddEdgesForWaitQueue</name><parameter_list>(<parameter><decl><type><name>WaitGraph</name> <modifier>*</modifier></type><name>waitGraph</name></decl></parameter>, <parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>waitingProc</name></decl></parameter>, <parameter><decl><type><name>PROCStack</name> <modifier>*</modifier></type><name>remaining</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* the lock for which this process is waiting */</comment>
	<decl_stmt><decl><type><name>LOCK</name> <modifier>*</modifier></type><name>waitLock</name> <init>= <expr><name><name>waitingProc</name><operator>-&gt;</operator><name>waitLock</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* determine the conflict mask for the lock level used by the process */</comment>
	<decl_stmt><decl><type><name>LockMethod</name></type> <name>lockMethodTable</name> <init>= <expr><call><name>GetLocksMethodTable</name><argument_list>(<argument><expr><name>waitLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>conflictMask</name> <init>= <expr><name><name>lockMethodTable</name><operator>-&gt;</operator><name>conflictTab</name><index>[<expr><name><name>waitingProc</name><operator>-&gt;</operator><name>waitLockMode</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* iterate through the wait queue */</comment>
	<decl_stmt><decl><type><name>PROC_QUEUE</name> <modifier>*</modifier></type><name>waitQueue</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>waitLock</name><operator>-&gt;</operator><name>waitProcs</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>queueSize</name> <init>= <expr><name><name>waitQueue</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>currentProc</name> <init>= <expr><operator>(</operator><name>PGPROC</name> <operator>*</operator><operator>)</operator> <name><name>waitQueue</name><operator>-&gt;</operator><name>links</name><operator>.</operator><name>next</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Iterate through the queue from the start until we encounter waitingProc,
	 * since we only care about processes in front of waitingProc in the queue.
	 */</comment>
	<while>while <condition>(<expr><name>queueSize</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>currentProc</name> <operator>!=</operator> <name>waitingProc</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>awaitMask</name> <init>= <expr><call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name><name>currentProc</name><operator>-&gt;</operator><name>waitLockMode</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Skip processes from the same lock group, processes that don't conflict,
		 * and processes that are waiting on safe operations.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsSameLockGroup</name><argument_list>(<argument><expr><name>waitingProc</name></expr></argument>, <argument><expr><name>currentProc</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>IsConflictingLockMask</name><argument_list>(<argument><expr><name>awaitMask</name></expr></argument>, <argument><expr><name>conflictMask</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>IsProcessWaitingForSafeOperations</name><argument_list>(<argument><expr><name>currentProc</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>AddWaitEdge</name><argument_list>(<argument><expr><name>waitGraph</name></expr></argument>, <argument><expr><name>waitingProc</name></expr></argument>, <argument><expr><name>currentProc</name></expr></argument>, <argument><expr><name>remaining</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>currentProc</name> <operator>=</operator> <operator>(</operator><name>PGPROC</name> <operator>*</operator><operator>)</operator> <name><name>currentProc</name><operator>-&gt;</operator><name>links</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>


<comment type="block">/*
 * AddWaitEdge adds a new wait edge to a wait graph. The nodes in the graph are
 * transactions and an edge indicates the "waiting" process is blocked on a lock
 * held by the "blocking" process.
 *
 * If the blocking process is itself waiting then it is added to the remaining
 * stack.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AddWaitEdge</name><parameter_list>(<parameter><decl><type><name>WaitGraph</name> <modifier>*</modifier></type><name>waitGraph</name></decl></parameter>, <parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>waitingProc</name></decl></parameter>, <parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>blockingProc</name></decl></parameter>,
			<parameter><decl><type><name>PROCStack</name> <modifier>*</modifier></type><name>remaining</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WaitEdge</name> <modifier>*</modifier></type><name>curEdge</name> <init>= <expr><call><name>AllocWaitEdge</name><argument_list>(<argument><expr><name>waitGraph</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BackendData</name></type> <name>waitingBackendData</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BackendData</name></type> <name>blockingBackendData</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>GetBackendDataForProc</name><argument_list>(<argument><expr><name>waitingProc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>waitingBackendData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GetBackendDataForProc</name><argument_list>(<argument><expr><name>blockingProc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blockingBackendData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>curEdge</name><operator>-&gt;</operator><name>isBlockingXactWaiting</name></name> <operator>=</operator>
		<call><name>IsProcessWaitingForLock</name><argument_list>(<argument><expr><name>blockingProc</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>IsProcessWaitingForSafeOperations</name><argument_list>(<argument><expr><name>blockingProc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>curEdge</name><operator>-&gt;</operator><name>isBlockingXactWaiting</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>AddProcToVisit</name><argument_list>(<argument><expr><name>remaining</name></expr></argument>, <argument><expr><name>blockingProc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>curEdge</name><operator>-&gt;</operator><name>waitingPid</name></name> <operator>=</operator> <name><name>waitingProc</name><operator>-&gt;</operator><name>pid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>curEdge</name><operator>-&gt;</operator><name>waitingGPid</name></name> <operator>=</operator> <name><name>waitingBackendData</name><operator>.</operator><name>globalPID</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsInDistributedTransaction</name><argument_list>(<argument><expr><operator>&amp;</operator><name>waitingBackendData</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DistributedTransactionId</name> <modifier>*</modifier></type><name>waitingTransactionId</name> <init>=
			<expr><operator>&amp;</operator><name><name>waitingBackendData</name><operator>.</operator><name>transactionId</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>curEdge</name><operator>-&gt;</operator><name>waitingNodeId</name></name> <operator>=</operator> <name><name>waitingTransactionId</name><operator>-&gt;</operator><name>initiatorNodeIdentifier</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>curEdge</name><operator>-&gt;</operator><name>waitingTransactionNum</name></name> <operator>=</operator> <name><name>waitingTransactionId</name><operator>-&gt;</operator><name>transactionNumber</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>curEdge</name><operator>-&gt;</operator><name>waitingTransactionStamp</name></name> <operator>=</operator> <name><name>waitingTransactionId</name><operator>-&gt;</operator><name>timestamp</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>curEdge</name><operator>-&gt;</operator><name>waitingNodeId</name></name> <operator>=</operator> <name><name>waitGraph</name><operator>-&gt;</operator><name>localNodeId</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>curEdge</name><operator>-&gt;</operator><name>waitingTransactionNum</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>curEdge</name><operator>-&gt;</operator><name>waitingTransactionStamp</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>curEdge</name><operator>-&gt;</operator><name>blockingPid</name></name> <operator>=</operator> <name><name>blockingProc</name><operator>-&gt;</operator><name>pid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>curEdge</name><operator>-&gt;</operator><name>blockingGPid</name></name> <operator>=</operator> <name><name>blockingBackendData</name><operator>.</operator><name>globalPID</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsInDistributedTransaction</name><argument_list>(<argument><expr><operator>&amp;</operator><name>blockingBackendData</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DistributedTransactionId</name> <modifier>*</modifier></type><name>blockingTransactionId</name> <init>=
			<expr><operator>&amp;</operator><name><name>blockingBackendData</name><operator>.</operator><name>transactionId</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>curEdge</name><operator>-&gt;</operator><name>blockingNodeId</name></name> <operator>=</operator> <name><name>blockingTransactionId</name><operator>-&gt;</operator><name>initiatorNodeIdentifier</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>curEdge</name><operator>-&gt;</operator><name>blockingTransactionNum</name></name> <operator>=</operator> <name><name>blockingTransactionId</name><operator>-&gt;</operator><name>transactionNumber</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>curEdge</name><operator>-&gt;</operator><name>blockingTransactionStamp</name></name> <operator>=</operator> <name><name>blockingTransactionId</name><operator>-&gt;</operator><name>timestamp</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>curEdge</name><operator>-&gt;</operator><name>blockingNodeId</name></name> <operator>=</operator> <name><name>waitGraph</name><operator>-&gt;</operator><name>localNodeId</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>curEdge</name><operator>-&gt;</operator><name>blockingTransactionNum</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>curEdge</name><operator>-&gt;</operator><name>blockingTransactionStamp</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * AllocWaitEdge allocates a wait edge as part of the given wait graph.
 * If the wait graph has insufficient space its size is doubled using
 * repalloc.
 */</comment>
<function><type><specifier>static</specifier> <name>WaitEdge</name> <modifier>*</modifier></type>
<name>AllocWaitEdge</name><parameter_list>(<parameter><decl><type><name>WaitGraph</name> <modifier>*</modifier></type><name>waitGraph</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* ensure space for new edge */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>waitGraph</name><operator>-&gt;</operator><name>allocatedSize</name></name> <operator>==</operator> <name><name>waitGraph</name><operator>-&gt;</operator><name>edgeCount</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>waitGraph</name><operator>-&gt;</operator><name>allocatedSize</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>waitGraph</name><operator>-&gt;</operator><name>edges</name></name> <operator>=</operator> <operator>(</operator><name>WaitEdge</name> <operator>*</operator><operator>)</operator>
						   <call><name>repalloc</name><argument_list>(<argument><expr><name><name>waitGraph</name><operator>-&gt;</operator><name>edges</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WaitEdge</name></expr></argument>)</argument_list></sizeof> <operator>*</operator>
									<name><name>waitGraph</name><operator>-&gt;</operator><name>allocatedSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><operator>&amp;</operator><name><name>waitGraph</name><operator>-&gt;</operator><name>edges</name><index>[<expr><name><name>waitGraph</name><operator>-&gt;</operator><name>edgeCount</name></name><operator>++</operator></expr>]</index></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AddProcToVisit adds a process to the stack of processes to visit
 * in the depth-first search, unless it was already added.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AddProcToVisit</name><parameter_list>(<parameter><decl><type><name>PROCStack</name> <modifier>*</modifier></type><name>remaining</name></decl></parameter>, <parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>remaining</name><operator>-&gt;</operator><name>procAdded</name><index>[<expr><name><name>proc</name><operator>-&gt;</operator><name>pgprocno</name></name></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>remaining</name><operator>-&gt;</operator><name>procCount</name></name> <operator>&lt;</operator> <call><name>TotalProcCount</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>remaining</name><operator>-&gt;</operator><name>procs</name><index>[<expr><name><name>remaining</name><operator>-&gt;</operator><name>procCount</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>proc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>remaining</name><operator>-&gt;</operator><name>procAdded</name><index>[<expr><name><name>proc</name><operator>-&gt;</operator><name>pgprocno</name></name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * IsProcessWaitingForLock returns whether a given process is waiting for a lock.
 */</comment>
<function><type><name>bool</name></type>
<name>IsProcessWaitingForLock</name><parameter_list>(<parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>proc</name><operator>-&gt;</operator><name>waitStatus</name></name> <operator>==</operator> <name>PROC_WAIT_STATUS_WAITING</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsSameLockGroup returns whether two processes are part of the same lock group,
 * meaning they are either the same process, or have the same lock group leader.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsSameLockGroup</name><parameter_list>(<parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>leftProc</name></decl></parameter>, <parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>rightProc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>leftProc</name> <operator>==</operator> <name>rightProc</name> <operator>||</operator>
		   <operator>(</operator><name><name>leftProc</name><operator>-&gt;</operator><name>lockGroupLeader</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<name><name>leftProc</name><operator>-&gt;</operator><name>lockGroupLeader</name></name> <operator>==</operator> <name><name>rightProc</name><operator>-&gt;</operator><name>lockGroupLeader</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsConflictingLockMask returns whether the given conflict mask conflicts with the
 * holdMask.
 *
 * holdMask is a bitmask with the i-th bit turned on if a lock mode i is held.
 *
 * conflictMask is a bitmask with the j-th bit turned on if it conflicts with
 * lock mode i.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsConflictingLockMask</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>holdMask</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>conflictMask</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name>holdMask</name> <operator>&amp;</operator> <name>conflictMask</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsInDistributedTransaction returns whether the given backend is in a
 * distributed transaction.
 */</comment>
<function><type><name>bool</name></type>
<name>IsInDistributedTransaction</name><parameter_list>(<parameter><decl><type><name>BackendData</name> <modifier>*</modifier></type><name>backendData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>backendData</name><operator>-&gt;</operator><name>transactionId</name><operator>.</operator><name>transactionNumber</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
</unit>
