<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/citus/src/backend/distributed/transaction/backend_data.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * backend_data.c
 *
 *  Infrastructure for managing per backend data that can efficiently
 *  accessed by all sessions.
 *
 * Copyright (c) Citus Data, Inc.
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_version_constants.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"unistd.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"safe_lib.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_authid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"datatype/timestamp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/backend_data.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/connection_management.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/lock_graph.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/remote_commands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shared_connection_stats.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/transaction_identifier.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/tuplestore.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_manager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/execnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/autovacuum.h"</cpp:file></cpp:include> <comment type="block">/* to access autovacuum_max_workers */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/walsender.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lwlock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procarray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/spin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/s_lock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timestamp.h"</cpp:file></cpp:include>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_ACTIVE_TRANSACTION_QUERY</name></cpp:macro> <cpp:value>"SELECT * FROM get_all_active_transactions();"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ACTIVE_TRANSACTION_COLUMN_COUNT</name></cpp:macro> <cpp:value>7</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GLOBAL_PID_NODE_ID_MULTIPLIER</name></cpp:macro> <cpp:value>10000000000</cpp:value></cpp:define>

<comment type="block">/*
 * Each backend's data reside in the shared memory
 * on the BackendManagementShmemData.
 */</comment>
<typedef>typedef <type><struct>struct <name>BackendManagementShmemData</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>trancheId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NamedLWLockTranche</name></type> <name>namedLockTranche</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LWLock</name></type> <name>lock</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We prefer to use an atomic integer over sequences for two
	 * reasons (i) orders of magnitude performance difference
	 * (ii) allowing read-only replicas to be able to generate ids
	 */</comment>
	<decl_stmt><decl><type><name>pg_atomic_uint64</name></type> <name>nextTransactionNumber</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Total number of external client backends that are authenticated.
	 *
	 * Note that the counter does not consider any background workers
	 * or such, and also exludes internal connections between nodes.
	 */</comment>
	<decl_stmt><decl><type><name>pg_atomic_uint32</name></type> <name>externalClientBackendCounter</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>BackendData</name></type> <name><name>backends</name><index>[<expr><name>FLEXIBLE_ARRAY_MEMBER</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>BackendManagementShmemData</name>;</typedef>

<comment type="block">/*
 * CitusBackendType reflects what type of backend we are in. This
 * can change depending on the application_name.
 */</comment>
<typedef>typedef <type><enum>enum <name>CitusBackendType</name>
<block>{
	<decl><name>CITUS_BACKEND_NOT_ASSIGNED</name></decl>,
	<decl><name>CITUS_INTERNAL_BACKEND</name></decl>,
	<decl><name>CITUS_REBALANCER_BACKEND</name></decl>,
	<decl><name>CITUS_RUN_COMMAND_BACKEND</name></decl>,
	<decl><name>EXTERNAL_CLIENT_BACKEND</name></decl>
}</block></enum></type> <name>CitusBackendType</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>CitusBackendPrefixes</name><index>[]</index></name> <init>= <expr><block>{
	<expr><name>CITUS_APPLICATION_NAME_PREFIX</name></expr>,
	<expr><name>CITUS_REBALANCER_APPLICATION_NAME_PREFIX</name></expr>,
	<expr><name>CITUS_RUN_COMMAND_APPLICATION_NAME_PREFIX</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>CitusBackendType</name></type> <name><name>CitusBackendTypes</name><index>[]</index></name> <init>= <expr><block>{
	<expr><name>CITUS_INTERNAL_BACKEND</name></expr>,
	<expr><name>CITUS_REBALANCER_BACKEND</name></expr>,
	<expr><name>CITUS_RUN_COMMAND_BACKEND</name></expr>,
}</block></expr></init></decl>;</decl_stmt>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>StoreAllActiveTransactions</name><parameter_list>(<parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tupleStore</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type>
									   <name>tupleDescriptor</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>UserHasPermissionToViewStatsOf</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>currentUserId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>backendOwnedId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint64</name></type> <name>CalculateGlobalPID</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>nodeId</name></decl></parameter>, <parameter><decl><type><name>pid_t</name></type> <name>pid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint64</name></type> <name>GenerateGlobalPID</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <name>shmem_startup_hook_type</name></type> <name>prev_shmem_startup_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>BackendManagementShmemData</name> <modifier>*</modifier></type><name>backendManagementShmemData</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>BackendData</name> <modifier>*</modifier></type><name>MyBackendData</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>CitusBackendType</name></type> <name>CurrentBackendType</name> <init>= <expr><name>CITUS_BACKEND_NOT_ASSIGNED</name></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>assign_distributed_transaction_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>get_current_transaction_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>get_global_active_transactions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>get_all_active_transactions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>citus_calculate_gpid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>citus_backend_gpid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>citus_nodeid_for_gpid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>citus_pid_for_gpid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<comment type="block">/*
 * assign_distributed_transaction_id updates the shared memory allocated for this backend
 * and sets initiatorNodeIdentifier, transactionNumber, timestamp fields with the given
 * inputs. Also, the function sets the database id and process id via the information that
 * Postgres provides.
 *
 * This function is only intended for internal use for managing distributed transactions.
 * Users should not use this function for any purpose.
 */</comment>
<function><type><name>Datum</name></type>
<name>assign_distributed_transaction_id</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* prepare data before acquiring spinlock to protect against errors */</comment>
	<decl_stmt><decl><type><name>int32</name></type> <name>initiatorNodeIdentifier</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>transactionNumber</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>timestamp</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMPTZ</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* MyBackendData should always be avaliable, just out of paranoia */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>MyBackendData</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"backend is not ready for distributed transactions"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Note that we don't need to lock shared memory (i.e., LockBackendSharedMemory()) here
	 * since this function is executed after AssignDistributedTransactionId() issued on the
	 * initiator node, which already takes the required lock to enforce the consistency.
	 */</comment>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyBackendData</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* if an id is already assigned, release the lock and error */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>MyBackendData</name><operator>-&gt;</operator><name>transactionId</name><operator>.</operator><name>transactionNumber</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyBackendData</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"the backend has already been assigned a "</literal>
							   <literal type="string">"transaction id"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>MyBackendData</name><operator>-&gt;</operator><name>transactionId</name><operator>.</operator><name>initiatorNodeIdentifier</name></name> <operator>=</operator> <name>initiatorNodeIdentifier</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyBackendData</name><operator>-&gt;</operator><name>transactionId</name><operator>.</operator><name>transactionNumber</name></name> <operator>=</operator> <name>transactionNumber</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyBackendData</name><operator>-&gt;</operator><name>transactionId</name><operator>.</operator><name>timestamp</name></name> <operator>=</operator> <name>timestamp</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyBackendData</name><operator>-&gt;</operator><name>transactionId</name><operator>.</operator><name>transactionOriginator</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyBackendData</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * get_current_transaction_id returns a tuple with (databaseId, processId,
 * initiatorNodeIdentifier, transactionNumber, timestamp) that exists in the
 * shared memory associated with this backend. Note that if the backend
 * is not in a transaction, the function returns uninitialized data where
 * transactionNumber equals to 0.
 */</comment>
<function><type><name>Datum</name></type>
<name>get_current_transaction_id</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Datum</name></type> <name><name>values</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name><name>isNulls</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>


	<comment type="block">/* build a tuple descriptor for our result type */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>get_call_result_type</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupleDescriptor</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TYPEFUNC_COMPOSITE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"return type must be a row type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* MyBackendData should always be avaliable, just out of paranoia */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>MyBackendData</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"backend is not ready for distributed transactions"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>DistributedTransactionId</name> <modifier>*</modifier></type><name>distributedTransctionId</name> <init>=
		<expr><call><name>GetCurrentDistributedTransactionId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>isNulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>isNulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* first two fields do not change for this backend, so get directly */</comment>
	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>MyProcPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>distributedTransctionId</name><operator>-&gt;</operator><name>initiatorNodeIdentifier</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>UInt64GetDatum</name><argument_list>(<argument><expr><name><name>distributedTransctionId</name><operator>-&gt;</operator><name>transactionNumber</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* provide a better output */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>distributedTransctionId</name><operator>-&gt;</operator><name>transactionNumber</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <call><name>TimestampTzGetDatum</name><argument_list>(<argument><expr><name><name>distributedTransctionId</name><operator>-&gt;</operator><name>timestamp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>isNulls</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>heapTuple</name> <init>= <expr><call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isNulls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * get_global_active_transactions returns all the available information about all
 * the active backends from each node of the cluster. If you call that function from
 * the coordinator, it will returns back active transaction from the coordinator as
 * well. Yet, if you call it from the worker, result won't include the transactions
 * on the coordinator node, since worker nodes are not aware of the coordinator.
 */</comment>
<function><type><name>Datum</name></type>
<name>get_global_active_transactions</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>workerNodeList</name> <init>= <expr><call><name>ActivePrimaryNonCoordinatorNodeList</name><argument_list>(<argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>connectionList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>queryToSend</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tupleStore</name> <init>= <expr><call><name>SetupTuplestore</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupleDescriptor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>queryToSend</name></expr></argument>, <argument><expr><name>GET_ACTIVE_TRANSACTION_QUERY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* add active transactions for local node */</comment>
	<expr_stmt><expr><call><name>StoreAllActiveTransactions</name><argument_list>(<argument><expr><name>tupleStore</name></expr></argument>, <argument><expr><name>tupleDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int32</name></type> <name>localGroupId</name> <init>= <expr><call><name>GetLocalGroupId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* open connections in parallel */</comment>
	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>workerNode</argument>, <argument>workerNodeList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nodeName</name> <init>= <expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>nodePort</name> <init>= <expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>connectionFlags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>workerNode</name><operator>-&gt;</operator><name>groupId</name></name> <operator>==</operator> <name>localGroupId</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* we already get these transactions via GetAllActiveTransactions() */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><call><name>StartNodeConnection</name><argument_list>(<argument><expr><name>connectionFlags</name></expr></argument>, <argument><expr><name>nodeName</name></expr></argument>,
														  <argument><expr><name>nodePort</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>connectionList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>connectionList</name></expr></argument>, <argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>FinishConnectionListEstablishment</name><argument_list>(<argument><expr><name>connectionList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* send commands in parallel */</comment>
	<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>connection</argument>, <argument>connectionList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>querySent</name> <init>= <expr><call><name>SendRemoteCommand</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name><name>queryToSend</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>querySent</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ReportConnectionError</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>WARNING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* receive query results */</comment>
	<macro><name>foreach_ptr</name><argument_list>(<argument>connection</argument>, <argument>connectionList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>raiseInterrupts</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type> <name><name>values</name><index>[<expr><name>ACTIVE_TRANSACTION_COLUMN_COUNT</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name><name>isNulls</name><index>[<expr><name>ACTIVE_TRANSACTION_COLUMN_COUNT</name></expr>]</index></name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PQstatus</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CONNECTION_OK</name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>GetRemoteCommandResult</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>raiseInterrupts</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsResponseOK</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ReportResultError</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>WARNING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>int64</name></type> <name>rowCount</name> <init>= <expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int64</name></type> <name>colCount</name> <init>= <expr><call><name>PQnfields</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Although it is not expected */</comment>
		<if_stmt><if>if <condition>(<expr><name>colCount</name> <operator>!=</operator> <name>ACTIVE_TRANSACTION_COLUMN_COUNT</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected number of columns from "</literal>
									 <literal type="string">"get_all_active_transactions"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<for>for <control>(<init><decl><type><name>int64</name></type> <name>rowIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>rowIndex</name> <operator>&lt;</operator> <name>rowCount</name></expr>;</condition> <incr><expr><name>rowIndex</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>isNulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>isNulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>ParseIntField</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ParseIntField</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>ParseIntField</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>ParseBoolField</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <call><name>ParseIntField</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <call><name>ParseTimestampTzField</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <call><name>ParseIntField</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>tuplestore_putvalues</name><argument_list>(<argument><expr><name>tupleStore</name></expr></argument>, <argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isNulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ForgetResults</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * get_all_active_transactions returns all the avaliable information about all
 * the active backends.
 */</comment>
<function><type><name>Datum</name></type>
<name>get_all_active_transactions</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tupleStore</name> <init>= <expr><call><name>SetupTuplestore</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupleDescriptor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>StoreAllActiveTransactions</name><argument_list>(<argument><expr><name>tupleStore</name></expr></argument>, <argument><expr><name>tupleDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * StoreAllActiveTransactions gets active transaction from the local node and inserts
 * them into the given tuplestore.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>StoreAllActiveTransactions</name><parameter_list>(<parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tupleStore</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type> <name><name>values</name><index>[<expr><name>ACTIVE_TRANSACTION_COLUMN_COUNT</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name><name>isNulls</name><index>[<expr><name>ACTIVE_TRANSACTION_COLUMN_COUNT</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>showAllBackends</name> <init>= <expr><call><name>superuser</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Oid</name></type> <name>userId</name> <init>= <expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>showAllBackends</name> <operator>&amp;&amp;</operator> <call><name>is_member_of_role</name><argument_list>(<argument><expr><name>userId</name></expr></argument>, <argument><expr><name>ROLE_PG_MONITOR</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>showAllBackends</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* we're reading all distributed transactions, prevent new backends */</comment>
	<expr_stmt><expr><call><name>LockBackendSharedMemory</name><argument_list>(<argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>backendIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>backendIndex</name> <operator>&lt;</operator> <call><name>TotalProcCount</name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>backendIndex</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>showCurrentBackendDetails</name> <init>= <expr><name>showAllBackends</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BackendData</name> <modifier>*</modifier></type><name>currentBackend</name> <init>=
			<expr><operator>&amp;</operator><name><name>backendManagementShmemData</name><operator>-&gt;</operator><name>backends</name><index>[<expr><name>backendIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>currentProc</name> <init>= <expr><operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>allProcs</name><index>[<expr><name>backendIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* to work on data after releasing g spinlock to protect against errors */</comment>
		<decl_stmt><decl><type><name>uint64</name></type> <name>transactionNumber</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>currentBackend</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>currentProc</name><operator>-&gt;</operator><name>pid</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><name><name>currentBackend</name><operator>-&gt;</operator><name>activeBackend</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* unused PGPROC slot or the backend already exited */</comment>
			<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>currentBackend</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Unless the user has a role that allows seeing all transactions (superuser,
		 * pg_monitor), we only follow pg_stat_statements owner checks.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>showCurrentBackendDetails</name> <operator>&amp;&amp;</operator>
			<call><name>UserHasPermissionToViewStatsOf</name><argument_list>(<argument><expr><name>userId</name></expr></argument>, <argument><expr><name><name>currentProc</name><operator>-&gt;</operator><name>roleId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>showCurrentBackendDetails</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>Oid</name></type> <name>databaseId</name> <init>= <expr><name><name>currentBackend</name><operator>-&gt;</operator><name>databaseId</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>backendPid</name> <init>= <expr><name><name>ProcGlobal</name><operator>-&gt;</operator><name>allProcs</name><index>[<expr><name>backendIndex</name></expr>]</index></name><operator>.</operator><name>pid</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * We prefer to use worker_query instead of distributedCommandOriginator in
		 * the user facing functions since it's more intuitive. Thus,
		 * we negate the result before returning.
		 */</comment>
		<decl_stmt><decl><type><name>bool</name></type> <name>distributedCommandOriginator</name> <init>=
			<expr><name><name>currentBackend</name><operator>-&gt;</operator><name>distributedCommandOriginator</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>transactionNumber</name> <operator>=</operator> <name><name>currentBackend</name><operator>-&gt;</operator><name>transactionId</name><operator>.</operator><name>transactionNumber</name></name></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>TimestampTz</name></type> <name>transactionIdTimestamp</name> <init>= <expr><name><name>currentBackend</name><operator>-&gt;</operator><name>transactionId</name><operator>.</operator><name>timestamp</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>currentBackend</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>isNulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>isNulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We imitate pg_stat_activity such that if a user doesn't have enough
		 * privileges, we only show the minimal information including the pid,
		 * global pid and distributedCommandOriginator.
		 *
		 * pid is already can be found in pg_stat_activity for any process, and
		 * the rest doesn't reveal anything critial for under priviledge users
		 * but still could be useful for monitoring purposes of Citus.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>showCurrentBackendDetails</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type> <name>missingOk</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>initiatorNodeId</name> <init>=
				<expr><call><name>ExtractNodeIdFromGlobalPID</name><argument_list>(<argument><expr><name><name>currentBackend</name><operator>-&gt;</operator><name>globalPID</name></name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>databaseId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>backendPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>initiatorNodeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>!</operator><name>distributedCommandOriginator</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <call><name>UInt64GetDatum</name><argument_list>(<argument><expr><name>transactionNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <call><name>TimestampTzGetDatum</name><argument_list>(<argument><expr><name>transactionIdTimestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <call><name>UInt64GetDatum</name><argument_list>(<argument><expr><name><name>currentBackend</name><operator>-&gt;</operator><name>globalPID</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>isNulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>backendPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>isNulls</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>!</operator><name>distributedCommandOriginator</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>isNulls</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>isNulls</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <call><name>UInt64GetDatum</name><argument_list>(<argument><expr><name><name>currentBackend</name><operator>-&gt;</operator><name>globalPID</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>tuplestore_putvalues</name><argument_list>(<argument><expr><name>tupleStore</name></expr></argument>, <argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isNulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We don't want to initialize memory while spinlock is held so we
		 * prefer to do it here. This initialization is done for the rows
		 * starting from the second one.
		 */</comment>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>isNulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>isNulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>UnlockBackendSharedMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * UserHasPermissionToViewStatsOf returns true if currentUserId can
 * see backends of backendOwnedId.
 *
 * We follow the same approach with pg_stat_activity.
 */</comment>
<function><type><specifier>static</specifier>
<name>bool</name></type>
<name>UserHasPermissionToViewStatsOf</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>currentUserId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>backendOwnedId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>has_privs_of_role</name><argument_list>(<argument><expr><name>currentUserId</name></expr></argument>, <argument><expr><name>backendOwnedId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>is_member_of_role</name><argument_list>(<argument><expr><name>currentUserId</name></expr></argument>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <name>PG_VERSION_14</name></expr></cpp:if>
						  <argument><expr><name>ROLE_PG_READ_ALL_STATS</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
						  <expr_stmt><expr><name>DEFAULT_ROLE_READ_ALL_STATS</name></expr></expr_stmt></block_content></block></if></if_stmt>)</block_content></block></function>)
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
}


<comment type="block">/*
 * InitializeBackendManagement requests the necessary shared memory
 * from Postgres and sets up the shared memory startup hook.
 */</comment>
void
<macro><name>InitializeBackendManagement</name><argument_list>(<argument>void</argument>)</argument_list></macro>
<block>{<block_content>
<comment type="block">/* on PG 15, we use shmem_request_hook_type */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <name>PG_VERSION_15</name></expr></cpp:if>

	<comment type="block">/* allocate shared memory */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>RequestAddinShmemSpace</name><argument_list>(<argument><expr><call><name>BackendManagementShmemSize</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name>prev_shmem_startup_hook</name> <operator>=</operator> <name>shmem_startup_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>shmem_startup_hook</name> <operator>=</operator> <name>BackendManagementShmemInit</name></expr>;</expr_stmt>
</block_content>}</block>


<comment type="block">/*
 * BackendManagementShmemInit is the callback that is to be called on shared
 * memory startup hook. The function sets up the necessary shared memory
 * segment for the backend manager.
 */</comment>
<function><type><name>void</name></type>
<name>BackendManagementShmemInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>alreadyInitialized</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* we may update the shmem, acquire lock exclusively */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>AddinShmemInitLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>backendManagementShmemData</name> <operator>=</operator>
		<operator>(</operator><name>BackendManagementShmemData</name> <operator>*</operator><operator>)</operator> <call><name>ShmemInitStruct</name><argument_list>(
			<argument><expr><literal type="string">"Backend Management Shmem"</literal></expr></argument>,
			<argument><expr><call><name>BackendManagementShmemSize</name><argument_list>()</argument_list></call></expr></argument>,
			<argument><expr><operator>&amp;</operator><name>alreadyInitialized</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>alreadyInitialized</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>trancheName</name> <init>= <expr><literal type="string">"Backend Management Tranche"</literal></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>NamedLWLockTranche</name> <modifier>*</modifier></type><name>namedLockTranche</name> <init>=
			<expr><operator>&amp;</operator><name><name>backendManagementShmemData</name><operator>-&gt;</operator><name>namedLockTranche</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* start by zeroing out all the memory */</comment>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>backendManagementShmemData</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
			   <argument><expr><call><name>BackendManagementShmemSize</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>namedLockTranche</name><operator>-&gt;</operator><name>trancheId</name></name> <operator>=</operator> <call><name>LWLockNewTrancheId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LWLockRegisterTranche</name><argument_list>(<argument><expr><name><name>namedLockTranche</name><operator>-&gt;</operator><name>trancheId</name></name></expr></argument>, <argument><expr><name>trancheName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockInitialize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>backendManagementShmemData</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>,
						 <argument><expr><name><name>namedLockTranche</name><operator>-&gt;</operator><name>trancheId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* start the distributed transaction ids from 1 */</comment>
		<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>backendManagementShmemData</name><operator>-&gt;</operator><name>nextTransactionNumber</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* there are no active backends yet, so start with zero */</comment>
		<expr_stmt><expr><call><name>pg_atomic_init_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>backendManagementShmemData</name><operator>-&gt;</operator><name>externalClientBackendCounter</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We need to init per backend's spinlock before any backend
		 * starts its execution. Note that we initialize TotalProcs (e.g., not
		 * MaxBackends) since some of the blocking processes could be prepared
		 * transactions, which aren't covered by MaxBackends.
		 *
		 * We also initiate initiatorNodeIdentifier to -1, which can never be
		 * used as a node id.
		 */</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>totalProcs</name> <init>= <expr><call><name>TotalProcCount</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>backendIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>backendIndex</name> <operator>&lt;</operator> <name>totalProcs</name></expr>;</condition> <incr><expr><operator>++</operator><name>backendIndex</name></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BackendData</name> <modifier>*</modifier></type><name>backendData</name> <init>=
				<expr><operator>&amp;</operator><name><name>backendManagementShmemData</name><operator>-&gt;</operator><name>backends</name><index>[<expr><name>backendIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>SpinLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>backendData</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>AddinShmemInitLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>prev_shmem_startup_hook</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>prev_shmem_startup_hook</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * BackendManagementShmemSize returns the size that should be allocated
 * on the shared memory for backend management.
 */</comment>
<function><type><name>size_t</name></type>
<name>BackendManagementShmemSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type> <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>totalProcs</name> <init>= <expr><call><name>TotalProcCount</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BackendManagementShmemData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BackendData</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>totalProcs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * TotalProcCount returns the total processes that could run via the current
 * postgres server. See the details in the function comments.
 *
 * There is one thing we should warn the readers. Citus enforces to be loaded
 * as the first extension in shared_preload_libraries. However, if any other
 * extension overrides MaxConnections, autovacuum_max_workers or
 * max_worker_processes, our reasoning in this function may not work as expected.
 * Given that it is not a usual pattern for extension, we consider Citus' behaviour
 * good enough for now.
 */</comment>
<function><type><name>int</name></type>
<name>TotalProcCount</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>maxBackends</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>totalProcs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>

	<comment type="block">/* autovacuum_max_workers is not PGDLLIMPORT, so use a high estimate for windows */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>estimatedMaxAutovacuumWorkers</name> <init>= <expr><literal type="number">30</literal></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>maxBackends</name> <operator>=</operator>
		<name>MaxConnections</name> <operator>+</operator> <name>estimatedMaxAutovacuumWorkers</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>max_worker_processes</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

	<comment type="block">/*
	 * We're simply imitating Postgrsql's InitializeMaxBackends(). Given that all
	 * the items used here PGC_POSTMASTER, should be safe to access them
	 * anytime during the execution even before InitializeMaxBackends() is called.
	 */</comment>
	<expr_stmt><expr><name>maxBackends</name> <operator>=</operator> <name>MaxConnections</name> <operator>+</operator> <name>autovacuum_max_workers</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>max_worker_processes</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * We prefer to maintain space for auxiliary procs or preperad transactions in
	 * the backend space because they could be blocking processes and our current
	 * implementation of distributed deadlock detection could process them
	 * as a regular backend. In the future, we could consider changing deadlock
	 * detection algorithm to ignore auxiliary procs or prepared transactions and
	 * save some space.
	 */</comment>
	<expr_stmt><expr><name>totalProcs</name> <operator>=</operator> <name>maxBackends</name> <operator>+</operator> <name>NUM_AUXILIARY_PROCS</name> <operator>+</operator> <name>max_prepared_xacts</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>totalProcs</name> <operator>+=</operator> <name>max_wal_senders</name></expr>;</expr_stmt>

	<return>return <expr><name>totalProcs</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * InitializeBackendData initialises MyBackendData to the shared memory segment
 * belonging to the current backend.
 *
 * The function is called through CitusHasBeenLoaded when we first detect that
 * the Citus extension is present, and after any subsequent invalidation of
 * pg_dist_partition (see InvalidateMetadataSystemCache()).
 *
 * We only need to initialise MyBackendData once. The main goal here is to make
 * sure that we don't use the backend data from a previous backend with the same
 * pgprocno. Resetting the backend data after a distributed transaction happens
 * on COMMIT/ABORT through transaction callbacks.
 *
 * We do also initialize the distributedCommandOriginator and globalPID values
 * based on these values. This is to make sure that once the backend date is
 * initialized this backend can be correctly shown in citus_lock_waits.
 */</comment>
<function><type><name>void</name></type>
<name>InitializeBackendData</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>applicationName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>MyBackendData</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We already initialized MyBackendData before. We definitely should
		 * not initialise it again, because we might be in the middle of a
		 * distributed transaction.
		 */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>uint64</name></type> <name>gpid</name> <init>= <expr><call><name>ExtractGlobalPID</name><argument_list>(<argument><expr><name>applicationName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>MyBackendData</name> <operator>=</operator> <operator>&amp;</operator><name><name>backendManagementShmemData</name><operator>-&gt;</operator><name>backends</name><index>[<expr><name><name>MyProc</name><operator>-&gt;</operator><name>pgprocno</name></name></expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>MyBackendData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LockBackendSharedMemory</name><argument_list>(<argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* zero out the backend its transaction id */</comment>
	<expr_stmt><expr><call><name>UnSetDistributedTransactionId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UnSetGlobalPID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyBackendData</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyBackendData</name><operator>-&gt;</operator><name>distributedCommandOriginator</name></name> <operator>=</operator> <call><name>IsExternalClientBackend</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyBackendData</name><operator>-&gt;</operator><name>globalPID</name></name> <operator>=</operator> <name>gpid</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyBackendData</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Signal that this backend is active and should show up
	 * on activity monitors.
	 */</comment>
	<expr_stmt><expr><call><name>SetActiveMyBackend</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>UnlockBackendSharedMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * UnSetDistributedTransactionId simply acquires the mutex and resets the backend's
 * distributed transaction data in shared memory to the initial values.
 */</comment>
<function><type><name>void</name></type>
<name>UnSetDistributedTransactionId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* backend does not exist if the extension is not created */</comment>
	<if_stmt><if>if <condition>(<expr><name>MyBackendData</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyBackendData</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>MyBackendData</name><operator>-&gt;</operator><name>cancelledDueToDeadlock</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>MyBackendData</name><operator>-&gt;</operator><name>transactionId</name><operator>.</operator><name>initiatorNodeIdentifier</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>MyBackendData</name><operator>-&gt;</operator><name>transactionId</name><operator>.</operator><name>transactionOriginator</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>MyBackendData</name><operator>-&gt;</operator><name>transactionId</name><operator>.</operator><name>transactionNumber</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>MyBackendData</name><operator>-&gt;</operator><name>transactionId</name><operator>.</operator><name>timestamp</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyBackendData</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * UnSetGlobalPID resets the global pid for the current backend.
 */</comment>
<function><type><name>void</name></type>
<name>UnSetGlobalPID</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* backend does not exist if the extension is not created */</comment>
	<if_stmt><if>if <condition>(<expr><name>MyBackendData</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyBackendData</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>MyBackendData</name><operator>-&gt;</operator><name>globalPID</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>MyBackendData</name><operator>-&gt;</operator><name>databaseId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>MyBackendData</name><operator>-&gt;</operator><name>userId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>MyBackendData</name><operator>-&gt;</operator><name>distributedCommandOriginator</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyBackendData</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * SetActiveMyBackend is a wrapper around MyBackendData-&gt;activeBackend.
 */</comment>
<function><type><name>void</name></type>
<name>SetActiveMyBackend</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* backend does not exist if the extension is not created */</comment>
	<if_stmt><if>if <condition>(<expr><name>MyBackendData</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyBackendData</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>MyBackendData</name><operator>-&gt;</operator><name>activeBackend</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyBackendData</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * LockBackendSharedMemory is a simple wrapper around LWLockAcquire on the
 * shared memory lock.
 *
 * We use the backend shared memory lock for preventing new backends to be part
 * of a new distributed transaction or an existing backend to leave a distributed
 * transaction while we're reading the all backends' data.
 *
 * The primary goal is to provide consistent view of the current distributed
 * transactions while doing the deadlock detection.
 */</comment>
<function><type><name>void</name></type>
<name>LockBackendSharedMemory</name><parameter_list>(<parameter><decl><type><name>LWLockMode</name></type> <name>lockMode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>backendManagementShmemData</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>, <argument><expr><name>lockMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * UnlockBackendSharedMemory is a simple wrapper around LWLockRelease on the
 * shared memory lock.
 */</comment>
<function><type><name>void</name></type>
<name>UnlockBackendSharedMemory</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>backendManagementShmemData</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * GetCurrentDistributedTransactionId reads the backend's distributed transaction id and
 * returns a copy of it.
 *
 * When called from a parallel worker, it uses the parent's transaction ID per the logic
 * in GetBackendDataForProc.
 */</comment>
<function><type><name>DistributedTransactionId</name> <modifier>*</modifier></type>
<name>GetCurrentDistributedTransactionId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DistributedTransactionId</name> <modifier>*</modifier></type><name>currentDistributedTransactionId</name> <init>=
		<expr><operator>(</operator><name>DistributedTransactionId</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DistributedTransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BackendData</name></type> <name>backendData</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>GetBackendDataForProc</name><argument_list>(<argument><expr><name>MyProc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>backendData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>currentDistributedTransactionId</name><operator>-&gt;</operator><name>initiatorNodeIdentifier</name></name> <operator>=</operator>
		<name><name>backendData</name><operator>.</operator><name>transactionId</name><operator>.</operator><name>initiatorNodeIdentifier</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>currentDistributedTransactionId</name><operator>-&gt;</operator><name>transactionOriginator</name></name> <operator>=</operator>
		<name><name>backendData</name><operator>.</operator><name>transactionId</name><operator>.</operator><name>transactionOriginator</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>currentDistributedTransactionId</name><operator>-&gt;</operator><name>transactionNumber</name></name> <operator>=</operator>
		<name><name>backendData</name><operator>.</operator><name>transactionId</name><operator>.</operator><name>transactionNumber</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>currentDistributedTransactionId</name><operator>-&gt;</operator><name>timestamp</name></name> <operator>=</operator>
		<name><name>backendData</name><operator>.</operator><name>transactionId</name><operator>.</operator><name>timestamp</name></name></expr>;</expr_stmt>

	<return>return <expr><name>currentDistributedTransactionId</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AssignDistributedTransactionId generates a new distributed transaction id and
 * sets it for the current backend. It also sets the databaseId and
 * processId fields.
 *
 * This function should only be called on UseCoordinatedTransaction(). Any other
 * callers is very likely to break the distributed transaction management.
 */</comment>
<function><type><name>void</name></type>
<name>AssignDistributedTransactionId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pg_atomic_uint64</name> <modifier>*</modifier></type><name>transactionNumberSequence</name> <init>=
		<expr><operator>&amp;</operator><name><name>backendManagementShmemData</name><operator>-&gt;</operator><name>nextTransactionNumber</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint64</name></type> <name>nextTransactionNumber</name> <init>= <expr><call><name>pg_atomic_fetch_add_u64</name><argument_list>(<argument><expr><name>transactionNumberSequence</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>localGroupId</name> <init>= <expr><call><name>GetLocalGroupId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>currentTimestamp</name> <init>= <expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyBackendData</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>MyBackendData</name><operator>-&gt;</operator><name>transactionId</name><operator>.</operator><name>initiatorNodeIdentifier</name></name> <operator>=</operator> <name>localGroupId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyBackendData</name><operator>-&gt;</operator><name>transactionId</name><operator>.</operator><name>transactionOriginator</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyBackendData</name><operator>-&gt;</operator><name>transactionId</name><operator>.</operator><name>transactionNumber</name></name> <operator>=</operator> <name>nextTransactionNumber</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyBackendData</name><operator>-&gt;</operator><name>transactionId</name><operator>.</operator><name>timestamp</name></name> <operator>=</operator> <name>currentTimestamp</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyBackendData</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * AssignGlobalPID assigns a global process id for the current backend.
 * If this is a Citus initiated backend, which means it is distributed part of a distributed
 * query, then this function assigns the global pid extracted from the application name.
 * If not, this function assigns a new generated global pid.
 *
 * If a global PID is already assigned to this backend, then this function is a
 * no-op. In most scenarios this would already be the case, because a newly
 * assigned global PID would be the same as a proviously assigned one. But
 * there's two important cases where the newly assigned  global PID would be
 * different from the previous one:
 * 1. The current backend is an internal backend and in the meantime the
 *    application_name was changed to one without a gpid, e.g.
 *    citus_rebalancer. In this case we don't want to throw away the original
 *    gpid of the query originator, because that would mess up distributed
 *    deadlock detection involving this backend.
 * 2. The current backend is an external backend and the node id of the current
 *    node changed. Updating the gpid to match the nodeid might actually seem
 *    like a desirable property, but that's not the case. Updating the gpid
 *    with the new nodeid would mess up distributed deadlock and originator
 *    detection of queries too. Because if this backend already opened
 *    connections to other nodes, then those backends will still have the old
 *    gpid.
 */</comment>
<function><type><name>void</name></type>
<name>AssignGlobalPID</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>GetGlobalPID</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>INVALID_CITUS_INTERNAL_BACKEND_GPID</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>uint64</name></type> <name>globalPID</name> <init>= <expr><name>INVALID_CITUS_INTERNAL_BACKEND_GPID</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>distributedCommandOriginator</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCitusInternalBackend</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>globalPID</name> <operator>=</operator> <call><name>GenerateGlobalPID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>distributedCommandOriginator</name> <operator>=</operator> <call><name>IsExternalClientBackend</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>globalPID</name> <operator>=</operator> <call><name>ExtractGlobalPID</name><argument_list>(<argument><expr><name>application_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>userId</name> <init>= <expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyBackendData</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>MyBackendData</name><operator>-&gt;</operator><name>globalPID</name></name> <operator>=</operator> <name>globalPID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyBackendData</name><operator>-&gt;</operator><name>distributedCommandOriginator</name></name> <operator>=</operator> <name>distributedCommandOriginator</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyBackendData</name><operator>-&gt;</operator><name>databaseId</name></name> <operator>=</operator> <name>MyDatabaseId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyBackendData</name><operator>-&gt;</operator><name>userId</name></name> <operator>=</operator> <name>userId</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyBackendData</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * SetBackendDataDistributedCommandOriginator is used to set the distributedCommandOriginator
 * field on MyBackendData.
 */</comment>
<function><type><name>void</name></type>
<name>SetBackendDataDistributedCommandOriginator</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>distributedCommandOriginator</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>MyBackendData</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyBackendData</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyBackendData</name><operator>-&gt;</operator><name>distributedCommandOriginator</name></name> <operator>=</operator>
		<name>distributedCommandOriginator</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyBackendData</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * GetGlobalPID returns the global process id of the current backend.
 */</comment>
<function><type><name>uint64</name></type>
<name>GetGlobalPID</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type> <name>globalPID</name> <init>= <expr><name>INVALID_CITUS_INTERNAL_BACKEND_GPID</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>MyBackendData</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyBackendData</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>globalPID</name> <operator>=</operator> <name><name>MyBackendData</name><operator>-&gt;</operator><name>globalPID</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyBackendData</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>globalPID</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * citus_calculate_gpid calculates the gpid for any given process on any
 * given node.
 */</comment>
<function><type><name>Datum</name></type>
<name>citus_calculate_gpid</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int32</name></type> <name>nodeId</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>pid</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_UINT64</name><argument_list>(<argument><expr><call><name>CalculateGlobalPID</name><argument_list>(<argument><expr><name>nodeId</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CalculateGlobalPID gets a nodeId and pid, and returns the global pid
 * that can be assigned for a process with the given input.
 */</comment>
<function><type><specifier>static</specifier> <name>uint64</name></type>
<name>CalculateGlobalPID</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>nodeId</name></decl></parameter>, <parameter><decl><type><name>pid_t</name></type> <name>pid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We try to create a human readable global pid that consists of node id and process id.
	 * By multiplying node id with 10^10 and adding pid we generate a number where the smallest
	 * 10 digit represent the pid and the remaining digits are the node id.
	 *
	 * Both node id and pid are 32 bit. We use 10^10 to fit all possible pids. Some very large
	 * node ids might cause overflow. But even for the applications that scale around 50 nodes every
	 * day it'd take about 100K years. So we are not worried.
	 */</comment>
	<return>return <expr><operator>(</operator><operator>(</operator><operator>(</operator><name>uint64</name><operator>)</operator> <name>nodeId</name><operator>)</operator> <operator>*</operator> <name>GLOBAL_PID_NODE_ID_MULTIPLIER</name><operator>)</operator> <operator>+</operator> <name>pid</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GenerateGlobalPID generates the global process id for the current backend.
 * See CalculateGlobalPID for the details.
 */</comment>
<function><type><specifier>static</specifier> <name>uint64</name></type>
<name>GenerateGlobalPID</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>CalculateGlobalPID</name><argument_list>(<argument><expr><call><name>GetLocalNodeId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * citus_backend_gpid similar to pg_backend_pid, but returns Citus
 * assigned gpid.
 */</comment>
<function><type><name>Datum</name></type>
<name>citus_backend_gpid</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_UINT64</name><argument_list>(<argument><expr><call><name>GetGlobalPID</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * citus_nodeid_for_gpid returns node id for the global process with given global pid
 */</comment>
<function><type><name>Datum</name></type>
<name>citus_nodeid_for_gpid</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>uint64</name></type> <name>globalPID</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>missingOk</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><call><name>ExtractNodeIdFromGlobalPID</name><argument_list>(<argument><expr><name>globalPID</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * citus_pid_for_gpid returns process id for the global process with given global pid
 */</comment>
<function><type><name>Datum</name></type>
<name>citus_pid_for_gpid</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>uint64</name></type> <name>globalPID</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><call><name>ExtractProcessIdFromGlobalPID</name><argument_list>(<argument><expr><name>globalPID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ExtractGlobalPID extracts the global process id from the application name and returns it
 * if the application name is not compatible with Citus' application names returns 0.
 */</comment>
<function><type><name>uint64</name></type>
<name>ExtractGlobalPID</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>applicationName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* does application name exist */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>applicationName</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>INVALID_CITUS_INTERNAL_BACKEND_GPID</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* we create our own copy of application name incase the original changes */</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>applicationNameCopy</name> <init>= <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>applicationName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>CitusBackendPrefixes</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint64</name></type> <name>prefixLength</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>CitusBackendPrefixes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* does application name start with this prefix prefix */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>applicationNameCopy</name></expr></argument>, <argument><expr><name><name>CitusBackendPrefixes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>prefixLength</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>globalPIDString</name> <init>= <expr><operator>&amp;</operator><name><name>applicationNameCopy</name><index>[<expr><name>prefixLength</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type> <name>globalPID</name> <init>= <expr><call><name>strtoul</name><argument_list>(<argument><expr><name>globalPIDString</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>globalPID</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * INVALID_CITUS_INTERNAL_BACKEND_GPID is 0, but just to be explicit
			 * about how we handle strtoul errors.
			 */</comment>
			<return>return <expr><name>INVALID_CITUS_INTERNAL_BACKEND_GPID</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>globalPID</name></expr>;</return>
	</block_content>}</block></for>
	<return>return <expr><name>INVALID_CITUS_INTERNAL_BACKEND_GPID</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExtractNodeIdFromGlobalPID extracts the node id from the global pid.
 * Global pid is constructed by multiplying node id with GLOBAL_PID_NODE_ID_MULTIPLIER
 * and adding process id. So integer division of global pid by GLOBAL_PID_NODE_ID_MULTIPLIER
 * gives us the node id.
 */</comment>
<function><type><name>int</name></type>
<name>ExtractNodeIdFromGlobalPID</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>globalPID</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missingOk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>nodeId</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>globalPID</name> <operator>/</operator> <name>GLOBAL_PID_NODE_ID_MULTIPLIER</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>missingOk</name> <operator>&amp;&amp;</operator>
		<name>nodeId</name> <operator>==</operator> <name>GLOBAL_PID_NODE_ID_FOR_NODES_NOT_IN_METADATA</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"originator node of the query with the global pid "</literal>
							   <literal type="string">"%lu is not in Citus' metadata"</literal></expr></argument>, <argument><expr><name>globalPID</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"connect to the node directly run pg_cancel_backend(pid) "</literal>
								<literal type="string">"or pg_terminate_backend(pid)"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>nodeId</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExtractProcessIdFromGlobalPID extracts the process id from the global pid.
 * Global pid is constructed by multiplying node id with GLOBAL_PID_NODE_ID_MULTIPLIER
 * and adding process id. So global pid mod GLOBAL_PID_NODE_ID_MULTIPLIER gives us the
 * process id.
 */</comment>
<function><type><name>int</name></type>
<name>ExtractProcessIdFromGlobalPID</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>globalPID</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>globalPID</name> <operator>%</operator> <name>GLOBAL_PID_NODE_ID_MULTIPLIER</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CurrentDistributedTransactionNumber returns the transaction number of the
 * current distributed transaction. The caller must make sure a distributed
 * transaction is in progress.
 */</comment>
<function><type><name>uint64</name></type>
<name>CurrentDistributedTransactionNumber</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>MyBackendData</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>MyBackendData</name><operator>-&gt;</operator><name>transactionId</name><operator>.</operator><name>transactionNumber</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetBackendDataForProc writes the backend data for the given process to
 * result. If the process is part of a lock group (parallel query) it
 * returns the leader data instead.
 */</comment>
<function><type><name>void</name></type>
<name>GetBackendDataForProc</name><parameter_list>(<parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>, <parameter><decl><type><name>BackendData</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>pgprocno</name> <init>= <expr><name><name>proc</name><operator>-&gt;</operator><name>pgprocno</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>lockGroupLeader</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>pgprocno</name> <operator>=</operator> <name><name>proc</name><operator>-&gt;</operator><name>lockGroupLeader</name><operator>-&gt;</operator><name>pgprocno</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>BackendData</name> <modifier>*</modifier></type><name>backendData</name> <init>= <expr><operator>&amp;</operator><name><name>backendManagementShmemData</name><operator>-&gt;</operator><name>backends</name><index>[<expr><name>pgprocno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>backendData</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <operator>*</operator><name>backendData</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>backendData</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CancelTransactionDueToDeadlock cancels the input proc and also marks the backend
 * data with this information.
 */</comment>
<function><type><name>void</name></type>
<name>CancelTransactionDueToDeadlock</name><parameter_list>(<parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BackendData</name> <modifier>*</modifier></type><name>backendData</name> <init>= <expr><operator>&amp;</operator><name><name>backendManagementShmemData</name><operator>-&gt;</operator><name>backends</name><index>[<expr><name><name>proc</name><operator>-&gt;</operator><name>pgprocno</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* backend might not have used citus yet and thus not initialized backend data */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>backendData</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>backendData</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* send a SIGINT only if the process is still in a distributed transaction */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>backendData</name><operator>-&gt;</operator><name>transactionId</name><operator>.</operator><name>transactionNumber</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>backendData</name><operator>-&gt;</operator><name>cancelledDueToDeadlock</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>backendData</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>kill</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>, <argument><expr><name>SIGINT</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"attempted to cancel this backend (pid: %d) to resolve a "</literal>
							<literal type="string">"distributed deadlock but the backend could not "</literal>
							<literal type="string">"be cancelled"</literal></expr></argument>, <argument><expr><name><name>proc</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>backendData</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * MyBackendGotCancelledDueToDeadlock returns whether the current distributed
 * transaction was cancelled due to a deadlock. If the backend is not in a
 * distributed transaction, the function returns false.
 * We keep some session level state to keep track of if we were cancelled
 * because of a distributed deadlock. When clearState is true, this function
 * also resets that state. So after calling this function with clearState true,
 * a second would always return false.
 */</comment>
<function><type><name>bool</name></type>
<name>MyBackendGotCancelledDueToDeadlock</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>clearState</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>cancelledDueToDeadlock</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* backend might not have used citus yet and thus not initialized backend data */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>MyBackendData</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyBackendData</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsInDistributedTransaction</name><argument_list>(<argument><expr><name>MyBackendData</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>cancelledDueToDeadlock</name> <operator>=</operator> <name><name>MyBackendData</name><operator>-&gt;</operator><name>cancelledDueToDeadlock</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>clearState</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>MyBackendData</name><operator>-&gt;</operator><name>cancelledDueToDeadlock</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyBackendData</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>cancelledDueToDeadlock</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * MyBackendIsInDisributedTransaction returns true if MyBackendData
 * is in a distributed transaction.
 */</comment>
<function><type><name>bool</name></type>
<name>MyBackendIsInDisributedTransaction</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* backend might not have used citus yet and thus not initialized backend data */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>MyBackendData</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>IsInDistributedTransaction</name><argument_list>(<argument><expr><name>MyBackendData</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ActiveDistributedTransactionNumbers returns a list of pointers to
 * transaction numbers of distributed transactions that are in progress
 * and were started by the node on which it is called.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>ActiveDistributedTransactionNumbers</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>activeTransactionNumberList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* build list of starting procs */</comment>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>curBackend</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>curBackend</name> <operator>&lt;</operator> <name>MaxBackends</name></expr>;</condition> <incr><expr><name>curBackend</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>currentProc</name> <init>= <expr><operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>allProcs</name><index>[<expr><name>curBackend</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BackendData</name></type> <name>currentBackendData</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>currentProc</name><operator>-&gt;</operator><name>pid</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* unused PGPROC slot */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>GetBackendDataForProc</name><argument_list>(<argument><expr><name>currentProc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>currentBackendData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>currentBackendData</name><operator>.</operator><name>activeBackend</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Skip if the PGPROC slot is unused. We should normally use
			 * IsBackendPid() to be able to skip reliably all the exited
			 * processes. However, that is a costly operation. Instead, we
			 * keep track of activeBackend in Citus code.
			 */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsInDistributedTransaction</name><argument_list>(<argument><expr><operator>&amp;</operator><name>currentBackendData</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* not a distributed transaction */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>currentBackendData</name><operator>.</operator><name>transactionId</name><operator>.</operator><name>transactionOriginator</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* not a coordinator process */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>uint64</name> <modifier>*</modifier></type><name>transactionNumber</name> <init>= <expr><operator>(</operator><name>uint64</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint64</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><operator>*</operator><name>transactionNumber</name> <operator>=</operator> <name><name>currentBackendData</name><operator>.</operator><name>transactionId</name><operator>.</operator><name>transactionNumber</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>activeTransactionNumberList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>activeTransactionNumberList</name></expr></argument>,
											  <argument><expr><name>transactionNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>activeTransactionNumberList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetMyProcLocalTransactionId() is a wrapper for
 * getting lxid of MyProc.
 */</comment>
<function><type><name>LocalTransactionId</name></type>
<name>GetMyProcLocalTransactionId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>MyProc</name><operator>-&gt;</operator><name>lxid</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetExternalClientBackendCount returns externalClientBackendCounter in
 * the shared memory.
 */</comment>
<function><type><name>int</name></type>
<name>GetExternalClientBackendCount</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>activeBackendCount</name> <init>=
		<expr><call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>backendManagementShmemData</name><operator>-&gt;</operator><name>externalClientBackendCounter</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>activeBackendCount</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IncrementExternalClientBackendCounter increments externalClientBackendCounter in
 * the shared memory by one.
 */</comment>
<function><type><name>uint32</name></type>
<name>IncrementExternalClientBackendCounter</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>pg_atomic_add_fetch_u32</name><argument_list>(
		<argument><expr><operator>&amp;</operator><name><name>backendManagementShmemData</name><operator>-&gt;</operator><name>externalClientBackendCounter</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DecrementExternalClientBackendCounter decrements externalClientBackendCounter in
 * the shared memory by one.
 */</comment>
<function><type><name>void</name></type>
<name>DecrementExternalClientBackendCounter</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pg_atomic_sub_fetch_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>backendManagementShmemData</name><operator>-&gt;</operator><name>externalClientBackendCounter</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ResetCitusBackendType resets the backend type cache.
 */</comment>
<function><type><name>void</name></type>
<name>ResetCitusBackendType</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>CurrentBackendType</name> <operator>=</operator> <name>CITUS_BACKEND_NOT_ASSIGNED</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * IsRebalancerInitiatedBackend returns true if we are in a backend that citus
 * rebalancer initiated.
 */</comment>
<function><type><name>bool</name></type>
<name>IsRebalancerInternalBackend</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>CurrentBackendType</name> <operator>==</operator> <name>CITUS_BACKEND_NOT_ASSIGNED</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>DetermineCitusBackendType</name><argument_list>(<argument><expr><name>application_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>CurrentBackendType</name> <operator>==</operator> <name>CITUS_REBALANCER_BACKEND</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsCitusInitiatedRemoteBackend returns true if we are in a backend that citus
 * initiated via remote connection.
 */</comment>
<function><type><name>bool</name></type>
<name>IsCitusInternalBackend</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>CurrentBackendType</name> <operator>==</operator> <name>CITUS_BACKEND_NOT_ASSIGNED</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>DetermineCitusBackendType</name><argument_list>(<argument><expr><name>application_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>CurrentBackendType</name> <operator>==</operator> <name>CITUS_INTERNAL_BACKEND</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsCitusRunCommandBackend returns true if we are in a backend that one of
 * the run_command_on_* functions initiated.
 */</comment>
<function><type><name>bool</name></type>
<name>IsCitusRunCommandBackend</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>CurrentBackendType</name> <operator>==</operator> <name>CITUS_BACKEND_NOT_ASSIGNED</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>DetermineCitusBackendType</name><argument_list>(<argument><expr><name>application_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>CurrentBackendType</name> <operator>==</operator> <name>CITUS_RUN_COMMAND_BACKEND</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>bool</name></type>
<name>IsExternalClientBackend</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>CurrentBackendType</name> <operator>==</operator> <name>CITUS_BACKEND_NOT_ASSIGNED</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>DetermineCitusBackendType</name><argument_list>(<argument><expr><name>application_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>CurrentBackendType</name> <operator>==</operator> <name>EXTERNAL_CLIENT_BACKEND</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DetermineCitusBackendType determines the type of backend based on the application_name.
 */</comment>
<function><type><name>void</name></type>
<name>DetermineCitusBackendType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>applicationName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>applicationName</name> <operator>&amp;&amp;</operator>
		<call><name>ExtractGlobalPID</name><argument_list>(<argument><expr><name>applicationName</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>INVALID_CITUS_INTERNAL_BACKEND_GPID</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>CitusBackendPrefixes</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>uint64</name></type> <name>prefixLength</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>CitusBackendPrefixes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* does application name start with this prefix prefix */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>applicationName</name></expr></argument>, <argument><expr><name><name>CitusBackendPrefixes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>prefixLength</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>CurrentBackendType</name> <operator>=</operator> <name><name>CitusBackendTypes</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>CurrentBackendType</name> <operator>=</operator> <name>EXTERNAL_CLIENT_BACKEND</name></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
