<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/builded_projects/citus/src/backend/distributed/worker/worker_data_fetch_protocol.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * worker_data_fetch_protocol.c
 *
 * Routines for fetching remote resources from other nodes to this worker node,
 * and materializing these resources on this node if necessary.
 *
 * Copyright (c) Citus Data, Inc.
 *
 * $Id$
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-fe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/copy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/dbcommands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/extension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/sequence.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_ruleutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands/multi_copy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands/utility_hook.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/connection_management.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/coordinator_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/deparser.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/intermediate_results.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_sync.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_logical_optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_partitioning_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_server_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/relay_utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/remote_commands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/resource_lock.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_create_or_replace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/version_compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/spi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/regproc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/varlena.h"</cpp:file></cpp:include>


<comment type="block">/* Local functions forward declarations */</comment>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_log_statement</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>stmt_list</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AlterSequenceMinMax</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>sequenceId</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>schemaName</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sequenceName</name></decl></parameter>,
								<parameter><decl><type><name>Oid</name></type> <name>sequenceTypeId</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/* exports for SQL callable functions */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>worker_apply_shard_ddl_command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>worker_apply_inter_shard_ddl_command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>worker_apply_sequence_command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>worker_append_table_to_shard</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>worker_nextval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<comment type="block">/*
 * worker_apply_shard_ddl_command extends table, index, or constraint names in
 * the given DDL command. The function then applies this extended DDL command
 * against the database.
 */</comment>
<function><type><name>Datum</name></type>
<name>worker_apply_shard_ddl_command</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>uint64</name></type> <name>shardId</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>schemaNameText</name> <init>= <expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>ddlCommandText</name> <init>= <expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>schemaName</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><name>schemaNameText</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ddlCommand</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><name>ddlCommandText</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>ddlCommandNode</name> <init>= <expr><call><name>ParseTreeNode</name><argument_list>(<argument><expr><name>ddlCommand</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* extend names in ddl command and apply extended command */</comment>
	<expr_stmt><expr><call><name>RelayEventExtendNames</name><argument_list>(<argument><expr><name>ddlCommandNode</name></expr></argument>, <argument><expr><name>schemaName</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ProcessUtilityParseTree</name><argument_list>(<argument><expr><name>ddlCommandNode</name></expr></argument>, <argument><expr><name>ddlCommand</name></expr></argument>, <argument><expr><name>PROCESS_UTILITY_QUERY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							<argument><expr><name>None_Receiver</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * worker_apply_inter_shard_ddl_command extends table, index, or constraint names in
 * the given DDL command. The function then applies this extended DDL command
 * against the database.
 */</comment>
<function><type><name>Datum</name></type>
<name>worker_apply_inter_shard_ddl_command</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>uint64</name></type> <name>leftShardId</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>leftShardSchemaNameText</name> <init>= <expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>rightShardId</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>rightShardSchemaNameText</name> <init>= <expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>ddlCommandText</name> <init>= <expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>leftShardSchemaName</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><name>leftShardSchemaNameText</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>rightShardSchemaName</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><name>rightShardSchemaNameText</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ddlCommand</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><name>ddlCommandText</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>ddlCommandNode</name> <init>= <expr><call><name>ParseTreeNode</name><argument_list>(<argument><expr><name>ddlCommand</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* extend names in ddl command and apply extended command */</comment>
	<expr_stmt><expr><call><name>RelayEventExtendNamesForInterShardCommands</name><argument_list>(<argument><expr><name>ddlCommandNode</name></expr></argument>, <argument><expr><name>leftShardId</name></expr></argument>,
											   <argument><expr><name>leftShardSchemaName</name></expr></argument>, <argument><expr><name>rightShardId</name></expr></argument>,
											   <argument><expr><name>rightShardSchemaName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ProcessUtilityParseTree</name><argument_list>(<argument><expr><name>ddlCommandNode</name></expr></argument>, <argument><expr><name>ddlCommand</name></expr></argument>, <argument><expr><name>PROCESS_UTILITY_QUERY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							<argument><expr><name>None_Receiver</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * worker_apply_sequence_command takes a CREATE SEQUENCE command string, runs the
 * CREATE SEQUENCE command then creates and runs an ALTER SEQUENCE statement
 * which adjusts the minvalue and maxvalue of the sequence such that the sequence
 * creates globally unique values.
 */</comment>
<function><type><name>Datum</name></type>
<name>worker_apply_sequence_command</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>commandText</name> <init>= <expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>sequenceTypeId</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>commandString</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><name>commandText</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>commandNode</name> <init>= <expr><call><name>ParseTreeNode</name><argument_list>(<argument><expr><name>commandString</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>NodeTag</name></type> <name>nodeType</name> <init>= <expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>commandNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>nodeType</name> <operator>!=</operator> <name>T_CreateSeqStmt</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must call worker_apply_sequence_command with a CREATE"</literal>
						<literal type="string">" SEQUENCE command string"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If sequence with the same name exist for different type, it must have been
	 * stayed on that node after a rollbacked create_distributed_table operation.
	 * We must change its name first to create the sequence with the correct type.
	 */</comment>
	<decl_stmt><decl><type><name>CreateSeqStmt</name> <modifier>*</modifier></type><name>createSequenceStatement</name> <init>= <expr><operator>(</operator><name>CreateSeqStmt</name> <operator>*</operator><operator>)</operator> <name>commandNode</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>RenameExistingSequenceWithDifferentTypeIfExists</name><argument_list>(<argument><expr><name><name>createSequenceStatement</name><operator>-&gt;</operator><name>sequence</name></name></expr></argument>,
													<argument><expr><name>sequenceTypeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* run the CREATE SEQUENCE command */</comment>
	<expr_stmt><expr><call><name>ProcessUtilityParseTree</name><argument_list>(<argument><expr><name>commandNode</name></expr></argument>, <argument><expr><name>commandString</name></expr></argument>, <argument><expr><name>PROCESS_UTILITY_QUERY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							<argument><expr><name>None_Receiver</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>sequenceRelationId</name> <init>= <expr><call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name><name>createSequenceStatement</name><operator>-&gt;</operator><name>sequence</name></name></expr></argument>,
											  <argument><expr><name>AccessShareLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sequenceName</name> <init>= <expr><name><name>createSequenceStatement</name><operator>-&gt;</operator><name>sequence</name><operator>-&gt;</operator><name>relname</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sequenceSchema</name> <init>= <expr><name><name>createSequenceStatement</name><operator>-&gt;</operator><name>sequence</name><operator>-&gt;</operator><name>schemaname</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>sequenceRelationId</name> <operator>!=</operator> <name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AlterSequenceMinMax</name><argument_list>(<argument><expr><name>sequenceRelationId</name></expr></argument>, <argument><expr><name>sequenceSchema</name></expr></argument>, <argument><expr><name>sequenceName</name></expr></argument>, <argument><expr><name>sequenceTypeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ExtractShardIdFromTableName tries to extract shard id from the given table name,
 * and returns the shard id if table name is formatted as shard name.
 * Else, the function returns INVALID_SHARD_ID.
 */</comment>
<function><type><name>uint64</name></type>
<name>ExtractShardIdFromTableName</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tableName</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missingOk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>shardIdStringEnd</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* find the last underscore and increment for shardId string */</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>shardIdString</name> <init>= <expr><call><name>strrchr</name><argument_list>(<argument><expr><name>tableName</name></expr></argument>, <argument><expr><name>SHARD_NAME_SEPARATOR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>shardIdString</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>missingOk</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not extract shardId from table name \"%s\""</literal></expr></argument>,
							   <argument><expr><name>tableName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>shardIdString</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>missingOk</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>INVALID_SHARD_ID</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>shardIdString</name><operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>shardId</name> <init>= <expr><call><name>strtou64</name><argument_list>(<argument><expr><name>shardIdString</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shardIdStringEnd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><operator>*</operator><name>shardIdStringEnd</name> <operator>!=</operator> <literal type="char">'\0'</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>missingOk</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not extract shardId from table name \"%s\""</literal></expr></argument>,
								   <argument><expr><name>tableName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<return>return <expr><name>INVALID_SHARD_ID</name></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>shardId</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Parses the given DDL command, and returns the tree node for parsed command.
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>ParseTreeNode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ddlCommand</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>parseTreeNode</name> <init>= <expr><call><name>ParseTreeRawStmt</name><argument_list>(<argument><expr><name>ddlCommand</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>parseTreeNode</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RawStmt</name> <operator>*</operator><operator>)</operator> <name>parseTreeNode</name><operator>)</operator><operator>-&gt;</operator><name>stmt</name></expr>;</expr_stmt>

	<return>return <expr><name>parseTreeNode</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Parses the given DDL command, and returns the tree node for parsed command.
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>ParseTreeRawStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ddlCommand</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>parseTreeList</name> <init>= <expr><call><name>pg_parse_query</name><argument_list>(<argument><expr><name>ddlCommand</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* log immediately if dictated by log statement */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>check_log_statement</name><argument_list>(<argument><expr><name>parseTreeList</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"statement: %s"</literal></expr></argument>, <argument><expr><name>ddlCommand</name></expr></argument>)</argument_list></call><operator>,</operator>
					  <call><name>errhidestmt</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>uint32</name></type> <name>parseTreeCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>parseTreeList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>parseTreeCount</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot execute multiple utility events"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * xact.c rejects certain commands that are unsafe to run inside transaction
	 * blocks. Since we only apply commands that relate to creating tables and
	 * those commands are safe, we can safely set the ProcessUtilityContext to
	 * PROCESS_UTILITY_TOPLEVEL.
	 */</comment>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>parseTreeNode</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>parseTreeList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>parseTreeNode</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * worker_append_table_to_shard is deprecated.
 */</comment>
<function><type><name>Datum</name></type>
<name>worker_append_table_to_shard</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"worker_append_table_to_shard has been deprecated"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * worker_nextval calculates nextval() in worker nodes
 * for int and smallint column default types
 * TODO: not error out but get the proper nextval()
 */</comment>
<function><type><name>Datum</name></type>
<name>worker_nextval</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
						<argument><expr><literal type="string">"nextval(sequence) calls in worker nodes are not supported"</literal>
						<literal type="string">" for column defaults of type int or smallint"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * check_log_statement is a copy of postgres' check_log_statement function and
 * returns whether a statement ought to be logged or not.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_log_statement</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>statementList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>log_statement</name> <operator>==</operator> <name>LOGSTMT_NONE</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>log_statement</name> <operator>==</operator> <name>LOGSTMT_ALL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* else we have to inspect the statement(s) to see whether to log */</comment>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>statement</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>statement</argument>, <argument>statementList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>GetCommandLogLevel</name><argument_list>(<argument><expr><name>statement</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>log_statement</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AlterSequenceMinMax arranges the min and max value of the given sequence. The function
 * creates ALTER SEQUENCE statemenet which sets the start, minvalue and maxvalue of
 * the given sequence.
 *
 * The function provides the uniqueness by shifting the start of the sequence by
 * GetLocalGroupId() &lt;&lt; 48 + 1 and sets a maxvalue which stops it from passing out any
 * values greater than: (GetLocalGroupID() + 1) &lt;&lt; 48.
 *
 * For serial we only have 32 bits and therefore shift by 28, and for smallserial
 * we only have 16 bits and therefore shift by 12.
 *
 * This is to ensure every group of workers passes out values from a unique range,
 * and therefore that all values generated for the sequence are globally unique.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AlterSequenceMinMax</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>sequenceId</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>schemaName</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sequenceName</name></decl></parameter>,
					<parameter><decl><type><name>Oid</name></type> <name>sequenceTypeId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_sequence</name></type> <name>sequenceData</name> <init>= <expr><call><name>pg_get_sequencedef</name><argument_list>(<argument><expr><name>sequenceId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>sequenceMaxValue</name> <init>= <expr><name><name>sequenceData</name><operator>-&gt;</operator><name>seqmax</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>sequenceMinValue</name> <init>= <expr><name><name>sequenceData</name><operator>-&gt;</operator><name>seqmin</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>valueBitLength</name> <init>= <expr><literal type="number">48</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * For int and smallint, we don't currently support insertion from workers
	 * Check issue #5126 and PR #5254 for details.
	 * https://github.com/citusdata/citus/issues/5126
	 * So, no need to alter sequence min/max for now
	 * We call setval(sequence, maxvalue) such that manually using
	 * nextval(sequence) in the workers will error out as well.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>sequenceTypeId</name> <operator>!=</operator> <name>INT8OID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>setval_oid</name></expr></argument>,
							<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>sequenceId</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>sequenceMaxValue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* calculate min/max values that the sequence can generate in this worker */</comment>
	<decl_stmt><decl><type><name>int64</name></type> <name>startValue</name> <init>= <expr><operator>(</operator><operator>(</operator><operator>(</operator><name>int64</name><operator>)</operator> <call><name>GetLocalGroupId</name><argument_list>()</argument_list></call><operator>)</operator> <operator>&lt;&lt;</operator> <name>valueBitLength</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>maxValue</name> <init>= <expr><name>startValue</name> <operator>+</operator> <operator>(</operator><operator>(</operator><name>int64</name><operator>)</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>valueBitLength</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We alter the sequence if the previously set min and max values are not equal to
	 * their correct values.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>sequenceMinValue</name> <operator>!=</operator> <name>startValue</name> <operator>||</operator> <name>sequenceMaxValue</name> <operator>!=</operator> <name>maxValue</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>StringInfo</name></type> <name>startNumericString</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StringInfo</name></type> <name>maxNumericString</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AlterSeqStmt</name> <modifier>*</modifier></type><name>alterSequenceStatement</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>AlterSeqStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dummyString</name> <init>= <expr><literal type="string">"-"</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>alterSequenceStatement</name><operator>-&gt;</operator><name>sequence</name></name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>, <argument><expr><name>sequenceName</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * DefElem-&gt;arg can only hold literal ints up to int4, in order to represent
		 * larger numbers we need to construct a float represented as a string.
		 */</comment>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>startNumericString</name></expr></argument>, <argument><expr><name>INT64_FORMAT</name></expr></argument>, <argument><expr><name>startValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>startFloatArg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeFloat</name><argument_list>(<argument><expr><name><name>startNumericString</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>maxNumericString</name></expr></argument>, <argument><expr><name>INT64_FORMAT</name></expr></argument>, <argument><expr><name>maxValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>maxFloatArg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeFloat</name><argument_list>(<argument><expr><name><name>maxNumericString</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>SetDefElemArg</name><argument_list>(<argument><expr><name>alterSequenceStatement</name></expr></argument>, <argument><expr><literal type="string">"start"</literal></expr></argument>, <argument><expr><name>startFloatArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SetDefElemArg</name><argument_list>(<argument><expr><name>alterSequenceStatement</name></expr></argument>, <argument><expr><literal type="string">"minvalue"</literal></expr></argument>, <argument><expr><name>startFloatArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SetDefElemArg</name><argument_list>(<argument><expr><name>alterSequenceStatement</name></expr></argument>, <argument><expr><literal type="string">"maxvalue"</literal></expr></argument>, <argument><expr><name>maxFloatArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SetDefElemArg</name><argument_list>(<argument><expr><name>alterSequenceStatement</name></expr></argument>, <argument><expr><literal type="string">"restart"</literal></expr></argument>, <argument><expr><name>startFloatArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* since the command is an AlterSeqStmt, a dummy command string works fine */</comment>
		<expr_stmt><expr><call><name>ProcessUtilityParseTree</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>alterSequenceStatement</name></expr></argument>, <argument><expr><name>dummyString</name></expr></argument>,
								<argument><expr><name>PROCESS_UTILITY_QUERY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>None_Receiver</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * SetDefElemArg scans through all the DefElem's of an AlterSeqStmt and
 * and sets the arg of the one with a defname of name to arg.
 *
 * If a DefElem with the given defname does not exist it is created and
 * added to the AlterSeqStmt.
 */</comment>
<function><type><name>void</name></type>
<name>SetDefElemArg</name><parameter_list>(<parameter><decl><type><name>AlterSeqStmt</name> <modifier>*</modifier></type><name>statement</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>defElem</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>defElem</argument>, <argument>statement-&gt;options</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defElem</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>defElem</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>defElem</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name>defElem</name> <operator>=</operator> <call><name>makeDefElem</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>name</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>statement</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>statement</name><operator>-&gt;</operator><name>options</name></name></expr></argument>, <argument><expr><name>defElem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
