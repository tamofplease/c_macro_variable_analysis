<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/citus/src/backend/distributed/worker/worker_shard_visibility.c"><comment type="block">/*
 * worker_shard_visibility.c
 *
 * Implements the functions for hiding shards on the Citus MX
 * worker (data) nodes.
 *
 * Copyright (c) Citus Data, Inc.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_class.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/backend_data.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/coordinator_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/local_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/query_colocation_checker.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_shard_visibility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/varlena.h"</cpp:file></cpp:include>


<comment type="block">/* HideShardsMode is used to determine whether to hide shards */</comment>
<typedef>typedef <type><enum>enum <name>HideShardsMode</name>
<block>{
	<decl><name>CHECK_APPLICATION_NAME</name></decl>,
	<decl><name>HIDE_SHARDS_FROM_APPLICATION</name></decl>,
	<decl><name>DO_NOT_HIDE_SHARDS</name></decl>
}</block></enum></type> <name>HideShardsMode</name>;</typedef>

<comment type="block">/* Config variable managed via guc.c */</comment>
<decl_stmt><decl><type><name>bool</name></type> <name>OverrideTableVisibility</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>EnableManualChangesToShards</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* show shards when the application_name starts with one of: */</comment>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ShowShardsForAppNamePrefixes</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* cache of whether or not to hide shards */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>HideShardsMode</name></type> <name>HideShards</name> <init>= <expr><name>CHECK_APPLICATION_NAME</name></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ShouldHideShards</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ShouldHideShardsInternal</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsPgBgWorker</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>FilterShardsFromPgclass</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type> <name>CreateRelationIsAKnownShardFilter</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>pgClassVarno</name></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>citus_table_is_visible</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>relation_is_a_known_shard</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<comment type="block">/*
 * relation_is_a_known_shard a wrapper around RelationIsAKnownShard(), so
 * see the details there. The function also treats the indexes on shards
 * as if they were shards.
 */</comment>
<function><type><name>Datum</name></type>
<name>relation_is_a_known_shard</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>RelationIsAKnownShard</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * citus_table_is_visible aims to behave exactly the same with
 * pg_table_is_visible with only one exception. The former one
 * returns false for the relations that are known to be shards.
 */</comment>
<function><type><name>Datum</name></type>
<name>citus_table_is_visible</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>relKind</name> <init>= <expr><literal type="char">'\0'</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We don't want to deal with not valid/existing relations
	 * as pg_table_is_visible does.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SearchSysCacheExists1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RelationIsVisible</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* relation is not on the search path */</comment>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RelationIsAKnownShard</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If the input relation is an index we simply replace the
		 * relationId with the corresponding relation to hide indexes
		 * as well. See RelationIsAKnownShard() for the details and give
		 * more meaningful debug message here.
		 */</comment>
		<expr_stmt><expr><name>relKind</name> <operator>=</operator> <call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>relKind</name> <operator>==</operator> <name>RELKIND_INDEX</name> <operator>||</operator> <name>relKind</name> <operator>==</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skipping index \"%s\" since it belongs to a shard"</literal></expr></argument>,
									<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skipping relation \"%s\" since it is a shard"</literal></expr></argument>,
									<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>RelationIsVisible</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ErrorIfRelationIsAKnownShard errors out if the relation with relationId is
 * a shard relation.
 */</comment>
<function><type><name>void</name></type>
<name>ErrorIfRelationIsAKnownShard</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RelationIsAKnownShard</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s\" is a shard relation "</literal></expr></argument>, <argument><expr><name>relationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ErrorIfIllegallyChangingKnownShard errors out if the relation with relationId is
 * a known shard and manual changes on known shards are disabled. This is
 * valid for only non-citus (external) connections.
 */</comment>
<function><type><name>void</name></type>
<name>ErrorIfIllegallyChangingKnownShard</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* allow Citus to make changes, and allow the user if explicitly enabled */</comment>
	<if_stmt><if>if <condition>(<expr><name>LocalExecutorShardId</name> <operator>!=</operator> <name>INVALID_SHARD_ID</name> <operator>||</operator>
		<call><name>IsCitusInternalBackend</name><argument_list>()</argument_list></call> <operator>||</operator>
		<call><name>IsRebalancerInternalBackend</name><argument_list>()</argument_list></call> <operator>||</operator>
		<name>EnableManualChangesToShards</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RelationIsAKnownShard</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot modify \"%s\" because it is a shard of "</literal>
							   <literal type="string">"a distributed table"</literal></expr></argument>,
							   <argument><expr><name>relationName</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use the distributed table or set "</literal>
								<literal type="string">"citus.enable_manual_changes_to_shards to on "</literal>
								<literal type="string">"to modify shards directly"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * RelationIsAKnownShard gets a relationId, check whether it's a shard of
 * any distributed table.
 */</comment>
<function><type><name>bool</name></type>
<name>RelationIsAKnownShard</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>shardRelationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>missingOk</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>relKind</name> <init>= <expr><literal type="char">'\0'</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>shardRelationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* we cannot continue without a valid Oid */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsCoordinator</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>coordinatorIsKnown</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>PrimaryNodeForGroup</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>coordinatorIsKnown</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>coordinatorIsKnown</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We're not interested in shards in the coordinator
			 * or non-mx worker nodes, unless the coordinator is
			 * in pg_dist_node.
			 */</comment>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We do not take locks here, because that might block a query on pg_class.
	 */</comment>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SearchSysCacheExists1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>shardRelationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* relation does not exist */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the input relation is an index we simply replace the
	 * relationId with the corresponding relation to hide indexes
	 * as well.
	 */</comment>
	<expr_stmt><expr><name>relKind</name> <operator>=</operator> <call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>shardRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>relKind</name> <operator>==</operator> <name>RELKIND_INDEX</name> <operator>||</operator> <name>relKind</name> <operator>==</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>shardRelationId</name> <operator>=</operator> <call><name>IndexGetRelation</name><argument_list>(<argument><expr><name>shardRelationId</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* get the shard's relation name */</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>shardRelationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>shardRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint64</name></type> <name>shardId</name> <init>= <expr><call><name>ExtractShardIdFromTableName</name><argument_list>(<argument><expr><name>shardRelationName</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>shardId</name> <operator>==</operator> <name>INVALID_SHARD_ID</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The format of the table name does not align with
		 * our shard name definition.
		 */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* try to get the relation id */</comment>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>LookupShardRelationFromCatalog</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* there is no such relation */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* verify that their namespaces are the same */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>shardRelationId</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Now get the relation name and append the shardId to it. We need
	 * to do that because otherwise a local table with a valid shardId
	 * appended to its name could be misleading.
	 */</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>generatedRelationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><operator>&amp;</operator><name>generatedRelationName</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>shardRelationName</name></expr></argument>, <argument><expr><name>generatedRelationName</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* we found the distributed table that the input shard belongs to */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * HideShardsFromSomeApplications transforms queries to pg_class to
 * filter out known shards if the application_name does not match any of
 * the prefixes in citus.show_shards_for_app_name_prefix.
 */</comment>
<function><type><name>void</name></type>
<name>HideShardsFromSomeApplications</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>OverrideTableVisibility</name> <operator>||</operator> <name>HideShards</name> <operator>==</operator> <name>DO_NOT_HIDE_SHARDS</name> <operator>||</operator>
		<operator>!</operator><call><name>CitusHasBeenLoaded</name><argument_list>()</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ShouldHideShards</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>FilterShardsFromPgclass</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>query</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ShouldHideShards returns whether we should hide shards in the current
 * session. It only checks the application_name once and then uses a
 * cached response unless either the application_name or
 * citus.show_shards_for_app_name_prefix changes.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ShouldHideShards</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>HideShards</name> <operator>==</operator> <name>CHECK_APPLICATION_NAME</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>ShouldHideShardsInternal</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>HideShards</name> <operator>=</operator> <name>HIDE_SHARDS_FROM_APPLICATION</name></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>HideShards</name> <operator>=</operator> <name>DO_NOT_HIDE_SHARDS</name></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<return>return <expr><name>HideShards</name> <operator>==</operator> <name>HIDE_SHARDS_FROM_APPLICATION</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ResetHideShardsDecision resets the decision whether to hide shards.
 */</comment>
<function><type><name>void</name></type>
<name>ResetHideShardsDecision</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>HideShards</name> <operator>=</operator> <name>CHECK_APPLICATION_NAME</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ShouldHideShardsInternal determines whether we should hide shards based on
 * the current application name.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ShouldHideShardsInternal</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>MyBackendType</name> <operator>==</operator> <name>B_BG_WORKER</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IsPgBgWorker</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If a background worker belongs to Postgres, we should
			 * never hide shards. For other background workers, enforce
			 * the application_name check below.
			 */</comment>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>MyBackendType</name> <operator>!=</operator> <name>B_BACKEND</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We are aiming only to hide shards from client
		 * backends or certain background workers(see above),
		 * not backends like walsender or checkpointer.
		 */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsCitusInternalBackend</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>IsRebalancerInternalBackend</name><argument_list>()</argument_list></call> <operator>||</operator>
		<call><name>IsCitusRunCommandBackend</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* we never hide shards from Citus */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>prefixList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* SplitGUCList scribbles on the input */</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>splitCopy</name> <init>= <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>ShowShardsForAppNamePrefixes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SplitGUCList</name><argument_list>(<argument><expr><name>splitCopy</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>prefixList</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* invalid GUC value, ignore */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>appNamePrefix</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>appNamePrefix</argument>, <argument>prefixList</argument>)</argument_list></macro>
	<block>{<block_content>
		<comment type="block">/* never hide shards when one of the prefixes is * */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>appNamePrefix</name></expr></argument>, <argument><expr><literal type="string">"*"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* compare only the first first &lt;prefixLength&gt; characters */</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>prefixLength</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>appNamePrefix</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>application_name</name></expr></argument>, <argument><expr><name>appNamePrefix</name></expr></argument>, <argument><expr><name>prefixLength</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* default behaviour: hide shards */</comment>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsPgBgWorker returns true if the current background worker
 * belongs to Postgres.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsPgBgWorker</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>MyBackendType</name> <operator>==</operator> <name>B_BG_WORKER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>MyBgworkerEntry</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>MyBgworkerEntry</name><operator>-&gt;</operator><name>bgw_library_name</name></name></expr></argument>, <argument><expr><literal type="string">"postgres"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FilterShardsFromPgclass adds a NOT relation_is_a_known_shard(oid) filter
 * to the security quals of pg_class RTEs.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>FilterShardsFromPgclass</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>queryContext</name> <init>= <expr><call><name>GetMemoryChunkContext</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * We process the whole rtable rather than visiting individual RangeTblEntry's
		 * in the walker, since we need to know the varno to generate the right
		 * fiter.
		 */</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>varno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<macro><name>foreach_ptr</name><argument_list>(<argument>rangeTableEntry</argument>, <argument>query-&gt;rtable</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>varno</name><operator>++</operator></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_RELATION</name> <operator>||</operator>
				<name><name>rangeTableEntry</name><operator>-&gt;</operator><name>relid</name></name> <operator>!=</operator> <name>RelationRelationId</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* not pg_class */</comment>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* make sure the expression is in the right memory context */</comment>
			<decl_stmt><decl><type><name>MemoryContext</name></type> <name>originalContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>queryContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* add NOT relation_is_a_known_shard(oid) to the security quals of the RTE */</comment>
			<expr_stmt><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>securityQuals</name></name> <operator>=</operator>
				<call><name>list_make1</name><argument_list>(<argument><expr><call><name>CreateRelationIsAKnownShardFilter</name><argument_list>(<argument><expr><name>varno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>originalContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<return>return <expr><call><name>query_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>FilterShardsFromPgclass</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>FilterShardsFromPgclass</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateRelationIsAKnownShardFilter constructs an expression of the form:
 * NOT pg_catalog.relation_is_a_known_shard(oid)
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>CreateRelationIsAKnownShardFilter</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>pgClassVarno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* oid is always the first column */</comment>
	<decl_stmt><decl><type><name>AttrNumber</name></type> <name>oidAttNum</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>oidVar</name> <init>= <expr><call><name>makeVar</name><argument_list>(<argument><expr><name>pgClassVarno</name></expr></argument>, <argument><expr><name>oidAttNum</name></expr></argument>, <argument><expr><name>OIDOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* build the call to read_intermediate_result */</comment>
	<decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>funcExpr</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>funcExpr</name><operator>-&gt;</operator><name>funcid</name></name> <operator>=</operator> <call><name>RelationIsAKnownShardFuncId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>funcExpr</name><operator>-&gt;</operator><name>funcretset</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>funcExpr</name><operator>-&gt;</operator><name>funcvariadic</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>funcExpr</name><operator>-&gt;</operator><name>funcformat</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>funcExpr</name><operator>-&gt;</operator><name>funccollid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>funcExpr</name><operator>-&gt;</operator><name>inputcollid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>funcExpr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>funcExpr</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>oidVar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>BoolExpr</name> <modifier>*</modifier></type><name>notExpr</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>BoolExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>notExpr</name><operator>-&gt;</operator><name>boolop</name></name> <operator>=</operator> <name>NOT_EXPR</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>notExpr</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>funcExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>notExpr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>notExpr</name></expr>;</return>
</block_content>}</block></function>
</unit>
