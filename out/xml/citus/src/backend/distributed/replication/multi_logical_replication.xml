<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/citus/src/backend/distributed/replication/multi_logical_replication.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * multi_logical_replication.c
 *
 * This file contains functions to use logical replication on the distributed
 * tables for moving/replicating shards.
 *
 * Copyright (c) 2017, Citus Data, Inc.
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-fe.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_version_constants.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/interrupt.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/dbcommands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/hashfn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_subscription_rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_constraint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/adaptive_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_safe_lib.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/colocation_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/connection_management.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/hash_helpers.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/coordinator_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_sync.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_join_order.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_logical_replication.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_partitioning_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/priority.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/distributed_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/remote_commands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/resource_lock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shard_cleaner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shard_rebalancer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shard_transfer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/version_compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/bitmapset.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/scansup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/latch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgrprotos.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/formatting.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/inval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/pg_lsn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ruleutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CURRENT_LOG_POSITION_COMMAND</name></cpp:macro> <cpp:value>"SELECT pg_current_wal_lsn()"</cpp:value></cpp:define>

<comment type="block">/* decimal representation of Adler-16 hash value of citus_shard_move_publication */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHARD_MOVE_ADVISORY_LOCK_FIRST_KEY</name></cpp:macro> <cpp:value>44000</cpp:value></cpp:define>

<comment type="block">/* decimal representation of Adler-16 hash value of citus_shard_move_subscription */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHARD_MOVE_ADVISORY_LOCK_SECOND_KEY</name></cpp:macro> <cpp:value>55152</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>publicationPrefix</name><index>[]</index></name> <init>= <expr><block>{
	<expr><index>[<expr><name>SHARD_MOVE</name></expr>]</index> <operator>=</operator> <literal type="string">"citus_shard_move_publication_"</literal></expr>,
	<expr><index>[<expr><name>SHARD_SPLIT</name></expr>]</index> <operator>=</operator> <literal type="string">"citus_shard_split_publication_"</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>replicationSlotPrefix</name><index>[]</index></name> <init>= <expr><block>{
	<expr><index>[<expr><name>SHARD_MOVE</name></expr>]</index> <operator>=</operator> <literal type="string">"citus_shard_move_slot_"</literal></expr>,
	<expr><index>[<expr><name>SHARD_SPLIT</name></expr>]</index> <operator>=</operator> <literal type="string">"citus_shard_split_slot_"</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * IMPORTANT: All the subscription names should start with "citus_". Otherwise
 * our utility hook does not defend against non-superusers altering or dropping
 * them, which is important for security purposes.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>subscriptionPrefix</name><index>[]</index></name> <init>= <expr><block>{
	<expr><index>[<expr><name>SHARD_MOVE</name></expr>]</index> <operator>=</operator> <literal type="string">"citus_shard_move_subscription_"</literal></expr>,
	<expr><index>[<expr><name>SHARD_SPLIT</name></expr>]</index> <operator>=</operator> <literal type="string">"citus_shard_split_subscription_"</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>subscriptionRolePrefix</name><index>[]</index></name> <init>= <expr><block>{
	<expr><index>[<expr><name>SHARD_MOVE</name></expr>]</index> <operator>=</operator> <literal type="string">"citus_shard_move_subscription_role_"</literal></expr>,
	<expr><index>[<expr><name>SHARD_SPLIT</name></expr>]</index> <operator>=</operator> <literal type="string">"citus_shard_split_subscription_role_"</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>


<comment type="block">/* GUC variable, defaults to 2 hours */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>LogicalReplicationTimeout</name> <init>= <expr><literal type="number">2</literal> <operator>*</operator> <literal type="number">60</literal> <operator>*</operator> <literal type="number">60</literal> <operator>*</operator> <literal type="number">1000</literal></expr></init></decl>;</decl_stmt>


<comment type="block">/* see the comment in master_move_shard_placement */</comment>
<decl_stmt><decl><type><name>bool</name></type> <name>PlacementMovedUsingLogicalReplicationInTX</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* report in every 10 seconds */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>logicalReplicationProgressReportTimeout</name> <init>= <expr><literal type="number">10</literal> <operator>*</operator> <literal type="number">1000</literal></expr></init></decl>;</decl_stmt>


<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>PrepareReplicationSubscriptionList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>GetReplicaIdentityCommandListForShard</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>GetIndexCommandListForShardBackingReplicaIdentity</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>,
																<parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CreatePostLogicalReplicationDataLoadObjects</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>logicalRepTargetList</name></decl></parameter>,
														<parameter><decl><type><name>LogicalRepType</name></type> <name>type</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecuteCreateIndexCommands</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>logicalRepTargetList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecuteCreateConstraintsBackedByIndexCommands</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>logicalRepTargetList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>ConvertNonExistingPlacementDDLCommandsToTasks</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardCommandList</name></decl></parameter>,
															<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>targetNodeName</name></decl></parameter>,
															<parameter><decl><type><name>int</name></type> <name>targetNodePort</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecuteClusterOnCommands</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>logicalRepTargetList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecuteCreateIndexStatisticsCommands</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>logicalRepTargetList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecuteRemainingPostLoadTableCommands</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>logicalRepTargetList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>escape_param_str</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>GetRemoteLSN</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>command</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WaitForMiliseconds</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>timeout</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>GetSubscriptionPosition</name><parameter_list>(
	<parameter><decl><type><name>GroupedLogicalRepTargets</name> <modifier>*</modifier></type><name>groupedLogicalRepTargets</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AcquireLogicalReplicationLock</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type> <name>CreateShardMovePublicationInfoHash</name><parameter_list>(<parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>targetNode</name></decl></parameter>,
												 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardIntervals</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>CreateShardMoveLogicalRepTargetList</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>publicationInfoHash</name></decl></parameter>,
												  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WaitForGroupedLogicalRepTargetsToCatchUp</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>sourcePosition</name></decl></parameter>,
													 <parameter><decl><type><name>GroupedLogicalRepTargets</name> <modifier>*</modifier></type>
													 <name>groupedLogicalRepTargets</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * LogicallyReplicateShards replicates a list of shards from one node to another
 * using logical replication. Once replication is reasonably caught up, writes
 * are blocked and then the publication and subscription are dropped.
 *
 * The caller of the function should ensure that logical replication is applicable
 * for the given shards, source and target nodes. Also, the caller is responsible
 * for ensuring that the input shard list consists of co-located distributed tables
 * or a single shard.
 */</comment>
<function><type><name>void</name></type>
<name>LogicallyReplicateShards</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardList</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sourceNodeName</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sourceNodePort</name></decl></parameter>,
						 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>targetNodeName</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>targetNodePort</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>AcquireLogicalReplicationLock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>superUser</name> <init>= <expr><call><name>CitusExtensionOwnerName</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>databaseName</name> <init>= <expr><call><name>get_database_name</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>connectionFlags</name> <init>= <expr><name>FORCE_NEW_CONNECTION</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>replicationSubscriptionList</name> <init>= <expr><call><name>PrepareReplicationSubscriptionList</name><argument_list>(<argument><expr><name>shardList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* no shards to move */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>replicationSubscriptionList</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>sourceConnection</name> <init>=
		<expr><call><name>GetNodeUserDatabaseConnection</name><argument_list>(<argument><expr><name>connectionFlags</name></expr></argument>, <argument><expr><name>sourceNodeName</name></expr></argument>, <argument><expr><name>sourceNodePort</name></expr></argument>,
									  <argument><expr><name>superUser</name></expr></argument>, <argument><expr><name>databaseName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Operations on publications and replication slots cannot run in a
	 * transaction block. We claim the connections exclusively to ensure they
	 * do not get used for metadata syncing, which does open a transaction
	 * block.
	 */</comment>
	<expr_stmt><expr><call><name>ClaimConnectionExclusively</name><argument_list>(<argument><expr><name>sourceConnection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>sourceNode</name> <init>= <expr><call><name>FindWorkerNode</name><argument_list>(<argument><expr><name>sourceNodeName</name></expr></argument>, <argument><expr><name>sourceNodePort</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>targetNode</name> <init>= <expr><call><name>FindWorkerNode</name><argument_list>(<argument><expr><name>targetNodeName</name></expr></argument>, <argument><expr><name>targetNodePort</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>publicationInfoHash</name> <init>= <expr><call><name>CreateShardMovePublicationInfoHash</name><argument_list>(
		<argument><expr><name>targetNode</name></expr></argument>, <argument><expr><name>replicationSubscriptionList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>logicalRepTargetList</name> <init>= <expr><call><name>CreateShardMoveLogicalRepTargetList</name><argument_list>(<argument><expr><name>publicationInfoHash</name></expr></argument>,
																	 <argument><expr><name>shardList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>groupedLogicalRepTargetsHash</name> <init>= <expr><call><name>CreateGroupedLogicalRepTargetsHash</name><argument_list>(
		<argument><expr><name>logicalRepTargetList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CreateGroupedLogicalRepTargetsConnections</name><argument_list>(<argument><expr><name>groupedLogicalRepTargetsHash</name></expr></argument>, <argument><expr><name>superUser</name></expr></argument>,
											  <argument><expr><name>databaseName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>sourceReplicationConnection</name> <init>=
			<expr><call><name>GetReplicationConnection</name><argument_list>(<argument><expr><name><name>sourceConnection</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>, <argument><expr><name><name>sourceConnection</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* set up the publication on the source and subscription on the target */</comment>
		<expr_stmt><expr><call><name>CreatePublications</name><argument_list>(<argument><expr><name>sourceConnection</name></expr></argument>, <argument><expr><name>publicationInfoHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>snapshot</name> <init>= <expr><call><name>CreateReplicationSlots</name><argument_list>(
			<argument><expr><name>sourceConnection</name></expr></argument>,
			<argument><expr><name>sourceReplicationConnection</name></expr></argument>,
			<argument><expr><name>logicalRepTargetList</name></expr></argument>,
			<argument><expr><literal type="string">"pgoutput"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CreateSubscriptions</name><argument_list>(
			<argument><expr><name>sourceConnection</name></expr></argument>,
			<argument><expr><name><name>sourceConnection</name><operator>-&gt;</operator><name>database</name></name></expr></argument>,
			<argument><expr><name>logicalRepTargetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* only useful for isolation testing, see the function comment for the details */</comment>
		<expr_stmt><expr><call><name>ConflictWithIsolationTestingBeforeCopy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We have to create the primary key (or any other replica identity)
		 * before the update/delete operations that are queued will be
		 * replicated. Because if the replica identity does not exist on the
		 * target, the replication would fail.
		 *
		 * So the latest possible moment we could do this is right after the
		 * initial data COPY, but before enabling the susbcriptions. It might
		 * seem like a good idea to it after the initial data COPY, since
		 * it's generally the rule that it's cheaper to build an index at once
		 * than to create it incrementally. This general rule, is why we create
		 * all the regular indexes as late during the move as possible.
		 *
		 * But as it turns out in practice it's not as clear cut, and we saw a
		 * speed degradation in the time it takes to move shards when doing the
		 * replica identity creation after the initial COPY. So, instead we
		 * keep it before the COPY.
		 */</comment>
		<expr_stmt><expr><call><name>CreateReplicaIdentities</name><argument_list>(<argument><expr><name>logicalRepTargetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>UpdatePlacementUpdateStatusForShardIntervalList</name><argument_list>(
			<argument><expr><name>shardList</name></expr></argument>,
			<argument><expr><name>sourceNodeName</name></expr></argument>,
			<argument><expr><name>sourceNodePort</name></expr></argument>,
			<argument><expr><name>PLACEMENT_UPDATE_STATUS_COPYING_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CopyShardsToNode</name><argument_list>(<argument><expr><name>sourceNode</name></expr></argument>, <argument><expr><name>targetNode</name></expr></argument>, <argument><expr><name>shardList</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We can close this connection now, because we're done copying the
		 * data and thus don't need access to the snapshot anymore. The
		 * replication slot will still be at the same LSN, because the
		 * subscriptions have not been enabled yet.
		 */</comment>
		<expr_stmt><expr><call><name>CloseConnection</name><argument_list>(<argument><expr><name>sourceReplicationConnection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Start the replication and copy all data
		 */</comment>
		<expr_stmt><expr><call><name>CompleteNonBlockingShardTransfer</name><argument_list>(<argument><expr><name>shardList</name></expr></argument>,
										 <argument><expr><name>sourceConnection</name></expr></argument>,
										 <argument><expr><name>publicationInfoHash</name></expr></argument>,
										 <argument><expr><name>logicalRepTargetList</name></expr></argument>,
										 <argument><expr><name>groupedLogicalRepTargetsHash</name></expr></argument>,
										 <argument><expr><name>SHARD_MOVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We use these connections exclusively for subscription management,
		 * because otherwise subsequent metadata changes may inadvertedly use
		 * these connections instead of the connections that were used to
		 * grab locks in BlockWritesToShardList.
		 */</comment>
		<expr_stmt><expr><call><name>CloseGroupedLogicalRepTargetsConnections</name><argument_list>(<argument><expr><name>groupedLogicalRepTargetsHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CloseConnection</name><argument_list>(<argument><expr><name>sourceConnection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block">/* We don't need to UnclaimConnections since we're already erroring out */</comment>

		<comment type="block">/*
		 * Drop temporary objects that were marked as CLEANUP_ON_FAILURE
		 * or CLEANUP_ALWAYS.
		 */</comment>
		<expr_stmt><expr><call><name>FinalizeOperationNeedingCleanupOnFailure</name><argument_list>(<argument><expr><literal type="string">"citus_[move/copy]_shard_placement"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CreateGroupedLogicalRepTargetsHash creates a hashmap that groups the subscriptions
 * logicalRepTargetList by node. This is useful for cases where we want to
 * iterate the subscriptions by node, so we can batch certain operations, such
 * as checking subscription readiness.
 */</comment>
<function><type><name>HTAB</name> <modifier>*</modifier></type>
<name>CreateGroupedLogicalRepTargetsHash</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>logicalRepTargetList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>logicalRepTargetsHash</name> <init>= <expr><call><name>CreateSimpleHash</name><argument_list>(<argument><expr><name>uint32</name></expr></argument>, <argument><expr><name>GroupedLogicalRepTargets</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LogicalRepTarget</name> <modifier>*</modifier></type><name>target</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>target</argument>, <argument>logicalRepTargetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>GroupedLogicalRepTargets</name> <modifier>*</modifier></type><name>groupedLogicalRepTargets</name> <init>=
			<expr><operator>(</operator><name>GroupedLogicalRepTargets</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(
				<argument><expr><name>logicalRepTargetsHash</name></expr></argument>,
				<argument><expr><operator>&amp;</operator><name><name>target</name><operator>-&gt;</operator><name>replicationSlot</name><operator>-&gt;</operator><name>targetNodeId</name></name></expr></argument>,
				<argument><expr><name>HASH_ENTER</name></expr></argument>,
				<argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>groupedLogicalRepTargets</name><operator>-&gt;</operator><name>logicalRepTargetList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>groupedLogicalRepTargets</name><operator>-&gt;</operator><name>superuserConnection</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>groupedLogicalRepTargets</name><operator>-&gt;</operator><name>logicalRepTargetList</name></name> <operator>=</operator>
			<call><name>lappend</name><argument_list>(<argument><expr><name><name>groupedLogicalRepTargets</name><operator>-&gt;</operator><name>logicalRepTargetList</name></name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<return>return <expr><name>logicalRepTargetsHash</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CompleteNonBlockingShardTransfer uses logical replication to apply the changes
 * made on the source to the target. It also runs all DDL on the target shards
 * that need to be run after the data copy.
 *
 * For shard splits it skips the partition hierarchy and foreign key creation
 * though, since those need to happen after the metadata is updated.
 */</comment>
<function><type><name>void</name></type>
<name>CompleteNonBlockingShardTransfer</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardList</name></decl></parameter>,
								 <parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>sourceConnection</name></decl></parameter>,
								 <parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>publicationInfoHash</name></decl></parameter>,
								 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>logicalRepTargetList</name></decl></parameter>,
								 <parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>groupedLogicalRepTargetsHash</name></decl></parameter>,
								 <parameter><decl><type><name>LogicalRepType</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Start applying the changes from the replication slots to catch up. */</comment>
	<expr_stmt><expr><call><name>EnableSubscriptions</name><argument_list>(<argument><expr><name>logicalRepTargetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>UpdatePlacementUpdateStatusForShardIntervalList</name><argument_list>(
		<argument><expr><name>shardList</name></expr></argument>,
		<argument><expr><name><name>sourceConnection</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>,
		<argument><expr><name><name>sourceConnection</name><operator>-&gt;</operator><name>port</name></name></expr></argument>,
		<argument><expr><name>PLACEMENT_UPDATE_STATUS_CATCHING_UP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Wait until all the subscriptions are caught up to changes that
	 * happened after the initial COPY on the shards.
	 */</comment>
	<expr_stmt><expr><call><name>WaitForAllSubscriptionsToCatchUp</name><argument_list>(<argument><expr><name>sourceConnection</name></expr></argument>, <argument><expr><name>groupedLogicalRepTargetsHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>UpdatePlacementUpdateStatusForShardIntervalList</name><argument_list>(
		<argument><expr><name>shardList</name></expr></argument>,
		<argument><expr><name><name>sourceConnection</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>,
		<argument><expr><name><name>sourceConnection</name><operator>-&gt;</operator><name>port</name></name></expr></argument>,
		<argument><expr><name>PLACEMENT_UPDATE_STATUS_CREATING_CONSTRAINTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now lets create the post-load objects, such as the indexes, constraints
	 * and partitioning hierarchy. Once they are done, wait until the replication
	 * catches up again. So we don't block writes too long.
	 */</comment>
	<expr_stmt><expr><call><name>CreatePostLogicalReplicationDataLoadObjects</name><argument_list>(<argument><expr><name>logicalRepTargetList</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>UpdatePlacementUpdateStatusForShardIntervalList</name><argument_list>(
		<argument><expr><name>shardList</name></expr></argument>,
		<argument><expr><name><name>sourceConnection</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>,
		<argument><expr><name><name>sourceConnection</name><operator>-&gt;</operator><name>port</name></name></expr></argument>,
		<argument><expr><name>PLACEMENT_UPDATE_STATUS_FINAL_CATCH_UP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WaitForAllSubscriptionsToCatchUp</name><argument_list>(<argument><expr><name>sourceConnection</name></expr></argument>, <argument><expr><name>groupedLogicalRepTargetsHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<comment type="block">/* only useful for isolation testing, see the function comment for the details */</comment>
	<expr_stmt><expr><call><name>ConflictWithIsolationTestingAfterCopy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We're almost done, we'll block the writes to the shards that we're
	 * replicating and expect all the subscription to catch up quickly
	 * afterwards.
	 *
	 * Notice that although shards in partitioned relation are excluded from
	 * logical replication, they are still locked against modification, and
	 * foreign constraints are created on them too.
	 */</comment>
	<expr_stmt><expr><call><name>BlockWritesToShardList</name><argument_list>(<argument><expr><name>shardList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WaitForAllSubscriptionsToCatchUp</name><argument_list>(<argument><expr><name>sourceConnection</name></expr></argument>, <argument><expr><name>groupedLogicalRepTargetsHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>SHARD_SPLIT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>UpdatePlacementUpdateStatusForShardIntervalList</name><argument_list>(
			<argument><expr><name>shardList</name></expr></argument>,
			<argument><expr><name><name>sourceConnection</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>,
			<argument><expr><name><name>sourceConnection</name><operator>-&gt;</operator><name>port</name></name></expr></argument>,
			<argument><expr><name>PLACEMENT_UPDATE_STATUS_CREATING_FOREIGN_KEYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We're creating the foreign constraints to reference tables after the
		 * data is already replicated and all the necessary locks are acquired.
		 *
		 * We prefer to do it here because the placements of reference tables
		 * are always valid, and any modification during the shard move would
		 * cascade to the hash distributed tables' shards if we had created
		 * the constraints earlier. The same is true for foreign keys between
		 * tables owned by different users.
		 */</comment>
		<expr_stmt><expr><call><name>CreateUncheckedForeignKeyConstraints</name><argument_list>(<argument><expr><name>logicalRepTargetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>UpdatePlacementUpdateStatusForShardIntervalList</name><argument_list>(
		<argument><expr><name>shardList</name></expr></argument>,
		<argument><expr><name><name>sourceConnection</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>,
		<argument><expr><name><name>sourceConnection</name><operator>-&gt;</operator><name>port</name></name></expr></argument>,
		<argument><expr><name>PLACEMENT_UPDATE_STATUS_COMPLETING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CreateShardMovePublicationInfoHash creates hashmap of PublicationInfos for a
 * shard move. Even though we only support moving a shard to a single target
 * node, the resulting hashmap can have multiple PublicationInfos in it.
 * The reason for that is that we need a separate publication for each
 * distributed table owning user in the shard group.
 */</comment>
<function><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type>
<name>CreateShardMovePublicationInfoHash</name><parameter_list>(<parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>targetNode</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardIntervals</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>publicationInfoHash</name> <init>= <expr><call><name>CreateSimpleHash</name><argument_list>(<argument><expr><name>NodeAndOwner</name></expr></argument>, <argument><expr><name>PublicationInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>shardInterval</argument>, <argument>shardIntervals</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>NodeAndOwner</name></type> <name>key</name></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>key</name><operator>.</operator><name>nodeId</name></name> <operator>=</operator> <name><name>targetNode</name><operator>-&gt;</operator><name>nodeId</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>key</name><operator>.</operator><name>tableOwnerId</name></name> <operator>=</operator> <call><name>TableOwnerOid</name><argument_list>(<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PublicationInfo</name> <modifier>*</modifier></type><name>publicationInfo</name> <init>=
			<expr><operator>(</operator><name>PublicationInfo</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>publicationInfoHash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>,
											<argument><expr><name>HASH_ENTER</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>publicationInfo</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>PublicationName</name><argument_list>(<argument><expr><name>SHARD_MOVE</name></expr></argument>, <argument><expr><name><name>key</name><operator>.</operator><name>nodeId</name></name></expr></argument>,
													<argument><expr><name><name>key</name><operator>.</operator><name>tableOwnerId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>publicationInfo</name><operator>-&gt;</operator><name>shardIntervals</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>publicationInfo</name><operator>-&gt;</operator><name>shardIntervals</name></name> <operator>=</operator>
			<call><name>lappend</name><argument_list>(<argument><expr><name><name>publicationInfo</name><operator>-&gt;</operator><name>shardIntervals</name></name></expr></argument>, <argument><expr><name>shardInterval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<return>return <expr><name>publicationInfoHash</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateShardMoveLogicalRepTargetList creates the list containing all the
 * subscriptions that should be connected to the publications in the given
 * publicationHash.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>CreateShardMoveLogicalRepTargetList</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>publicationInfoHash</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>logicalRepTargetList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>publicationInfoHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>nodeId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>PublicationInfo</name> <modifier>*</modifier></type><name>publication</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>publication</name> <operator>=</operator> <operator>(</operator><name>PublicationInfo</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>ownerId</name> <init>= <expr><name><name>publication</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>tableOwnerId</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>nodeId</name> <operator>=</operator> <name><name>publication</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>nodeId</name></name></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>LogicalRepTarget</name> <modifier>*</modifier></type><name>target</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LogicalRepTarget</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>subscriptionName</name></name> <operator>=</operator> <call><name>SubscriptionName</name><argument_list>(<argument><expr><name>SHARD_MOVE</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>tableOwnerId</name></name> <operator>=</operator> <name>ownerId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>publication</name></name> <operator>=</operator> <name>publication</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>publication</name><operator>-&gt;</operator><name>target</name></name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>newShards</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>subscriptionOwnerName</name></name> <operator>=</operator> <call><name>SubscriptionRoleName</name><argument_list>(<argument><expr><name>SHARD_MOVE</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>replicationSlot</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ReplicationSlotInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>replicationSlot</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator>
			<call><name>ReplicationSlotNameForNodeAndOwnerForOperation</name><argument_list>(<argument><expr><name>SHARD_MOVE</name></expr></argument>,
														   <argument><expr><name>nodeId</name></expr></argument>,
														   <argument><expr><name>ownerId</name></expr></argument>,
														   <argument><expr><name>CurrentOperationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>replicationSlot</name><operator>-&gt;</operator><name>targetNodeId</name></name> <operator>=</operator> <name>nodeId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>replicationSlot</name><operator>-&gt;</operator><name>tableOwnerId</name></name> <operator>=</operator> <name>ownerId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>logicalRepTargetList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>logicalRepTargetList</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>shardInterval</argument>, <argument>shardList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>NodeAndOwner</name></type> <name>key</name></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>key</name><operator>.</operator><name>nodeId</name></name> <operator>=</operator> <name>nodeId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>key</name><operator>.</operator><name>tableOwnerId</name></name> <operator>=</operator> <call><name>TableOwnerOid</name><argument_list>(<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>publication</name> <operator>=</operator> <operator>(</operator><name>PublicationInfo</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(
			<argument><expr><name>publicationInfoHash</name></expr></argument>,
			<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>,
			<argument><expr><name>HASH_FIND</name></expr></argument>,
			<argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Could not find publication matching a split"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>publication</name><operator>-&gt;</operator><name>target</name><operator>-&gt;</operator><name>newShards</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(
			<argument><expr><name><name>publication</name><operator>-&gt;</operator><name>target</name><operator>-&gt;</operator><name>newShards</name></name></expr></argument>, <argument><expr><name>shardInterval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<return>return <expr><name>logicalRepTargetList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AcquireLogicalReplicationLock tries to acquire a lock for logical
 * replication. We need this lock, because at the start of logical replication
 * we clean up old subscriptions and publications. Because of this cleanup it's
 * not safe to run multiple logical replication based shard moves at the same
 * time. If multiple logical replication moves would run at the same time, the
 * second move might clean up subscriptions and publications that are in use by
 * another move.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AcquireLogicalReplicationLock</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKTAG</name></type> <name>tag</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>SET_LOCKTAG_LOGICAL_REPLICATION</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * PrepareReplicationSubscriptionList returns list of shards to be logically
 * replicated from given shard list. This is needed because Postgres does not
 * allow logical replication on partitioned tables, therefore shards belonging
 * to a partitioned tables should be exluded from logical replication
 * subscription list.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>PrepareReplicationSubscriptionList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>replicationSubscriptionList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>shardCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>shardCell</argument>, <argument>shardList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><operator>(</operator><name>ShardInterval</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>shardCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PartitionedTable</name><argument_list>(<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* only add regular and child tables to subscription */</comment>
			<expr_stmt><expr><name>replicationSubscriptionList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>replicationSubscriptionList</name></expr></argument>,
												  <argument><expr><name>shardInterval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>replicationSubscriptionList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateReplicaIdentities creates replica identities for all the shards that
 * are part of the given subscriptions.
 */</comment>
<function><type><name>void</name></type>
<name>CreateReplicaIdentities</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>logicalRepTargetList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LogicalRepTarget</name> <modifier>*</modifier></type><name>target</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>target</argument>, <argument>logicalRepTargetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>superuserConnection</name> <init>= <expr><name><name>target</name><operator>-&gt;</operator><name>superuserConnection</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>CreateReplicaIdentitiesOnNode</name><argument_list>(
			<argument><expr><name><name>target</name><operator>-&gt;</operator><name>newShards</name></name></expr></argument>,
			<argument><expr><name><name>superuserConnection</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>,
			<argument><expr><name><name>superuserConnection</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * CreateReplicaIdentitiesOnNode gets a shardList and creates all the replica
 * identities on the shards in the given node.
 */</comment>
<function><type><name>void</name></type>
<name>CreateReplicaIdentitiesOnNode</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardList</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>nodeName</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>nodePort</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>localContext</name> <init>= <expr><call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
													   <argument><expr><literal type="string">"CreateReplicaIdentitiesOnNode"</literal></expr></argument>,
													   <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>localContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>shardInterval</argument>, <argument>shardList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint64</name></type> <name>shardId</name> <init>= <expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name><name>shardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>backingIndexCommandList</name> <init>=
			<expr><call><name>GetIndexCommandListForShardBackingReplicaIdentity</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>replicaIdentityShardCommandList</name> <init>=
			<expr><call><name>GetReplicaIdentityCommandListForShard</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commandList</name> <init>=
			<expr><call><name>list_concat</name><argument_list>(<argument><expr><name>backingIndexCommandList</name></expr></argument>, <argument><expr><name>replicaIdentityShardCommandList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>commandList</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Creating replica identity for shard %ld on "</literal>
									<literal type="string">"target node %s:%d"</literal></expr></argument>, <argument><expr><name>shardId</name></expr></argument>, <argument><expr><name>nodeName</name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>SendCommandListToWorkerOutsideTransaction</name><argument_list>(<argument><expr><name>nodeName</name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>,
													  <argument><expr><call><name>TableOwner</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>,
													  <argument><expr><name>commandList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>localContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * GetIndexCommandListForShardBackingReplicaIdentity returns all the create index
 * commands that are needed to create replica identity. If the table doesn't have
 * a replica identity, the function returns NIL.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>GetIndexCommandListForShardBackingReplicaIdentity</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commandList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>replicaIdentityIndex</name> <init>= <expr><call><name>GetRelationIdentityOrPK</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>replicaIdentityIndex</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The replica identity is backed by an index or primary key,
		 * so get the index/pkey definition first.
		 */</comment>
		<decl_stmt><decl><type><name>HeapTuple</name></type> <name>indexTuple</name> <init>=
			<expr><call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>replicaIdentityIndex</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* should not happen */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for index %u"</literal></expr></argument>, <argument><expr><name>replicaIdentityIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>Form_pg_index</name></type> <name>indexForm</name> <init>= <expr><operator>(</operator><operator>(</operator><name>Form_pg_index</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>indexCommandTableDDLList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>indexFlags</name> <init>= <expr><name>INCLUDE_INDEX_ALL_STATEMENTS</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>GatherIndexAndConstraintDefinitionList</name><argument_list>(<argument><expr><name>indexForm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>indexCommandTableDDLList</name></expr></argument>,
											   <argument><expr><name>indexFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>indexCommandShardDDLList</name> <init>=
			<expr><call><name>WorkerApplyShardDDLCommandList</name><argument_list>(<argument><expr><name>indexCommandTableDDLList</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>commandList</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>commandList</name></expr></argument>, <argument><expr><name>indexCommandShardDDLList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>commandList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetReplicaIdentityCommandListForShard returns the create replica identity
 * command that are needed to create replica identity. If the table doesn't have
 * a replica identity, the function returns NIL.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>GetReplicaIdentityCommandListForShard</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>replicaIdentityTableDDLCommand</name> <init>=
		<expr><call><name>GetTableReplicaIdentityCommand</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>replicaIdentityShardCommandList</name> <init>=
		<expr><call><name>WorkerApplyShardDDLCommandList</name><argument_list>(<argument><expr><name>replicaIdentityTableDDLCommand</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>replicaIdentityShardCommandList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreatePostLogicalReplicationDataLoadObjects gets a shardList and creates all
 * the objects that can be created after the data is moved with logical replication.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CreatePostLogicalReplicationDataLoadObjects</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>logicalRepTargetList</name></decl></parameter>,
											<parameter><decl><type><name>LogicalRepType</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We create indexes in 4 steps.
	 *  - CREATE INDEX statements
	 *  - CREATE CONSTRAINT statements that are backed by
	 *    indexes (unique and exclude constraints)
	 *  - ALTER TABLE %s CLUSTER ON %s
	 *  - ALTER INDEX %s ALTER COLUMN %d SET STATISTICS %d
	 *
	 *  On each step, we execute can execute commands in parallel. For example,
	 *  multiple indexes on the shard table or indexes for the colocated shards
	 *  can be created in parallel. However, the latter two steps, clustering the
	 *  table and setting the statistics of indexes, depends on the indexes being
	 *  created. That's why the execution is divided into four distinct stages.
	 */</comment>
	<expr_stmt><expr><call><name>ExecuteCreateIndexCommands</name><argument_list>(<argument><expr><name>logicalRepTargetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecuteCreateConstraintsBackedByIndexCommands</name><argument_list>(<argument><expr><name>logicalRepTargetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecuteClusterOnCommands</name><argument_list>(<argument><expr><name>logicalRepTargetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecuteCreateIndexStatisticsCommands</name><argument_list>(<argument><expr><name>logicalRepTargetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Once the indexes are created, there are few more objects like triggers and table
	 * statistics that should be created after the data move.
	 */</comment>
	<expr_stmt><expr><call><name>ExecuteRemainingPostLoadTableCommands</name><argument_list>(<argument><expr><name>logicalRepTargetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Creating the partitioning hierarchy errors out in shard splits when
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>SHARD_SPLIT</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* create partitioning hierarchy, if any */</comment>
		<expr_stmt><expr><call><name>CreatePartitioningHierarchy</name><argument_list>(<argument><expr><name>logicalRepTargetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ExecuteCreateIndexCommands gets a shardList and creates all the indexes
 * for the given shardList in the given target node.
 *
 * The execution is done in parallel, and throws an error if any of the
 * commands fail.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecuteCreateIndexCommands</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>logicalRepTargetList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LogicalRepTarget</name> <modifier>*</modifier></type><name>target</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>target</argument>, <argument>logicalRepTargetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>shardInterval</argument>, <argument>target-&gt;newShards</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name><name>shardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>tableCreateIndexCommandList</name> <init>=
				<expr><call><name>GetTableIndexAndConstraintCommandsExcludingReplicaIdentity</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>,
																		   <argument><expr><name>INCLUDE_CREATE_INDEX_STATEMENTS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardCreateIndexCommandList</name> <init>=
				<expr><call><name>WorkerApplyShardDDLCommandList</name><argument_list>(<argument><expr><name>tableCreateIndexCommandList</name></expr></argument>,
											   <argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>taskListForShard</name> <init>=
				<expr><call><name>ConvertNonExistingPlacementDDLCommandsToTasks</name><argument_list>(
					<argument><expr><name>shardCreateIndexCommandList</name></expr></argument>,
					<argument><expr><name><name>target</name><operator>-&gt;</operator><name>superuserConnection</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>,
					<argument><expr><name><name>target</name><operator>-&gt;</operator><name>superuserConnection</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>taskList</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>, <argument><expr><name>taskListForShard</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block>

	<comment type="block">/*
	 * We are going to create indexes and constraints using the current user. That is
	 * alright because an index/constraint always belongs to the owner of the table,
	 * and Citus already ensures that the current user owns all the tables that are
	 * moved.
	 *
	 * CREATE INDEX commands acquire ShareLock on a relation. So, it is
	 * allowed to run multiple CREATE INDEX commands concurrently on a table
	 * and across different tables (e.g., shards).
	 */</comment>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Creating post logical replication objects "</literal>
							<literal type="string">"(indexes)"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecuteTaskListOutsideTransaction</name><argument_list>(<argument><expr><name>ROW_MODIFY_NONE</name></expr></argument>, <argument><expr><name>taskList</name></expr></argument>,
									  <argument><expr><name>MaxAdaptiveExecutorPoolSize</name></expr></argument>,
									  <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ExecuteCreateConstraintsBackedByIndexCommands gets a shardList and creates all the constraints
 * that are backed by indexes for the given shardList in the given target node.
 *
 * The execution is done in sequential mode, and throws an error if any of the
 * commands fail.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecuteCreateConstraintsBackedByIndexCommands</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>logicalRepTargetList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Creating post logical replication objects "</literal>
							<literal type="string">"(constraints backed by indexes)"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>localContext</name> <init>= <expr><call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
													   <argument><expr><literal type="string">"CreateConstraintsBackedByIndexContext"</literal></expr></argument>,
													   <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>localContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>LogicalRepTarget</name> <modifier>*</modifier></type><name>target</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>target</argument>, <argument>logicalRepTargetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>shardInterval</argument>, <argument>target-&gt;newShards</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name><name>shardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>tableCreateConstraintCommandList</name> <init>=
				<expr><call><name>GetTableIndexAndConstraintCommandsExcludingReplicaIdentity</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>,
																		   <argument><expr><name>INCLUDE_CREATE_CONSTRAINT_STATEMENTS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>tableCreateConstraintCommandList</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* no constraints backed by indexes, skip */</comment>
				<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>localContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardCreateConstraintCommandList</name> <init>=
				<expr><call><name>WorkerApplyShardDDLCommandList</name><argument_list>(<argument><expr><name>tableCreateConstraintCommandList</name></expr></argument>,
											   <argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tableOwner</name> <init>= <expr><call><name>TableOwner</name><argument_list>(<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>SendCommandListToWorkerOutsideTransaction</name><argument_list>(
				<argument><expr><name><name>target</name><operator>-&gt;</operator><name>superuserConnection</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>,
				<argument><expr><name><name>target</name><operator>-&gt;</operator><name>superuserConnection</name><operator>-&gt;</operator><name>port</name></name></expr></argument>,
				<argument><expr><name>tableOwner</name></expr></argument>,
				<argument><expr><name>shardCreateConstraintCommandList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>localContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ConvertNonExistingShardDDLCommandsToTasks generates one task per input
 * element in shardCommandList.
 *
 * The generated tasks' placements do not exist (yet). We are generating
 * fake placements for the tasks.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>ConvertNonExistingPlacementDDLCommandsToTasks</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardCommandList</name></decl></parameter>,
											  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>targetNodeName</name></decl></parameter>,
											  <parameter><decl><type><name>int</name></type> <name>targetNodePort</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><call><name>FindWorkerNodeOrError</name><argument_list>(<argument><expr><name>targetNodeName</name></expr></argument>, <argument><expr><name>targetNodePort</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>jobId</name> <init>= <expr><name>INVALID_JOB_ID</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>commandCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>taskId</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<macro><name>foreach</name><argument_list>(<argument>commandCell</argument>, <argument>shardCommandList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>command</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>commandCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name> <init>= <expr><call><name>CreateBasicTask</name><argument_list>(<argument><expr><name>jobId</name></expr></argument>, <argument><expr><name>taskId</name></expr></argument>, <argument><expr><name>DDL_TASK</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* this placement currently does not exist */</comment>
		<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>taskPlacement</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>ShardPlacement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>SetPlacementNodeMetadata</name><argument_list>(<argument><expr><name>taskPlacement</name></expr></argument>, <argument><expr><name>workerNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>taskPlacementList</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>taskPlacement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>taskList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>, <argument><expr><name>task</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>taskId</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>taskList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExecuteClusterOnCommands gets a shardList and creates all the CLUSTER ON commands
 * for the given shardList in the given target node.
 *
 * The execution is done in parallel, and in case of any failure, the transaction
 * is aborted.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecuteClusterOnCommands</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>logicalRepTargetList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LogicalRepTarget</name> <modifier>*</modifier></type><name>target</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>target</argument>, <argument>logicalRepTargetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>shardInterval</argument>, <argument>target-&gt;newShards</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name><name>shardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>tableAlterTableClusterOnCommandList</name> <init>=
				<expr><call><name>GetTableIndexAndConstraintCommandsExcludingReplicaIdentity</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>,
																		   <argument><expr><name>INCLUDE_INDEX_CLUSTERED_STATEMENTS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardAlterTableClusterOnCommandList</name> <init>=
				<expr><call><name>WorkerApplyShardDDLCommandList</name><argument_list>(<argument><expr><name>tableAlterTableClusterOnCommandList</name></expr></argument>,
											   <argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>taskListForShard</name> <init>=
				<expr><call><name>ConvertNonExistingPlacementDDLCommandsToTasks</name><argument_list>(
					<argument><expr><name>shardAlterTableClusterOnCommandList</name></expr></argument>,
					<argument><expr><name><name>target</name><operator>-&gt;</operator><name>superuserConnection</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>,
					<argument><expr><name><name>target</name><operator>-&gt;</operator><name>superuserConnection</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>taskList</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>, <argument><expr><name>taskListForShard</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Creating post logical replication objects "</literal>
							<literal type="string">"(CLUSTER ON)"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecuteTaskListOutsideTransaction</name><argument_list>(<argument><expr><name>ROW_MODIFY_NONE</name></expr></argument>, <argument><expr><name>taskList</name></expr></argument>,
									  <argument><expr><name>MaxAdaptiveExecutorPoolSize</name></expr></argument>,
									  <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ExecuteCreateIndexStatisticsCommands gets a shardList and creates
 * all the statistics objects for the indexes in the given target node.
 *
 * The execution is done in sequentially, and in case of any failure, the transaction
 * is aborted.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecuteCreateIndexStatisticsCommands</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>logicalRepTargetList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Creating post logical replication objects "</literal>
							<literal type="string">"(index statistics)"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>localContext</name> <init>= <expr><call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
													   <argument><expr><literal type="string">"CreateIndexStatisticsContext"</literal></expr></argument>,
													   <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>localContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>LogicalRepTarget</name> <modifier>*</modifier></type><name>target</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>target</argument>, <argument>logicalRepTargetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>shardInterval</argument>, <argument>target-&gt;newShards</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name><name>shardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>tableAlterIndexSetStatisticsCommandList</name> <init>=
				<expr><call><name>GetTableIndexAndConstraintCommandsExcludingReplicaIdentity</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>,
																		   <argument><expr><name>INCLUDE_INDEX_STATISTICS_STATEMENTTS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardAlterIndexSetStatisticsCommandList</name> <init>=
				<expr><call><name>WorkerApplyShardDDLCommandList</name><argument_list>(<argument><expr><name>tableAlterIndexSetStatisticsCommandList</name></expr></argument>,
											   <argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>shardAlterIndexSetStatisticsCommandList</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* no index statistics exists, skip */</comment>
				<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>localContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * These remaining operations do not require significant resources, so no
			 * need to create them in parallel.
			 */</comment>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tableOwner</name> <init>= <expr><call><name>TableOwner</name><argument_list>(<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>SendCommandListToWorkerOutsideTransaction</name><argument_list>(
				<argument><expr><name><name>target</name><operator>-&gt;</operator><name>superuserConnection</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>,
				<argument><expr><name><name>target</name><operator>-&gt;</operator><name>superuserConnection</name><operator>-&gt;</operator><name>port</name></name></expr></argument>,
				<argument><expr><name>tableOwner</name></expr></argument>,
				<argument><expr><name>shardAlterIndexSetStatisticsCommandList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>localContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ExecuteRemainingPostLoadTableCommands gets a shardList and creates
 * all the remaining post load objects other than the indexes
 * in the given target node.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecuteRemainingPostLoadTableCommands</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>logicalRepTargetList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Creating post logical replication objects "</literal>
							<literal type="string">"(triggers and table statistics)"</literal></expr></argument>
							)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>localContext</name> <init>= <expr><call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
													   <argument><expr><literal type="string">"CreateTableStatisticsContext"</literal></expr></argument>,
													   <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>localContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>LogicalRepTarget</name> <modifier>*</modifier></type><name>target</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>target</argument>, <argument>logicalRepTargetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>shardInterval</argument>, <argument>target-&gt;newShards</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name><name>shardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>bool</name></type> <name>includeIndexes</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>includeReplicaIdentity</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>tablePostLoadTableCommandList</name> <init>=
				<expr><call><name>GetPostLoadTableCreationCommands</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>includeIndexes</name></expr></argument>,
												 <argument><expr><name>includeReplicaIdentity</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardPostLoadTableCommandList</name> <init>=
				<expr><call><name>WorkerApplyShardDDLCommandList</name><argument_list>(<argument><expr><name>tablePostLoadTableCommandList</name></expr></argument>,
											   <argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>shardPostLoadTableCommandList</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* no index statistics exists, skip */</comment>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * These remaining operations do not require significant resources, so no
			 * need to create them in parallel.
			 */</comment>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tableOwner</name> <init>= <expr><call><name>TableOwner</name><argument_list>(<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>SendCommandListToWorkerOutsideTransaction</name><argument_list>(
				<argument><expr><name><name>target</name><operator>-&gt;</operator><name>superuserConnection</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>,
				<argument><expr><name><name>target</name><operator>-&gt;</operator><name>superuserConnection</name><operator>-&gt;</operator><name>port</name></name></expr></argument>,
				<argument><expr><name>tableOwner</name></expr></argument>,
				<argument><expr><name>shardPostLoadTableCommandList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>localContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CreatePartitioningHierarchy gets a shardList and creates the partitioning
 * hierarchy between the shardList, if any,
 */</comment>
<function><type><name>void</name></type>
<name>CreatePartitioningHierarchy</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>logicalRepTargetList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Creating post logical replication objects "</literal>
							<literal type="string">"(partitioning hierarchy)"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>localContext</name> <init>= <expr><call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
													   <argument><expr><literal type="string">"CreatePartitioningHierarchy"</literal></expr></argument>,
													   <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>localContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>LogicalRepTarget</name> <modifier>*</modifier></type><name>target</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>target</argument>, <argument>logicalRepTargetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>shardInterval</argument>, <argument>target-&gt;newShards</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>PartitionTable</name><argument_list>(<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>attachPartitionCommand</name> <init>=
					<expr><call><name>GenerateAttachShardPartitionCommand</name><argument_list>(<argument><expr><name>shardInterval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tableOwner</name> <init>= <expr><call><name>TableOwner</name><argument_list>(<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * Attaching partition may acquire conflicting locks when created in
				 * parallel, so create them sequentially. Also attaching partition
				 * is a quick operation, so it is fine to execute sequentially.
				 */</comment>

				<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>=
					<expr><call><name>GetNodeUserDatabaseConnection</name><argument_list>(<argument><expr><name>OUTSIDE_TRANSACTION</name></expr></argument>,
												  <argument><expr><name><name>target</name><operator>-&gt;</operator><name>superuserConnection</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>,
												  <argument><expr><name><name>target</name><operator>-&gt;</operator><name>superuserConnection</name><operator>-&gt;</operator><name>port</name></name></expr></argument>,
												  <argument><expr><name>tableOwner</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>ExecuteCriticalRemoteCommand</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>attachPartitionCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>localContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CreateUncheckedForeignKeyConstraints is used to create the foreign
 * constraints on the logical replication target without checking that they are
 * actually valid.
 *
 * We skip the validation phase of foreign keys to after a shard
 * move/copy/split because the validation is pretty costly and given that the
 * source placements are already valid, the validation in the target nodes is
 * useless.
 */</comment>
<function><type><name>void</name></type>
<name>CreateUncheckedForeignKeyConstraints</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>logicalRepTargetList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>localContext</name> <init>=
		<expr><call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
							  <argument><expr><literal type="string">"CreateKeyForeignConstraints"</literal></expr></argument>,
							  <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>localContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


	<comment type="block">/*
	 * Iterate over all the shards in the shard group.
	 */</comment>
	<decl_stmt><decl><type><name>LogicalRepTarget</name> <modifier>*</modifier></type><name>target</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>target</argument>, <argument>logicalRepTargetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Iterate on split shards list for a given shard and create constraints.
		 */</comment>
		<macro><name>foreach_ptr</name><argument_list>(<argument>shardInterval</argument>, <argument>target-&gt;newShards</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commandList</name> <init>= <expr><call><name>CopyShardForeignConstraintCommandList</name><argument_list>(
				<argument><expr><name>shardInterval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>commandList</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(
				<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><literal type="string">"SET LOCAL citus.skip_constraint_validation TO ON;"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>commandList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>SendCommandListToWorkerOutsideTransactionWithConnection</name><argument_list>(
				<argument><expr><name><name>target</name><operator>-&gt;</operator><name>superuserConnection</name></name></expr></argument>,
				<argument><expr><name>commandList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>localContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ConflictWithIsolationTestingBeforeCopy is only useful to test
 * get_rebalance_progress by pausing before doing the actual copy. This way we
 * can see the state of the tables at that point. This should not be called by
 * any code-path except for code paths to move and split shards().
 *
 * Note that since the cost of calling this function is pretty low, we prefer
 * to use it in non-assert builds as well not to diverge in the behaviour.
 */</comment>
<function><type><specifier>extern</specifier> <name>void</name></type>
<name>ConflictWithIsolationTestingBeforeCopy</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKTAG</name></type> <name>tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>sessionLock</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>dontWait</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>RunningUnderIsolationTest</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SET_LOCKTAG_ADVISORY</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>MyDatabaseId</name></expr></argument>,
							 <argument><expr><name>SHARD_MOVE_ADVISORY_LOCK_SECOND_KEY</name></expr></argument>,
							 <argument><expr><name>SHARD_MOVE_ADVISORY_LOCK_FIRST_KEY</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* uses sharelock so concurrent moves don't conflict with eachother */</comment>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>, <argument><expr><name>sessionLock</name></expr></argument>, <argument><expr><name>dontWait</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ConflictWithIsolationTestingAfterCopy is only useful for two types of tests.
 * 1. Testing the output of get_rebalance_progress after the copy is completed,
 *    but before the move is completely finished. Because finishing the move
 *    will clear the contents of get_rebalance_progress.
 * 2. To test that our non-blocking shard moves/splits actually don't block
 *    writes. Since logically replicating shards does eventually block
 *    modifications, it becomes tricky to use isolation tester to show
 *    concurrent behaviour of online shard rebalancing and modification
 *    queries. So, during logical replication we call this function at
 *    the end of the catchup, right before blocking writes.
 *
 * Note that since the cost of calling this function is pretty low, we prefer
 * to use it in non-assert builds as well not to diverge in the behaviour.
 */</comment>
<function><type><specifier>extern</specifier> <name>void</name></type>
<name>ConflictWithIsolationTestingAfterCopy</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKTAG</name></type> <name>tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>sessionLock</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>dontWait</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>RunningUnderIsolationTest</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SET_LOCKTAG_ADVISORY</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>MyDatabaseId</name></expr></argument>,
							 <argument><expr><name>SHARD_MOVE_ADVISORY_LOCK_FIRST_KEY</name></expr></argument>,
							 <argument><expr><name>SHARD_MOVE_ADVISORY_LOCK_SECOND_KEY</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* uses sharelock so concurrent moves don't conflict with eachother */</comment>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>, <argument><expr><name>sessionLock</name></expr></argument>, <argument><expr><name>dontWait</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * PublicationName returns the name of the publication for the given node and
 * table owner.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>PublicationName</name><parameter_list>(<parameter><decl><type><name>LogicalRepType</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>nodeId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>ownerId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s%u_%u_%lu"</literal></expr></argument>, <argument><expr><name><name>publicationPrefix</name><index>[<expr><name>type</name></expr>]</index></name></expr></argument>,
					<argument><expr><name>nodeId</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>, <argument><expr><name>CurrentOperationId</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ReplicationSlotNameForNodeAndOwnerForOperation returns the name of the
 * replication slot for the given node, table owner and operation id.
 *
 * Note that PG15 introduced a new ReplicationSlotName function that caused name conflicts
 * and we renamed this function.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>ReplicationSlotNameForNodeAndOwnerForOperation</name><parameter_list>(<parameter><decl><type><name>LogicalRepType</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>nodeId</name></decl></parameter>,
											   <parameter><decl><type><name>Oid</name></type> <name>ownerId</name></decl></parameter>, <parameter><decl><type><name>OperationId</name></type> <name>operationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>slotName</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>slotName</name></expr></argument>, <argument><expr><literal type="string">"%s%u_%u_%lu"</literal></expr></argument>, <argument><expr><name><name>replicationSlotPrefix</name><index>[<expr><name>type</name></expr>]</index></name></expr></argument>, <argument><expr><name>nodeId</name></expr></argument>,
					 <argument><expr><name>ownerId</name></expr></argument>, <argument><expr><name>operationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>slotName</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <name>NAMEDATALEN</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
					 <argument><expr><literal type="string">"Replication Slot name:%s having length:%d is greater than maximum allowed length:%d"</literal></expr></argument>,
					 <argument><expr><name><name>slotName</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>slotName</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name><name>slotName</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SubscriptionName returns the name of the subscription for the given owner.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>SubscriptionName</name><parameter_list>(<parameter><decl><type><name>LogicalRepType</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>ownerId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s%i_%lu"</literal></expr></argument>, <argument><expr><name><name>subscriptionPrefix</name><index>[<expr><name>type</name></expr>]</index></name></expr></argument>,
					<argument><expr><name>ownerId</name></expr></argument>, <argument><expr><name>CurrentOperationId</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SubscriptionRoleName returns the name of the role used by the
 * subscription that subscribes to the tables of the given owner.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>SubscriptionRoleName</name><parameter_list>(<parameter><decl><type><name>LogicalRepType</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>ownerId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s%i_%lu"</literal></expr></argument>, <argument><expr><name><name>subscriptionRolePrefix</name><index>[<expr><name>type</name></expr>]</index></name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>,
					<argument><expr><name>CurrentOperationId</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetQueryResultStringList expects a query that returns a single column of
 * strings. This query is executed on the connection and the function then
 * returns the results of the query in a List.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>GetQueryResultStringList</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>raiseInterrupts</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>querySent</name> <init>= <expr><call><name>SendRemoteCommand</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>querySent</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReportConnectionError</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>GetRemoteCommandResult</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>raiseInterrupts</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsResponseOK</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReportResultError</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>rowCount</name> <init>= <expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>columnCount</name> <init>= <expr><call><name>PQnfields</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>columnCount</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected number of columns returned while reading "</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>resultList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>rowIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>rowIndex</name> <operator>&lt;</operator> <name>rowCount</name></expr>;</condition> <incr><expr><name>rowIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>columnIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StringInfo</name></type> <name>resultStringInfo</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>resultString</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><name>columnIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* we're using the stringinfo to copy the data into the current memory context */</comment>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>resultStringInfo</name></expr></argument>, <argument><expr><name>resultString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>resultList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>resultList</name></expr></argument>, <argument><expr><name><name>resultStringInfo</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ForgetResults</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>resultList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreatePublications creates a the publications defined in the
 * publicationInfoHash over the given connection.
 */</comment>
<function><type><name>void</name></type>
<name>CreatePublications</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>,
				   <parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>publicationInfoHash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>publicationInfoHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>PublicationInfo</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <operator>(</operator><name>PublicationInfo</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>StringInfo</name></type> <name>createPublicationCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>prefixWithComma</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>createPublicationCommand</name></expr></argument>, <argument><expr><literal type="string">"CREATE PUBLICATION %s FOR TABLE "</literal></expr></argument>,
						 <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shard</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>shard</argument>, <argument>entry-&gt;shardIntervals</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>shardName</name> <init>= <expr><call><name>ConstructQualifiedShardName</name><argument_list>(<argument><expr><name>shard</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>prefixWithComma</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>createPublicationCommand</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>createPublicationCommand</name></expr></argument>, <argument><expr><name>shardName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>prefixWithComma</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block>

		<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>worker</name> <init>= <expr><call><name>FindWorkerNode</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>,
											<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>InsertCleanupRecordInSubtransaction</name><argument_list>(<argument><expr><name>CLEANUP_OBJECT_PUBLICATION</name></expr></argument>,
											<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
											<argument><expr><name><name>worker</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>,
											<argument><expr><name>CLEANUP_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ExecuteCriticalRemoteCommand</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name><name>createPublicationCommand</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>createPublicationCommand</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>createPublicationCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>


<comment type="block">/*
 * GetReplicationConnection opens a new replication connection to this node.
 * This connection can be used to send replication commands, such as
 * CREATE_REPLICATION_SLOT.
 */</comment>
<function><type><name>MultiConnection</name> <modifier>*</modifier></type>
<name>GetReplicationConnection</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>nodeName</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nodePort</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>connectionFlags</name> <init>= <expr><name>FORCE_NEW_CONNECTION</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>connectionFlags</name> <operator>|=</operator> <name>REQUIRE_REPLICATION_CONNECTION_PARAM</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><call><name>GetNodeUserDatabaseConnection</name><argument_list>(
		<argument><expr><name>connectionFlags</name></expr></argument>,
		<argument><expr><name>nodeName</name></expr></argument>,
		<argument><expr><name>nodePort</name></expr></argument>,
		<argument><expr><call><name>CitusExtensionOwnerName</name><argument_list>()</argument_list></call></expr></argument>,
		<argument><expr><call><name>get_database_name</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Replication connections are special and don't support all of SQL, so we
	 * don't want it to be used for other purposes what we create it for.
	 */</comment>
	<expr_stmt><expr><call><name>ClaimConnectionExclusively</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>connection</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateReplicationSlot creates a replication slot with the given slot name
 * over the given connection. The given connection should be a replication
 * connection. This function returns the name of the snapshot that is used for
 * this replication slot. When using this snapshot name for other transactions
 * you need to keep the given replication connection open until you have used
 * the snapshot name.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>CreateReplicationSlot</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>slotname</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>outputPlugin</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>createReplicationSlotCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>createReplicationSlotCommand</name></expr></argument>,
					 <argument><expr><literal type="string">"CREATE_REPLICATION_SLOT %s LOGICAL %s EXPORT_SNAPSHOT;"</literal></expr></argument>,
					 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>slotname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>outputPlugin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>response</name> <init>= <expr><call><name>ExecuteOptionalRemoteCommand</name><argument_list>(<argument><expr><name>connection</name></expr></argument>,
												<argument><expr><name><name>createReplicationSlotCommand</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
												<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>response</name> <operator>!=</operator> <name>RESPONSE_OKAY</name> <operator>||</operator> <operator>!</operator><call><name>IsResponseOK</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReportResultError</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*'snapshot_name' is second column where index starts from zero.
	 * We're using the pstrdup to copy the data into the current memory context */</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>snapShotName</name> <init>= <expr><call><name>pstrdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument> <comment type="block">/* columIndex */</comment>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ForgetResults</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>snapShotName</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateReplicationSlots creates the replication slots that the subscriptions
 * in the logicalRepTargetList can use.
 *
 * This function returns the snapshot name of the replication slots that are
 * used by the subscription. When using this snapshot name for other
 * transactions you need to keep the given replication connection open until
 * you are finished using the snapshot.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>CreateReplicationSlots</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>sourceConnection</name></decl></parameter>,
					   <parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>sourceReplicationConnection</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>logicalRepTargetList</name></decl></parameter>,
					   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>outputPlugin</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ReplicationSlotInfo</name> <modifier>*</modifier></type><name>firstReplicationSlot</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>snapshot</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LogicalRepTarget</name> <modifier>*</modifier></type><name>target</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>target</argument>, <argument>logicalRepTargetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ReplicationSlotInfo</name> <modifier>*</modifier></type><name>replicationSlot</name> <init>= <expr><name><name>target</name><operator>-&gt;</operator><name>replicationSlot</name></name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>worker</name> <init>= <expr><call><name>FindWorkerNode</name><argument_list>(<argument><expr><name><name>sourceConnection</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>,
											<argument><expr><name><name>sourceConnection</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>InsertCleanupRecordInSubtransaction</name><argument_list>(<argument><expr><name>CLEANUP_OBJECT_REPLICATION_SLOT</name></expr></argument>,
											<argument><expr><name><name>replicationSlot</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
											<argument><expr><name><name>worker</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>,
											<argument><expr><name>CLEANUP_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>firstReplicationSlot</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>firstReplicationSlot</name> <operator>=</operator> <name>replicationSlot</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>snapshot</name> <operator>=</operator> <call><name>CreateReplicationSlot</name><argument_list>(
				<argument><expr><name>sourceReplicationConnection</name></expr></argument>,
				<argument><expr><name><name>replicationSlot</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
				<argument><expr><name>outputPlugin</name></expr></argument>
				)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ExecuteCriticalRemoteCommand</name><argument_list>(
				<argument><expr><name>sourceConnection</name></expr></argument>,
				<argument><expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"SELECT pg_catalog.pg_copy_logical_replication_slot(%s, %s)"</literal></expr></argument>,
						 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name><name>firstReplicationSlot</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name><name>replicationSlot</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>snapshot</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateSubscriptions creates the subscriptions according to their definition
 * in the logicalRepTargetList. The remote node(s) needs to have appropriate
 * pg_dist_authinfo rows for the superuser such that the apply process can
 * connect. Because the generated CREATE SUBSCRIPTION statements use the host
 * and port names directly (rather than looking up any relevant
 * pg_dist_poolinfo rows), all such connections remain direct and will not
 * route through any configured poolers.
 *
 * The subscriptions created by this function are created in the disabled
 * state. This is done so a data copy can be done manually afterwards. To
 * enable the subscriptions you can use EnableSubscriptions().
 */</comment>
<function><type><name>void</name></type>
<name>CreateSubscriptions</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>sourceConnection</name></decl></parameter>,
					<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>databaseName</name></decl></parameter>,
					<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>logicalRepTargetList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LogicalRepTarget</name> <modifier>*</modifier></type><name>target</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>target</argument>, <argument>logicalRepTargetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>ownerId</name> <init>= <expr><name><name>target</name><operator>-&gt;</operator><name>tableOwnerId</name></name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>worker</name> <init>= <expr><call><name>FindWorkerNode</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>superuserConnection</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>,
											<argument><expr><name><name>target</name><operator>-&gt;</operator><name>superuserConnection</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * The CREATE USER command should not propagate, so we temporarily
		 * disable DDL propagation.
		 *
		 * Subscription workers have SUPERUSER permissions. Hence we temporarily
		 * create a user with SUPERUSER permissions and then alter it to NOSUPERUSER.
		 * This prevents permission escalations.
		 */</comment>
		<expr_stmt><expr><call><name>SendCommandListToWorkerOutsideTransactionWithConnection</name><argument_list>(
			<argument><expr><name><name>target</name><operator>-&gt;</operator><name>superuserConnection</name></name></expr></argument>,
			<argument><expr><call><name>list_make2</name><argument_list>(
				<argument><expr><literal type="string">"SET LOCAL citus.enable_ddl_propagation TO OFF;"</literal></expr></argument>,
				<argument><expr><call><name>psprintf</name><argument_list>(
					<argument><expr><literal type="string">"CREATE USER %s SUPERUSER IN ROLE %s;"</literal></expr></argument>,
					<argument><expr><name><name>target</name><operator>-&gt;</operator><name>subscriptionOwnerName</name></name></expr></argument>,
					<argument><expr><call><name>GetUserNameFromId</name><argument_list>(<argument><expr><name>ownerId</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>
					)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>InsertCleanupRecordInSubtransaction</name><argument_list>(<argument><expr><name>CLEANUP_OBJECT_USER</name></expr></argument>,
											<argument><expr><name><name>target</name><operator>-&gt;</operator><name>subscriptionOwnerName</name></name></expr></argument>,
											<argument><expr><name><name>worker</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>,
											<argument><expr><name>CLEANUP_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>StringInfo</name></type> <name>conninfo</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>conninfo</name></expr></argument>, <argument><expr><literal type="string">"host='%s' port=%d user='%s' dbname='%s' "</literal>
								   <literal type="string">"connect_timeout=20"</literal></expr></argument>,
						 <argument><expr><call><name>escape_param_str</name><argument_list>(<argument><expr><name><name>sourceConnection</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name><name>sourceConnection</name><operator>-&gt;</operator><name>port</name></name></expr></argument>,
						 <argument><expr><call><name>escape_param_str</name><argument_list>(<argument><expr><name><name>sourceConnection</name><operator>-&gt;</operator><name>user</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>escape_param_str</name><argument_list>(
							 <argument><expr><name>databaseName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>CpuPriorityLogicalRepSender</name> <operator>!=</operator> <name>CPU_PRIORITY_INHERIT</name> <operator>&amp;&amp;</operator>
			<call><name>list_length</name><argument_list>(<argument><expr><name>logicalRepTargetList</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>MaxHighPriorityBackgroundProcesess</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>conninfo</name></expr></argument>,
							 <argument><expr><literal type="string">" options='-c citus.cpu_priority=%d'"</literal></expr></argument>,
							 <argument><expr><name>CpuPriorityLogicalRepSender</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>StringInfo</name></type> <name>createSubscriptionCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>createSubscriptionCommand</name></expr></argument>,
						 <argument><expr><literal type="string">"CREATE SUBSCRIPTION %s CONNECTION %s PUBLICATION %s "</literal>
						 <literal type="string">"WITH (citus_use_authinfo=true, create_slot=false, "</literal>
						 <literal type="string">"copy_data=false, enabled=false, slot_name=%s"</literal></expr></argument>,
						 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>subscriptionName</name></name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name><name>conninfo</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>publication</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>replicationSlot</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>EnableBinaryProtocol</name> <operator>&amp;&amp;</operator> <name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <name>PG_VERSION_14</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>createSubscriptionCommand</name></expr></argument>, <argument><expr><literal type="string">", binary=true)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>createSubscriptionCommand</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>


		<expr_stmt><expr><call><name>ExecuteCriticalRemoteCommand</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>superuserConnection</name></name></expr></argument>,
									 <argument><expr><name><name>createSubscriptionCommand</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>createSubscriptionCommand</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>createSubscriptionCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>InsertCleanupRecordInSubtransaction</name><argument_list>(<argument><expr><name>CLEANUP_OBJECT_SUBSCRIPTION</name></expr></argument>,
											<argument><expr><name><name>target</name><operator>-&gt;</operator><name>subscriptionName</name></name></expr></argument>,
											<argument><expr><name><name>worker</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>,
											<argument><expr><name>CLEANUP_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ExecuteCriticalRemoteCommand</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>superuserConnection</name></name></expr></argument>, <argument><expr><call><name>psprintf</name><argument_list>(
										 <argument><expr><literal type="string">"ALTER SUBSCRIPTION %s OWNER TO %s"</literal></expr></argument>,
										 <argument><expr><name><name>target</name><operator>-&gt;</operator><name>subscriptionName</name></name></expr></argument>,
										 <argument><expr><name><name>target</name><operator>-&gt;</operator><name>subscriptionOwnerName</name></name></expr></argument>
										 )</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * The ALTER ROLE command should not propagate, so we temporarily
		 * disable DDL propagation.
		 */</comment>
		<expr_stmt><expr><call><name>SendCommandListToWorkerOutsideTransactionWithConnection</name><argument_list>(
			<argument><expr><name><name>target</name><operator>-&gt;</operator><name>superuserConnection</name></name></expr></argument>,
			<argument><expr><call><name>list_make2</name><argument_list>(
				<argument><expr><literal type="string">"SET LOCAL citus.enable_ddl_propagation TO OFF;"</literal></expr></argument>,
				<argument><expr><call><name>psprintf</name><argument_list>(
					<argument><expr><literal type="string">"ALTER ROLE %s NOSUPERUSER;"</literal></expr></argument>,
					<argument><expr><name><name>target</name><operator>-&gt;</operator><name>subscriptionOwnerName</name></name></expr></argument>
					)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * EnableSubscriptions enables all the the subscriptions in the
 * logicalRepTargetList. This means the replication slot will start to be read
 * and the catchup phase begins.
 */</comment>
<function><type><name>void</name></type>
<name>EnableSubscriptions</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>logicalRepTargetList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LogicalRepTarget</name> <modifier>*</modifier></type><name>target</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>target</argument>, <argument>logicalRepTargetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecuteCriticalRemoteCommand</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>superuserConnection</name></name></expr></argument>, <argument><expr><call><name>psprintf</name><argument_list>(
										 <argument><expr><literal type="string">"ALTER SUBSCRIPTION %s ENABLE"</literal></expr></argument>,
										 <argument><expr><name><name>target</name><operator>-&gt;</operator><name>subscriptionName</name></name></expr></argument>
										 )</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/* *INDENT-OFF* */</comment>
<comment type="block">/*
 * Escaping libpq connect parameter strings.
 *
 * Replaces "'" with "\'" and "\" with "\\".
 *
 * Copied from dblink.c to escape libpq params
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>escape_param_str</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cp</name> <init>= <expr><name>str</name></expr></init></decl>;</init> <condition><expr><operator>*</operator><name>cp</name></expr>;</condition> <incr><expr><name>cp</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>||</operator> <operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'\''</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\\'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* *INDENT-ON* */</comment>


<comment type="block">/*
 * GetRemoteLogPosition gets the current WAL log position over the given connection.
 */</comment>
<function><type><name>XLogRecPtr</name></type>
<name>GetRemoteLogPosition</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>GetRemoteLSN</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>CURRENT_LOG_POSITION_COMMAND</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetRemoteLSN executes a command that returns a single LSN over the given connection
 * and returns it as an XLogRecPtr (uint64).
 */</comment>
<function><type><specifier>static</specifier> <name>XLogRecPtr</name></type>
<name>GetRemoteLSN</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>command</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>raiseInterrupts</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>remoteLogPosition</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>querySent</name> <init>= <expr><call><name>SendRemoteCommand</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>querySent</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReportConnectionError</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>GetRemoteCommandResult</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>raiseInterrupts</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsResponseOK</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReportResultError</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>rowCount</name> <init>= <expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>rowCount</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ForgetResults</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>InvalidXLogRecPtr</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>colCount</name> <init>= <expr><call><name>PQnfields</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>colCount</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected number of columns returned by: %s"</literal></expr></argument>,
							   <argument><expr><name>command</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>resultString</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type> <name>remoteLogPositionDatum</name> <init>= <expr><call><name>DirectFunctionCall1Coll</name><argument_list>(<argument><expr><name>pg_lsn_in</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
															   <argument><expr><call><name>CStringGetDatum</name><argument_list>(
																   <argument><expr><name>resultString</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>remoteLogPosition</name> <operator>=</operator> <call><name>DatumGetLSN</name><argument_list>(<argument><expr><name>remoteLogPositionDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ForgetResults</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>remoteLogPosition</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateGroupedLogicalRepTargetsConnections creates connections for all of the nodes
 * in the groupedLogicalRepTargetsHash.
 */</comment>
<function><type><name>void</name></type>
<name>CreateGroupedLogicalRepTargetsConnections</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>groupedLogicalRepTargetsHash</name></decl></parameter>,
										  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>user</name></decl></parameter>,
										  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>databaseName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>connectionFlags</name> <init>= <expr><name>FORCE_NEW_CONNECTION</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GroupedLogicalRepTargets</name> <modifier>*</modifier></type><name>groupedLogicalRepTargets</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_htab</name><argument_list>(<argument>groupedLogicalRepTargets</argument>, <argument>&amp;status</argument>, <argument>groupedLogicalRepTargetsHash</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>targetWorkerNode</name> <init>= <expr><call><name>FindNodeWithNodeId</name><argument_list>(
			<argument><expr><name><name>groupedLogicalRepTargets</name><operator>-&gt;</operator><name>nodeId</name></name></expr></argument>,
			<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>superuserConnection</name> <init>=
			<expr><call><name>GetNodeUserDatabaseConnection</name><argument_list>(<argument><expr><name>connectionFlags</name></expr></argument>, <argument><expr><name><name>targetWorkerNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>,
										  <argument><expr><name><name>targetWorkerNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>,
										  <argument><expr><name>user</name></expr></argument>,
										  <argument><expr><name>databaseName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Operations on subscriptions cannot run in a transaction block. We
		 * claim the connections exclusively to ensure they do not get used for
		 * metadata syncing, which does open a transaction block.
		 */</comment>
		<expr_stmt><expr><call><name>ClaimConnectionExclusively</name><argument_list>(<argument><expr><name>superuserConnection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>groupedLogicalRepTargets</name><operator>-&gt;</operator><name>superuserConnection</name></name> <operator>=</operator> <name>superuserConnection</name></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>LogicalRepTarget</name> <modifier>*</modifier></type><name>target</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>target</argument>, <argument>groupedLogicalRepTargets-&gt;logicalRepTargetList</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>superuserConnection</name></name> <operator>=</operator> <name>superuserConnection</name></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * CreateGroupedLogicalRepTargetsConnections closes the  connections for all of the
 * nodes in the groupedLogicalRepTargetsHash.
 */</comment>
<function><type><name>void</name></type>
<name>CloseGroupedLogicalRepTargetsConnections</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>groupedLogicalRepTargetsHash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GroupedLogicalRepTargets</name> <modifier>*</modifier></type><name>groupedLogicalRepTargets</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_htab</name><argument_list>(<argument>groupedLogicalRepTargets</argument>, <argument>&amp;status</argument>, <argument>groupedLogicalRepTargetsHash</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CloseConnection</name><argument_list>(<argument><expr><name><name>groupedLogicalRepTargets</name><operator>-&gt;</operator><name>superuserConnection</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * SubscriptionNamesValueList returns a SQL value list containing the
 * subscription names from the logicalRepTargetList. This value list can
 * be used in a query by using the IN operator.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>SubscriptionNamesValueList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>logicalRepTargetList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>subscriptionValueList</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>subscriptionValueList</name></expr></argument>, <argument><expr><literal type="string">"("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>LogicalRepTarget</name> <modifier>*</modifier></type><name>target</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>target</argument>, <argument>logicalRepTargetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>subscriptionValueList</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>subscriptionValueList</name></expr></argument>, <argument><expr><call><name>quote_literal_cstr</name><argument_list>(
								   <argument><expr><name><name>target</name><operator>-&gt;</operator><name>subscriptionName</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>subscriptionValueList</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>subscriptionValueList</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * WaitForAllSubscriptionToCatchUp waits until the last LSN reported by the
 * subscription.
 *
 * The function errors if the target LSN doesn't increase within
 * LogicalReplicationErrorTimeout. The function also reports its progress in
 * every logicalReplicationProgressReportTimeout.
 */</comment>
<function><type><name>void</name></type>
<name>WaitForAllSubscriptionsToCatchUp</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>sourceConnection</name></decl></parameter>,
								 <parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>groupedLogicalRepTargetsHash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>sourcePosition</name> <init>= <expr><call><name>GetRemoteLogPosition</name><argument_list>(<argument><expr><name>sourceConnection</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GroupedLogicalRepTargets</name> <modifier>*</modifier></type><name>groupedLogicalRepTargets</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_htab</name><argument_list>(<argument>groupedLogicalRepTargets</argument>, <argument>&amp;status</argument>, <argument>groupedLogicalRepTargetsHash</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>WaitForGroupedLogicalRepTargetsToCatchUp</name><argument_list>(<argument><expr><name>sourcePosition</name></expr></argument>,
												 <argument><expr><name>groupedLogicalRepTargets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * WaitForNodeSubscriptionToCatchUp waits until the last LSN reported by the
 * subscription.
 *
 * The function errors if the target LSN doesn't increase within
 * LogicalReplicationErrorTimeout. The function also reports its progress in
 * every logicalReplicationProgressReportTimeout.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>WaitForGroupedLogicalRepTargetsToCatchUp</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>sourcePosition</name></decl></parameter>,
										 <parameter><decl><type><name>GroupedLogicalRepTargets</name> <modifier>*</modifier></type>
										 <name>groupedLogicalRepTargets</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>previousTargetPosition</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>previousLSNIncrementTime</name> <init>= <expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* report in the first iteration as well */</comment>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>previousReportTime</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>superuserConnection</name> <init>= <expr><name><name>groupedLogicalRepTargets</name><operator>-&gt;</operator><name>superuserConnection</name></name></expr></init></decl>;</decl_stmt>


	<comment type="block">/*
	 * We might be in the loop for a while. Since we don't need to preserve
	 * any memory beyond this function, we can simply switch to a child context
	 * and reset it on every iteration to make sure we don't slowly build up
	 * a lot of memory.
	 */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>loopContext</name> <init>= <expr><call><name>AllocSetContextCreateInternal</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
															  <argument><expr><literal type="string">"WaitForShardSubscriptionToCatchUp"</literal></expr></argument>,
															  <argument><expr><name>ALLOCSET_DEFAULT_MINSIZE</name></expr></argument>,
															  <argument><expr><name>ALLOCSET_DEFAULT_INITSIZE</name></expr></argument>,
															  <argument><expr><name>ALLOCSET_DEFAULT_MAXSIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>loopContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>targetPosition</name> <init>= <expr><call><name>GetSubscriptionPosition</name><argument_list>(<argument><expr><name>groupedLogicalRepTargets</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>targetPosition</name> <operator>&gt;=</operator> <name>sourcePosition</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
							  <argument><expr><literal type="string">"The LSN of the target subscriptions on node %s:%d have "</literal>
							  <literal type="string">"caught up with the source LSN "</literal></expr></argument>,
							  <argument><expr><name><name>superuserConnection</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>,
							  <argument><expr><name><name>superuserConnection</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * The following logic ensures that the subsription continues to grow withing
		 * LogicalReplicationErrorTimeout duration. Otherwise, we error out since we
		 * suspect that there is a problem on the target. It also handles the progess
		 * reporting.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>targetPosition</name> <operator>&gt;</operator> <name>previousTargetPosition</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* variable is only used for the log message */</comment>
			<decl_stmt><decl><type><name>uint64</name></type> <name>previousTargetBeforeThisLoop</name> <init>= <expr><name>previousTargetPosition</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>previousTargetPosition</name> <operator>=</operator> <name>targetPosition</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>previousLSNIncrementTime</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>TimestampDifferenceExceeds</name><argument_list>(<argument><expr><name>previousReportTime</name></expr></argument>,
										   <argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>,
										   <argument><expr><name>logicalReplicationProgressReportTimeout</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
								  <argument><expr><literal type="string">"The LSN of the target subscriptions on node %s:%d have "</literal>
								  <literal type="string">"increased from %ld to %ld at %s where the source LSN is %ld  "</literal></expr></argument>,
								  <argument><expr><name><name>superuserConnection</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>,
								  <argument><expr><name><name>superuserConnection</name><operator>-&gt;</operator><name>port</name></name></expr></argument>, <argument><expr><name>previousTargetBeforeThisLoop</name></expr></argument>,
								  <argument><expr><name>targetPosition</name></expr></argument>,
								  <argument><expr><call><name>timestamptz_to_str</name><argument_list>(<argument><expr><name>previousLSNIncrementTime</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>sourcePosition</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>previousReportTime</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>TimestampDifferenceExceeds</name><argument_list>(<argument><expr><name>previousLSNIncrementTime</name></expr></argument>,
										   <argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>,
										   <argument><expr><name>LogicalReplicationTimeout</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"The logical replication waiting timeout "</literal>
									   <literal type="string">"of %d msec is exceeded"</literal></expr></argument>,
									   <argument><expr><name>LogicalReplicationTimeout</name></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The LSN on the target subscription hasn't "</literal>
										  <literal type="string">"caught up ready on the target node %s:%d"</literal></expr></argument>,
										  <argument><expr><name><name>superuserConnection</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>,
										  <argument><expr><name><name>superuserConnection</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errhint</name><argument_list>(
									<argument><expr><literal type="string">"There might have occurred problems on the target "</literal>
									<literal type="string">"node. If not consider using higher values for "</literal>
									<literal type="string">"citus.logical_replication_error_timeout"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* sleep for 1 seconds (1000 miliseconds) and try again */</comment>
		<expr_stmt><expr><call><name>WaitForMiliseconds</name><argument_list>(<argument><expr><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>loopContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * WaitForMiliseconds waits for given timeout and then checks for some
 * interrupts.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>WaitForMiliseconds</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>timeout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>latchFlags</name> <init>= <expr><name>WL_LATCH_SET</name> <operator>|</operator> <name>WL_TIMEOUT</name> <operator>|</operator> <name>WL_POSTMASTER_DEATH</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* wait until timeout, or until somebody wakes us up */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>WaitLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>, <argument><expr><name>latchFlags</name></expr></argument>, <argument><expr><name>timeout</name></expr></argument>, <argument><expr><name>PG_WAIT_EXTENSION</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* emergency bailout if postmaster has died */</comment>
	<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&amp;</operator> <name>WL_POSTMASTER_DEATH</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&amp;</operator> <name>WL_LATCH_SET</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>ConfigReloadPending</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>ConfigReloadPending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ProcessConfigFile</name><argument_list>(<argument><expr><name>PGC_SIGHUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * GetSubscriptionPosition gets the minimum WAL log position of the
 * subscription given subscriptions: That is the WAL log position on the source
 * node up to which the subscription completed replication.
 */</comment>
<function><type><specifier>static</specifier> <name>XLogRecPtr</name></type>
<name>GetSubscriptionPosition</name><parameter_list>(<parameter><decl><type><name>GroupedLogicalRepTargets</name> <modifier>*</modifier></type><name>groupedLogicalRepTargets</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>subscriptionValueList</name> <init>= <expr><call><name>SubscriptionNamesValueList</name><argument_list>(
		<argument><expr><name><name>groupedLogicalRepTargets</name><operator>-&gt;</operator><name>logicalRepTargetList</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>GetRemoteLSN</name><argument_list>(<argument><expr><name><name>groupedLogicalRepTargets</name><operator>-&gt;</operator><name>superuserConnection</name></name></expr></argument>, <argument><expr><call><name>psprintf</name><argument_list>(
							<argument><expr><literal type="string">"SELECT min(latest_end_lsn) FROM pg_stat_subscription "</literal>
							<literal type="string">"WHERE subname IN %s"</literal></expr></argument>, <argument><expr><name>subscriptionValueList</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
